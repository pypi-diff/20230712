# Comparing `tmp/bzip3-0.1.2rc1.tar.gz` & `tmp/bzip3-0.1.3rc1.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "bzip3-0.1.2rc1.tar", last modified: Thu Mar 23 09:06:04 2023, max compression
+gzip compressed data, was "bzip3-0.1.3rc1.tar", last modified: Wed Jul 12 12:56:05 2023, max compression
```

## Comparing `bzip3-0.1.2rc1.tar` & `bzip3-0.1.3rc1.tar`

### file list

```diff
@@ -1,49 +1,42 @@
-drwxrwxrwx   0        0        0        0 2023-03-23 09:06:04.353715 bzip3-0.1.2rc1/
--rw-rw-rw-   0        0        0      113 2023-03-22 04:12:38.000000 bzip3-0.1.2rc1/MANIFEST.in
--rw-rw-rw-   0        0        0     4573 2023-03-23 09:06:04.353212 bzip3-0.1.2rc1/PKG-INFO
--rw-rw-rw-   0        0        0     3486 2023-03-23 03:37:09.000000 bzip3-0.1.2rc1/README.markdown
-drwxrwxrwx   0        0        0        0 2023-03-23 09:06:04.333609 bzip3-0.1.2rc1/bz3/
--rw-rw-rw-   0        0        0      314 2023-03-23 04:31:56.000000 bzip3-0.1.2rc1/bz3/__init__.py
-drwxrwxrwx   0        0        0        0 2023-03-23 09:06:04.337127 bzip3-0.1.2rc1/bz3/__pycache__/
--rw-rw-rw-   0        0        0      514 2023-03-23 05:48:49.000000 bzip3-0.1.2rc1/bz3/__pycache__/__init__.cpython-310.pyc
--rw-rw-rw-   0        0        0    10777 2023-03-23 05:48:49.000000 bzip3-0.1.2rc1/bz3/__pycache__/bz3.cpython-310.pyc
--rw-rw-rw-   0        0        0     4662 2023-03-23 05:48:49.000000 bzip3-0.1.2rc1/bz3/__pycache__/compression.cpython-310.pyc
-drwxrwxrwx   0        0        0        0 2023-03-23 09:06:04.337630 bzip3-0.1.2rc1/bz3/backends/
--rw-rw-rw-   0        0        0      938 2023-03-23 04:31:56.000000 bzip3-0.1.2rc1/bz3/backends/__init__.py
-drwxrwxrwx   0        0        0        0 2023-03-23 09:06:04.338133 bzip3-0.1.2rc1/bz3/backends/__pycache__/
--rw-rw-rw-   0        0        0      926 2023-03-23 05:48:49.000000 bzip3-0.1.2rc1/bz3/backends/__pycache__/__init__.cpython-310.pyc
-drwxrwxrwx   0        0        0        0 2023-03-23 09:06:04.341148 bzip3-0.1.2rc1/bz3/backends/cffi/
--rw-rw-rw-   0        0        0    15817 2023-03-23 03:11:21.000000 bzip3-0.1.2rc1/bz3/backends/cffi/__init__.py
--rw-rw-rw-   0        0        0    73728 2023-03-22 10:47:17.000000 bzip3-0.1.2rc1/bz3/backends/cffi/_bz3.pyd
--rw-rw-rw-   0        0        0     4831 2023-03-23 03:11:21.000000 bzip3-0.1.2rc1/bz3/backends/cffi/build.py
-drwxrwxrwx   0        0        0        0 2023-03-23 09:06:04.343159 bzip3-0.1.2rc1/bz3/backends/cython/
--rw-rw-rw-   0        0        0      331 2023-03-23 04:31:56.000000 bzip3-0.1.2rc1/bz3/backends/cython/__init__.py
-drwxrwxrwx   0        0        0        0 2023-03-23 09:06:04.344165 bzip3-0.1.2rc1/bz3/backends/cython/__pycache__/
--rw-rw-rw-   0        0        0      525 2023-03-23 05:48:49.000000 bzip3-0.1.2rc1/bz3/backends/cython/__pycache__/__init__.cpython-310.pyc
--rw-rw-rw-   0        0        0  1349036 2023-03-23 03:18:21.000000 bzip3-0.1.2rc1/bz3/backends/cython/_bz3.c
--rw-rw-rw-   0        0        0    32418 2023-03-23 03:18:03.000000 bzip3-0.1.2rc1/bz3/backends/cython/_bz3.pyx
--rw-rw-rw-   0        0        0     1723 2023-03-22 04:12:38.000000 bzip3-0.1.2rc1/bz3/backends/cython/bzip3.pxd
--rw-rw-rw-   0        0        0    12232 2023-03-23 03:39:51.000000 bzip3-0.1.2rc1/bz3/bz3.py
--rw-rw-rw-   0        0        0     5535 2023-03-23 03:37:25.000000 bzip3-0.1.2rc1/bz3/compression.py
-drwxrwxrwx   0        0        0        0 2023-03-23 09:06:04.347683 bzip3-0.1.2rc1/bzip3.egg-info/
--rw-rw-rw-   0        0        0     4573 2023-03-23 09:06:04.000000 bzip3-0.1.2rc1/bzip3.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0      936 2023-03-23 09:06:04.000000 bzip3-0.1.2rc1/bzip3.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2023-03-23 09:06:04.000000 bzip3-0.1.2rc1/bzip3.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0        2 2023-03-23 09:01:42.000000 bzip3-0.1.2rc1/bzip3.egg-info/not-zip-safe
--rw-rw-rw-   0        0        0       12 2023-03-23 09:06:04.000000 bzip3-0.1.2rc1/bzip3.egg-info/requires.txt
--rw-rw-rw-   0        0        0        4 2023-03-23 09:06:04.000000 bzip3-0.1.2rc1/bzip3.egg-info/top_level.txt
-drwxrwxrwx   0        0        0        0 2023-03-23 09:06:04.328583 bzip3-0.1.2rc1/dep/
-drwxrwxrwx   0        0        0        0 2023-03-23 09:06:04.349694 bzip3-0.1.2rc1/dep/include/
--rw-rw-rw-   0        0        0     5046 2023-03-22 05:48:00.000000 bzip3-0.1.2rc1/dep/include/common.h
--rw-rw-rw-   0        0        0     7802 2023-03-22 04:15:07.000000 bzip3-0.1.2rc1/dep/include/getopt-shim.h
--rw-rw-rw-   0        0        0     5451 2023-03-22 04:15:07.000000 bzip3-0.1.2rc1/dep/include/libbz3.h
--rw-rw-rw-   0        0        0   219888 2023-03-22 05:48:00.000000 bzip3-0.1.2rc1/dep/include/libsais.h
-drwxrwxrwx   0        0        0        0 2023-03-23 09:06:04.350699 bzip3-0.1.2rc1/dep/src/
--rw-rw-rw-   0        0        0    30894 2023-03-22 05:48:00.000000 bzip3-0.1.2rc1/dep/src/libbz3.c
--rw-rw-rw-   0        0        0    25682 2023-03-22 05:48:00.000000 bzip3-0.1.2rc1/dep/src/main.c
--rw-rw-rw-   0        0        0       42 2023-03-23 09:06:04.353715 bzip3-0.1.2rc1/setup.cfg
--rw-rw-rw-   0        0        0     4696 2023-03-23 04:31:45.000000 bzip3-0.1.2rc1/setup.py
-drwxrwxrwx   0        0        0        0 2023-03-23 09:06:04.352710 bzip3-0.1.2rc1/test/
--rw-rw-rw-   0        0        0     1600 2023-03-22 04:12:38.000000 bzip3-0.1.2rc1/test/test_compress.py
--rw-rw-rw-   0        0        0     1172 2023-03-23 03:11:21.000000 bzip3-0.1.2rc1/test/test_omp.py
--rw-rw-rw-   0        0        0      915 2023-03-22 04:12:38.000000 bzip3-0.1.2rc1/test/test_thread.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-12 12:56:05.753803 bzip3-0.1.3rc1/
+-rw-r--r--   0 runner    (1001) docker     (123)      110 2023-07-12 12:55:47.000000 bzip3-0.1.3rc1/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (123)     4576 2023-07-12 12:56:05.749803 bzip3-0.1.3rc1/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     3515 2023-07-12 12:55:47.000000 bzip3-0.1.3rc1/README.markdown
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-12 12:56:05.745803 bzip3-0.1.3rc1/bz3/
+-rw-r--r--   0 runner    (1001) docker     (123)      329 2023-07-12 12:55:47.000000 bzip3-0.1.3rc1/bz3/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-12 12:56:05.745803 bzip3-0.1.3rc1/bz3/backends/
+-rw-r--r--   0 runner    (1001) docker     (123)      949 2023-07-12 12:55:47.000000 bzip3-0.1.3rc1/bz3/backends/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-12 12:56:05.745803 bzip3-0.1.3rc1/bz3/backends/cffi/
+-rw-r--r--   0 runner    (1001) docker     (123)    18788 2023-07-12 12:55:47.000000 bzip3-0.1.3rc1/bz3/backends/cffi/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4676 2023-07-12 12:55:47.000000 bzip3-0.1.3rc1/bz3/backends/cffi/build.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-12 12:56:05.749803 bzip3-0.1.3rc1/bz3/backends/cython/
+-rw-r--r--   0 runner    (1001) docker     (123)      345 2023-07-12 12:55:47.000000 bzip3-0.1.3rc1/bz3/backends/cython/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)  1443071 2023-07-12 12:56:05.000000 bzip3-0.1.3rc1/bz3/backends/cython/_bz3.c
+-rw-r--r--   0 runner    (1001) docker     (123)    38370 2023-07-12 12:55:47.000000 bzip3-0.1.3rc1/bz3/backends/cython/_bz3.pyx
+-rw-r--r--   0 runner    (1001) docker     (123)     1873 2023-07-12 12:55:47.000000 bzip3-0.1.3rc1/bz3/backends/cython/bzip3.pxd
+-rw-r--r--   0 runner    (1001) docker     (123)    12080 2023-07-12 12:55:47.000000 bzip3-0.1.3rc1/bz3/bz3.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5403 2023-07-12 12:55:47.000000 bzip3-0.1.3rc1/bz3/compression.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-12 12:56:05.749803 bzip3-0.1.3rc1/bzip3.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     4576 2023-07-12 12:56:05.000000 bzip3-0.1.3rc1/bzip3.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)      689 2023-07-12 12:56:05.000000 bzip3-0.1.3rc1/bzip3.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-07-12 12:56:05.000000 bzip3-0.1.3rc1/bzip3.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-07-12 12:56:05.000000 bzip3-0.1.3rc1/bzip3.egg-info/not-zip-safe
+-rw-r--r--   0 runner    (1001) docker     (123)       12 2023-07-12 12:56:05.000000 bzip3-0.1.3rc1/bzip3.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        4 2023-07-12 12:56:05.000000 bzip3-0.1.3rc1/bzip3.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-12 12:56:05.745803 bzip3-0.1.3rc1/dep/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-12 12:56:05.749803 bzip3-0.1.3rc1/dep/include/
+-rw-r--r--   0 runner    (1001) docker     (123)     4959 2023-07-12 12:55:48.000000 bzip3-0.1.3rc1/dep/include/common.h
+-rw-r--r--   0 runner    (1001) docker     (123)     7566 2023-07-12 12:55:48.000000 bzip3-0.1.3rc1/dep/include/getopt-shim.h
+-rw-r--r--   0 runner    (1001) docker     (123)     5310 2023-07-12 12:55:48.000000 bzip3-0.1.3rc1/dep/include/libbz3.h
+-rw-r--r--   0 runner    (1001) docker     (123)   214460 2023-07-12 12:55:48.000000 bzip3-0.1.3rc1/dep/include/libsais.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-12 12:56:05.749803 bzip3-0.1.3rc1/dep/src/
+-rw-r--r--   0 runner    (1001) docker     (123)    30595 2023-07-12 12:55:48.000000 bzip3-0.1.3rc1/dep/src/libbz3.c
+-rw-r--r--   0 runner    (1001) docker     (123)    28266 2023-07-12 12:55:48.000000 bzip3-0.1.3rc1/dep/src/main.c
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-07-12 12:56:05.753803 bzip3-0.1.3rc1/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     4645 2023-07-12 12:55:47.000000 bzip3-0.1.3rc1/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-12 12:56:05.749803 bzip3-0.1.3rc1/test/
+-rw-r--r--   0 runner    (1001) docker     (123)     1836 2023-07-12 12:55:47.000000 bzip3-0.1.3rc1/test/test_compress.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2000 2023-07-12 12:55:47.000000 bzip3-0.1.3rc1/test/test_mem.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1134 2023-07-12 12:55:47.000000 bzip3-0.1.3rc1/test/test_omp.py
+-rw-r--r--   0 runner    (1001) docker     (123)      909 2023-07-12 12:55:47.000000 bzip3-0.1.3rc1/test/test_seek.py
+-rw-r--r--   0 runner    (1001) docker     (123)      890 2023-07-12 12:55:47.000000 bzip3-0.1.3rc1/test/test_thread.py
```

### Comparing `bzip3-0.1.2rc1/PKG-INFO` & `bzip3-0.1.3rc1/PKG-INFO`

 * *Files 15% similar despite different names*

```diff
@@ -1,113 +1,114 @@
-Metadata-Version: 2.1
-Name: bzip3
-Version: 0.1.2rc1
-Summary: bz3 compress and decompress
-Home-page: https://github.com/synodriver/python-bz3
-Author: synodriver
-Author-email: diguohuangjiajinweijun@gmail.com
-License: BSD
-Keywords: bz3,compress,decompress
-Classifier: Development Status :: 3 - Alpha
-Classifier: Operating System :: OS Independent
-Classifier: License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)
-Classifier: Programming Language :: C
-Classifier: Programming Language :: Cython
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3.6
-Classifier: Programming Language :: Python :: 3.7
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-Classifier: Programming Language :: Python :: Implementation :: CPython
-Classifier: Programming Language :: Python :: Implementation :: PyPy
-Requires-Python: >=3.6
-Description-Content-Type: text/markdown
-
-<h1 align="center"><i>✨ python-bz3 ✨ </i></h1>
-
-<h3 align="center">The python binding for <a href="https://github.com/kspalaiologos/bzip3/tree/master">bzip3</a> with parallel support</h3>
-
-[![pypi](https://img.shields.io/pypi/v/bzip3.svg)](https://pypi.org/project/bzip3/)
-![python](https://img.shields.io/pypi/pyversions/bzip3)
-![implementation](https://img.shields.io/pypi/implementation/bzip3)
-![wheel](https://img.shields.io/pypi/wheel/bzip3)
-![license](https://img.shields.io/github/license/synodriver/python-bz3.svg)
-![action](https://img.shields.io/github/workflow/status/synodriver/python-bz3/build%20wheel)
-
-### install
-```bash
-pip install bzip3
-```
-
-
-### Usage
-```python
-from bz3 import compress_file, decompress_file, test_file, compress, decompress
-import bz3
-
-with open("test_inp.txt", "rb") as inp, open("compressed.bz3", "wb") as out:
-    compress_file(inp, out, 1000 * 1000)
-
-with open("compressed.bz3", "rb") as inp:
-    test_file(inp, True)    
-
-with open("compressed.bz3", "rb") as inp, open("output.txt", "wb") as out:
-    decompress_file(inp, out)
-
-print(decompress(compress(b"12121")))
-
-with bz3.open("test.bz3", "wt", encoding="utf-8", num_threads=4) as f:
-    f.write("test data")
-
-with bz3.open("test.bz3", "rt", encoding="utf-8", num_threads=4) as f:
-    print(f.read())
-```
-- use ```BZ3_USE_CFFI``` env var to specify a backend
-- ```num_threads``` is only available on cython backend which have openmp support
-
-### Public functions
-```python
-from typing import IO, Optional
-
-def compress_file(input: IO, output: IO, block_size: int) -> None: ...
-def decompress_file(input: IO, output: IO) -> None: ...
-def test_file(input: IO, should_raise: bool = ...) -> bool: ...
-
-
-class BZ3File:
-    def __init__(self, filename, mode: str = ..., block_size: int = ..., num_threads: int = ...) -> None: ...
-    def close(self) -> None: ...
-    @property
-    def closed(self): ...
-    def fileno(self): ...
-    def seekable(self): ...
-    def readable(self): ...
-    def writable(self): ...
-    def peek(self, n: int = ...): ...
-    def read(self, size: int = ...): ...
-    def read1(self, size: int = ...): ...
-    def readinto(self, b): ...
-    def readline(self, size: int = ...): ...
-    def readlines(self, size: int = ...): ...
-    def write(self, data): ...
-    def writelines(self, seq): ...
-    def seek(self, offset, whence=...): ...
-    def tell(self): ...
-
-def open(filename, mode: str = ..., block_size: int = ..., encoding: str = ..., errors: str = ..., newline: str = ..., num_threads: int = 1) -> BZ3File: ...
-def compress(data: bytes, block_size: int = ..., num_threads: int = 1) -> bytes: ...
-def decompress(data: bytes, num_threads: int = 1) -> bytes: ...
-
-def libversion() -> str: ... # Get bzip3 version
-def bound(inp: int) -> int: ... # Return the recommended size of the output buffer for the compression functions.
-
-# High-level api
-# Compress a block of data into out buffer, zerocopy, both parameters accept objects which implements buffer-protocol.
-# out must be writabel, size of out must be at least equal to bound(len(inp))
-def compress_into(inp: Union[bytes, bytearray], out: bytearray) -> int: ...
-# Decompress a block of data into out buffer, zerocopy
-def decompress_into(inp: Union[bytes, bytearray], out: bytearray) -> int: ...
-```
-
-- Note, high-level api won't work with low-level api, see [this](https://github.com/kspalaiologos/bzip3/issues/70)
+Metadata-Version: 2.1
+Name: bzip3
+Version: 0.1.3rc1
+Summary: bz3 compress and decompress
+Home-page: https://github.com/synodriver/python-bz3
+Author: synodriver
+Author-email: diguohuangjiajinweijun@gmail.com
+License: BSD
+Keywords: bz3,compress,decompress
+Classifier: Development Status :: 3 - Alpha
+Classifier: Operating System :: OS Independent
+Classifier: License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)
+Classifier: Programming Language :: C
+Classifier: Programming Language :: Cython
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3.6
+Classifier: Programming Language :: Python :: 3.7
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: Implementation :: CPython
+Classifier: Programming Language :: Python :: Implementation :: PyPy
+Requires-Python: >=3.6
+Description-Content-Type: text/markdown
+
+<h1 align="center"><i>✨ python-bz3 ✨ </i></h1>
+
+<h3 align="center">The python binding for <a href="https://github.com/kspalaiologos/bzip3/tree/master">bzip3</a> with parallel support</h3>
+
+[![pypi](https://img.shields.io/pypi/v/bzip3.svg)](https://pypi.org/project/bzip3/)
+![python](https://img.shields.io/pypi/pyversions/bzip3)
+![implementation](https://img.shields.io/pypi/implementation/bzip3)
+![wheel](https://img.shields.io/pypi/wheel/bzip3)
+![license](https://img.shields.io/github/license/synodriver/python-bz3.svg)
+![action](https://img.shields.io/github/workflow/status/synodriver/python-bz3/build%20wheel)
+
+### install
+```bash
+pip install bzip3
+```
+
+
+### Usage
+```python
+from bz3 import compress_file, decompress_file, test_file, compress, decompress
+import bz3
+
+with open("test_inp.txt", "rb") as inp, open("compressed.bz3", "wb") as out:
+    compress_file(inp, out, 1000 * 1000)
+
+with open("compressed.bz3", "rb") as inp:
+    test_file(inp, True)    
+
+with open("compressed.bz3", "rb") as inp, open("output.txt", "wb") as out:
+    decompress_file(inp, out)
+
+print(decompress(compress(b"12121")))
+
+with bz3.open("test.bz3", "wt", encoding="utf-8", num_threads=4) as f:
+    f.write("test data")
+
+with bz3.open("test.bz3", "rt", encoding="utf-8", num_threads=4) as f:
+    print(f.read())
+```
+- use ```BZ3_USE_CFFI``` env var to specify a backend
+- ```num_threads``` is only available on cython backend which have openmp support
+
+### Public functions
+```python
+from typing import IO, Optional, Union
+
+def compress_file(input: IO, output: IO, block_size: int) -> None: ...
+def decompress_file(input: IO, output: IO) -> None: ...
+def recover_file(input: IO, output: IO) -> None: ...
+def test_file(input: IO, should_raise: bool = ...) -> bool: ...
+
+
+class BZ3File:
+    def __init__(self, filename, mode: str = ..., block_size: int = ..., num_threads: int = ..., ignore_error: bool = False) -> None: ...
+    def close(self) -> None: ...
+    @property
+    def closed(self): ...
+    def fileno(self): ...
+    def seekable(self): ...
+    def readable(self): ...
+    def writable(self): ...
+    def peek(self, n: int = ...): ...
+    def read(self, size: int = ...): ...
+    def read1(self, size: int = ...): ...
+    def readinto(self, b): ...
+    def readline(self, size: int = ...): ...
+    def readlines(self, size: int = ...): ...
+    def write(self, data): ...
+    def writelines(self, seq): ...
+    def seek(self, offset, whence=...): ...
+    def tell(self): ...
+
+def open(filename, mode: str = ..., block_size: int = ..., encoding: str = ..., errors: str = ..., newline: str = ..., num_threads: int = 1, ignore_error: bool = False) -> BZ3File: ...
+def compress(data: bytes, block_size: int = ..., num_threads: int = 1) -> bytes: ...
+def decompress(data: bytes, num_threads: int = 1) -> bytes: ...
+
+def libversion() -> str: ... # Get bzip3 version
+def bound(inp: int) -> int: ... # Return the recommended size of the output buffer for the compression functions.
+
+# High-level api
+# Compress a block of data into out buffer, zerocopy, both parameters accept objects which implements buffer-protocol.
+# out must be writabel, size of out must be at least equal to bound(len(inp))
+def compress_into(inp: Union[bytes, bytearray], out: bytearray) -> int: ...
+# Decompress a block of data into out buffer, zerocopy
+def decompress_into(inp: Union[bytes, bytearray], out: bytearray) -> int: ...
+```
+
+- Note, high-level api won't work with low-level api, see [this](https://github.com/kspalaiologos/bzip3/issues/70)
```

### Comparing `bzip3-0.1.2rc1/README.markdown` & `bzip3-0.1.3rc1/README.markdown`

 * *Files 11% similar despite different names*

```diff
@@ -1,87 +1,88 @@
-<h1 align="center"><i>✨ python-bz3 ✨ </i></h1>
-
-<h3 align="center">The python binding for <a href="https://github.com/kspalaiologos/bzip3/tree/master">bzip3</a> with parallel support</h3>
-
-[![pypi](https://img.shields.io/pypi/v/bzip3.svg)](https://pypi.org/project/bzip3/)
-![python](https://img.shields.io/pypi/pyversions/bzip3)
-![implementation](https://img.shields.io/pypi/implementation/bzip3)
-![wheel](https://img.shields.io/pypi/wheel/bzip3)
-![license](https://img.shields.io/github/license/synodriver/python-bz3.svg)
-![action](https://img.shields.io/github/workflow/status/synodriver/python-bz3/build%20wheel)
-
-### install
-```bash
-pip install bzip3
-```
-
-
-### Usage
-```python
-from bz3 import compress_file, decompress_file, test_file, compress, decompress
-import bz3
-
-with open("test_inp.txt", "rb") as inp, open("compressed.bz3", "wb") as out:
-    compress_file(inp, out, 1000 * 1000)
-
-with open("compressed.bz3", "rb") as inp:
-    test_file(inp, True)    
-
-with open("compressed.bz3", "rb") as inp, open("output.txt", "wb") as out:
-    decompress_file(inp, out)
-
-print(decompress(compress(b"12121")))
-
-with bz3.open("test.bz3", "wt", encoding="utf-8", num_threads=4) as f:
-    f.write("test data")
-
-with bz3.open("test.bz3", "rt", encoding="utf-8", num_threads=4) as f:
-    print(f.read())
-```
-- use ```BZ3_USE_CFFI``` env var to specify a backend
-- ```num_threads``` is only available on cython backend which have openmp support
-
-### Public functions
-```python
-from typing import IO, Optional
-
-def compress_file(input: IO, output: IO, block_size: int) -> None: ...
-def decompress_file(input: IO, output: IO) -> None: ...
-def test_file(input: IO, should_raise: bool = ...) -> bool: ...
-
-
-class BZ3File:
-    def __init__(self, filename, mode: str = ..., block_size: int = ..., num_threads: int = ...) -> None: ...
-    def close(self) -> None: ...
-    @property
-    def closed(self): ...
-    def fileno(self): ...
-    def seekable(self): ...
-    def readable(self): ...
-    def writable(self): ...
-    def peek(self, n: int = ...): ...
-    def read(self, size: int = ...): ...
-    def read1(self, size: int = ...): ...
-    def readinto(self, b): ...
-    def readline(self, size: int = ...): ...
-    def readlines(self, size: int = ...): ...
-    def write(self, data): ...
-    def writelines(self, seq): ...
-    def seek(self, offset, whence=...): ...
-    def tell(self): ...
-
-def open(filename, mode: str = ..., block_size: int = ..., encoding: str = ..., errors: str = ..., newline: str = ..., num_threads: int = 1) -> BZ3File: ...
-def compress(data: bytes, block_size: int = ..., num_threads: int = 1) -> bytes: ...
-def decompress(data: bytes, num_threads: int = 1) -> bytes: ...
-
-def libversion() -> str: ... # Get bzip3 version
-def bound(inp: int) -> int: ... # Return the recommended size of the output buffer for the compression functions.
-
-# High-level api
-# Compress a block of data into out buffer, zerocopy, both parameters accept objects which implements buffer-protocol.
-# out must be writabel, size of out must be at least equal to bound(len(inp))
-def compress_into(inp: Union[bytes, bytearray], out: bytearray) -> int: ...
-# Decompress a block of data into out buffer, zerocopy
-def decompress_into(inp: Union[bytes, bytearray], out: bytearray) -> int: ...
-```
-
-- Note, high-level api won't work with low-level api, see [this](https://github.com/kspalaiologos/bzip3/issues/70)
+<h1 align="center"><i>✨ python-bz3 ✨ </i></h1>
+
+<h3 align="center">The python binding for <a href="https://github.com/kspalaiologos/bzip3/tree/master">bzip3</a> with parallel support</h3>
+
+[![pypi](https://img.shields.io/pypi/v/bzip3.svg)](https://pypi.org/project/bzip3/)
+![python](https://img.shields.io/pypi/pyversions/bzip3)
+![implementation](https://img.shields.io/pypi/implementation/bzip3)
+![wheel](https://img.shields.io/pypi/wheel/bzip3)
+![license](https://img.shields.io/github/license/synodriver/python-bz3.svg)
+![action](https://img.shields.io/github/workflow/status/synodriver/python-bz3/build%20wheel)
+
+### install
+```bash
+pip install bzip3
+```
+
+
+### Usage
+```python
+from bz3 import compress_file, decompress_file, test_file, compress, decompress
+import bz3
+
+with open("test_inp.txt", "rb") as inp, open("compressed.bz3", "wb") as out:
+    compress_file(inp, out, 1000 * 1000)
+
+with open("compressed.bz3", "rb") as inp:
+    test_file(inp, True)    
+
+with open("compressed.bz3", "rb") as inp, open("output.txt", "wb") as out:
+    decompress_file(inp, out)
+
+print(decompress(compress(b"12121")))
+
+with bz3.open("test.bz3", "wt", encoding="utf-8", num_threads=4) as f:
+    f.write("test data")
+
+with bz3.open("test.bz3", "rt", encoding="utf-8", num_threads=4) as f:
+    print(f.read())
+```
+- use ```BZ3_USE_CFFI``` env var to specify a backend
+- ```num_threads``` is only available on cython backend which have openmp support
+
+### Public functions
+```python
+from typing import IO, Optional, Union
+
+def compress_file(input: IO, output: IO, block_size: int) -> None: ...
+def decompress_file(input: IO, output: IO) -> None: ...
+def recover_file(input: IO, output: IO) -> None: ...
+def test_file(input: IO, should_raise: bool = ...) -> bool: ...
+
+
+class BZ3File:
+    def __init__(self, filename, mode: str = ..., block_size: int = ..., num_threads: int = ..., ignore_error: bool = False) -> None: ...
+    def close(self) -> None: ...
+    @property
+    def closed(self): ...
+    def fileno(self): ...
+    def seekable(self): ...
+    def readable(self): ...
+    def writable(self): ...
+    def peek(self, n: int = ...): ...
+    def read(self, size: int = ...): ...
+    def read1(self, size: int = ...): ...
+    def readinto(self, b): ...
+    def readline(self, size: int = ...): ...
+    def readlines(self, size: int = ...): ...
+    def write(self, data): ...
+    def writelines(self, seq): ...
+    def seek(self, offset, whence=...): ...
+    def tell(self): ...
+
+def open(filename, mode: str = ..., block_size: int = ..., encoding: str = ..., errors: str = ..., newline: str = ..., num_threads: int = 1, ignore_error: bool = False) -> BZ3File: ...
+def compress(data: bytes, block_size: int = ..., num_threads: int = 1) -> bytes: ...
+def decompress(data: bytes, num_threads: int = 1) -> bytes: ...
+
+def libversion() -> str: ... # Get bzip3 version
+def bound(inp: int) -> int: ... # Return the recommended size of the output buffer for the compression functions.
+
+# High-level api
+# Compress a block of data into out buffer, zerocopy, both parameters accept objects which implements buffer-protocol.
+# out must be writabel, size of out must be at least equal to bound(len(inp))
+def compress_into(inp: Union[bytes, bytearray], out: bytearray) -> int: ...
+# Decompress a block of data into out buffer, zerocopy
+def decompress_into(inp: Union[bytes, bytearray], out: bytearray) -> int: ...
+```
+
+- Note, high-level api won't work with low-level api, see [this](https://github.com/kspalaiologos/bzip3/issues/70)
```

### Comparing `bzip3-0.1.2rc1/bz3/backends/cffi/__init__.py` & `bzip3-0.1.3rc1/bz3/backends/cffi/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,404 +1,480 @@
-from typing import IO, Optional
-
-from bz3.backends.cffi._bz3 import ffi, lib
-
-
-def KiB(x: int) -> int:
-    return x * 1024
-
-
-def MiB(x: int) -> int:
-    return x * 1024 * 1024
-
-
-def check_file(file) -> bool:
-    if hasattr(file, "read") and hasattr(file, "write"):
-        return True
-    return False
-
-
-class BZ3Compressor:
-    def __init__(self, block_size: int):
-        if block_size < KiB(65) or block_size > MiB(511):
-            raise ValueError("Block size must be between 65 KiB and 511 MiB")
-        self.block_size = block_size
-        self.state = lib.bz3_new(block_size)
-        if self.state == ffi.NULL:
-            raise MemoryError("Failed to create a block encoder state")
-        self.buffer = ffi.cast(
-            "uint8_t*", lib.PyMem_Malloc(block_size + block_size // 50 + 32)
-        )
-        if self.buffer == ffi.NULL:
-            lib.bz3_free(self.state)
-            raise MemoryError("Failed to allocate memory")
-        self.uncompressed = bytearray()
-        self.have_magic_number = False  # 还没有写入magic number
-        self.byteswap_buf = ffi.new(
-            "uint8_t[4]"
-        )  # fixme: multithread concurrent competition, e.g. single instance in multithread
-
-    def __del__(self):
-        if self.state != ffi.NULL:
-            lib.bz3_free(self.state)
-        if self.buffer != ffi.NULL:
-            lib.PyMem_Freffi.e(self.buffer)
-
-    def compress(self, data: bytes) -> bytes:
-        input_size: int = len(data)
-        ret = bytearray()
-        if not self.have_magic_number:
-            ret.extend(b"BZ3v1")
-            lib.write_neutral_s32(
-                ffi.cast("uint8_t*", self.byteswap_buf), self.block_size
-            )
-            ret.extend(ffi.unpack(ffi.cast("char*", self.byteswap_buf), 4))
-            self.have_magic_number = True
-
-        if input_size > 0:
-            self.uncompressed.extend(data)
-            while len(self.uncompressed) >= self.block_size:
-                lib.memcpy(
-                    self.buffer, ffi.from_buffer(self.uncompressed), self.block_size
-                )
-                # make a copy
-                new_size = lib.bz3_encode_block(
-                    self.state, self.buffer, self.block_size
-                )
-                if new_size == -1:
-                    raise ValueError(
-                        "Failed to encode a block: %s" % lib.bz3_strerror(self.state)
-                    )
-
-                lib.write_neutral_s32(ffi.cast("uint8_t*", self.byteswap_buf), new_size)
-                ret.extend(ffi.unpack(ffi.cast("char*", self.byteswap_buf), 4))
-                lib.write_neutral_s32(
-                    ffi.cast("uint8_t*", self.byteswap_buf), self.block_size
-                )
-                ret.extend(ffi.unpack(ffi.cast("char*", self.byteswap_buf), 4))
-                ret.extend(ffi.unpack(ffi.cast("char*", self.buffer), new_size))
-
-                del self.uncompressed[: self.block_size]
-        return bytes(ret)
-
-    def flush(self) -> bytes:
-        ret = bytearray()
-        if self.uncompressed:
-            lib.memcpy(
-                self.buffer, ffi.from_buffer(self.uncompressed), len(self.uncompressed)
-            )
-            new_size = lib.bz3_encode_block(
-                self.state, self.buffer, len(self.uncompressed)
-            )
-            if new_size == -1:
-                raise ValueError(
-                    "Failed to encode a block: %s" % lib.bz3_strerror(self.state)
-                )
-            # ret = PyBytes_FromStringAndSize(NULL, new_size + 8)
-            # if not ret:
-            #     raise
-            lib.write_neutral_s32(ffi.cast("uint8_t*", self.byteswap_buf), new_size)
-            ret.extend(ffi.unpack(ffi.cast("char*", self.byteswap_buf), 4))
-            lib.write_neutral_s32(
-                ffi.cast("uint8_t*", self.byteswap_buf), len(self.uncompressed)
-            )
-            ret.extend(ffi.unpack(ffi.cast("char*", self.byteswap_buf), 4))
-            ret.extend(ffi.unpack(ffi.cast("char*", self.buffer), new_size))
-            self.uncompressed.clear()
-        return bytes(ret)
-
-    def error(self) -> str:
-        if lib.bz3_last_error(self.state) != lib.BZ3_OK:
-            return ffi.string(lib.bz3_strerror(self.state)).decode()
-        return None
-
-
-class BZ3Decompressor:
-    # cdef:
-    #     bz3_state * state
-    #     uint8_t * buffer
-    #     int32_t block_size
-    #     uint8_t byteswap_buf[4]
-    #     bytearray unused  # 还没解压的数据
-    #     bint have_magic_number
-
-    # cdef readonly bint eof
-    # cdef readonly bint needs_input
-    # cdef readonly bint needs_input
-
-    def init_state(self, block_size: int) -> int:
-        """should exec only once"""
-        self.block_size = block_size
-        self.state = lib.bz3_new(block_size)
-        if self.state == ffi.NULL:
-            raise MemoryError("Failed to create a block encoder state")
-        self.buffer = ffi.cast(
-            "uint8_t*", lib.PyMem_Malloc(block_size + block_size // 50 + 32)
-        )
-        if self.buffer == ffi.NULL:
-            lib.bz3_free(self.state)
-            self.state = ffi.NULL
-            raise MemoryError("Failed to allocate memory")
-
-    def __init__(self):
-        self.unused = bytearray()
-        self.have_magic_number = False  # 还没有读到magic number
-
-    def __del__(self):
-        if self.state != ffi.NULL:
-            lib.bz3_free(self.state)
-        if self.buffer != ffi.NULL:
-            lib.PyMem_Free(self.buffer)
-
-    def decompress(self, data: bytes) -> bytes:
-        input_size: int = len(data)
-        ret = bytearray()
-        # cdef int32_t new_size, old_size, block_size
-        if input_size > 0:
-            # if PyByteArray_Resize(self.unused, input_size+PyByteArray_GET_SIZE(self.unused)) < 0:
-            #     raise
-            # memcpy(&(PyByteArray_AS_STRING(self.unused)[PyByteArray_GET_SIZE(self.unused)-input_size]), &data[0], input_size) # self.unused.extend
-            self.unused.extend(data)
-            if (
-                len(self.unused) > 9 and not self.have_magic_number
-            ):  # 9 bytes magic number
-                if bytes(self.unused[:5]) != b"BZ3v1":
-                    raise ValueError("Invalid signature")
-                temp = self.unused[5:9]
-                block_size = lib.read_neutral_s32(
-                    ffi.cast("uint8_t*", ffi.from_buffer(temp))
-                )
-                if block_size < KiB(65) or block_size > MiB(511):
-                    raise ValueError(
-                        "The input file is corrupted. Reason: Invalid block size in the header"
-                    )
-                self.init_state(block_size)
-                del self.unused[:9]
-                self.have_magic_number = True
-
-            while True:
-                if len(self.unused) < 8:  # 8 byte的 header都不够 直接返回
-                    break
-                new_size = lib.read_neutral_s32(
-                    ffi.cast("uint8_t*", ffi.from_buffer(self.unused))
-                )  # todo gcc warning but bytes is contst
-                temp = self.unused[4:8]
-                old_size = lib.read_neutral_s32(
-                    ffi.cast("uint8_t*", ffi.from_buffer(temp))
-                )
-                if len(self.unused) < new_size + 8:  # 数据段不够
-                    break
-                temp = self.unused[8:]
-                lib.memcpy(self.buffer, ffi.from_buffer(temp), new_size)
-
-                code = lib.bz3_decode_block(self.state, self.buffer, new_size, old_size)
-                if code == -1:
-                    raise ValueError(
-                        "Failed to decode a block: %s" % lib.bz3_strerror(self.state)
-                    )
-                ret.extend(ffi.unpack(ffi.cast("char*", self.buffer), old_size))
-                del self.unused[: new_size + 8]
-        return bytes(ret)
-
-    @property
-    def unused_data(self):
-        """Data found after the end of the compressed stream."""
-        return bytes(self.unused)
-
-    def error(self) -> Optional[str]:
-        if lib.bz3_last_error(self.state) != lib.BZ3_OK:
-            return ffi.string(lib.bz3_strerror(self.state)).decode()
-        return None
-
-
-def compress_file(input: IO, output: IO, block_size: int) -> None:
-    if not check_file(input):
-        raise TypeError(
-            "input except a file-like object, got %s" % type(input).__name__
-        )
-    if not check_file(output):
-        raise TypeError(
-            "output except a file-like object, got %s" % type(output).__name__
-        )
-    state = lib.bz3_new(block_size)
-    if state == ffi.NULL:
-        raise MemoryError("Failed to create a block encoder state")
-    buffer = ffi.cast("uint8_t*", lib.PyMem_Malloc(block_size + block_size // 50 + 32))
-    if buffer == ffi.NULL:
-        lib.bz3_free(state)
-        raise MemoryError
-    byteswap_buf = ffi.new("uint8_t[4]")
-    output.write(b"BZ3v1")
-    lib.write_neutral_s32(byteswap_buf, block_size)
-    output.write(ffi.unpack(ffi.cast("char*", byteswap_buf), 4))  # magic header
-
-    try:
-        while True:
-            data = input.read(block_size)
-            if not data:
-                break
-            lib.memcpy(buffer, ffi.from_buffer(data), len(data))
-            new_size = lib.bz3_encode_block(state, buffer, len(data))
-            if new_size == -1:
-                raise ValueError(
-                    "Failed to encode a block: %s" % lib.bz3_strerror(state)
-                )
-            lib.write_neutral_s32(byteswap_buf, new_size)
-            output.write(ffi.unpack(ffi.cast("char*", byteswap_buf), 4))
-            lib.write_neutral_s32(byteswap_buf, len(data))
-            output.write(ffi.unpack(ffi.cast("char*", byteswap_buf), 4))
-            output.write(ffi.unpack(ffi.cast("char*", buffer), new_size))
-            output.flush()
-    finally:
-        output.flush()
-        lib.bz3_free(state)
-        lib.PyMem_Free(buffer)
-
-
-def decompress_file(input: IO, output: IO) -> None:
-    if not check_file(input):
-        raise TypeError(
-            "input except a file-like object, got %s" % type(input).__name__
-        )
-    if not check_file(output):
-        raise TypeError(
-            "output except a file-like object, got %s" % type(output).__name__
-        )
-    # cdef bytes data
-    # cdef int32_t block_size
-    data: bytes = input.read(9)  # magic and block_size type: bytes len = 9
-    if len(data) < 9:
-        raise ValueError("Invalid file. Reason: Smaller than magic header")
-    if data[:5] != b"BZ3v1":
-        raise ValueError("Invalid signature")
-    block_size: int = lib.read_neutral_s32(
-        ffi.cast("uint8_t*", ffi.from_buffer(data[5:]))
-    )
-    if block_size < KiB(65) or block_size > MiB(511):
-        raise ValueError(
-            "The input file is corrupted. Reason: Invalid block size in the header"
-        )
-    state = lib.bz3_new(block_size)
-    if state == ffi.NULL:
-        raise MemoryError("Failed to create a block encoder state")
-    buffer = ffi.cast("uint8_t*", lib.PyMem_Malloc(block_size + block_size // 50 + 32))
-    if buffer == ffi.NULL:
-        lib.bz3_free(state)
-        raise MemoryError("Failed to allocate memory")
-    # cdef uint8_t byteswap_buf[4]
-    # cdef int32_t new_size, old_size, code
-    try:
-        while True:
-            data = input.read(4)
-            if len(data) < 4:
-                break
-            new_size = lib.read_neutral_s32(ffi.cast("uint8_t*", ffi.from_buffer(data)))
-            data = input.read(4)
-            if len(data) < 4:
-                break
-            old_size = lib.read_neutral_s32(ffi.cast("uint8_t*", ffi.from_buffer(data)))
-            data = input.read(new_size)  # type: bytes
-            if len(data) < new_size:
-                break
-            lib.memcpy(buffer, ffi.cast("uint8_t*", ffi.from_buffer(data)), new_size)
-            code = lib.bz3_decode_block(state, buffer, new_size, old_size)
-            if code == -1:
-                raise ValueError(
-                    "Failed to decode a block: %s" % lib.bz3_strerror(state)
-                )
-            output.write(ffi.unpack(ffi.cast("char*", buffer), old_size))
-            output.flush()
-    finally:
-        output.flush()
-        lib.bz3_free(state)
-        lib.PyMem_Free(buffer)
-
-
-def test_file(input: IO, should_raise: bool = False) -> bool:
-    if not check_file(input):
-        raise TypeError(
-            "input except a file-like object, got %s" % type(input).__name__
-        )
-    # cdef bytes data
-    # cdef int32_t block_size
-    data: bytes = input.read(9)  # magic and block_size type: bytes len = 9
-    if len(data) < 9:
-        if should_raise:
-            raise ValueError("Invalid file. Reason: Smaller than magic header")
-        return False
-    if data[:5] != b"BZ3v1":
-        if should_raise:
-            raise ValueError("Invalid signature")
-        return False
-    block_size: int = lib.read_neutral_s32(
-        ffi.cast("uint8_t*", ffi.from_buffer(data[5:]))
-    )
-    if block_size < KiB(65) or block_size > MiB(511):
-        if should_raise:
-            raise ValueError(
-                "The input file is corrupted. Reason: Invalid block size in the header"
-            )
-        return False
-    state = lib.bz3_new(block_size)
-    if state == ffi.NULL:
-        raise MemoryError("Failed to create a block encoder state")
-    buffer = ffi.cast("uint8_t*", lib.PyMem_Malloc(block_size + block_size // 50 + 32))
-    if buffer == ffi.NULL:
-        lib.bz3_free(state)
-        raise MemoryError("Failed to allocate memory")
-    # cdef uint8_t byteswap_buf[4]
-    # cdef int32_t new_size, old_size, code
-    try:
-        while True:
-            data = input.read(4)
-            if len(data) < 4:
-                break
-            new_size = lib.read_neutral_s32(ffi.cast("uint8_t*", ffi.from_buffer(data)))
-            data = input.read(4)
-            if len(data) < 4:
-                break
-            old_size = lib.read_neutral_s32(ffi.cast("uint8_t*", ffi.from_buffer(data)))
-            data = input.read(new_size)  # type: bytes
-            if len(data) < new_size:
-                break
-            lib.memcpy(buffer, ffi.cast("uint8_t*", ffi.from_buffer(data)), new_size)
-            code = lib.bz3_decode_block(state, buffer, new_size, old_size)
-            if code == -1:
-                if should_raise:
-                    raise ValueError(
-                        "Failed to decode a block: %s" % lib.bz3_strerror(state)
-                    )
-                return False
-        return True
-    finally:
-        lib.bz3_free(state)
-        lib.PyMem_Free(buffer)
-
-
-def bound(input_size: int) -> int:
-    return lib.bz3_bound(input_size)
-
-
-def compress_into(data, out, block_size: int = 1000000) -> int:
-    out_size = ffi.new("size_t*")
-    out_size[0] = len(out)
-    bzerr = lib.bz3_compress(
-        block_size, ffi.from_buffer(data), ffi.from_buffer(out), len(data), out_size
-    )
-    if bzerr != lib.BZ3_OK:
-        raise ValueError(f"bz3_compress() failed with error code {bzerr}")
-    return out_size[0]
-
-
-def decompress_into(data, out) -> int:
-    out_size = ffi.new("size_t*")
-    out_size[0] = len(out)
-    bzerr = lib.bz3_decompress(
-        ffi.from_buffer(data), ffi.from_buffer(out), len(data), out_size
-    )
-    if bzerr != lib.BZ3_OK:
-        raise ValueError(f"bz3_decompress() failed with error code {bzerr}")
-    return out_size[0]
-
-
-def libversion() -> str:
-    return ffi.string(lib.bz3_version()).decode()
+import sys
+from typing import IO, Optional
+
+from bz3.backends.cffi._bz3 import ffi, lib
+
+
+def KiB(x: int) -> int:
+    return x * 1024
+
+
+def MiB(x: int) -> int:
+    return x * 1024 * 1024
+
+
+def check_file(file) -> bool:
+    if hasattr(file, "read") and hasattr(file, "write"):
+        return True
+    return False
+
+
+class BZ3Compressor:
+    def __init__(self, block_size: int):
+        if block_size < KiB(65) or block_size > MiB(511):
+            raise ValueError("Block size must be between 65 KiB and 511 MiB")
+        self.block_size = block_size
+        self.state = lib.bz3_new(block_size)
+        if self.state == ffi.NULL:
+            raise MemoryError("Failed to create a block encoder state")
+        self.buffer = ffi.cast(
+            "uint8_t*", lib.PyMem_Malloc(lib.bz3_bound(block_size))
+        )
+        if self.buffer == ffi.NULL:
+            lib.bz3_free(self.state)
+            raise MemoryError("Failed to allocate memory")
+        self.uncompressed = bytearray()
+        self.have_magic_number = False  # 还没有写入magic number
+        self.byteswap_buf = ffi.new(
+            "uint8_t[4]"
+        )  # fixme: multithread concurrent competition, e.g. single instance in multithread
+
+    def __del__(self):
+        if self.state != ffi.NULL:
+            lib.bz3_free(self.state)
+        if self.buffer != ffi.NULL:
+            lib.PyMem_Free(self.buffer)
+
+    def compress(self, data: bytes) -> bytes:
+        input_size: int = len(data)
+        ret = bytearray()
+        if not self.have_magic_number:
+            ret.extend(b"BZ3v1")
+            lib.write_neutral_s32(
+                ffi.cast("uint8_t*", self.byteswap_buf), self.block_size
+            )
+            ret.extend(ffi.unpack(ffi.cast("char*", self.byteswap_buf), 4))
+            self.have_magic_number = True
+
+        if input_size > 0:
+            self.uncompressed.extend(data)
+            while len(self.uncompressed) >= self.block_size:
+                lib.memcpy(
+                    self.buffer, ffi.from_buffer(self.uncompressed), self.block_size
+                )
+                # make a copy
+                new_size = lib.bz3_encode_block(
+                    self.state, self.buffer, self.block_size
+                )
+                if new_size == -1:
+                    raise ValueError(
+                        "Failed to encode a block: %s" % lib.bz3_strerror(self.state)
+                    )
+
+                lib.write_neutral_s32(ffi.cast("uint8_t*", self.byteswap_buf), new_size)
+                ret.extend(ffi.unpack(ffi.cast("char*", self.byteswap_buf), 4))
+                lib.write_neutral_s32(
+                    ffi.cast("uint8_t*", self.byteswap_buf), self.block_size
+                )
+                ret.extend(ffi.unpack(ffi.cast("char*", self.byteswap_buf), 4))
+                ret.extend(ffi.unpack(ffi.cast("char*", self.buffer), new_size))
+
+                del self.uncompressed[: self.block_size]
+        return bytes(ret)
+
+    def flush(self) -> bytes:
+        ret = bytearray()
+        if self.uncompressed:
+            lib.memcpy(
+                self.buffer, ffi.from_buffer(self.uncompressed), len(self.uncompressed)
+            )
+            new_size = lib.bz3_encode_block(
+                self.state, self.buffer, len(self.uncompressed)
+            )
+            if new_size == -1:
+                raise ValueError(
+                    "Failed to encode a block: %s" % lib.bz3_strerror(self.state)
+                )
+            # ret = PyBytes_FromStringAndSize(NULL, new_size + 8)
+            # if not ret:
+            #     raise
+            lib.write_neutral_s32(ffi.cast("uint8_t*", self.byteswap_buf), new_size)
+            ret.extend(ffi.unpack(ffi.cast("char*", self.byteswap_buf), 4))
+            lib.write_neutral_s32(
+                ffi.cast("uint8_t*", self.byteswap_buf), len(self.uncompressed)
+            )
+            ret.extend(ffi.unpack(ffi.cast("char*", self.byteswap_buf), 4))
+            ret.extend(ffi.unpack(ffi.cast("char*", self.buffer), new_size))
+            self.uncompressed.clear()
+        return bytes(ret)
+
+    def error(self) -> str:
+        if lib.bz3_last_error(self.state) != lib.BZ3_OK:
+            return ffi.string(lib.bz3_strerror(self.state)).decode()
+        return None
+
+
+class BZ3Decompressor:
+    # cdef:
+    #     bz3_state * state
+    #     uint8_t * buffer
+    #     int32_t block_size
+    #     uint8_t byteswap_buf[4]
+    #     bytearray unused  # 还没解压的数据
+    #     bint have_magic_number
+
+    # cdef readonly bint eof
+    # cdef readonly bint needs_input
+    # cdef readonly bint needs_input
+
+    def init_state(self, block_size: int) -> int:
+        """should exec only once"""
+        self.block_size = block_size
+        self.state = lib.bz3_new(block_size)
+        if self.state == ffi.NULL:
+            raise MemoryError("Failed to create a block encoder state")
+        self.buffer = ffi.cast(
+            "uint8_t*", lib.PyMem_Malloc(lib.bz3_bound(block_size))
+        )
+        if self.buffer == ffi.NULL:
+            lib.bz3_free(self.state)
+            self.state = ffi.NULL
+            raise MemoryError("Failed to allocate memory")
+
+    def __init__(self, ignore_error: bool = False):
+        self.unused = bytearray()
+        self.have_magic_number = False  # 还没有读到magic number
+        self.ignore_error = ignore_error
+
+    def __del__(self):
+        if self.state != ffi.NULL:
+            lib.bz3_free(self.state)
+        if self.buffer != ffi.NULL:
+            lib.PyMem_Free(self.buffer)
+
+    def decompress(self, data: bytes) -> bytes:
+        input_size: int = len(data)
+        ret = bytearray()
+        # cdef int32_t new_size, old_size, block_size
+        if input_size > 0:
+            # if PyByteArray_Resize(self.unused, input_size+PyByteArray_GET_SIZE(self.unused)) < 0:
+            #     raise
+            # memcpy(&(PyByteArray_AS_STRING(self.unused)[PyByteArray_GET_SIZE(self.unused)-input_size]), &data[0], input_size) # self.unused.extend
+            self.unused.extend(data)
+            if (
+                len(self.unused) > 9 and not self.have_magic_number
+            ):  # 9 bytes magic number
+                if bytes(self.unused[:5]) != b"BZ3v1":
+                    raise ValueError("Invalid signature")
+                temp = self.unused[5:9]
+                block_size = lib.read_neutral_s32(
+                    ffi.cast("uint8_t*", ffi.from_buffer(temp))
+                )
+                if block_size < KiB(65) or block_size > MiB(511):
+                    raise ValueError(
+                        "The input file is corrupted. Reason: Invalid block size in the header"
+                    )
+                self.init_state(block_size)
+                del self.unused[:9]
+                self.have_magic_number = True
+
+            while True:
+                if len(self.unused) < 8:  # 8 byte的 header都不够 直接返回
+                    break
+                new_size = lib.read_neutral_s32(
+                    ffi.cast("uint8_t*", ffi.from_buffer(self.unused))
+                )  # todo gcc warning but bytes is contst
+                temp = self.unused[4:8]
+                old_size = lib.read_neutral_s32(
+                    ffi.cast("uint8_t*", ffi.from_buffer(temp))
+                )
+                if old_size > lib.bz3_bound(self.block_size) or new_size > lib.bz3_bound(self.block_size):
+                    raise ValueError("Failed to decode a block: Inconsistent headers.")
+                if len(self.unused) < new_size + 8:  # 数据段不够
+                    break
+                temp = self.unused[8:]
+                lib.memcpy(self.buffer, ffi.from_buffer(temp), new_size)
+
+                code = lib.bz3_decode_block(self.state, self.buffer, new_size, old_size)
+                if code == -1:
+                    if self.ignore_error:
+                        print(
+                            f"Writing invalid block: {lib.bz3_strerror(self.state)}",
+                            file=sys.stderr,
+                        )
+                    else:
+                        raise ValueError(
+                            "Failed to decode a block: %s"
+                            % lib.bz3_strerror(self.state)
+                        )
+                ret.extend(ffi.unpack(ffi.cast("char*", self.buffer), old_size))
+                del self.unused[: new_size + 8]
+        return bytes(ret)
+
+    @property
+    def unused_data(self):
+        """Data found after the end of the compressed stream."""
+        return bytes(self.unused)
+
+    def error(self) -> Optional[str]:
+        if lib.bz3_last_error(self.state) != lib.BZ3_OK:
+            return ffi.string(lib.bz3_strerror(self.state)).decode()
+        return None
+
+
+def compress_file(input: IO, output: IO, block_size: int) -> None:
+    if not check_file(input):
+        raise TypeError(
+            "input except a file-like object, got %s" % type(input).__name__
+        )
+    if not check_file(output):
+        raise TypeError(
+            "output except a file-like object, got %s" % type(output).__name__
+        )
+    state = lib.bz3_new(block_size)
+    if state == ffi.NULL:
+        raise MemoryError("Failed to create a block encoder state")
+    buffer = ffi.cast("uint8_t*", lib.PyMem_Malloc(lib.bz3_bound(block_size)))
+    if buffer == ffi.NULL:
+        lib.bz3_free(state)
+        raise MemoryError
+    byteswap_buf = ffi.new("uint8_t[4]")
+    output.write(b"BZ3v1")
+    lib.write_neutral_s32(byteswap_buf, block_size)
+    output.write(ffi.unpack(ffi.cast("char*", byteswap_buf), 4))  # magic header
+
+    try:
+        while True:
+            data = input.read(block_size)
+            if not data:
+                break
+            lib.memcpy(buffer, ffi.from_buffer(data), len(data))
+            new_size = lib.bz3_encode_block(state, buffer, len(data))
+            if new_size == -1:
+                raise ValueError(
+                    "Failed to encode a block: %s" % lib.bz3_strerror(state)
+                )
+            lib.write_neutral_s32(byteswap_buf, new_size)
+            output.write(ffi.unpack(ffi.cast("char*", byteswap_buf), 4))
+            lib.write_neutral_s32(byteswap_buf, len(data))
+            output.write(ffi.unpack(ffi.cast("char*", byteswap_buf), 4))
+            output.write(ffi.unpack(ffi.cast("char*", buffer), new_size))
+            output.flush()
+    finally:
+        output.flush()
+        lib.bz3_free(state)
+        lib.PyMem_Free(buffer)
+
+
+def decompress_file(input: IO, output: IO) -> None:
+    if not check_file(input):
+        raise TypeError(
+            "input except a file-like object, got %s" % type(input).__name__
+        )
+    if not check_file(output):
+        raise TypeError(
+            "output except a file-like object, got %s" % type(output).__name__
+        )
+    # cdef bytes data
+    # cdef int32_t block_size
+    data: bytes = input.read(9)  # magic and block_size type: bytes len = 9
+    if len(data) < 9:
+        raise ValueError("Invalid file. Reason: Smaller than magic header")
+    if data[:5] != b"BZ3v1":
+        raise ValueError("Invalid signature")
+    block_size: int = lib.read_neutral_s32(
+        ffi.cast("uint8_t*", ffi.from_buffer(data[5:]))
+    )
+    if block_size < KiB(65) or block_size > MiB(511):
+        raise ValueError(
+            "The input file is corrupted. Reason: Invalid block size in the header"
+        )
+    state = lib.bz3_new(block_size)
+    if state == ffi.NULL:
+        raise MemoryError("Failed to create a block encoder state")
+    buffer = ffi.cast("uint8_t*", lib.PyMem_Malloc(lib.bz3_bound(block_size)))
+    if buffer == ffi.NULL:
+        lib.bz3_free(state)
+        raise MemoryError("Failed to allocate memory")
+    # cdef uint8_t byteswap_buf[4]
+    # cdef int32_t new_size, old_size, code
+    try:
+        while True:
+            data = input.read(4)
+            if len(data) < 4:
+                break
+            new_size = lib.read_neutral_s32(ffi.cast("uint8_t*", ffi.from_buffer(data)))
+            data = input.read(4)
+            if len(data) < 4:
+                break
+            old_size = lib.read_neutral_s32(ffi.cast("uint8_t*", ffi.from_buffer(data)))
+            if old_size > lib.bz3_bound(block_size) or new_size > lib.bz3_bound(block_size):
+                raise ValueError("Failed to decode a block: Inconsistent headers.")
+            data = input.read(new_size)  # type: bytes
+            if len(data) < new_size:
+                break
+            lib.memcpy(buffer, ffi.cast("uint8_t*", ffi.from_buffer(data)), new_size)
+            code = lib.bz3_decode_block(state, buffer, new_size, old_size)
+            if code == -1:
+                raise ValueError(
+                    "Failed to decode a block: %s" % lib.bz3_strerror(state)
+                )
+            output.write(ffi.unpack(ffi.cast("char*", buffer), old_size))
+            output.flush()
+    finally:
+        output.flush()
+        lib.bz3_free(state)
+        lib.PyMem_Free(buffer)
+
+
+def recover_file(input: IO, output: IO) -> None:
+    if not check_file(input):
+        raise TypeError(
+            "input except a file-like object, got %s" % type(input).__name__
+        )
+    if not check_file(output):
+        raise TypeError(
+            "output except a file-like object, got %s" % type(output).__name__
+        )
+    # cdef bytes data
+    # cdef int32_t block_size
+    data: bytes = input.read(9)  # magic and block_size type: bytes len = 9
+    if len(data) < 9:
+        raise ValueError("Invalid file. Reason: Smaller than magic header")
+    if data[:5] != b"BZ3v1":
+        raise ValueError("Invalid signature")
+    block_size: int = lib.read_neutral_s32(
+        ffi.cast("uint8_t*", ffi.from_buffer(data[5:]))
+    )
+    if block_size < KiB(65) or block_size > MiB(511):
+        raise ValueError(
+            "The input file is corrupted. Reason: Invalid block size in the header"
+        )
+    state = lib.bz3_new(block_size)
+    if state == ffi.NULL:
+        raise MemoryError("Failed to create a block encoder state")
+    buffer = ffi.cast("uint8_t*", lib.PyMem_Malloc(lib.bz3_bound(block_size)))
+    if buffer == ffi.NULL:
+        lib.bz3_free(state)
+        raise MemoryError("Failed to allocate memory")
+    # cdef uint8_t byteswap_buf[4]
+    # cdef int32_t new_size, old_size, code
+    try:
+        while True:
+            data = input.read(4)
+            if len(data) < 4:
+                break
+            new_size = lib.read_neutral_s32(ffi.cast("uint8_t*", ffi.from_buffer(data)))
+            data = input.read(4)
+            if len(data) < 4:
+                break
+            old_size = lib.read_neutral_s32(ffi.cast("uint8_t*", ffi.from_buffer(data)))
+            if old_size > lib.bz3_bound(block_size) or new_size > lib.bz3_bound(block_size):
+                raise ValueError("Failed to decode a block: Inconsistent headers.")
+            data = input.read(new_size)  # type: bytes
+            if len(data) < new_size:
+                break
+            lib.memcpy(buffer, ffi.cast("uint8_t*", ffi.from_buffer(data)), new_size)
+            code = lib.bz3_decode_block(state, buffer, new_size, old_size)
+            if code == -1:
+                print(
+                    f"Writing invalid block: {lib.bz3_strerror(state)}", file=sys.stderr
+                )
+            output.write(ffi.unpack(ffi.cast("char*", buffer), old_size))
+            output.flush()
+    finally:
+        output.flush()
+        lib.bz3_free(state)
+        lib.PyMem_Free(buffer)
+
+
+def test_file(input: IO, should_raise: bool = False) -> bool:
+    if not check_file(input):
+        raise TypeError(
+            "input except a file-like object, got %s" % type(input).__name__
+        )
+    # cdef bytes data
+    # cdef int32_t block_size
+    data: bytes = input.read(9)  # magic and block_size type: bytes len = 9
+    if len(data) < 9:
+        if should_raise:
+            raise ValueError("Invalid file. Reason: Smaller than magic header")
+        return False
+    if data[:5] != b"BZ3v1":
+        if should_raise:
+            raise ValueError("Invalid signature")
+        return False
+    block_size: int = lib.read_neutral_s32(
+        ffi.cast("uint8_t*", ffi.from_buffer(data[5:]))
+    )
+    if block_size < KiB(65) or block_size > MiB(511):
+        if should_raise:
+            raise ValueError(
+                "The input file is corrupted. Reason: Invalid block size in the header"
+            )
+        return False
+    state = lib.bz3_new(block_size)
+    if state == ffi.NULL:
+        raise MemoryError("Failed to create a block encoder state")
+    buffer = ffi.cast("uint8_t*", lib.PyMem_Malloc(lib.bz3_bound(block_size)))
+    if buffer == ffi.NULL:
+        lib.bz3_free(state)
+        raise MemoryError("Failed to allocate memory")
+    # cdef uint8_t byteswap_buf[4]
+    # cdef int32_t new_size, old_size, code
+    try:
+        while True:
+            data = input.read(4)
+            if len(data) < 4:
+                break
+            new_size = lib.read_neutral_s32(ffi.cast("uint8_t*", ffi.from_buffer(data)))
+            data = input.read(4)
+            if len(data) < 4:
+                break
+            old_size = lib.read_neutral_s32(ffi.cast("uint8_t*", ffi.from_buffer(data)))
+            if old_size > lib.bz3_bound(block_size) or new_size > lib.bz3_bound(block_size):
+                raise ValueError("Failed to decode a block: Inconsistent headers.")
+            data = input.read(new_size)  # type: bytes
+            if len(data) < new_size:
+                break
+            lib.memcpy(buffer, ffi.cast("uint8_t*", ffi.from_buffer(data)), new_size)
+            code = lib.bz3_decode_block(state, buffer, new_size, old_size)
+            if code == -1:
+                if should_raise:
+                    raise ValueError(
+                        "Failed to decode a block: %s" % lib.bz3_strerror(state)
+                    )
+                return False
+        return True
+    finally:
+        lib.bz3_free(state)
+        lib.PyMem_Free(buffer)
+
+
+def bound(input_size: int) -> int:
+    return lib.bz3_bound(input_size)
+
+
+def compress_into(data, out, block_size: int = 1000000) -> int:
+    out_size = ffi.new("size_t*")
+    out_size[0] = len(out)
+    bzerr = lib.bz3_compress(
+        block_size, ffi.from_buffer(data), ffi.from_buffer(out), len(data), out_size
+    )
+    if bzerr != lib.BZ3_OK:
+        raise ValueError(f"bz3_compress() failed with error code {bzerr}")
+    return out_size[0]
+
+
+def decompress_into(data, out) -> int:
+    out_size = ffi.new("size_t*")
+    out_size[0] = len(out)
+    bzerr = lib.bz3_decompress(
+        ffi.from_buffer(data), ffi.from_buffer(out), len(data), out_size
+    )
+    if bzerr != lib.BZ3_OK:
+        raise ValueError(f"bz3_decompress() failed with error code {bzerr}")
+    return out_size[0]
+
+
+def libversion() -> str:
+    return ffi.string(lib.bz3_version()).decode()
```

### Comparing `bzip3-0.1.2rc1/bz3/backends/cffi/build.py` & `bzip3-0.1.3rc1/bz3/backends/cffi/build.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,143 +1,142 @@
-import glob
-import sys
-
-from cffi import FFI
-
-ffibuilder = FFI()
-ffibuilder.cdef(
-    """
-typedef uint8_t u8;
-typedef uint16_t u16;
-typedef uint32_t u32;
-typedef uint64_t u64;
-
-typedef int8_t s8;
-typedef int16_t s16;
-typedef int32_t s32;
-
-
-
-#define BZ3_OK 0
-#define BZ3_ERR_OUT_OF_BOUNDS -1
-#define BZ3_ERR_BWT -2
-#define BZ3_ERR_CRC -3
-#define BZ3_ERR_MALFORMED_HEADER -4
-#define BZ3_ERR_TRUNCATED_DATA -5
-#define BZ3_ERR_DATA_TOO_BIG -6
-
-struct bz3_state;
-
-/**
- * @brief Get the last error number associated with a given state.
- */
-int8_t bz3_last_error(struct bz3_state * state);
-
-/**
- * @brief Return a user-readable message explaining the cause of the last error.
- */
-const char * bz3_strerror(struct bz3_state * state);
-
-/**
- * @brief Construct a new block encoder state, which will encode blocks as big as the given block size.
- * The decoder will be able to decode blocks at most as big as the given block size.
- * Returns NULL in case allocation fails or the block size is not between 65K and 511M
- */
-struct bz3_state * bz3_new(int32_t block_size);
-
-/**
- * @brief Free the memory occupied by a block encoder state.
- */
-void bz3_free(struct bz3_state * state);
-
-/**
- * @brief Return the recommended size of the output buffer for the compression functions.
- */
-size_t bz3_bound(size_t input_size);
-
-/* ** HIGH LEVEL APIs ** */
-
-/**
- * @brief Compress a block of data. This function does not support parallelism
- * by itself, consider using the low level `bz3_encode_blocks()` function instead.
- * Using the low level API might provide better performance.
- * Returns a bzip3 error code; BZ3_OK when the operation is successful.
- * Make sure to set out_size to the size of the output buffer before the operation;
- * out_size must be at least equal to `bz3_bound(in_size)'.
- */
-int bz3_compress(uint32_t block_size, const uint8_t * in, uint8_t * out, size_t in_size, size_t * out_size);
-
-/**
- * @brief Decompress a block of data. This function does not support parallelism
- * by itself, consider using the low level `bz3_decode_blocks()` function instad.
- * Using the low level API might provide better performance.
- * Returns a bzip3 error code; BZ3_OK when the operation is successful.
- * Make sure to set out_size to the size of the output buffer before the operation.
- */
-int bz3_decompress(const uint8_t * in, uint8_t * out, size_t in_size, size_t * out_size);
-
-/**
- * @brief Encode a single block. Returns the amount of bytes written to `buffer'.
- * `buffer' must be able to hold at least `size + size / 50 + 32' bytes. The size must not
- * exceed the block size associated with the state.
- */
-int32_t bz3_encode_block(struct bz3_state * state, uint8_t * buffer, int32_t size);
-
-/**
- * @brief Decode a single block.
- * `buffer' must be able to hold at least `size + size / 50 + 32' bytes. The size must not exceed
- * the block size associated with the state.
- * @param size The size of the compressed data in `buffer'
- * @param orig_size The original size of the data before compression.
- */
-int32_t bz3_decode_block(struct bz3_state * state, uint8_t * buffer, int32_t size, int32_t orig_size);
-
-/**
- * @brief Encode `n' blocks, all in parallel.
- * All specifics of the `bz3_encode_block' still hold. The function will launch a thread for each block.
- * The compressed sizes are written to the `sizes' array. Every buffer is overwritten and none of them can overlap.
- * Precisely `n' states, buffers and sizes must be supplied.
- *
- * Expects `n' between 2 and 16.
- *
- * Present in the shared library only if -lpthread was present during building.
- */
-//void bz3_encode_blocks(struct bz3_state * states[], uint8_t * buffers[], int32_t sizes[], int32_t n);
-
-/**
- * @brief Decode `n' blocks, all in parallel.
- * Same specifics as `bz3_encode_blocks', but doesn't overwrite `sizes'.
- */
-//void bz3_decode_blocks(struct bz3_state * states[], uint8_t * buffers[], int32_t sizes[], int32_t orig_sizes[], int32_t n);
-
-const char * bz3_version();
-
-s32 read_neutral_s32(u8 * data);
-void write_neutral_s32(u8 * data, s32 value);
-void* PyMem_Malloc(size_t n);
-void PyMem_Free(void* p);
-int strncmp (const char *s1, const char *s2, size_t size);
-void *memcpy  (void *pto, const void *pfrom, size_t size);
-    """
-)
-
-source = """
-#include <stdint.h>
-#include <string.h>
-#include "common.h"
-#include "libbz3.h"
-#include "libsais.h"
-"""
-c_sources = glob.glob("./dep/src/*.c")
-c_sources = list(filter(lambda x: "main" not in x, c_sources))
-print(c_sources)
-
-ffibuilder.set_source(
-    "bz3.backends.cffi._bz3",
-    source,
-    sources=c_sources,
-    include_dirs=["./dep/include"],
-    define_macros=[("VERSION", '"1.2.2.r16-gafe4343"')],
-)
-
-if __name__ == "__main__":
-    ffibuilder.compile()
+import glob
+
+from cffi import FFI
+
+ffibuilder = FFI()
+ffibuilder.cdef(
+    """
+typedef uint8_t u8;
+typedef uint16_t u16;
+typedef uint32_t u32;
+typedef uint64_t u64;
+
+typedef int8_t s8;
+typedef int16_t s16;
+typedef int32_t s32;
+
+
+
+#define BZ3_OK 0
+#define BZ3_ERR_OUT_OF_BOUNDS -1
+#define BZ3_ERR_BWT -2
+#define BZ3_ERR_CRC -3
+#define BZ3_ERR_MALFORMED_HEADER -4
+#define BZ3_ERR_TRUNCATED_DATA -5
+#define BZ3_ERR_DATA_TOO_BIG -6
+
+struct bz3_state;
+
+/**
+ * @brief Get the last error number associated with a given state.
+ */
+int8_t bz3_last_error(struct bz3_state * state);
+
+/**
+ * @brief Return a user-readable message explaining the cause of the last error.
+ */
+const char * bz3_strerror(struct bz3_state * state);
+
+/**
+ * @brief Construct a new block encoder state, which will encode blocks as big as the given block size.
+ * The decoder will be able to decode blocks at most as big as the given block size.
+ * Returns NULL in case allocation fails or the block size is not between 65K and 511M
+ */
+struct bz3_state * bz3_new(int32_t block_size);
+
+/**
+ * @brief Free the memory occupied by a block encoder state.
+ */
+void bz3_free(struct bz3_state * state);
+
+/**
+ * @brief Return the recommended size of the output buffer for the compression functions.
+ */
+size_t bz3_bound(size_t input_size);
+
+/* ** HIGH LEVEL APIs ** */
+
+/**
+ * @brief Compress a block of data. This function does not support parallelism
+ * by itself, consider using the low level `bz3_encode_blocks()` function instead.
+ * Using the low level API might provide better performance.
+ * Returns a bzip3 error code; BZ3_OK when the operation is successful.
+ * Make sure to set out_size to the size of the output buffer before the operation;
+ * out_size must be at least equal to `bz3_bound(in_size)'.
+ */
+int bz3_compress(uint32_t block_size, const uint8_t * in, uint8_t * out, size_t in_size, size_t * out_size);
+
+/**
+ * @brief Decompress a block of data. This function does not support parallelism
+ * by itself, consider using the low level `bz3_decode_blocks()` function instad.
+ * Using the low level API might provide better performance.
+ * Returns a bzip3 error code; BZ3_OK when the operation is successful.
+ * Make sure to set out_size to the size of the output buffer before the operation.
+ */
+int bz3_decompress(const uint8_t * in, uint8_t * out, size_t in_size, size_t * out_size);
+
+/**
+ * @brief Encode a single block. Returns the amount of bytes written to `buffer'.
+ * `buffer' must be able to hold at least `size + size / 50 + 32' bytes. The size must not
+ * exceed the block size associated with the state.
+ */
+int32_t bz3_encode_block(struct bz3_state * state, uint8_t * buffer, int32_t size);
+
+/**
+ * @brief Decode a single block.
+ * `buffer' must be able to hold at least `size + size / 50 + 32' bytes. The size must not exceed
+ * the block size associated with the state.
+ * @param size The size of the compressed data in `buffer'
+ * @param orig_size The original size of the data before compression.
+ */
+int32_t bz3_decode_block(struct bz3_state * state, uint8_t * buffer, int32_t size, int32_t orig_size);
+
+/**
+ * @brief Encode `n' blocks, all in parallel.
+ * All specifics of the `bz3_encode_block' still hold. The function will launch a thread for each block.
+ * The compressed sizes are written to the `sizes' array. Every buffer is overwritten and none of them can overlap.
+ * Precisely `n' states, buffers and sizes must be supplied.
+ *
+ * Expects `n' between 2 and 16.
+ *
+ * Present in the shared library only if -lpthread was present during building.
+ */
+//void bz3_encode_blocks(struct bz3_state * states[], uint8_t * buffers[], int32_t sizes[], int32_t n);
+
+/**
+ * @brief Decode `n' blocks, all in parallel.
+ * Same specifics as `bz3_encode_blocks', but doesn't overwrite `sizes'.
+ */
+//void bz3_decode_blocks(struct bz3_state * states[], uint8_t * buffers[], int32_t sizes[], int32_t orig_sizes[], int32_t n);
+
+const char * bz3_version();
+
+s32 read_neutral_s32(u8 * data);
+void write_neutral_s32(u8 * data, s32 value);
+void* PyMem_Malloc(size_t n);
+void PyMem_Free(void* p);
+int strncmp (const char *s1, const char *s2, size_t size);
+void *memcpy  (void *pto, const void *pfrom, size_t size);
+    """
+)
+
+source = """
+#include <stdint.h>
+#include <string.h>
+#include "common.h"
+#include "libbz3.h"
+#include "libsais.h"
+"""
+c_sources = glob.glob("./dep/src/*.c")
+c_sources = list(filter(lambda x: "main" not in x, c_sources))
+print(c_sources)
+
+ffibuilder.set_source(
+    "bz3.backends.cffi._bz3",
+    source,
+    sources=c_sources,
+    include_dirs=["./dep/include"],
+    define_macros=[("VERSION", '"1.3.1.r4-g6d041f4"')],
+)
+
+if __name__ == "__main__":
+    ffibuilder.compile()
```

### Comparing `bzip3-0.1.2rc1/bz3/backends/cython/_bz3.c` & `bzip3-0.1.3rc1/bz3/backends/cython/_bz3.c`

 * *Files 0% similar despite different names*

```diff
@@ -1,29 +1,35 @@
-/* Generated by Cython 0.29.33 */
+/* Generated by Cython 0.29.36 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "define_macros": [
             [
                 "VERSION",
-                "\"1.2.2.r16-gafe4343\""
+                "\"1.3.1.r4-g6d041f4\""
             ]
         ],
         "depends": [
-            "dep\\include\\common.h",
-            "dep\\include\\libbz3.h"
+            "dep/include/common.h",
+            "dep/include/libbz3.h"
+        ],
+        "extra_compile_args": [
+            "-fopenmp"
+        ],
+        "extra_link_args": [
+            "-fopenmp"
         ],
         "include_dirs": [
             "./dep/include"
         ],
         "name": "bz3.backends.cython._bz3",
         "sources": [
             "bz3/backends/cython/_bz3.pyx",
-            "./dep/src\\libbz3.c"
+            "./dep/src/libbz3.c"
         ]
     },
     "module_name": "bz3.backends.cython._bz3"
 }
 END: Cython Metadata */
 
 #ifndef PY_SSIZE_T_CLEAN
@@ -31,16 +37,16 @@
 #endif /* PY_SSIZE_T_CLEAN */
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
 #elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
     #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define CYTHON_ABI "0_29_33"
-#define CYTHON_HEX_VERSION 0x001D21F0
+#define CYTHON_ABI "0_29_36"
+#define CYTHON_HEX_VERSION 0x001D24F0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -100,18 +106,22 @@
   #define CYTHON_ASSUME_SAFE_MACROS 0
   #undef CYTHON_UNPACK_METHODS
   #define CYTHON_UNPACK_METHODS 0
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
-  #undef CYTHON_PEP489_MULTI_PHASE_INIT
-  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #if PY_VERSION_HEX < 0x03090000
+    #undef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
+  #endif
   #undef CYTHON_USE_TP_FINALIZE
-  #define CYTHON_USE_TP_FINALIZE 0
+  #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1 && PYPY_VERSION_NUM >= 0x07030C00)
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
@@ -225,15 +235,15 @@
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
   #if PY_VERSION_HEX < 0x02070000
     #undef CYTHON_USE_PYLONG_INTERNALS
     #define CYTHON_USE_PYLONG_INTERNALS 0
   #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
-    #define CYTHON_USE_PYLONG_INTERNALS 1
+    #define CYTHON_USE_PYLONG_INTERNALS (PY_VERSION_HEX < 0x030C00A5)
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
@@ -264,15 +274,15 @@
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
   #endif
   #ifndef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
+    #define CYTHON_USE_DICT_VERSIONS ((PY_VERSION_HEX >= 0x030600B1) && (PY_VERSION_HEX < 0x030C00A5))
   #endif
   #if PY_VERSION_HEX >= 0x030B00A4
     #undef CYTHON_USE_EXC_INFO_STACK
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
   #endif
@@ -387,17 +397,14 @@
   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
     #define CYTHON_INLINE inline
   #else
     #define CYTHON_INLINE
   #endif
 #endif
 
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
-  #define Py_OptimizeFlag 0
-#endif
 #define __PYX_BUILD_PY_SSIZE_T "n"
 #define CYTHON_FORMAT_SSIZE_T "z"
 #if PY_MAJOR_VERSION < 3
   #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
   #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
           PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
   #define __Pyx_DefaultClassType PyClass_Type
@@ -467,14 +474,19 @@
     }
 #else
   #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
           PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
 #endif
   #define __Pyx_DefaultClassType PyType_Type
 #endif
+#if PY_VERSION_HEX >= 0x030900F0 && !CYTHON_COMPILING_IN_PYPY
+  #define __Pyx_PyObject_GC_IsFinalized(o) PyObject_GC_IsFinalized(o)
+#else
+  #define __Pyx_PyObject_GC_IsFinalized(o) _PyGC_FINALIZED(o)
+#endif
 #ifndef Py_TPFLAGS_CHECKTYPES
   #define Py_TPFLAGS_CHECKTYPES 0
 #endif
 #ifndef Py_TPFLAGS_HAVE_INDEX
   #define Py_TPFLAGS_HAVE_INDEX 0
 #endif
 #ifndef Py_TPFLAGS_HAVE_NEWBUFFER
@@ -765,14 +777,21 @@
 #endif
 
 #define __PYX_HAVE__bz3__backends__cython___bz3
 #define __PYX_HAVE_API__bz3__backends__cython___bz3
 /* Early includes */
 #include <string.h>
 #include <stdio.h>
+
+#ifdef MEMDEBUG
+    #define MEMLOG(...) fprintf(stderr, __VA_ARGS__)
+#else
+    #define MEMLOG(...)
+#endif
+    
 #include <stdint.h>
 #include "common.h"
 #include "libbz3.h"
 #include "pythread.h"
 #include <stdlib.h>
 #include "pystate.h"
 #ifdef _OPENMP
@@ -980,15 +999,15 @@
 static int __pyx_lineno;
 static int __pyx_clineno = 0;
 static const char * __pyx_cfilenm= __FILE__;
 static const char *__pyx_filename;
 
 
 static const char *__pyx_f[] = {
-  "bz3\\backends\\cython\\_bz3.pyx",
+  "bz3/backends/cython/_bz3.pyx",
   "stringsource",
   "type.pxd",
 };
 /* NoFastGil.proto */
 #define __Pyx_PyGILState_Ensure PyGILState_Ensure
 #define __Pyx_PyGILState_Release PyGILState_Release
 #define __Pyx_FastGIL_Remember()
@@ -1101,39 +1120,39 @@
 struct __pyx_array_obj;
 struct __pyx_MemviewEnum_obj;
 struct __pyx_memoryview_obj;
 struct __pyx_memoryviewslice_obj;
 struct __pyx_opt_args_3bz3_8backends_6cython_4_bz3_test_file;
 struct __pyx_opt_args_3bz3_8backends_6cython_4_bz3_compress_into;
 
-/* "bz3/backends/cython/_bz3.pyx":299
- *         PyMem_Free(buffer)
+/* "bz3/backends/cython/_bz3.pyx":368
+ *         buffer = NULL
  * 
  * cpdef inline bint test_file(object input, bint should_raise = False) except? 0:             # <<<<<<<<<<<<<<
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  */
 struct __pyx_opt_args_3bz3_8backends_6cython_4_bz3_test_file {
   int __pyx_n;
   int should_raise;
 };
 
-/* "bz3/backends/cython/_bz3.pyx":359
+/* "bz3/backends/cython/_bz3.pyx":433
  * 
  * 
  * cpdef inline size_t compress_into(const uint8_t[::1] data, uint8_t[::1] out, uint32_t block_size = 1000000) except? 0:             # <<<<<<<<<<<<<<
  *     cdef:
  *         size_t out_size = <size_t>out.shape[0]
  */
 struct __pyx_opt_args_3bz3_8backends_6cython_4_bz3_compress_into {
   int __pyx_n;
   uint32_t block_size;
 };
 
-/* "bz3/backends/cython/_bz3.pyx":30
+/* "bz3/backends/cython/_bz3.pyx":34
  * @cython.no_gc
  * @cython.final
  * cdef class BZ3Compressor:             # <<<<<<<<<<<<<<
  *     cdef:
  *         bz3_state * state
  */
 struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Compressor {
@@ -1143,33 +1162,34 @@
   uint8_t *buffer;
   int32_t block_size;
   PyObject *uncompressed;
   int have_magic_number;
 };
 
 
-/* "bz3/backends/cython/_bz3.pyx":122
+/* "bz3/backends/cython/_bz3.pyx":126
  * @cython.no_gc
  * @cython.final
  * cdef class BZ3Decompressor:             # <<<<<<<<<<<<<<
  *     cdef:
  *         bz3_state * state
  */
 struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor {
   PyObject_HEAD
   struct __pyx_vtabstruct_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *__pyx_vtab;
   struct bz3_state *state;
   uint8_t *buffer;
   int32_t block_size;
   PyObject *unused;
   int have_magic_number;
+  int ignore_error;
 };
 
 
-/* "bz3/backends/cython/_bz3.pyx":396
+/* "bz3/backends/cython/_bz3.pyx":470
  * @cython.no_gc
  * @cython.final
  * cdef class BZ3OmpCompressor:             # <<<<<<<<<<<<<<
  *     cdef:
  *         bz3_state ** states
  */
 struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor {
@@ -1182,15 +1202,15 @@
   int32_t block_size;
   PyObject *uncompressed;
   int have_magic_number;
   uint32_t numthreads;
 };
 
 
-/* "bz3/backends/cython/_bz3.pyx":573
+/* "bz3/backends/cython/_bz3.pyx":682
  * @cython.no_gc
  * @cython.final
  * cdef class BZ3OmpDecompressor:             # <<<<<<<<<<<<<<
  *     cdef:
  *         bz3_state ** states
  */
 struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor {
@@ -1200,14 +1220,15 @@
   uint8_t **buffers;
   int32_t *sizes;
   int32_t *old_sizes;
   int32_t block_size;
   PyObject *unused;
   int have_magic_number;
   uint32_t numthreads;
+  int ignore_error;
 };
 
 
 /* "View.MemoryView":106
  * 
  * @cname("__pyx_array")
  * cdef class array:             # <<<<<<<<<<<<<<
@@ -1281,15 +1302,15 @@
   PyObject *from_object;
   PyObject *(*to_object_func)(char *);
   int (*to_dtype_func)(char *, PyObject *);
 };
 
 
 
-/* "bz3/backends/cython/_bz3.pyx":30
+/* "bz3/backends/cython/_bz3.pyx":34
  * @cython.no_gc
  * @cython.final
  * cdef class BZ3Compressor:             # <<<<<<<<<<<<<<
  *     cdef:
  *         bz3_state * state
  */
 
@@ -1300,15 +1321,15 @@
 };
 static struct __pyx_vtabstruct_3bz3_8backends_6cython_4_bz3_BZ3Compressor *__pyx_vtabptr_3bz3_8backends_6cython_4_bz3_BZ3Compressor;
 static CYTHON_INLINE PyObject *__pyx_f_3bz3_8backends_6cython_4_bz3_13BZ3Compressor_compress(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Compressor *, __Pyx_memviewslice, int __pyx_skip_dispatch);
 static CYTHON_INLINE PyObject *__pyx_f_3bz3_8backends_6cython_4_bz3_13BZ3Compressor_flush(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Compressor *, int __pyx_skip_dispatch);
 static CYTHON_INLINE PyObject *__pyx_f_3bz3_8backends_6cython_4_bz3_13BZ3Compressor_error(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Compressor *, int __pyx_skip_dispatch);
 
 
-/* "bz3/backends/cython/_bz3.pyx":122
+/* "bz3/backends/cython/_bz3.pyx":126
  * @cython.no_gc
  * @cython.final
  * cdef class BZ3Decompressor:             # <<<<<<<<<<<<<<
  *     cdef:
  *         bz3_state * state
  */
 
@@ -1319,15 +1340,15 @@
 };
 static struct __pyx_vtabstruct_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *__pyx_vtabptr_3bz3_8backends_6cython_4_bz3_BZ3Decompressor;
 static CYTHON_INLINE int __pyx_f_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_init_state(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *, int32_t);
 static CYTHON_INLINE PyObject *__pyx_f_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_decompress(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *, __Pyx_memviewslice, int __pyx_skip_dispatch);
 static CYTHON_INLINE PyObject *__pyx_f_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_error(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *, int __pyx_skip_dispatch);
 
 
-/* "bz3/backends/cython/_bz3.pyx":396
+/* "bz3/backends/cython/_bz3.pyx":470
  * @cython.no_gc
  * @cython.final
  * cdef class BZ3OmpCompressor:             # <<<<<<<<<<<<<<
  *     cdef:
  *         bz3_state ** states
  */
 
@@ -1342,15 +1363,15 @@
 static CYTHON_INLINE void __pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_free_states(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *);
 static CYTHON_INLINE void __pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_free_buffers(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *);
 static CYTHON_INLINE PyObject *__pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_compress(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *, __Pyx_memviewslice, int __pyx_skip_dispatch);
 static CYTHON_INLINE PyObject *__pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_flush(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *, int __pyx_skip_dispatch);
 static CYTHON_INLINE PyObject *__pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_error(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *, int __pyx_skip_dispatch);
 
 
-/* "bz3/backends/cython/_bz3.pyx":573
+/* "bz3/backends/cython/_bz3.pyx":682
  * @cython.no_gc
  * @cython.final
  * cdef class BZ3OmpDecompressor:             # <<<<<<<<<<<<<<
  *     cdef:
  *         bz3_state ** states
  */
 
@@ -1692,17 +1713,14 @@
          const char* encoding, const char* errors,
          PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors)) {
     return __Pyx_decode_c_bytes(
         PyBytes_AS_STRING(string), PyBytes_GET_SIZE(string),
         start, stop, encoding, errors, decode_func);
 }
 
-/* KeywordStringCheck.proto */
-static int __Pyx_CheckKeywordStrings(PyObject *kwdict, const char* function_name, int kw_allowed);
-
 /* GetException.proto */
 #if CYTHON_FAST_THREAD_STATE
 #define __Pyx_GetException(type, value, tb)  __Pyx__GetException(__pyx_tstate, type, value, tb)
 static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
 #else
 static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb);
 #endif
@@ -1942,14 +1960,31 @@
     Py_DECREF(none);
     return 0;
 #else
     return PyList_SetSlice(L, PY_SSIZE_T_MAX, PY_SSIZE_T_MAX, v);
 #endif
 }
 
+/* AssertionsEnabled.proto */
+#define __Pyx_init_assertions_enabled()
+#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
+  #define __pyx_assertions_enabled() (1)
+#elif PY_VERSION_HEX < 0x03080000  ||  CYTHON_COMPILING_IN_PYPY  ||  defined(Py_LIMITED_API)
+  #define __pyx_assertions_enabled() (!Py_OptimizeFlag)
+#elif CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030900A6
+  static int __pyx_assertions_enabled_flag;
+  #define __pyx_assertions_enabled() (__pyx_assertions_enabled_flag)
+  #undef __Pyx_init_assertions_enabled
+  static void __Pyx_init_assertions_enabled(void) {
+    __pyx_assertions_enabled_flag = ! _PyInterpreterState_GetConfig(__Pyx_PyThreadState_Current->interp)->optimization_level;
+  }
+#else
+  #define __pyx_assertions_enabled() (!Py_OptimizeFlag)
+#endif
+
 /* PySequenceContains.proto */
 static CYTHON_INLINE int __Pyx_PySequence_ContainsTF(PyObject* item, PyObject* seq, int eq) {
     int result = PySequence_Contains(seq, item);
     return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
 }
 
 /* ImportFrom.proto */
@@ -1978,22 +2013,30 @@
 /* PyObjectGetAttrStrNoError.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name);
 
 /* SetupReduce.proto */
 static int __Pyx_setup_reduce(PyObject* type_obj);
 
 /* TypeImport.proto */
-#ifndef __PYX_HAVE_RT_ImportType_proto
-#define __PYX_HAVE_RT_ImportType_proto
-enum __Pyx_ImportType_CheckSize {
-   __Pyx_ImportType_CheckSize_Error = 0,
-   __Pyx_ImportType_CheckSize_Warn = 1,
-   __Pyx_ImportType_CheckSize_Ignore = 2
+#ifndef __PYX_HAVE_RT_ImportType_proto_0_29_36
+#define __PYX_HAVE_RT_ImportType_proto_0_29_36
+#if __STDC_VERSION__ >= 201112L
+#include <stdalign.h>
+#endif
+#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
+#define __PYX_GET_STRUCT_ALIGNMENT_0_29_36(s) alignof(s)
+#else
+#define __PYX_GET_STRUCT_ALIGNMENT_0_29_36(s) sizeof(void*)
+#endif
+enum __Pyx_ImportType_CheckSize_0_29_36 {
+   __Pyx_ImportType_CheckSize_Error_0_29_36 = 0,
+   __Pyx_ImportType_CheckSize_Warn_0_29_36 = 1,
+   __Pyx_ImportType_CheckSize_Ignore_0_29_36 = 2
 };
-static PyTypeObject *__Pyx_ImportType(PyObject* module, const char *module_name, const char *class_name, size_t size, enum __Pyx_ImportType_CheckSize check_size);
+static PyTypeObject *__Pyx_ImportType_0_29_36(PyObject* module, const char *module_name, const char *class_name, size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_0_29_36 check_size);
 #endif
 
 /* CLineInTraceback.proto */
 #ifdef CYTHON_CLINE_IN_TRACEBACK
 #define __Pyx_CLineForTraceback(tstate, c_line)  (((CYTHON_CLINE_IN_TRACEBACK)) ? c_line : 0)
 #else
 static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line);
@@ -2323,15 +2366,17 @@
 static const char __pyx_k_block_size[] = "block_size";
 static const char __pyx_k_numthreads[] = "numthreads";
 static const char __pyx_k_pyx_result[] = "__pyx_result";
 static const char __pyx_k_pyx_vtable[] = "__pyx_vtable__";
 static const char __pyx_k_MemoryError[] = "MemoryError";
 static const char __pyx_k_PickleError[] = "PickleError";
 static const char __pyx_k_byteswap_buf[] = "byteswap_buf";
+static const char __pyx_k_ignore_error[] = "ignore_error";
 static const char __pyx_k_pyx_checksum[] = "__pyx_checksum";
+static const char __pyx_k_recover_file[] = "recover_file";
 static const char __pyx_k_should_raise[] = "should_raise";
 static const char __pyx_k_stringsource[] = "stringsource";
 static const char __pyx_k_BZ3Compressor[] = "BZ3Compressor";
 static const char __pyx_k_compress_file[] = "compress_file";
 static const char __pyx_k_pyx_getbuffer[] = "__pyx_getbuffer";
 static const char __pyx_k_reduce_cython[] = "__reduce_cython__";
 static const char __pyx_k_BZ3Decompressor[] = "BZ3Decompressor";
@@ -2356,25 +2401,26 @@
 static const char __pyx_k_Cannot_index_with_type_s[] = "Cannot index with type '%s'";
 static const char __pyx_k_bz3_backends_cython__bz3[] = "bz3.backends.cython._bz3";
 static const char __pyx_k_Failed_to_allocate_memory[] = "Failed to allocate memory";
 static const char __pyx_k_Invalid_shape_in_axis_d_d[] = "Invalid shape in axis %d: %d.";
 static const char __pyx_k_Failed_to_decode_a_block_s[] = "Failed to decode a block: %s";
 static const char __pyx_k_Failed_to_encode_a_block_s[] = "Failed to encode a block: %s";
 static const char __pyx_k_itemsize_0_for_cython_array[] = "itemsize <= 0 for cython.array";
-static const char __pyx_k_bz3_backends_cython__bz3_pyx[] = "bz3\\backends\\cython\\_bz3.pyx";
+static const char __pyx_k_bz3_backends_cython__bz3_pyx[] = "bz3/backends/cython/_bz3.pyx";
 static const char __pyx_k_unable_to_allocate_array_data[] = "unable to allocate array data.";
 static const char __pyx_k_strided_and_direct_or_indirect[] = "<strided and direct or indirect>";
 static const char __pyx_k_input_except_a_file_like_object[] = "input except a file-like object, got %s";
 static const char __pyx_k_Block_size_must_be_between_65_Ki[] = "Block size must be between 65 KiB and 511 MiB";
 static const char __pyx_k_Buffer_view_does_not_expose_stri[] = "Buffer view does not expose strides";
 static const char __pyx_k_Can_only_create_a_buffer_that_is[] = "Can only create a buffer that is contiguous in memory.";
 static const char __pyx_k_Cannot_assign_to_read_only_memor[] = "Cannot assign to read-only memoryview";
 static const char __pyx_k_Cannot_create_writable_memory_vi[] = "Cannot create writable memory view from read-only memoryview";
 static const char __pyx_k_Empty_shape_tuple_for_cython_arr[] = "Empty shape tuple for cython.array";
 static const char __pyx_k_Failed_to_create_a_block_encoder[] = "Failed to create a block encoder state";
+static const char __pyx_k_Failed_to_decode_a_block_Inconsi[] = "Failed to decode a block: Inconsistent headers.";
 static const char __pyx_k_Incompatible_checksums_0x_x_vs_0[] = "Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))";
 static const char __pyx_k_Indirect_dimensions_not_supporte[] = "Indirect dimensions not supported";
 static const char __pyx_k_Invalid_file_Reason_Smaller_than[] = "Invalid file. Reason: Smaller than magic header";
 static const char __pyx_k_Invalid_mode_expected_c_or_fortr[] = "Invalid mode, expected 'c' or 'fortran', got %s";
 static const char __pyx_k_Out_of_bounds_on_buffer_access_a[] = "Out of bounds on buffer access (axis %d)";
 static const char __pyx_k_The_input_file_is_corrupted_Reas[] = "The input file is corrupted. Reason: Invalid block size in the header";
 static const char __pyx_k_Unable_to_convert_item_to_object[] = "Unable to convert item to object";
@@ -2396,14 +2442,15 @@
 static PyObject *__pyx_kp_s_Cannot_assign_to_read_only_memor;
 static PyObject *__pyx_kp_s_Cannot_create_writable_memory_vi;
 static PyObject *__pyx_kp_s_Cannot_index_with_type_s;
 static PyObject *__pyx_n_s_Ellipsis;
 static PyObject *__pyx_kp_s_Empty_shape_tuple_for_cython_arr;
 static PyObject *__pyx_kp_u_Failed_to_allocate_memory;
 static PyObject *__pyx_kp_u_Failed_to_create_a_block_encoder;
+static PyObject *__pyx_kp_u_Failed_to_decode_a_block_Inconsi;
 static PyObject *__pyx_kp_u_Failed_to_decode_a_block_s;
 static PyObject *__pyx_kp_u_Failed_to_decode_data_s;
 static PyObject *__pyx_kp_u_Failed_to_encode_a_block_s;
 static PyObject *__pyx_kp_s_Incompatible_checksums_0x_x_vs_0;
 static PyObject *__pyx_n_s_IndexError;
 static PyObject *__pyx_kp_s_Indirect_dimensions_not_supporte;
 static PyObject *__pyx_kp_u_Invalid_file_Reason_Smaller_than;
@@ -2454,14 +2501,15 @@
 static PyObject *__pyx_n_s_flush;
 static PyObject *__pyx_n_s_format;
 static PyObject *__pyx_n_s_fortran;
 static PyObject *__pyx_n_u_fortran;
 static PyObject *__pyx_n_s_getstate;
 static PyObject *__pyx_kp_s_got_differing_extents_in_dimensi;
 static PyObject *__pyx_n_s_id;
+static PyObject *__pyx_n_s_ignore_error;
 static PyObject *__pyx_n_s_import;
 static PyObject *__pyx_n_s_input;
 static PyObject *__pyx_kp_u_input_except_a_file_like_object;
 static PyObject *__pyx_n_s_itemsize;
 static PyObject *__pyx_kp_s_itemsize_0_for_cython_array;
 static PyObject *__pyx_n_s_main;
 static PyObject *__pyx_n_s_memview;
@@ -2486,14 +2534,15 @@
 static PyObject *__pyx_n_s_pyx_result;
 static PyObject *__pyx_n_s_pyx_state;
 static PyObject *__pyx_n_s_pyx_type;
 static PyObject *__pyx_n_s_pyx_unpickle_Enum;
 static PyObject *__pyx_n_s_pyx_vtable;
 static PyObject *__pyx_n_s_range;
 static PyObject *__pyx_n_s_read;
+static PyObject *__pyx_n_s_recover_file;
 static PyObject *__pyx_n_s_reduce;
 static PyObject *__pyx_n_s_reduce_cython;
 static PyObject *__pyx_n_s_reduce_ex;
 static PyObject *__pyx_n_s_setstate;
 static PyObject *__pyx_n_s_setstate_cython;
 static PyObject *__pyx_n_s_shape;
 static PyObject *__pyx_n_s_should_raise;
@@ -2517,45 +2566,48 @@
 static void __pyx_pf_3bz3_8backends_6cython_4_bz3_13BZ3Compressor_2__dealloc__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Compressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_13BZ3Compressor_4compress(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Compressor *__pyx_v_self, __Pyx_memviewslice __pyx_v_data); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_13BZ3Compressor_6flush(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Compressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_13BZ3Compressor_8error(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Compressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_13BZ3Compressor_10block_size___get__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Compressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_13BZ3Compressor_10__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Compressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_13BZ3Compressor_12__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Compressor *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
-static int __pyx_pf_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor___cinit__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *__pyx_v_self); /* proto */
+static int __pyx_pf_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor___cinit__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *__pyx_v_self, int __pyx_v_ignore_error); /* proto */
 static void __pyx_pf_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_2__dealloc__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_4decompress(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *__pyx_v_self, __Pyx_memviewslice __pyx_v_data); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_11unused_data___get__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_6error(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_10block_size___get__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_12ignore_error___get__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_8__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_10__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_compress_file(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_input, PyObject *__pyx_v_output, int32_t __pyx_v_block_size); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_2decompress_file(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_input, PyObject *__pyx_v_output); /* proto */
-static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_4test_file(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_input, int __pyx_v_should_raise); /* proto */
-static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_6bound(CYTHON_UNUSED PyObject *__pyx_self, size_t __pyx_v_input_size); /* proto */
-static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_8compress_into(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_data, __Pyx_memviewslice __pyx_v_out, uint32_t __pyx_v_block_size); /* proto */
-static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_10decompress_into(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_data, __Pyx_memviewslice __pyx_v_out); /* proto */
-static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_12libversion(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
+static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_4recover_file(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_input, PyObject *__pyx_v_output); /* proto */
+static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_6test_file(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_input, int __pyx_v_should_raise); /* proto */
+static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_8bound(CYTHON_UNUSED PyObject *__pyx_self, size_t __pyx_v_input_size); /* proto */
+static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_10compress_into(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_data, __Pyx_memviewslice __pyx_v_out, uint32_t __pyx_v_block_size); /* proto */
+static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_12decompress_into(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_data, __Pyx_memviewslice __pyx_v_out); /* proto */
+static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_14libversion(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
 static int __pyx_pf_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor___cinit__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *__pyx_v_self, int32_t __pyx_v_block_size, uint32_t __pyx_v_numthreads); /* proto */
 static void __pyx_pf_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_2__dealloc__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_4compress(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *__pyx_v_self, __Pyx_memviewslice __pyx_v_data); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_6flush(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_8error(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_10block_size___get__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_10numthreads___get__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_10__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_12__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
-static int __pyx_pf_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor___cinit__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *__pyx_v_self, uint32_t __pyx_v_numthreads); /* proto */
+static int __pyx_pf_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor___cinit__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *__pyx_v_self, uint32_t __pyx_v_numthreads, int __pyx_v_ignore_error); /* proto */
 static void __pyx_pf_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_2__dealloc__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_4decompress(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *__pyx_v_self, __Pyx_memviewslice __pyx_v_data); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_11unused_data___get__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_6error(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_10block_size___get__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_10numthreads___get__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_12ignore_error___get__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_8__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_10__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array___cinit__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_shape, Py_ssize_t __pyx_v_itemsize, PyObject *__pyx_v_format, PyObject *__pyx_v_mode, int __pyx_v_allocate_buffer); /* proto */
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array_2__getbuffer__(struct __pyx_array_obj *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /* proto */
 static void __pyx_array___pyx_pf_15View_dot_MemoryView_5array_4__dealloc__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_15View_dot_MemoryView_5array_7memview___get__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static Py_ssize_t __pyx_array___pyx_pf_15View_dot_MemoryView_5array_6__len__(struct __pyx_array_obj *__pyx_v_self); /* proto */
@@ -2615,15 +2667,15 @@
 static PyObject *__pyx_int_neg_1;
 static PyObject *__pyx_tuple_;
 static PyObject *__pyx_tuple__2;
 static PyObject *__pyx_tuple__3;
 static PyObject *__pyx_tuple__7;
 static PyObject *__pyx_tuple__8;
 static PyObject *__pyx_tuple__9;
-static PyObject *__pyx_slice__32;
+static PyObject *__pyx_slice__33;
 static PyObject *__pyx_tuple__10;
 static PyObject *__pyx_tuple__11;
 static PyObject *__pyx_tuple__12;
 static PyObject *__pyx_tuple__13;
 static PyObject *__pyx_tuple__14;
 static PyObject *__pyx_tuple__15;
 static PyObject *__pyx_tuple__16;
@@ -2638,47 +2690,50 @@
 static PyObject *__pyx_tuple__25;
 static PyObject *__pyx_tuple__26;
 static PyObject *__pyx_tuple__27;
 static PyObject *__pyx_tuple__28;
 static PyObject *__pyx_tuple__29;
 static PyObject *__pyx_tuple__30;
 static PyObject *__pyx_tuple__31;
-static PyObject *__pyx_tuple__33;
+static PyObject *__pyx_tuple__32;
 static PyObject *__pyx_tuple__34;
 static PyObject *__pyx_tuple__35;
 static PyObject *__pyx_tuple__36;
 static PyObject *__pyx_tuple__37;
-static PyObject *__pyx_tuple__39;
-static PyObject *__pyx_tuple__41;
+static PyObject *__pyx_tuple__38;
+static PyObject *__pyx_tuple__40;
 static PyObject *__pyx_tuple__42;
-static PyObject *__pyx_tuple__43;
 static PyObject *__pyx_tuple__44;
 static PyObject *__pyx_tuple__45;
 static PyObject *__pyx_tuple__46;
-static PyObject *__pyx_codeobj__38;
-static PyObject *__pyx_codeobj__40;
-static PyObject *__pyx_codeobj__47;
+static PyObject *__pyx_tuple__47;
+static PyObject *__pyx_tuple__48;
+static PyObject *__pyx_tuple__49;
+static PyObject *__pyx_codeobj__39;
+static PyObject *__pyx_codeobj__41;
+static PyObject *__pyx_codeobj__43;
+static PyObject *__pyx_codeobj__50;
 /* Late includes */
 
-/* "bz3/backends/cython/_bz3.pyx":22
+/* "bz3/backends/cython/_bz3.pyx":26
  * cdef const char* magic = "BZ3v1"
  * 
  * cdef inline uint8_t PyFile_Check(object file):             # <<<<<<<<<<<<<<
  *     if PyObject_HasAttrString(file, "read") and PyObject_HasAttrString(file, "write"):  # should we check seek method?
  *         return 1
  */
 
 static CYTHON_INLINE uint8_t __pyx_f_3bz3_8backends_6cython_4_bz3_PyFile_Check(PyObject *__pyx_v_file) {
   uint8_t __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_t_2;
   __Pyx_RefNannySetupContext("PyFile_Check", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":23
+  /* "bz3/backends/cython/_bz3.pyx":27
  * 
  * cdef inline uint8_t PyFile_Check(object file):
  *     if PyObject_HasAttrString(file, "read") and PyObject_HasAttrString(file, "write"):  # should we check seek method?             # <<<<<<<<<<<<<<
  *         return 1
  *     return 0
  */
   __pyx_t_2 = (PyObject_HasAttrString(__pyx_v_file, ((char const *)"read")) != 0);
@@ -2688,58 +2743,58 @@
     goto __pyx_L4_bool_binop_done;
   }
   __pyx_t_2 = (PyObject_HasAttrString(__pyx_v_file, ((char const *)"write")) != 0);
   __pyx_t_1 = __pyx_t_2;
   __pyx_L4_bool_binop_done:;
   if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":24
+    /* "bz3/backends/cython/_bz3.pyx":28
  * cdef inline uint8_t PyFile_Check(object file):
  *     if PyObject_HasAttrString(file, "read") and PyObject_HasAttrString(file, "write"):  # should we check seek method?
  *         return 1             # <<<<<<<<<<<<<<
  *     return 0
  * 
  */
     __pyx_r = 1;
     goto __pyx_L0;
 
-    /* "bz3/backends/cython/_bz3.pyx":23
+    /* "bz3/backends/cython/_bz3.pyx":27
  * 
  * cdef inline uint8_t PyFile_Check(object file):
  *     if PyObject_HasAttrString(file, "read") and PyObject_HasAttrString(file, "write"):  # should we check seek method?             # <<<<<<<<<<<<<<
  *         return 1
  *     return 0
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":25
+  /* "bz3/backends/cython/_bz3.pyx":29
  *     if PyObject_HasAttrString(file, "read") and PyObject_HasAttrString(file, "write"):  # should we check seek method?
  *         return 1
  *     return 0             # <<<<<<<<<<<<<<
  * 
  * @cython.freelist(8)
  */
   __pyx_r = 0;
   goto __pyx_L0;
 
-  /* "bz3/backends/cython/_bz3.pyx":22
+  /* "bz3/backends/cython/_bz3.pyx":26
  * cdef const char* magic = "BZ3v1"
  * 
  * cdef inline uint8_t PyFile_Check(object file):             # <<<<<<<<<<<<<<
  *     if PyObject_HasAttrString(file, "read") and PyObject_HasAttrString(file, "write"):  # should we check seek method?
  *         return 1
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":38
+/* "bz3/backends/cython/_bz3.pyx":42
  *         bint have_magic_number
  * 
  *     def __cinit__(self, int32_t block_size):             # <<<<<<<<<<<<<<
  *         if block_size < KiB(65) or block_size > MiB(511):
  *             raise ValueError("Block size must be between 65 KiB and 511 MiB")
  */
 
@@ -2768,26 +2823,26 @@
       kw_args = PyDict_Size(__pyx_kwds);
       switch (pos_args) {
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_block_size)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 38, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 42, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
     }
-    __pyx_v_block_size = __Pyx_PyInt_As_int32_t(values[0]); if (unlikely((__pyx_v_block_size == ((int32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 38, __pyx_L3_error)
+    __pyx_v_block_size = __Pyx_PyInt_As_int32_t(values[0]); if (unlikely((__pyx_v_block_size == ((int32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 42, __pyx_L3_error)
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 38, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 42, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("bz3.backends.cython._bz3.BZ3Compressor.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_3bz3_8backends_6cython_4_bz3_13BZ3Compressor___cinit__(((struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Compressor *)__pyx_v_self), __pyx_v_block_size);
 
@@ -2803,15 +2858,15 @@
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__cinit__", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":39
+  /* "bz3/backends/cython/_bz3.pyx":43
  * 
  *     def __cinit__(self, int32_t block_size):
  *         if block_size < KiB(65) or block_size > MiB(511):             # <<<<<<<<<<<<<<
  *             raise ValueError("Block size must be between 65 KiB and 511 MiB")
  *         self.block_size = block_size
  */
   __pyx_t_2 = ((__pyx_v_block_size < KiB(65)) != 0);
@@ -2821,170 +2876,170 @@
     goto __pyx_L4_bool_binop_done;
   }
   __pyx_t_2 = ((__pyx_v_block_size > MiB(0x1FF)) != 0);
   __pyx_t_1 = __pyx_t_2;
   __pyx_L4_bool_binop_done:;
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":40
+    /* "bz3/backends/cython/_bz3.pyx":44
  *     def __cinit__(self, int32_t block_size):
  *         if block_size < KiB(65) or block_size > MiB(511):
  *             raise ValueError("Block size must be between 65 KiB and 511 MiB")             # <<<<<<<<<<<<<<
  *         self.block_size = block_size
  *         self.state = bz3_new(block_size)
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 40, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 44, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(0, 40, __pyx_L1_error)
+    __PYX_ERR(0, 44, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":39
+    /* "bz3/backends/cython/_bz3.pyx":43
  * 
  *     def __cinit__(self, int32_t block_size):
  *         if block_size < KiB(65) or block_size > MiB(511):             # <<<<<<<<<<<<<<
  *             raise ValueError("Block size must be between 65 KiB and 511 MiB")
  *         self.block_size = block_size
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":41
+  /* "bz3/backends/cython/_bz3.pyx":45
  *         if block_size < KiB(65) or block_size > MiB(511):
  *             raise ValueError("Block size must be between 65 KiB and 511 MiB")
  *         self.block_size = block_size             # <<<<<<<<<<<<<<
  *         self.state = bz3_new(block_size)
  *         if self.state == NULL:
  */
   __pyx_v_self->block_size = __pyx_v_block_size;
 
-  /* "bz3/backends/cython/_bz3.pyx":42
+  /* "bz3/backends/cython/_bz3.pyx":46
  *             raise ValueError("Block size must be between 65 KiB and 511 MiB")
  *         self.block_size = block_size
  *         self.state = bz3_new(block_size)             # <<<<<<<<<<<<<<
  *         if self.state == NULL:
  *             raise MemoryError("Failed to create a block encoder state")
  */
   __pyx_v_self->state = bz3_new(__pyx_v_block_size);
 
-  /* "bz3/backends/cython/_bz3.pyx":43
+  /* "bz3/backends/cython/_bz3.pyx":47
  *         self.block_size = block_size
  *         self.state = bz3_new(block_size)
  *         if self.state == NULL:             # <<<<<<<<<<<<<<
  *             raise MemoryError("Failed to create a block encoder state")
- *         self.buffer = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
+ *         self.buffer = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))
  */
   __pyx_t_1 = ((__pyx_v_self->state == NULL) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":44
+    /* "bz3/backends/cython/_bz3.pyx":48
  *         self.state = bz3_new(block_size)
  *         if self.state == NULL:
  *             raise MemoryError("Failed to create a block encoder state")             # <<<<<<<<<<<<<<
- *         self.buffer = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
+ *         self.buffer = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))
  *         if self.buffer == NULL:
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 44, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 48, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(0, 44, __pyx_L1_error)
+    __PYX_ERR(0, 48, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":43
+    /* "bz3/backends/cython/_bz3.pyx":47
  *         self.block_size = block_size
  *         self.state = bz3_new(block_size)
  *         if self.state == NULL:             # <<<<<<<<<<<<<<
  *             raise MemoryError("Failed to create a block encoder state")
- *         self.buffer = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
+ *         self.buffer = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":45
+  /* "bz3/backends/cython/_bz3.pyx":49
  *         if self.state == NULL:
  *             raise MemoryError("Failed to create a block encoder state")
- *         self.buffer = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)             # <<<<<<<<<<<<<<
+ *         self.buffer = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))             # <<<<<<<<<<<<<<
  *         if self.buffer == NULL:
  *             bz3_free(self.state)
  */
-  __pyx_v_self->buffer = ((uint8_t *)PyMem_Malloc(((__pyx_v_block_size + (((long)__pyx_v_block_size) / 50)) + 32)));
+  __pyx_v_self->buffer = ((uint8_t *)PyMem_Malloc(bz3_bound(__pyx_v_block_size)));
 
-  /* "bz3/backends/cython/_bz3.pyx":46
+  /* "bz3/backends/cython/_bz3.pyx":50
  *             raise MemoryError("Failed to create a block encoder state")
- *         self.buffer = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
+ *         self.buffer = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))
  *         if self.buffer == NULL:             # <<<<<<<<<<<<<<
  *             bz3_free(self.state)
  *             self.state = NULL
  */
   __pyx_t_1 = ((__pyx_v_self->buffer == NULL) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":47
- *         self.buffer = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
+    /* "bz3/backends/cython/_bz3.pyx":51
+ *         self.buffer = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))
  *         if self.buffer == NULL:
  *             bz3_free(self.state)             # <<<<<<<<<<<<<<
  *             self.state = NULL
  *             raise MemoryError("Failed to allocate memory")
  */
     bz3_free(__pyx_v_self->state);
 
-    /* "bz3/backends/cython/_bz3.pyx":48
+    /* "bz3/backends/cython/_bz3.pyx":52
  *         if self.buffer == NULL:
  *             bz3_free(self.state)
  *             self.state = NULL             # <<<<<<<<<<<<<<
  *             raise MemoryError("Failed to allocate memory")
  *         self.uncompressed = bytearray()
  */
     __pyx_v_self->state = NULL;
 
-    /* "bz3/backends/cython/_bz3.pyx":49
+    /* "bz3/backends/cython/_bz3.pyx":53
  *             bz3_free(self.state)
  *             self.state = NULL
  *             raise MemoryError("Failed to allocate memory")             # <<<<<<<<<<<<<<
  *         self.uncompressed = bytearray()
  *         self.have_magic_number = 0 # magic number
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 49, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 53, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(0, 49, __pyx_L1_error)
+    __PYX_ERR(0, 53, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":46
+    /* "bz3/backends/cython/_bz3.pyx":50
  *             raise MemoryError("Failed to create a block encoder state")
- *         self.buffer = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
+ *         self.buffer = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))
  *         if self.buffer == NULL:             # <<<<<<<<<<<<<<
  *             bz3_free(self.state)
  *             self.state = NULL
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":50
+  /* "bz3/backends/cython/_bz3.pyx":54
  *             self.state = NULL
  *             raise MemoryError("Failed to allocate memory")
  *         self.uncompressed = bytearray()             # <<<<<<<<<<<<<<
  *         self.have_magic_number = 0 # magic number
  * 
  */
-  __pyx_t_3 = __Pyx_PyObject_CallNoArg(((PyObject *)(&PyByteArray_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 50, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_CallNoArg(((PyObject *)(&PyByteArray_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 54, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_3);
   __Pyx_GOTREF(__pyx_v_self->uncompressed);
   __Pyx_DECREF(__pyx_v_self->uncompressed);
   __pyx_v_self->uncompressed = ((PyObject*)__pyx_t_3);
   __pyx_t_3 = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":51
+  /* "bz3/backends/cython/_bz3.pyx":55
  *             raise MemoryError("Failed to allocate memory")
  *         self.uncompressed = bytearray()
  *         self.have_magic_number = 0 # magic number             # <<<<<<<<<<<<<<
  * 
  *     def __dealloc__(self):
  */
   __pyx_v_self->have_magic_number = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":38
+  /* "bz3/backends/cython/_bz3.pyx":42
  *         bint have_magic_number
  * 
  *     def __cinit__(self, int32_t block_size):             # <<<<<<<<<<<<<<
  *         if block_size < KiB(65) or block_size > MiB(511):
  *             raise ValueError("Block size must be between 65 KiB and 511 MiB")
  */
 
@@ -2996,15 +3051,15 @@
   __Pyx_AddTraceback("bz3.backends.cython._bz3.BZ3Compressor.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":53
+/* "bz3/backends/cython/_bz3.pyx":57
  *         self.have_magic_number = 0 # magic number
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         if self.state != NULL:
  *             bz3_free(self.state)
  */
 
@@ -3020,101 +3075,101 @@
 }
 
 static void __pyx_pf_3bz3_8backends_6cython_4_bz3_13BZ3Compressor_2__dealloc__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Compressor *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":54
+  /* "bz3/backends/cython/_bz3.pyx":58
  * 
  *     def __dealloc__(self):
  *         if self.state != NULL:             # <<<<<<<<<<<<<<
  *             bz3_free(self.state)
  *             self.state = NULL
  */
   __pyx_t_1 = ((__pyx_v_self->state != NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":55
+    /* "bz3/backends/cython/_bz3.pyx":59
  *     def __dealloc__(self):
  *         if self.state != NULL:
  *             bz3_free(self.state)             # <<<<<<<<<<<<<<
  *             self.state = NULL
  *         if self.buffer !=NULL:
  */
     bz3_free(__pyx_v_self->state);
 
-    /* "bz3/backends/cython/_bz3.pyx":56
+    /* "bz3/backends/cython/_bz3.pyx":60
  *         if self.state != NULL:
  *             bz3_free(self.state)
  *             self.state = NULL             # <<<<<<<<<<<<<<
  *         if self.buffer !=NULL:
  *             PyMem_Free(self.buffer)
  */
     __pyx_v_self->state = NULL;
 
-    /* "bz3/backends/cython/_bz3.pyx":54
+    /* "bz3/backends/cython/_bz3.pyx":58
  * 
  *     def __dealloc__(self):
  *         if self.state != NULL:             # <<<<<<<<<<<<<<
  *             bz3_free(self.state)
  *             self.state = NULL
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":57
+  /* "bz3/backends/cython/_bz3.pyx":61
  *             bz3_free(self.state)
  *             self.state = NULL
  *         if self.buffer !=NULL:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.buffer)
  *             self.buffer = NULL
  */
   __pyx_t_1 = ((__pyx_v_self->buffer != NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":58
+    /* "bz3/backends/cython/_bz3.pyx":62
  *             self.state = NULL
  *         if self.buffer !=NULL:
  *             PyMem_Free(self.buffer)             # <<<<<<<<<<<<<<
  *             self.buffer = NULL
  * 
  */
     PyMem_Free(__pyx_v_self->buffer);
 
-    /* "bz3/backends/cython/_bz3.pyx":59
+    /* "bz3/backends/cython/_bz3.pyx":63
  *         if self.buffer !=NULL:
  *             PyMem_Free(self.buffer)
  *             self.buffer = NULL             # <<<<<<<<<<<<<<
  * 
  *     cpdef inline bytes compress(self, const uint8_t[::1] data):
  */
     __pyx_v_self->buffer = NULL;
 
-    /* "bz3/backends/cython/_bz3.pyx":57
+    /* "bz3/backends/cython/_bz3.pyx":61
  *             bz3_free(self.state)
  *             self.state = NULL
  *         if self.buffer !=NULL:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.buffer)
  *             self.buffer = NULL
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":53
+  /* "bz3/backends/cython/_bz3.pyx":57
  *         self.have_magic_number = 0 # magic number
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         if self.state != NULL:
  *             bz3_free(self.state)
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "bz3/backends/cython/_bz3.pyx":61
+/* "bz3/backends/cython/_bz3.pyx":65
  *             self.buffer = NULL
  * 
  *     cpdef inline bytes compress(self, const uint8_t[::1] data):             # <<<<<<<<<<<<<<
  *         cdef Py_ssize_t input_size = data.shape[0]
  *         cdef int32_t new_size
  */
 
@@ -3131,180 +3186,180 @@
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("compress", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":62
+  /* "bz3/backends/cython/_bz3.pyx":66
  * 
  *     cpdef inline bytes compress(self, const uint8_t[::1] data):
  *         cdef Py_ssize_t input_size = data.shape[0]             # <<<<<<<<<<<<<<
  *         cdef int32_t new_size
  *         cdef bytearray ret = bytearray()
  */
   __pyx_v_input_size = (__pyx_v_data.shape[0]);
 
-  /* "bz3/backends/cython/_bz3.pyx":64
+  /* "bz3/backends/cython/_bz3.pyx":68
  *         cdef Py_ssize_t input_size = data.shape[0]
  *         cdef int32_t new_size
  *         cdef bytearray ret = bytearray()             # <<<<<<<<<<<<<<
  *         if not self.have_magic_number:
  *             # if PyByteArray_Resize(ret, 9) < 0:
  */
-  __pyx_t_1 = __Pyx_PyObject_CallNoArg(((PyObject *)(&PyByteArray_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 64, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_CallNoArg(((PyObject *)(&PyByteArray_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 68, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_ret = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":65
+  /* "bz3/backends/cython/_bz3.pyx":69
  *         cdef int32_t new_size
  *         cdef bytearray ret = bytearray()
  *         if not self.have_magic_number:             # <<<<<<<<<<<<<<
  *             # if PyByteArray_Resize(ret, 9) < 0:
  *             #     raise
  */
   __pyx_t_2 = ((!(__pyx_v_self->have_magic_number != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "bz3/backends/cython/_bz3.pyx":69
+    /* "bz3/backends/cython/_bz3.pyx":73
  *             #     raise
  *             # memcpy(PyByteArray_AS_STRING(ret), magic, 5)
  *             ret.extend(<bytes>magic[:5]+b"\x00\x00\x00\x00")  # 9 bytes             # <<<<<<<<<<<<<<
  *             write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[5]), self.block_size)
  *             self.have_magic_number = 1
  */
-    __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_3bz3_8backends_6cython_4_bz3_magic + 0, 5 - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 69, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_3bz3_8backends_6cython_4_bz3_magic + 0, 5 - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 73, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = PyNumber_Add(__pyx_t_1, __pyx_kp_b__4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 69, __pyx_L1_error)
+    __pyx_t_3 = PyNumber_Add(__pyx_t_1, __pyx_kp_b__4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 73, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = __Pyx_CallUnboundCMethod1(&__pyx_umethod_PyByteArray_Type_extend, __pyx_v_ret, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 69, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_CallUnboundCMethod1(&__pyx_umethod_PyByteArray_Type_extend, __pyx_v_ret, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 73, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "bz3/backends/cython/_bz3.pyx":70
+    /* "bz3/backends/cython/_bz3.pyx":74
  *             # memcpy(PyByteArray_AS_STRING(ret), magic, 5)
  *             ret.extend(<bytes>magic[:5]+b"\x00\x00\x00\x00")  # 9 bytes
  *             write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[5]), self.block_size)             # <<<<<<<<<<<<<<
  *             self.have_magic_number = 1
  * 
  */
     write_neutral_s32(((uint8_t *)(&(PyByteArray_AS_STRING(__pyx_v_ret)[5]))), __pyx_v_self->block_size);
 
-    /* "bz3/backends/cython/_bz3.pyx":71
+    /* "bz3/backends/cython/_bz3.pyx":75
  *             ret.extend(<bytes>magic[:5]+b"\x00\x00\x00\x00")  # 9 bytes
  *             write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[5]), self.block_size)
  *             self.have_magic_number = 1             # <<<<<<<<<<<<<<
  * 
  *         if input_size > 0:
  */
     __pyx_v_self->have_magic_number = 1;
 
-    /* "bz3/backends/cython/_bz3.pyx":65
+    /* "bz3/backends/cython/_bz3.pyx":69
  *         cdef int32_t new_size
  *         cdef bytearray ret = bytearray()
  *         if not self.have_magic_number:             # <<<<<<<<<<<<<<
  *             # if PyByteArray_Resize(ret, 9) < 0:
  *             #     raise
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":73
+  /* "bz3/backends/cython/_bz3.pyx":77
  *             self.have_magic_number = 1
  * 
  *         if input_size > 0:             # <<<<<<<<<<<<<<
  *             # if PyByteArray_Resize(self.uncompressed, input_size+PyByteArray_GET_SIZE(self.uncompressed)) < 0:
  *             #     raise
  */
   __pyx_t_2 = ((__pyx_v_input_size > 0) != 0);
   if (__pyx_t_2) {
 
-    /* "bz3/backends/cython/_bz3.pyx":77
+    /* "bz3/backends/cython/_bz3.pyx":81
  *             #     raise
  *             # memcpy(&(PyByteArray_AS_STRING(self.uncompressed)[PyByteArray_GET_SIZE(self.uncompressed)-input_size]), &data[0], input_size) # todo? direct copy to bytearray
  *             self.uncompressed.extend(data)             # <<<<<<<<<<<<<<
  *             while PyByteArray_GET_SIZE(self.uncompressed)>=self.block_size:
  *                 memcpy(self.buffer, PyByteArray_AS_STRING(self.uncompressed), <size_t>self.block_size)
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->uncompressed, __pyx_n_s_extend); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 77, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->uncompressed, __pyx_n_s_extend); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 81, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __pyx_memoryview_fromslice(__pyx_v_data, 1, (PyObject *(*)(char *)) __pyx_memview_get_nn_uint8_t__const__, (int (*)(char *, PyObject *)) NULL, 0);; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 77, __pyx_L1_error)
+    __pyx_t_4 = __pyx_memoryview_fromslice(__pyx_v_data, 1, (PyObject *(*)(char *)) __pyx_memview_get_nn_uint8_t__const__, (int (*)(char *, PyObject *)) NULL, 0);; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 81, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_5 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
     __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 77, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 81, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "bz3/backends/cython/_bz3.pyx":78
+    /* "bz3/backends/cython/_bz3.pyx":82
  *             # memcpy(&(PyByteArray_AS_STRING(self.uncompressed)[PyByteArray_GET_SIZE(self.uncompressed)-input_size]), &data[0], input_size) # todo? direct copy to bytearray
  *             self.uncompressed.extend(data)
  *             while PyByteArray_GET_SIZE(self.uncompressed)>=self.block_size:             # <<<<<<<<<<<<<<
  *                 memcpy(self.buffer, PyByteArray_AS_STRING(self.uncompressed), <size_t>self.block_size)
  *                 # make a copy
  */
     while (1) {
       __pyx_t_1 = __pyx_v_self->uncompressed;
       __Pyx_INCREF(__pyx_t_1);
       __pyx_t_2 = ((PyByteArray_GET_SIZE(__pyx_t_1) >= __pyx_v_self->block_size) != 0);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       if (!__pyx_t_2) break;
 
-      /* "bz3/backends/cython/_bz3.pyx":79
+      /* "bz3/backends/cython/_bz3.pyx":83
  *             self.uncompressed.extend(data)
  *             while PyByteArray_GET_SIZE(self.uncompressed)>=self.block_size:
  *                 memcpy(self.buffer, PyByteArray_AS_STRING(self.uncompressed), <size_t>self.block_size)             # <<<<<<<<<<<<<<
  *                 # make a copy
  *                 with nogil:
  */
       __pyx_t_1 = __pyx_v_self->uncompressed;
       __Pyx_INCREF(__pyx_t_1);
       (void)(memcpy(__pyx_v_self->buffer, PyByteArray_AS_STRING(__pyx_t_1), ((size_t)__pyx_v_self->block_size)));
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":81
+      /* "bz3/backends/cython/_bz3.pyx":85
  *                 memcpy(self.buffer, PyByteArray_AS_STRING(self.uncompressed), <size_t>self.block_size)
  *                 # make a copy
  *                 with nogil:             # <<<<<<<<<<<<<<
  *                     new_size = bz3_encode_block(self.state, self.buffer, self.block_size)
  *                 if new_size == -1:
  */
       {
           #ifdef WITH_THREAD
           PyThreadState *_save;
           Py_UNBLOCK_THREADS
           __Pyx_FastGIL_Remember();
           #endif
           /*try:*/ {
 
-            /* "bz3/backends/cython/_bz3.pyx":82
+            /* "bz3/backends/cython/_bz3.pyx":86
  *                 # make a copy
  *                 with nogil:
  *                     new_size = bz3_encode_block(self.state, self.buffer, self.block_size)             # <<<<<<<<<<<<<<
  *                 if new_size == -1:
  *                     raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.state))
  */
             __pyx_v_new_size = bz3_encode_block(__pyx_v_self->state, __pyx_v_self->buffer, __pyx_v_self->block_size);
           }
 
-          /* "bz3/backends/cython/_bz3.pyx":81
+          /* "bz3/backends/cython/_bz3.pyx":85
  *                 memcpy(self.buffer, PyByteArray_AS_STRING(self.uncompressed), <size_t>self.block_size)
  *                 # make a copy
  *                 with nogil:             # <<<<<<<<<<<<<<
  *                     new_size = bz3_encode_block(self.state, self.buffer, self.block_size)
  *                 if new_size == -1:
  */
           /*finally:*/ {
@@ -3315,134 +3370,134 @@
               #endif
               goto __pyx_L11;
             }
             __pyx_L11:;
           }
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":83
+      /* "bz3/backends/cython/_bz3.pyx":87
  *                 with nogil:
  *                     new_size = bz3_encode_block(self.state, self.buffer, self.block_size)
  *                 if new_size == -1:             # <<<<<<<<<<<<<<
  *                     raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.state))
  *                 # if PyByteArray_Resize(ret, PyByteArray_GET_SIZE(ret) + new_size + 8) < 0:
  */
       __pyx_t_2 = ((__pyx_v_new_size == -1L) != 0);
       if (unlikely(__pyx_t_2)) {
 
-        /* "bz3/backends/cython/_bz3.pyx":84
+        /* "bz3/backends/cython/_bz3.pyx":88
  *                     new_size = bz3_encode_block(self.state, self.buffer, self.block_size)
  *                 if new_size == -1:
  *                     raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.state))             # <<<<<<<<<<<<<<
  *                 # if PyByteArray_Resize(ret, PyByteArray_GET_SIZE(ret) + new_size + 8) < 0:
  *                 #     raise
  */
-        __pyx_t_1 = __Pyx_PyBytes_FromString(bz3_strerror(__pyx_v_self->state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 84, __pyx_L1_error)
+        __pyx_t_1 = __Pyx_PyBytes_FromString(bz3_strerror(__pyx_v_self->state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 88, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_1);
-        __pyx_t_3 = PyUnicode_Format(__pyx_kp_u_Failed_to_encode_a_block_s, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 84, __pyx_L1_error)
+        __pyx_t_3 = PyUnicode_Format(__pyx_kp_u_Failed_to_encode_a_block_s, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 88, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-        __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 84, __pyx_L1_error)
+        __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 88, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
         __Pyx_Raise(__pyx_t_1, 0, 0, 0);
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-        __PYX_ERR(0, 84, __pyx_L1_error)
+        __PYX_ERR(0, 88, __pyx_L1_error)
 
-        /* "bz3/backends/cython/_bz3.pyx":83
+        /* "bz3/backends/cython/_bz3.pyx":87
  *                 with nogil:
  *                     new_size = bz3_encode_block(self.state, self.buffer, self.block_size)
  *                 if new_size == -1:             # <<<<<<<<<<<<<<
  *                     raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.state))
  *                 # if PyByteArray_Resize(ret, PyByteArray_GET_SIZE(ret) + new_size + 8) < 0:
  */
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":87
+      /* "bz3/backends/cython/_bz3.pyx":91
  *                 # if PyByteArray_Resize(ret, PyByteArray_GET_SIZE(ret) + new_size + 8) < 0:
  *                 #     raise
  *                 ret.extend((new_size + 8)*b"\x00")             # <<<<<<<<<<<<<<
  *                 write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-new_size-8]), new_size)
  *                 write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-new_size-4]), self.block_size)
  */
-      __pyx_t_1 = __Pyx_PyInt_From_long((__pyx_v_new_size + 8)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 87, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyInt_From_long((__pyx_v_new_size + 8)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 91, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_3 = PyNumber_Multiply(__pyx_t_1, __pyx_kp_b__5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 87, __pyx_L1_error)
+      __pyx_t_3 = PyNumber_Multiply(__pyx_t_1, __pyx_kp_b__5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 91, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __pyx_t_1 = __Pyx_CallUnboundCMethod1(&__pyx_umethod_PyByteArray_Type_extend, __pyx_v_ret, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 87, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_CallUnboundCMethod1(&__pyx_umethod_PyByteArray_Type_extend, __pyx_v_ret, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 91, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":88
+      /* "bz3/backends/cython/_bz3.pyx":92
  *                 #     raise
  *                 ret.extend((new_size + 8)*b"\x00")
  *                 write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-new_size-8]), new_size)             # <<<<<<<<<<<<<<
  *                 write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-new_size-4]), self.block_size)
  *                 memcpy(&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-new_size]), self.buffer, <size_t>new_size)
  */
       write_neutral_s32(((uint8_t *)(&(PyByteArray_AS_STRING(__pyx_v_ret)[((PyByteArray_GET_SIZE(__pyx_v_ret) - __pyx_v_new_size) - 8)]))), __pyx_v_new_size);
 
-      /* "bz3/backends/cython/_bz3.pyx":89
+      /* "bz3/backends/cython/_bz3.pyx":93
  *                 ret.extend((new_size + 8)*b"\x00")
  *                 write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-new_size-8]), new_size)
  *                 write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-new_size-4]), self.block_size)             # <<<<<<<<<<<<<<
  *                 memcpy(&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-new_size]), self.buffer, <size_t>new_size)
  * 
  */
       write_neutral_s32(((uint8_t *)(&(PyByteArray_AS_STRING(__pyx_v_ret)[((PyByteArray_GET_SIZE(__pyx_v_ret) - __pyx_v_new_size) - 4)]))), __pyx_v_self->block_size);
 
-      /* "bz3/backends/cython/_bz3.pyx":90
+      /* "bz3/backends/cython/_bz3.pyx":94
  *                 write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-new_size-8]), new_size)
  *                 write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-new_size-4]), self.block_size)
  *                 memcpy(&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-new_size]), self.buffer, <size_t>new_size)             # <<<<<<<<<<<<<<
  * 
  *                 del self.uncompressed[:self.block_size]
  */
       (void)(memcpy((&(PyByteArray_AS_STRING(__pyx_v_ret)[(PyByteArray_GET_SIZE(__pyx_v_ret) - __pyx_v_new_size)])), __pyx_v_self->buffer, ((size_t)__pyx_v_new_size)));
 
-      /* "bz3/backends/cython/_bz3.pyx":92
+      /* "bz3/backends/cython/_bz3.pyx":96
  *                 memcpy(&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-new_size]), self.buffer, <size_t>new_size)
  * 
  *                 del self.uncompressed[:self.block_size]             # <<<<<<<<<<<<<<
  *         return bytes(ret)
  * 
  */
       if (unlikely(__pyx_v_self->uncompressed == Py_None)) {
         PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
-        __PYX_ERR(0, 92, __pyx_L1_error)
+        __PYX_ERR(0, 96, __pyx_L1_error)
       }
-      if (__Pyx_PyObject_DelSlice(__pyx_v_self->uncompressed, 0, __pyx_v_self->block_size, NULL, NULL, NULL, 0, 1, 0) < 0) __PYX_ERR(0, 92, __pyx_L1_error)
+      if (__Pyx_PyObject_DelSlice(__pyx_v_self->uncompressed, 0, __pyx_v_self->block_size, NULL, NULL, NULL, 0, 1, 0) < 0) __PYX_ERR(0, 96, __pyx_L1_error)
     }
 
-    /* "bz3/backends/cython/_bz3.pyx":73
+    /* "bz3/backends/cython/_bz3.pyx":77
  *             self.have_magic_number = 1
  * 
  *         if input_size > 0:             # <<<<<<<<<<<<<<
  *             # if PyByteArray_Resize(self.uncompressed, input_size+PyByteArray_GET_SIZE(self.uncompressed)) < 0:
  *             #     raise
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":93
+  /* "bz3/backends/cython/_bz3.pyx":97
  * 
  *                 del self.uncompressed[:self.block_size]
  *         return bytes(ret)             # <<<<<<<<<<<<<<
  * 
  *     cpdef inline bytes flush(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_ret); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 93, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_ret); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 97, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "bz3/backends/cython/_bz3.pyx":61
+  /* "bz3/backends/cython/_bz3.pyx":65
  *             self.buffer = NULL
  * 
  *     cpdef inline bytes compress(self, const uint8_t[::1] data):             # <<<<<<<<<<<<<<
  *         cdef Py_ssize_t input_size = data.shape[0]
  *         cdef int32_t new_size
  */
 
@@ -3469,15 +3524,15 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("compress (wrapper)", 0);
   assert(__pyx_arg_data); {
-    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t__const__(__pyx_arg_data, 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 61, __pyx_L3_error)
+    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t__const__(__pyx_arg_data, 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 65, __pyx_L3_error)
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   __Pyx_AddTraceback("bz3.backends.cython._bz3.BZ3Compressor.compress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
@@ -3493,16 +3548,16 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("compress", 0);
   __Pyx_XDECREF(__pyx_r);
-  if (unlikely(!__pyx_v_data.memview)) { __Pyx_RaiseUnboundLocalError("data"); __PYX_ERR(0, 61, __pyx_L1_error) }
-  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_13BZ3Compressor_compress(__pyx_v_self, __pyx_v_data, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 61, __pyx_L1_error)
+  if (unlikely(!__pyx_v_data.memview)) { __Pyx_RaiseUnboundLocalError("data"); __PYX_ERR(0, 65, __pyx_L1_error) }
+  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_13BZ3Compressor_compress(__pyx_v_self, __pyx_v_data, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 65, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -3512,15 +3567,15 @@
   __pyx_L0:;
   __PYX_XDEC_MEMVIEW(&__pyx_v_data, 1);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":95
+/* "bz3/backends/cython/_bz3.pyx":99
  *         return bytes(ret)
  * 
  *     cpdef inline bytes flush(self):             # <<<<<<<<<<<<<<
  *         cdef bytes ret = b""
  *         cdef int32_t new_size
  */
 
@@ -3537,84 +3592,84 @@
   int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("flush", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":96
+  /* "bz3/backends/cython/_bz3.pyx":100
  * 
  *     cpdef inline bytes flush(self):
  *         cdef bytes ret = b""             # <<<<<<<<<<<<<<
  *         cdef int32_t new_size
  *         cdef int32_t old_size = <int32_t>PyByteArray_GET_SIZE(self.uncompressed)
  */
   __Pyx_INCREF(__pyx_kp_b__6);
   __pyx_v_ret = __pyx_kp_b__6;
 
-  /* "bz3/backends/cython/_bz3.pyx":98
+  /* "bz3/backends/cython/_bz3.pyx":102
  *         cdef bytes ret = b""
  *         cdef int32_t new_size
  *         cdef int32_t old_size = <int32_t>PyByteArray_GET_SIZE(self.uncompressed)             # <<<<<<<<<<<<<<
  *         if self.uncompressed:
  *             memcpy(self.buffer, PyByteArray_AS_STRING(self.uncompressed), <size_t>old_size)
  */
   __pyx_t_1 = __pyx_v_self->uncompressed;
   __Pyx_INCREF(__pyx_t_1);
   __pyx_v_old_size = ((int32_t)PyByteArray_GET_SIZE(__pyx_t_1));
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":99
+  /* "bz3/backends/cython/_bz3.pyx":103
  *         cdef int32_t new_size
  *         cdef int32_t old_size = <int32_t>PyByteArray_GET_SIZE(self.uncompressed)
  *         if self.uncompressed:             # <<<<<<<<<<<<<<
  *             memcpy(self.buffer, PyByteArray_AS_STRING(self.uncompressed), <size_t>old_size)
  *             with nogil:
  */
   __pyx_t_2 = (__pyx_v_self->uncompressed != Py_None)&&(PyByteArray_GET_SIZE(__pyx_v_self->uncompressed) != 0);
   if (__pyx_t_2) {
 
-    /* "bz3/backends/cython/_bz3.pyx":100
+    /* "bz3/backends/cython/_bz3.pyx":104
  *         cdef int32_t old_size = <int32_t>PyByteArray_GET_SIZE(self.uncompressed)
  *         if self.uncompressed:
  *             memcpy(self.buffer, PyByteArray_AS_STRING(self.uncompressed), <size_t>old_size)             # <<<<<<<<<<<<<<
  *             with nogil:
  *                 new_size = bz3_encode_block(self.state, self.buffer, old_size)
  */
     __pyx_t_1 = __pyx_v_self->uncompressed;
     __Pyx_INCREF(__pyx_t_1);
     (void)(memcpy(__pyx_v_self->buffer, PyByteArray_AS_STRING(__pyx_t_1), ((size_t)__pyx_v_old_size)));
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "bz3/backends/cython/_bz3.pyx":101
+    /* "bz3/backends/cython/_bz3.pyx":105
  *         if self.uncompressed:
  *             memcpy(self.buffer, PyByteArray_AS_STRING(self.uncompressed), <size_t>old_size)
  *             with nogil:             # <<<<<<<<<<<<<<
  *                 new_size = bz3_encode_block(self.state, self.buffer, old_size)
  *             if new_size == -1:
  */
     {
         #ifdef WITH_THREAD
         PyThreadState *_save;
         Py_UNBLOCK_THREADS
         __Pyx_FastGIL_Remember();
         #endif
         /*try:*/ {
 
-          /* "bz3/backends/cython/_bz3.pyx":102
+          /* "bz3/backends/cython/_bz3.pyx":106
  *             memcpy(self.buffer, PyByteArray_AS_STRING(self.uncompressed), <size_t>old_size)
  *             with nogil:
  *                 new_size = bz3_encode_block(self.state, self.buffer, old_size)             # <<<<<<<<<<<<<<
  *             if new_size == -1:
  *                 raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.state))
  */
           __pyx_v_new_size = bz3_encode_block(__pyx_v_self->state, __pyx_v_self->buffer, __pyx_v_old_size);
         }
 
-        /* "bz3/backends/cython/_bz3.pyx":101
+        /* "bz3/backends/cython/_bz3.pyx":105
  *         if self.uncompressed:
  *             memcpy(self.buffer, PyByteArray_AS_STRING(self.uncompressed), <size_t>old_size)
  *             with nogil:             # <<<<<<<<<<<<<<
  *                 new_size = bz3_encode_block(self.state, self.buffer, old_size)
  *             if new_size == -1:
  */
         /*finally:*/ {
@@ -3625,168 +3680,168 @@
             #endif
             goto __pyx_L6;
           }
           __pyx_L6:;
         }
     }
 
-    /* "bz3/backends/cython/_bz3.pyx":103
+    /* "bz3/backends/cython/_bz3.pyx":107
  *             with nogil:
  *                 new_size = bz3_encode_block(self.state, self.buffer, old_size)
  *             if new_size == -1:             # <<<<<<<<<<<<<<
  *                 raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.state))
  *             ret = PyBytes_FromStringAndSize(NULL, new_size + 8)
  */
     __pyx_t_2 = ((__pyx_v_new_size == -1L) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "bz3/backends/cython/_bz3.pyx":104
+      /* "bz3/backends/cython/_bz3.pyx":108
  *                 new_size = bz3_encode_block(self.state, self.buffer, old_size)
  *             if new_size == -1:
  *                 raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.state))             # <<<<<<<<<<<<<<
  *             ret = PyBytes_FromStringAndSize(NULL, new_size + 8)
  *             if not ret:
  */
-      __pyx_t_1 = __Pyx_PyBytes_FromString(bz3_strerror(__pyx_v_self->state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 104, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyBytes_FromString(bz3_strerror(__pyx_v_self->state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 108, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_3 = PyUnicode_Format(__pyx_kp_u_Failed_to_encode_a_block_s, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 104, __pyx_L1_error)
+      __pyx_t_3 = PyUnicode_Format(__pyx_kp_u_Failed_to_encode_a_block_s, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 108, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 104, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 108, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_Raise(__pyx_t_1, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __PYX_ERR(0, 104, __pyx_L1_error)
+      __PYX_ERR(0, 108, __pyx_L1_error)
 
-      /* "bz3/backends/cython/_bz3.pyx":103
+      /* "bz3/backends/cython/_bz3.pyx":107
  *             with nogil:
  *                 new_size = bz3_encode_block(self.state, self.buffer, old_size)
  *             if new_size == -1:             # <<<<<<<<<<<<<<
  *                 raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.state))
  *             ret = PyBytes_FromStringAndSize(NULL, new_size + 8)
  */
     }
 
-    /* "bz3/backends/cython/_bz3.pyx":105
+    /* "bz3/backends/cython/_bz3.pyx":109
  *             if new_size == -1:
  *                 raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.state))
  *             ret = PyBytes_FromStringAndSize(NULL, new_size + 8)             # <<<<<<<<<<<<<<
  *             if not ret:
  *                 raise
  */
-    __pyx_t_1 = PyBytes_FromStringAndSize(NULL, (__pyx_v_new_size + 8)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 105, __pyx_L1_error)
+    __pyx_t_1 = PyBytes_FromStringAndSize(NULL, (__pyx_v_new_size + 8)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 109, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF_SET(__pyx_v_ret, ((PyObject*)__pyx_t_1));
     __pyx_t_1 = 0;
 
-    /* "bz3/backends/cython/_bz3.pyx":106
+    /* "bz3/backends/cython/_bz3.pyx":110
  *                 raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.state))
  *             ret = PyBytes_FromStringAndSize(NULL, new_size + 8)
  *             if not ret:             # <<<<<<<<<<<<<<
  *                 raise
  *             write_neutral_s32(<uint8_t*>PyBytes_AS_STRING(ret), new_size)
  */
     __pyx_t_2 = (__pyx_v_ret != Py_None)&&(PyBytes_GET_SIZE(__pyx_v_ret) != 0);
     __pyx_t_4 = ((!__pyx_t_2) != 0);
     if (unlikely(__pyx_t_4)) {
 
-      /* "bz3/backends/cython/_bz3.pyx":107
+      /* "bz3/backends/cython/_bz3.pyx":111
  *             ret = PyBytes_FromStringAndSize(NULL, new_size + 8)
  *             if not ret:
  *                 raise             # <<<<<<<<<<<<<<
  *             write_neutral_s32(<uint8_t*>PyBytes_AS_STRING(ret), new_size)
  *             write_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(ret)[4]), old_size)
  */
-      __Pyx_ReraiseException(); __PYX_ERR(0, 107, __pyx_L1_error)
+      __Pyx_ReraiseException(); __PYX_ERR(0, 111, __pyx_L1_error)
 
-      /* "bz3/backends/cython/_bz3.pyx":106
+      /* "bz3/backends/cython/_bz3.pyx":110
  *                 raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.state))
  *             ret = PyBytes_FromStringAndSize(NULL, new_size + 8)
  *             if not ret:             # <<<<<<<<<<<<<<
  *                 raise
  *             write_neutral_s32(<uint8_t*>PyBytes_AS_STRING(ret), new_size)
  */
     }
 
-    /* "bz3/backends/cython/_bz3.pyx":108
+    /* "bz3/backends/cython/_bz3.pyx":112
  *             if not ret:
  *                 raise
  *             write_neutral_s32(<uint8_t*>PyBytes_AS_STRING(ret), new_size)             # <<<<<<<<<<<<<<
  *             write_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(ret)[4]), old_size)
  *             memcpy(&(PyBytes_AS_STRING(ret)[8]), self.buffer, <size_t> new_size)
  */
     write_neutral_s32(((uint8_t *)PyBytes_AS_STRING(__pyx_v_ret)), __pyx_v_new_size);
 
-    /* "bz3/backends/cython/_bz3.pyx":109
+    /* "bz3/backends/cython/_bz3.pyx":113
  *                 raise
  *             write_neutral_s32(<uint8_t*>PyBytes_AS_STRING(ret), new_size)
  *             write_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(ret)[4]), old_size)             # <<<<<<<<<<<<<<
  *             memcpy(&(PyBytes_AS_STRING(ret)[8]), self.buffer, <size_t> new_size)
  *             self.uncompressed.clear()
  */
     write_neutral_s32(((uint8_t *)(&(PyBytes_AS_STRING(__pyx_v_ret)[4]))), __pyx_v_old_size);
 
-    /* "bz3/backends/cython/_bz3.pyx":110
+    /* "bz3/backends/cython/_bz3.pyx":114
  *             write_neutral_s32(<uint8_t*>PyBytes_AS_STRING(ret), new_size)
  *             write_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(ret)[4]), old_size)
  *             memcpy(&(PyBytes_AS_STRING(ret)[8]), self.buffer, <size_t> new_size)             # <<<<<<<<<<<<<<
  *             self.uncompressed.clear()
  *         return ret
  */
     (void)(memcpy((&(PyBytes_AS_STRING(__pyx_v_ret)[8])), __pyx_v_self->buffer, ((size_t)__pyx_v_new_size)));
 
-    /* "bz3/backends/cython/_bz3.pyx":111
+    /* "bz3/backends/cython/_bz3.pyx":115
  *             write_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(ret)[4]), old_size)
  *             memcpy(&(PyBytes_AS_STRING(ret)[8]), self.buffer, <size_t> new_size)
  *             self.uncompressed.clear()             # <<<<<<<<<<<<<<
  *         return ret
  * 
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->uncompressed, __pyx_n_s_clear); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 111, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->uncompressed, __pyx_n_s_clear); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 115, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_t_5 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
     __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 111, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 115, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "bz3/backends/cython/_bz3.pyx":99
+    /* "bz3/backends/cython/_bz3.pyx":103
  *         cdef int32_t new_size
  *         cdef int32_t old_size = <int32_t>PyByteArray_GET_SIZE(self.uncompressed)
  *         if self.uncompressed:             # <<<<<<<<<<<<<<
  *             memcpy(self.buffer, PyByteArray_AS_STRING(self.uncompressed), <size_t>old_size)
  *             with nogil:
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":112
+  /* "bz3/backends/cython/_bz3.pyx":116
  *             memcpy(&(PyBytes_AS_STRING(ret)[8]), self.buffer, <size_t> new_size)
  *             self.uncompressed.clear()
  *         return ret             # <<<<<<<<<<<<<<
  * 
  *     cpdef inline str error(self):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_ret);
   __pyx_r = __pyx_v_ret;
   goto __pyx_L0;
 
-  /* "bz3/backends/cython/_bz3.pyx":95
+  /* "bz3/backends/cython/_bz3.pyx":99
  *         return bytes(ret)
  * 
  *     cpdef inline bytes flush(self):             # <<<<<<<<<<<<<<
  *         cdef bytes ret = b""
  *         cdef int32_t new_size
  */
 
@@ -3823,15 +3878,15 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("flush", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_13BZ3Compressor_flush(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 95, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_13BZ3Compressor_flush(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 99, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -3840,15 +3895,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":114
+/* "bz3/backends/cython/_bz3.pyx":118
  *         return ret
  * 
  *     cpdef inline str error(self):             # <<<<<<<<<<<<<<
  *         if bz3_last_error(self.state) != BZ3_OK:
  *             return (<bytes>bz3_strerror(self.state)).decode()
  */
 
@@ -3860,66 +3915,66 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("error", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":115
+  /* "bz3/backends/cython/_bz3.pyx":119
  * 
  *     cpdef inline str error(self):
  *         if bz3_last_error(self.state) != BZ3_OK:             # <<<<<<<<<<<<<<
  *             return (<bytes>bz3_strerror(self.state)).decode()
  *         return None
  */
   __pyx_t_1 = ((bz3_last_error(__pyx_v_self->state) != BZ3_OK) != 0);
   if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":116
+    /* "bz3/backends/cython/_bz3.pyx":120
  *     cpdef inline str error(self):
  *         if bz3_last_error(self.state) != BZ3_OK:
  *             return (<bytes>bz3_strerror(self.state)).decode()             # <<<<<<<<<<<<<<
  *         return None
  * 
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __Pyx_PyBytes_FromString(bz3_strerror(__pyx_v_self->state)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 116, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyBytes_FromString(bz3_strerror(__pyx_v_self->state)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 120, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     if (unlikely(__pyx_t_2 == Py_None)) {
       PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "decode");
-      __PYX_ERR(0, 116, __pyx_L1_error)
+      __PYX_ERR(0, 120, __pyx_L1_error)
     }
-    __pyx_t_3 = __Pyx_decode_bytes(((PyObject*)__pyx_t_2), 0, PY_SSIZE_T_MAX, NULL, NULL, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 116, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_decode_bytes(((PyObject*)__pyx_t_2), 0, PY_SSIZE_T_MAX, NULL, NULL, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 120, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_r = ((PyObject*)__pyx_t_3);
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "bz3/backends/cython/_bz3.pyx":115
+    /* "bz3/backends/cython/_bz3.pyx":119
  * 
  *     cpdef inline str error(self):
  *         if bz3_last_error(self.state) != BZ3_OK:             # <<<<<<<<<<<<<<
  *             return (<bytes>bz3_strerror(self.state)).decode()
  *         return None
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":117
+  /* "bz3/backends/cython/_bz3.pyx":121
  *         if bz3_last_error(self.state) != BZ3_OK:
  *             return (<bytes>bz3_strerror(self.state)).decode()
  *         return None             # <<<<<<<<<<<<<<
  * 
  * @cython.freelist(8)
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_r = ((PyObject*)Py_None); __Pyx_INCREF(Py_None);
   goto __pyx_L0;
 
-  /* "bz3/backends/cython/_bz3.pyx":114
+  /* "bz3/backends/cython/_bz3.pyx":118
  *         return ret
  * 
  *     cpdef inline str error(self):             # <<<<<<<<<<<<<<
  *         if bz3_last_error(self.state) != BZ3_OK:
  *             return (<bytes>bz3_strerror(self.state)).decode()
  */
 
@@ -3954,15 +4009,15 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("error", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_13BZ3Compressor_error(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 114, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_13BZ3Compressor_error(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 118, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -3971,15 +4026,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":34
+/* "bz3/backends/cython/_bz3.pyx":38
  *         bz3_state * state
  *         uint8_t * buffer
  *         readonly int32_t block_size             # <<<<<<<<<<<<<<
  *         bytearray uncompressed
  *         bint have_magic_number
  */
 
@@ -4001,15 +4056,15 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_From_int32_t(__pyx_v_self->block_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 34, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int32_t(__pyx_v_self->block_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 38, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -4133,16 +4188,16 @@
   __Pyx_AddTraceback("bz3.backends.cython._bz3.BZ3Compressor.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":130
- *         bint have_magic_number
+/* "bz3/backends/cython/_bz3.pyx":135
+ *         readonly bint ignore_error # decode
  * 
  *     cdef inline int init_state(self, int32_t block_size) except -1:             # <<<<<<<<<<<<<<
  *         """should exec only once"""
  *         self.block_size = block_size
  */
 
 static CYTHON_INLINE int __pyx_f_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_init_state(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *__pyx_v_self, int32_t __pyx_v_block_size) {
@@ -4151,125 +4206,125 @@
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("init_state", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":132
+  /* "bz3/backends/cython/_bz3.pyx":137
  *     cdef inline int init_state(self, int32_t block_size) except -1:
  *         """should exec only once"""
  *         self.block_size = block_size             # <<<<<<<<<<<<<<
  *         self.state = bz3_new(block_size)
  *         if self.state == NULL:
  */
   __pyx_v_self->block_size = __pyx_v_block_size;
 
-  /* "bz3/backends/cython/_bz3.pyx":133
+  /* "bz3/backends/cython/_bz3.pyx":138
  *         """should exec only once"""
  *         self.block_size = block_size
  *         self.state = bz3_new(block_size)             # <<<<<<<<<<<<<<
  *         if self.state == NULL:
  *             raise MemoryError("Failed to create a block encoder state")
  */
   __pyx_v_self->state = bz3_new(__pyx_v_block_size);
 
-  /* "bz3/backends/cython/_bz3.pyx":134
+  /* "bz3/backends/cython/_bz3.pyx":139
  *         self.block_size = block_size
  *         self.state = bz3_new(block_size)
  *         if self.state == NULL:             # <<<<<<<<<<<<<<
  *             raise MemoryError("Failed to create a block encoder state")
- *         self.buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+ *         self.buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  */
   __pyx_t_1 = ((__pyx_v_self->state == NULL) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":135
+    /* "bz3/backends/cython/_bz3.pyx":140
  *         self.state = bz3_new(block_size)
  *         if self.state == NULL:
  *             raise MemoryError("Failed to create a block encoder state")             # <<<<<<<<<<<<<<
- *         self.buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+ *         self.buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  *         if self.buffer == NULL:
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 135, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 140, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(0, 135, __pyx_L1_error)
+    __PYX_ERR(0, 140, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":134
+    /* "bz3/backends/cython/_bz3.pyx":139
  *         self.block_size = block_size
  *         self.state = bz3_new(block_size)
  *         if self.state == NULL:             # <<<<<<<<<<<<<<
  *             raise MemoryError("Failed to create a block encoder state")
- *         self.buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+ *         self.buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":136
+  /* "bz3/backends/cython/_bz3.pyx":141
  *         if self.state == NULL:
  *             raise MemoryError("Failed to create a block encoder state")
- *         self.buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)             # <<<<<<<<<<<<<<
+ *         self.buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))             # <<<<<<<<<<<<<<
  *         if self.buffer == NULL:
  *             bz3_free(self.state)
  */
-  __pyx_v_self->buffer = ((uint8_t *)PyMem_Malloc(((__pyx_v_block_size + (((long)__pyx_v_block_size) / 50)) + 32)));
+  __pyx_v_self->buffer = ((uint8_t *)PyMem_Malloc(bz3_bound(__pyx_v_block_size)));
 
-  /* "bz3/backends/cython/_bz3.pyx":137
+  /* "bz3/backends/cython/_bz3.pyx":142
  *             raise MemoryError("Failed to create a block encoder state")
- *         self.buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+ *         self.buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  *         if self.buffer == NULL:             # <<<<<<<<<<<<<<
  *             bz3_free(self.state)
  *             self.state = NULL
  */
   __pyx_t_1 = ((__pyx_v_self->buffer == NULL) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":138
- *         self.buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+    /* "bz3/backends/cython/_bz3.pyx":143
+ *         self.buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  *         if self.buffer == NULL:
  *             bz3_free(self.state)             # <<<<<<<<<<<<<<
  *             self.state = NULL
  *             raise MemoryError("Failed to allocate memory")
  */
     bz3_free(__pyx_v_self->state);
 
-    /* "bz3/backends/cython/_bz3.pyx":139
+    /* "bz3/backends/cython/_bz3.pyx":144
  *         if self.buffer == NULL:
  *             bz3_free(self.state)
  *             self.state = NULL             # <<<<<<<<<<<<<<
  *             raise MemoryError("Failed to allocate memory")
  * 
  */
     __pyx_v_self->state = NULL;
 
-    /* "bz3/backends/cython/_bz3.pyx":140
+    /* "bz3/backends/cython/_bz3.pyx":145
  *             bz3_free(self.state)
  *             self.state = NULL
  *             raise MemoryError("Failed to allocate memory")             # <<<<<<<<<<<<<<
  * 
- *     def __cinit__(self):
+ *     def __cinit__(self, bint ignore_error = False):
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 140, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 145, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(0, 140, __pyx_L1_error)
+    __PYX_ERR(0, 145, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":137
+    /* "bz3/backends/cython/_bz3.pyx":142
  *             raise MemoryError("Failed to create a block encoder state")
- *         self.buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+ *         self.buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  *         if self.buffer == NULL:             # <<<<<<<<<<<<<<
  *             bz3_free(self.state)
  *             self.state = NULL
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":130
- *         bint have_magic_number
+  /* "bz3/backends/cython/_bz3.pyx":135
+ *         readonly bint ignore_error # decode
  * 
  *     cdef inline int init_state(self, int32_t block_size) except -1:             # <<<<<<<<<<<<<<
  *         """should exec only once"""
  *         self.block_size = block_size
  */
 
   /* function exit code */
@@ -4280,75 +4335,130 @@
   __Pyx_AddTraceback("bz3.backends.cython._bz3.BZ3Decompressor.init_state", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":142
+/* "bz3/backends/cython/_bz3.pyx":147
  *             raise MemoryError("Failed to allocate memory")
  * 
- *     def __cinit__(self):             # <<<<<<<<<<<<<<
+ *     def __cinit__(self, bint ignore_error = False):             # <<<<<<<<<<<<<<
  *         self.unused = bytearray()
  *         self.have_magic_number = 0 # magic number
  */
 
 /* Python wrapper */
 static int __pyx_pw_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static int __pyx_pw_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  int __pyx_v_ignore_error;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
-  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
-    __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return -1;}
-  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__cinit__", 0))) return -1;
-  __pyx_r = __pyx_pf_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor___cinit__(((struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *)__pyx_v_self));
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ignore_error,0};
+    PyObject* values[1] = {0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (kw_args > 0) {
+          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ignore_error);
+          if (value) { values[0] = value; kw_args--; }
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 147, __pyx_L3_error)
+      }
+    } else {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+    }
+    if (values[0]) {
+      __pyx_v_ignore_error = __Pyx_PyObject_IsTrue(values[0]); if (unlikely((__pyx_v_ignore_error == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 147, __pyx_L3_error)
+    } else {
+      __pyx_v_ignore_error = ((int)0);
+    }
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 147, __pyx_L3_error)
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("bz3.backends.cython._bz3.BZ3Decompressor.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return -1;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor___cinit__(((struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *)__pyx_v_self), __pyx_v_ignore_error);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static int __pyx_pf_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor___cinit__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *__pyx_v_self) {
+static int __pyx_pf_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor___cinit__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *__pyx_v_self, int __pyx_v_ignore_error) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__cinit__", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":143
+  /* "bz3/backends/cython/_bz3.pyx":148
  * 
- *     def __cinit__(self):
+ *     def __cinit__(self, bint ignore_error = False):
  *         self.unused = bytearray()             # <<<<<<<<<<<<<<
  *         self.have_magic_number = 0 # magic number
- * 
+ *         self.ignore_error = ignore_error
  */
-  __pyx_t_1 = __Pyx_PyObject_CallNoArg(((PyObject *)(&PyByteArray_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 143, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_CallNoArg(((PyObject *)(&PyByteArray_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 148, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __Pyx_GOTREF(__pyx_v_self->unused);
   __Pyx_DECREF(__pyx_v_self->unused);
   __pyx_v_self->unused = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":144
- *     def __cinit__(self):
+  /* "bz3/backends/cython/_bz3.pyx":149
+ *     def __cinit__(self, bint ignore_error = False):
  *         self.unused = bytearray()
  *         self.have_magic_number = 0 # magic number             # <<<<<<<<<<<<<<
+ *         self.ignore_error = ignore_error
  * 
- *     def __dealloc__(self):
  */
   __pyx_v_self->have_magic_number = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":142
+  /* "bz3/backends/cython/_bz3.pyx":150
+ *         self.unused = bytearray()
+ *         self.have_magic_number = 0 # magic number
+ *         self.ignore_error = ignore_error             # <<<<<<<<<<<<<<
+ * 
+ *     def __dealloc__(self):
+ */
+  __pyx_v_self->ignore_error = __pyx_v_ignore_error;
+
+  /* "bz3/backends/cython/_bz3.pyx":147
  *             raise MemoryError("Failed to allocate memory")
  * 
- *     def __cinit__(self):             # <<<<<<<<<<<<<<
+ *     def __cinit__(self, bint ignore_error = False):             # <<<<<<<<<<<<<<
  *         self.unused = bytearray()
  *         self.have_magic_number = 0 # magic number
  */
 
   /* function exit code */
   __pyx_r = 0;
   goto __pyx_L0;
@@ -4357,16 +4467,16 @@
   __Pyx_AddTraceback("bz3.backends.cython._bz3.BZ3Decompressor.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":146
- *         self.have_magic_number = 0 # magic number
+/* "bz3/backends/cython/_bz3.pyx":152
+ *         self.ignore_error = ignore_error
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         if self.state != NULL:
  *             bz3_free(self.state)
  */
 
 /* Python wrapper */
@@ -4381,101 +4491,101 @@
 }
 
 static void __pyx_pf_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_2__dealloc__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":147
+  /* "bz3/backends/cython/_bz3.pyx":153
  * 
  *     def __dealloc__(self):
  *         if self.state != NULL:             # <<<<<<<<<<<<<<
  *             bz3_free(self.state)
  *             self.state = NULL
  */
   __pyx_t_1 = ((__pyx_v_self->state != NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":148
+    /* "bz3/backends/cython/_bz3.pyx":154
  *     def __dealloc__(self):
  *         if self.state != NULL:
  *             bz3_free(self.state)             # <<<<<<<<<<<<<<
  *             self.state = NULL
  *         if self.buffer !=NULL:
  */
     bz3_free(__pyx_v_self->state);
 
-    /* "bz3/backends/cython/_bz3.pyx":149
+    /* "bz3/backends/cython/_bz3.pyx":155
  *         if self.state != NULL:
  *             bz3_free(self.state)
  *             self.state = NULL             # <<<<<<<<<<<<<<
  *         if self.buffer !=NULL:
  *             PyMem_Free(self.buffer)
  */
     __pyx_v_self->state = NULL;
 
-    /* "bz3/backends/cython/_bz3.pyx":147
+    /* "bz3/backends/cython/_bz3.pyx":153
  * 
  *     def __dealloc__(self):
  *         if self.state != NULL:             # <<<<<<<<<<<<<<
  *             bz3_free(self.state)
  *             self.state = NULL
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":150
+  /* "bz3/backends/cython/_bz3.pyx":156
  *             bz3_free(self.state)
  *             self.state = NULL
  *         if self.buffer !=NULL:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.buffer)
  *             self.buffer = NULL
  */
   __pyx_t_1 = ((__pyx_v_self->buffer != NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":151
+    /* "bz3/backends/cython/_bz3.pyx":157
  *             self.state = NULL
  *         if self.buffer !=NULL:
  *             PyMem_Free(self.buffer)             # <<<<<<<<<<<<<<
  *             self.buffer = NULL
  * 
  */
     PyMem_Free(__pyx_v_self->buffer);
 
-    /* "bz3/backends/cython/_bz3.pyx":152
+    /* "bz3/backends/cython/_bz3.pyx":158
  *         if self.buffer !=NULL:
  *             PyMem_Free(self.buffer)
  *             self.buffer = NULL             # <<<<<<<<<<<<<<
  * 
  *     cpdef inline bytes decompress(self, const uint8_t[::1] data):
  */
     __pyx_v_self->buffer = NULL;
 
-    /* "bz3/backends/cython/_bz3.pyx":150
+    /* "bz3/backends/cython/_bz3.pyx":156
  *             bz3_free(self.state)
  *             self.state = NULL
  *         if self.buffer !=NULL:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.buffer)
  *             self.buffer = NULL
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":146
- *         self.have_magic_number = 0 # magic number
+  /* "bz3/backends/cython/_bz3.pyx":152
+ *         self.ignore_error = ignore_error
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         if self.state != NULL:
  *             bz3_free(self.state)
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "bz3/backends/cython/_bz3.pyx":154
+/* "bz3/backends/cython/_bz3.pyx":160
  *             self.buffer = NULL
  * 
  *     cpdef inline bytes decompress(self, const uint8_t[::1] data):             # <<<<<<<<<<<<<<
  *         cdef Py_ssize_t input_size = data.shape[0]
  *         cdef int32_t code
  */
 
@@ -4497,75 +4607,75 @@
   int __pyx_t_6;
   int __pyx_t_7;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decompress", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":155
+  /* "bz3/backends/cython/_bz3.pyx":161
  * 
  *     cpdef inline bytes decompress(self, const uint8_t[::1] data):
  *         cdef Py_ssize_t input_size = data.shape[0]             # <<<<<<<<<<<<<<
  *         cdef int32_t code
  *         cdef bytearray ret = bytearray()
  */
   __pyx_v_input_size = (__pyx_v_data.shape[0]);
 
-  /* "bz3/backends/cython/_bz3.pyx":157
+  /* "bz3/backends/cython/_bz3.pyx":163
  *         cdef Py_ssize_t input_size = data.shape[0]
  *         cdef int32_t code
  *         cdef bytearray ret = bytearray()             # <<<<<<<<<<<<<<
  *         cdef int32_t new_size, old_size, block_size
  *         if input_size > 0:
  */
-  __pyx_t_1 = __Pyx_PyObject_CallNoArg(((PyObject *)(&PyByteArray_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 157, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_CallNoArg(((PyObject *)(&PyByteArray_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 163, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_ret = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":159
+  /* "bz3/backends/cython/_bz3.pyx":165
  *         cdef bytearray ret = bytearray()
  *         cdef int32_t new_size, old_size, block_size
  *         if input_size > 0:             # <<<<<<<<<<<<<<
  *             # if PyByteArray_Resize(self.unused, input_size+PyByteArray_GET_SIZE(self.unused)) < 0:
  *             #     raise
  */
   __pyx_t_2 = ((__pyx_v_input_size > 0) != 0);
   if (__pyx_t_2) {
 
-    /* "bz3/backends/cython/_bz3.pyx":163
+    /* "bz3/backends/cython/_bz3.pyx":169
  *             #     raise
  *             # memcpy(&(PyByteArray_AS_STRING(self.unused)[PyByteArray_GET_SIZE(self.unused)-input_size]), &data[0], input_size) # self.unused.extend
  *             self.unused.extend(data)             # <<<<<<<<<<<<<<
  *             if PyByteArray_GET_SIZE(self.unused) > 9 and not self.have_magic_number: # 9 bytes magic number
  *                 if strncmp(PyByteArray_AS_STRING(self.unused), magic, 5) != 0:
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->unused, __pyx_n_s_extend); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 163, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->unused, __pyx_n_s_extend); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 169, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __pyx_memoryview_fromslice(__pyx_v_data, 1, (PyObject *(*)(char *)) __pyx_memview_get_nn_uint8_t__const__, (int (*)(char *, PyObject *)) NULL, 0);; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 163, __pyx_L1_error)
+    __pyx_t_4 = __pyx_memoryview_fromslice(__pyx_v_data, 1, (PyObject *(*)(char *)) __pyx_memview_get_nn_uint8_t__const__, (int (*)(char *, PyObject *)) NULL, 0);; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 169, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_5 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
     __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 163, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 169, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "bz3/backends/cython/_bz3.pyx":164
+    /* "bz3/backends/cython/_bz3.pyx":170
  *             # memcpy(&(PyByteArray_AS_STRING(self.unused)[PyByteArray_GET_SIZE(self.unused)-input_size]), &data[0], input_size) # self.unused.extend
  *             self.unused.extend(data)
  *             if PyByteArray_GET_SIZE(self.unused) > 9 and not self.have_magic_number: # 9 bytes magic number             # <<<<<<<<<<<<<<
  *                 if strncmp(PyByteArray_AS_STRING(self.unused), magic, 5) != 0:
  *                     raise ValueError("Invalid signature")
  */
     __pyx_t_1 = __pyx_v_self->unused;
@@ -4578,62 +4688,62 @@
       goto __pyx_L5_bool_binop_done;
     }
     __pyx_t_6 = ((!(__pyx_v_self->have_magic_number != 0)) != 0);
     __pyx_t_2 = __pyx_t_6;
     __pyx_L5_bool_binop_done:;
     if (__pyx_t_2) {
 
-      /* "bz3/backends/cython/_bz3.pyx":165
+      /* "bz3/backends/cython/_bz3.pyx":171
  *             self.unused.extend(data)
  *             if PyByteArray_GET_SIZE(self.unused) > 9 and not self.have_magic_number: # 9 bytes magic number
  *                 if strncmp(PyByteArray_AS_STRING(self.unused), magic, 5) != 0:             # <<<<<<<<<<<<<<
  *                     raise ValueError("Invalid signature")
  *                 block_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[5]))
  */
       __pyx_t_1 = __pyx_v_self->unused;
       __Pyx_INCREF(__pyx_t_1);
       __pyx_t_2 = ((strncmp(PyByteArray_AS_STRING(__pyx_t_1), __pyx_v_3bz3_8backends_6cython_4_bz3_magic, 5) != 0) != 0);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       if (unlikely(__pyx_t_2)) {
 
-        /* "bz3/backends/cython/_bz3.pyx":166
+        /* "bz3/backends/cython/_bz3.pyx":172
  *             if PyByteArray_GET_SIZE(self.unused) > 9 and not self.have_magic_number: # 9 bytes magic number
  *                 if strncmp(PyByteArray_AS_STRING(self.unused), magic, 5) != 0:
  *                     raise ValueError("Invalid signature")             # <<<<<<<<<<<<<<
  *                 block_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[5]))
  *                 if block_size  < KiB(65) or block_size >MiB(511):
  */
-        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 166, __pyx_L1_error)
+        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 172, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_Raise(__pyx_t_1, 0, 0, 0);
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-        __PYX_ERR(0, 166, __pyx_L1_error)
+        __PYX_ERR(0, 172, __pyx_L1_error)
 
-        /* "bz3/backends/cython/_bz3.pyx":165
+        /* "bz3/backends/cython/_bz3.pyx":171
  *             self.unused.extend(data)
  *             if PyByteArray_GET_SIZE(self.unused) > 9 and not self.have_magic_number: # 9 bytes magic number
  *                 if strncmp(PyByteArray_AS_STRING(self.unused), magic, 5) != 0:             # <<<<<<<<<<<<<<
  *                     raise ValueError("Invalid signature")
  *                 block_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[5]))
  */
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":167
+      /* "bz3/backends/cython/_bz3.pyx":173
  *                 if strncmp(PyByteArray_AS_STRING(self.unused), magic, 5) != 0:
  *                     raise ValueError("Invalid signature")
  *                 block_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[5]))             # <<<<<<<<<<<<<<
  *                 if block_size  < KiB(65) or block_size >MiB(511):
  *                     raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  */
       __pyx_t_1 = __pyx_v_self->unused;
       __Pyx_INCREF(__pyx_t_1);
       __pyx_v_block_size = read_neutral_s32(((uint8_t *)(&(PyByteArray_AS_STRING(__pyx_t_1)[5]))));
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":168
+      /* "bz3/backends/cython/_bz3.pyx":174
  *                     raise ValueError("Invalid signature")
  *                 block_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[5]))
  *                 if block_size  < KiB(65) or block_size >MiB(511):             # <<<<<<<<<<<<<<
  *                     raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  *                 self.init_state(block_size)
  */
       __pyx_t_6 = ((__pyx_v_block_size < KiB(65)) != 0);
@@ -4643,318 +4753,390 @@
         goto __pyx_L9_bool_binop_done;
       }
       __pyx_t_6 = ((__pyx_v_block_size > MiB(0x1FF)) != 0);
       __pyx_t_2 = __pyx_t_6;
       __pyx_L9_bool_binop_done:;
       if (unlikely(__pyx_t_2)) {
 
-        /* "bz3/backends/cython/_bz3.pyx":169
+        /* "bz3/backends/cython/_bz3.pyx":175
  *                 block_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[5]))
  *                 if block_size  < KiB(65) or block_size >MiB(511):
  *                     raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")             # <<<<<<<<<<<<<<
  *                 self.init_state(block_size)
  *                 del self.unused[:9]
  */
-        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 169, __pyx_L1_error)
+        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 175, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_Raise(__pyx_t_1, 0, 0, 0);
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-        __PYX_ERR(0, 169, __pyx_L1_error)
+        __PYX_ERR(0, 175, __pyx_L1_error)
 
-        /* "bz3/backends/cython/_bz3.pyx":168
+        /* "bz3/backends/cython/_bz3.pyx":174
  *                     raise ValueError("Invalid signature")
  *                 block_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[5]))
  *                 if block_size  < KiB(65) or block_size >MiB(511):             # <<<<<<<<<<<<<<
  *                     raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  *                 self.init_state(block_size)
  */
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":170
+      /* "bz3/backends/cython/_bz3.pyx":176
  *                 if block_size  < KiB(65) or block_size >MiB(511):
  *                     raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  *                 self.init_state(block_size)             # <<<<<<<<<<<<<<
  *                 del self.unused[:9]
  *                 self.have_magic_number = 1
  */
-      __pyx_t_7 = __pyx_f_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_init_state(__pyx_v_self, __pyx_v_block_size); if (unlikely(__pyx_t_7 == ((int)-1))) __PYX_ERR(0, 170, __pyx_L1_error)
+      __pyx_t_7 = __pyx_f_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_init_state(__pyx_v_self, __pyx_v_block_size); if (unlikely(__pyx_t_7 == ((int)-1))) __PYX_ERR(0, 176, __pyx_L1_error)
 
-      /* "bz3/backends/cython/_bz3.pyx":171
+      /* "bz3/backends/cython/_bz3.pyx":177
  *                     raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  *                 self.init_state(block_size)
  *                 del self.unused[:9]             # <<<<<<<<<<<<<<
  *                 self.have_magic_number = 1
  * 
  */
       if (unlikely(__pyx_v_self->unused == Py_None)) {
         PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
-        __PYX_ERR(0, 171, __pyx_L1_error)
+        __PYX_ERR(0, 177, __pyx_L1_error)
       }
-      if (__Pyx_PyObject_DelSlice(__pyx_v_self->unused, 0, 9, NULL, NULL, NULL, 0, 1, 0) < 0) __PYX_ERR(0, 171, __pyx_L1_error)
+      if (__Pyx_PyObject_DelSlice(__pyx_v_self->unused, 0, 9, NULL, NULL, NULL, 0, 1, 0) < 0) __PYX_ERR(0, 177, __pyx_L1_error)
 
-      /* "bz3/backends/cython/_bz3.pyx":172
+      /* "bz3/backends/cython/_bz3.pyx":178
  *                 self.init_state(block_size)
  *                 del self.unused[:9]
  *                 self.have_magic_number = 1             # <<<<<<<<<<<<<<
  * 
  *             while True:
  */
       __pyx_v_self->have_magic_number = 1;
 
-      /* "bz3/backends/cython/_bz3.pyx":164
+      /* "bz3/backends/cython/_bz3.pyx":170
  *             # memcpy(&(PyByteArray_AS_STRING(self.unused)[PyByteArray_GET_SIZE(self.unused)-input_size]), &data[0], input_size) # self.unused.extend
  *             self.unused.extend(data)
  *             if PyByteArray_GET_SIZE(self.unused) > 9 and not self.have_magic_number: # 9 bytes magic number             # <<<<<<<<<<<<<<
  *                 if strncmp(PyByteArray_AS_STRING(self.unused), magic, 5) != 0:
  *                     raise ValueError("Invalid signature")
  */
     }
 
-    /* "bz3/backends/cython/_bz3.pyx":174
+    /* "bz3/backends/cython/_bz3.pyx":180
  *                 self.have_magic_number = 1
  * 
  *             while True:             # <<<<<<<<<<<<<<
  *                 if PyByteArray_GET_SIZE(self.unused)<8: # 8 byte header
  *                     break
  */
     while (1) {
 
-      /* "bz3/backends/cython/_bz3.pyx":175
+      /* "bz3/backends/cython/_bz3.pyx":181
  * 
  *             while True:
  *                 if PyByteArray_GET_SIZE(self.unused)<8: # 8 byte header             # <<<<<<<<<<<<<<
  *                     break
  *                 new_size = read_neutral_s32(<uint8_t*>PyByteArray_AS_STRING(self.unused)) # todo gcc warning but bytes is contst
  */
       __pyx_t_1 = __pyx_v_self->unused;
       __Pyx_INCREF(__pyx_t_1);
       __pyx_t_2 = ((PyByteArray_GET_SIZE(__pyx_t_1) < 8) != 0);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       if (__pyx_t_2) {
 
-        /* "bz3/backends/cython/_bz3.pyx":176
+        /* "bz3/backends/cython/_bz3.pyx":182
  *             while True:
  *                 if PyByteArray_GET_SIZE(self.unused)<8: # 8 byte header
  *                     break             # <<<<<<<<<<<<<<
  *                 new_size = read_neutral_s32(<uint8_t*>PyByteArray_AS_STRING(self.unused)) # todo gcc warning but bytes is contst
  *                 old_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[4]))
  */
         goto __pyx_L12_break;
 
-        /* "bz3/backends/cython/_bz3.pyx":175
+        /* "bz3/backends/cython/_bz3.pyx":181
  * 
  *             while True:
  *                 if PyByteArray_GET_SIZE(self.unused)<8: # 8 byte header             # <<<<<<<<<<<<<<
  *                     break
  *                 new_size = read_neutral_s32(<uint8_t*>PyByteArray_AS_STRING(self.unused)) # todo gcc warning but bytes is contst
  */
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":177
+      /* "bz3/backends/cython/_bz3.pyx":183
  *                 if PyByteArray_GET_SIZE(self.unused)<8: # 8 byte header
  *                     break
  *                 new_size = read_neutral_s32(<uint8_t*>PyByteArray_AS_STRING(self.unused)) # todo gcc warning but bytes is contst             # <<<<<<<<<<<<<<
  *                 old_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[4]))
- *                 if PyByteArray_GET_SIZE(self.unused) < new_size+8: #
+ *                 if old_size > <int32_t>bz3_bound(self.block_size) or new_size > <int32_t>bz3_bound(self.block_size):
  */
       __pyx_t_1 = __pyx_v_self->unused;
       __Pyx_INCREF(__pyx_t_1);
       __pyx_v_new_size = read_neutral_s32(((uint8_t *)PyByteArray_AS_STRING(__pyx_t_1)));
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":178
+      /* "bz3/backends/cython/_bz3.pyx":184
  *                     break
  *                 new_size = read_neutral_s32(<uint8_t*>PyByteArray_AS_STRING(self.unused)) # todo gcc warning but bytes is contst
  *                 old_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[4]))             # <<<<<<<<<<<<<<
- *                 if PyByteArray_GET_SIZE(self.unused) < new_size+8: #
- *                     break
+ *                 if old_size > <int32_t>bz3_bound(self.block_size) or new_size > <int32_t>bz3_bound(self.block_size):
+ *                     raise ValueError("Failed to decode a block: Inconsistent headers.")
  */
       __pyx_t_1 = __pyx_v_self->unused;
       __Pyx_INCREF(__pyx_t_1);
       __pyx_v_old_size = read_neutral_s32(((uint8_t *)(&(PyByteArray_AS_STRING(__pyx_t_1)[4]))));
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":179
+      /* "bz3/backends/cython/_bz3.pyx":185
+ *                 new_size = read_neutral_s32(<uint8_t*>PyByteArray_AS_STRING(self.unused)) # todo gcc warning but bytes is contst
+ *                 old_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[4]))
+ *                 if old_size > <int32_t>bz3_bound(self.block_size) or new_size > <int32_t>bz3_bound(self.block_size):             # <<<<<<<<<<<<<<
+ *                     raise ValueError("Failed to decode a block: Inconsistent headers.")
+ *                 if PyByteArray_GET_SIZE(self.unused) < new_size+8: #
+ */
+      __pyx_t_6 = ((__pyx_v_old_size > ((int32_t)bz3_bound(__pyx_v_self->block_size))) != 0);
+      if (!__pyx_t_6) {
+      } else {
+        __pyx_t_2 = __pyx_t_6;
+        goto __pyx_L15_bool_binop_done;
+      }
+      __pyx_t_6 = ((__pyx_v_new_size > ((int32_t)bz3_bound(__pyx_v_self->block_size))) != 0);
+      __pyx_t_2 = __pyx_t_6;
+      __pyx_L15_bool_binop_done:;
+      if (unlikely(__pyx_t_2)) {
+
+        /* "bz3/backends/cython/_bz3.pyx":186
+ *                 old_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[4]))
+ *                 if old_size > <int32_t>bz3_bound(self.block_size) or new_size > <int32_t>bz3_bound(self.block_size):
+ *                     raise ValueError("Failed to decode a block: Inconsistent headers.")             # <<<<<<<<<<<<<<
+ *                 if PyByteArray_GET_SIZE(self.unused) < new_size+8: #
+ *                     break
+ */
+        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 186, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_1);
+        __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        __PYX_ERR(0, 186, __pyx_L1_error)
+
+        /* "bz3/backends/cython/_bz3.pyx":185
  *                 new_size = read_neutral_s32(<uint8_t*>PyByteArray_AS_STRING(self.unused)) # todo gcc warning but bytes is contst
  *                 old_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[4]))
+ *                 if old_size > <int32_t>bz3_bound(self.block_size) or new_size > <int32_t>bz3_bound(self.block_size):             # <<<<<<<<<<<<<<
+ *                     raise ValueError("Failed to decode a block: Inconsistent headers.")
+ *                 if PyByteArray_GET_SIZE(self.unused) < new_size+8: #
+ */
+      }
+
+      /* "bz3/backends/cython/_bz3.pyx":187
+ *                 if old_size > <int32_t>bz3_bound(self.block_size) or new_size > <int32_t>bz3_bound(self.block_size):
+ *                     raise ValueError("Failed to decode a block: Inconsistent headers.")
  *                 if PyByteArray_GET_SIZE(self.unused) < new_size+8: #             # <<<<<<<<<<<<<<
  *                     break
  *                 memcpy(self.buffer, &(PyByteArray_AS_STRING(self.unused)[8]), <size_t>new_size)
  */
       __pyx_t_1 = __pyx_v_self->unused;
       __Pyx_INCREF(__pyx_t_1);
       __pyx_t_2 = ((PyByteArray_GET_SIZE(__pyx_t_1) < (__pyx_v_new_size + 8)) != 0);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       if (__pyx_t_2) {
 
-        /* "bz3/backends/cython/_bz3.pyx":180
- *                 old_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[4]))
+        /* "bz3/backends/cython/_bz3.pyx":188
+ *                     raise ValueError("Failed to decode a block: Inconsistent headers.")
  *                 if PyByteArray_GET_SIZE(self.unused) < new_size+8: #
  *                     break             # <<<<<<<<<<<<<<
  *                 memcpy(self.buffer, &(PyByteArray_AS_STRING(self.unused)[8]), <size_t>new_size)
  *                 with nogil:
  */
         goto __pyx_L12_break;
 
-        /* "bz3/backends/cython/_bz3.pyx":179
- *                 new_size = read_neutral_s32(<uint8_t*>PyByteArray_AS_STRING(self.unused)) # todo gcc warning but bytes is contst
- *                 old_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[4]))
+        /* "bz3/backends/cython/_bz3.pyx":187
+ *                 if old_size > <int32_t>bz3_bound(self.block_size) or new_size > <int32_t>bz3_bound(self.block_size):
+ *                     raise ValueError("Failed to decode a block: Inconsistent headers.")
  *                 if PyByteArray_GET_SIZE(self.unused) < new_size+8: #             # <<<<<<<<<<<<<<
  *                     break
  *                 memcpy(self.buffer, &(PyByteArray_AS_STRING(self.unused)[8]), <size_t>new_size)
  */
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":181
+      /* "bz3/backends/cython/_bz3.pyx":189
  *                 if PyByteArray_GET_SIZE(self.unused) < new_size+8: #
  *                     break
  *                 memcpy(self.buffer, &(PyByteArray_AS_STRING(self.unused)[8]), <size_t>new_size)             # <<<<<<<<<<<<<<
  *                 with nogil:
  *                     code = bz3_decode_block(self.state, self.buffer, new_size, old_size)
  */
       __pyx_t_1 = __pyx_v_self->unused;
       __Pyx_INCREF(__pyx_t_1);
       (void)(memcpy(__pyx_v_self->buffer, (&(PyByteArray_AS_STRING(__pyx_t_1)[8])), ((size_t)__pyx_v_new_size)));
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":182
+      /* "bz3/backends/cython/_bz3.pyx":190
  *                     break
  *                 memcpy(self.buffer, &(PyByteArray_AS_STRING(self.unused)[8]), <size_t>new_size)
  *                 with nogil:             # <<<<<<<<<<<<<<
  *                     code = bz3_decode_block(self.state, self.buffer, new_size, old_size)
  *                 if code == -1:
  */
       {
           #ifdef WITH_THREAD
           PyThreadState *_save;
           Py_UNBLOCK_THREADS
           __Pyx_FastGIL_Remember();
           #endif
           /*try:*/ {
 
-            /* "bz3/backends/cython/_bz3.pyx":183
+            /* "bz3/backends/cython/_bz3.pyx":191
  *                 memcpy(self.buffer, &(PyByteArray_AS_STRING(self.unused)[8]), <size_t>new_size)
  *                 with nogil:
  *                     code = bz3_decode_block(self.state, self.buffer, new_size, old_size)             # <<<<<<<<<<<<<<
  *                 if code == -1:
- *                     raise ValueError("Failed to decode a block: %s" % bz3_strerror(self.state))
+ *                     if self.ignore_error:
  */
             __pyx_v_code = bz3_decode_block(__pyx_v_self->state, __pyx_v_self->buffer, __pyx_v_new_size, __pyx_v_old_size);
           }
 
-          /* "bz3/backends/cython/_bz3.pyx":182
+          /* "bz3/backends/cython/_bz3.pyx":190
  *                     break
  *                 memcpy(self.buffer, &(PyByteArray_AS_STRING(self.unused)[8]), <size_t>new_size)
  *                 with nogil:             # <<<<<<<<<<<<<<
  *                     code = bz3_decode_block(self.state, self.buffer, new_size, old_size)
  *                 if code == -1:
  */
           /*finally:*/ {
             /*normal exit:*/{
               #ifdef WITH_THREAD
               __Pyx_FastGIL_Forget();
               Py_BLOCK_THREADS
               #endif
-              goto __pyx_L19;
+              goto __pyx_L22;
             }
-            __pyx_L19:;
+            __pyx_L22:;
           }
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":184
+      /* "bz3/backends/cython/_bz3.pyx":192
  *                 with nogil:
  *                     code = bz3_decode_block(self.state, self.buffer, new_size, old_size)
  *                 if code == -1:             # <<<<<<<<<<<<<<
- *                     raise ValueError("Failed to decode a block: %s" % bz3_strerror(self.state))
- *                 # if PyByteArray_Resize(ret, PyByteArray_GET_SIZE(ret) + old_size) < 0:
+ *                     if self.ignore_error:
+ *                         fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(self.state))
  */
       __pyx_t_2 = ((__pyx_v_code == -1L) != 0);
-      if (unlikely(__pyx_t_2)) {
+      if (__pyx_t_2) {
 
-        /* "bz3/backends/cython/_bz3.pyx":185
+        /* "bz3/backends/cython/_bz3.pyx":193
+ *                     code = bz3_decode_block(self.state, self.buffer, new_size, old_size)
+ *                 if code == -1:
+ *                     if self.ignore_error:             # <<<<<<<<<<<<<<
+ *                         fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(self.state))
+ *                     else:
+ */
+        __pyx_t_2 = (__pyx_v_self->ignore_error != 0);
+        if (likely(__pyx_t_2)) {
+
+          /* "bz3/backends/cython/_bz3.pyx":194
+ *                 if code == -1:
+ *                     if self.ignore_error:
+ *                         fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(self.state))             # <<<<<<<<<<<<<<
+ *                     else:
+ *                         raise ValueError("Failed to decode a block: %s" % bz3_strerror(self.state))
+ */
+          (void)(fprintf(stderr, ((char const *)"Writing invalid block: %s\n"), bz3_strerror(__pyx_v_self->state)));
+
+          /* "bz3/backends/cython/_bz3.pyx":193
  *                     code = bz3_decode_block(self.state, self.buffer, new_size, old_size)
  *                 if code == -1:
- *                     raise ValueError("Failed to decode a block: %s" % bz3_strerror(self.state))             # <<<<<<<<<<<<<<
+ *                     if self.ignore_error:             # <<<<<<<<<<<<<<
+ *                         fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(self.state))
+ *                     else:
+ */
+          goto __pyx_L24;
+        }
+
+        /* "bz3/backends/cython/_bz3.pyx":196
+ *                         fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(self.state))
+ *                     else:
+ *                         raise ValueError("Failed to decode a block: %s" % bz3_strerror(self.state))             # <<<<<<<<<<<<<<
  *                 # if PyByteArray_Resize(ret, PyByteArray_GET_SIZE(ret) + old_size) < 0:
  *                 #     raise
  */
-        __pyx_t_1 = __Pyx_PyBytes_FromString(bz3_strerror(__pyx_v_self->state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 185, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_1);
-        __pyx_t_3 = PyUnicode_Format(__pyx_kp_u_Failed_to_decode_a_block_s, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 185, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_3);
-        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-        __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 185, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_1);
-        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-        __Pyx_Raise(__pyx_t_1, 0, 0, 0);
-        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-        __PYX_ERR(0, 185, __pyx_L1_error)
+        /*else*/ {
+          __pyx_t_1 = __Pyx_PyBytes_FromString(bz3_strerror(__pyx_v_self->state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 196, __pyx_L1_error)
+          __Pyx_GOTREF(__pyx_t_1);
+          __pyx_t_3 = PyUnicode_Format(__pyx_kp_u_Failed_to_decode_a_block_s, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 196, __pyx_L1_error)
+          __Pyx_GOTREF(__pyx_t_3);
+          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+          __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 196, __pyx_L1_error)
+          __Pyx_GOTREF(__pyx_t_1);
+          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+          __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+          __PYX_ERR(0, 196, __pyx_L1_error)
+        }
+        __pyx_L24:;
 
-        /* "bz3/backends/cython/_bz3.pyx":184
+        /* "bz3/backends/cython/_bz3.pyx":192
  *                 with nogil:
  *                     code = bz3_decode_block(self.state, self.buffer, new_size, old_size)
  *                 if code == -1:             # <<<<<<<<<<<<<<
- *                     raise ValueError("Failed to decode a block: %s" % bz3_strerror(self.state))
- *                 # if PyByteArray_Resize(ret, PyByteArray_GET_SIZE(ret) + old_size) < 0:
+ *                     if self.ignore_error:
+ *                         fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(self.state))
  */
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":188
+      /* "bz3/backends/cython/_bz3.pyx":199
  *                 # if PyByteArray_Resize(ret, PyByteArray_GET_SIZE(ret) + old_size) < 0:
  *                 #     raise
  *                 ret.extend(<bytes>self.buffer[:old_size])             # <<<<<<<<<<<<<<
  *                 # memcpy(&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-old_size]), self.buffer, <size_t>old_size)
  *                 del self.unused[:new_size+8]
  */
-      __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_self->buffer) + 0, __pyx_v_old_size - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 188, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_self->buffer) + 0, __pyx_v_old_size - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 199, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_3 = __Pyx_CallUnboundCMethod1(&__pyx_umethod_PyByteArray_Type_extend, __pyx_v_ret, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 188, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_CallUnboundCMethod1(&__pyx_umethod_PyByteArray_Type_extend, __pyx_v_ret, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 199, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":190
+      /* "bz3/backends/cython/_bz3.pyx":201
  *                 ret.extend(<bytes>self.buffer[:old_size])
  *                 # memcpy(&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-old_size]), self.buffer, <size_t>old_size)
  *                 del self.unused[:new_size+8]             # <<<<<<<<<<<<<<
  *         return bytes(ret)
  * 
  */
       if (unlikely(__pyx_v_self->unused == Py_None)) {
         PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
-        __PYX_ERR(0, 190, __pyx_L1_error)
+        __PYX_ERR(0, 201, __pyx_L1_error)
       }
-      if (__Pyx_PyObject_DelSlice(__pyx_v_self->unused, 0, (__pyx_v_new_size + 8), NULL, NULL, NULL, 0, 1, 0) < 0) __PYX_ERR(0, 190, __pyx_L1_error)
+      if (__Pyx_PyObject_DelSlice(__pyx_v_self->unused, 0, (__pyx_v_new_size + 8), NULL, NULL, NULL, 0, 1, 0) < 0) __PYX_ERR(0, 201, __pyx_L1_error)
     }
     __pyx_L12_break:;
 
-    /* "bz3/backends/cython/_bz3.pyx":159
+    /* "bz3/backends/cython/_bz3.pyx":165
  *         cdef bytearray ret = bytearray()
  *         cdef int32_t new_size, old_size, block_size
  *         if input_size > 0:             # <<<<<<<<<<<<<<
  *             # if PyByteArray_Resize(self.unused, input_size+PyByteArray_GET_SIZE(self.unused)) < 0:
  *             #     raise
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":191
+  /* "bz3/backends/cython/_bz3.pyx":202
  *                 # memcpy(&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-old_size]), self.buffer, <size_t>old_size)
  *                 del self.unused[:new_size+8]
  *         return bytes(ret)             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_ret); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 191, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_ret); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 202, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_r = ((PyObject*)__pyx_t_3);
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
-  /* "bz3/backends/cython/_bz3.pyx":154
+  /* "bz3/backends/cython/_bz3.pyx":160
  *             self.buffer = NULL
  * 
  *     cpdef inline bytes decompress(self, const uint8_t[::1] data):             # <<<<<<<<<<<<<<
  *         cdef Py_ssize_t input_size = data.shape[0]
  *         cdef int32_t code
  */
 
@@ -4981,15 +5163,15 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("decompress (wrapper)", 0);
   assert(__pyx_arg_data); {
-    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t__const__(__pyx_arg_data, 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 154, __pyx_L3_error)
+    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t__const__(__pyx_arg_data, 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 160, __pyx_L3_error)
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   __Pyx_AddTraceback("bz3.backends.cython._bz3.BZ3Decompressor.decompress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
@@ -5005,16 +5187,16 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decompress", 0);
   __Pyx_XDECREF(__pyx_r);
-  if (unlikely(!__pyx_v_data.memview)) { __Pyx_RaiseUnboundLocalError("data"); __PYX_ERR(0, 154, __pyx_L1_error) }
-  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_decompress(__pyx_v_self, __pyx_v_data, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 154, __pyx_L1_error)
+  if (unlikely(!__pyx_v_data.memview)) { __Pyx_RaiseUnboundLocalError("data"); __PYX_ERR(0, 160, __pyx_L1_error) }
+  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_decompress(__pyx_v_self, __pyx_v_data, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 160, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -5024,15 +5206,15 @@
   __pyx_L0:;
   __PYX_XDEC_MEMVIEW(&__pyx_v_data, 1);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":194
+/* "bz3/backends/cython/_bz3.pyx":205
  * 
  *     @property
  *     def unused_data(self):             # <<<<<<<<<<<<<<
  *         """Data found after the end of the compressed stream."""
  *         return bytes(self.unused)
  */
 
@@ -5054,29 +5236,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":196
+  /* "bz3/backends/cython/_bz3.pyx":207
  *     def unused_data(self):
  *         """Data found after the end of the compressed stream."""
  *         return bytes(self.unused)             # <<<<<<<<<<<<<<
  * 
  *     cpdef inline str error(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_self->unused); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 196, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_self->unused); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 207, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "bz3/backends/cython/_bz3.pyx":194
+  /* "bz3/backends/cython/_bz3.pyx":205
  * 
  *     @property
  *     def unused_data(self):             # <<<<<<<<<<<<<<
  *         """Data found after the end of the compressed stream."""
  *         return bytes(self.unused)
  */
 
@@ -5087,15 +5269,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":198
+/* "bz3/backends/cython/_bz3.pyx":209
  *         return bytes(self.unused)
  * 
  *     cpdef inline str error(self):             # <<<<<<<<<<<<<<
  *         if bz3_last_error(self.state) != BZ3_OK:
  *             return (<bytes> bz3_strerror(self.state)).decode()
  */
 
@@ -5107,66 +5289,66 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("error", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":199
+  /* "bz3/backends/cython/_bz3.pyx":210
  * 
  *     cpdef inline str error(self):
  *         if bz3_last_error(self.state) != BZ3_OK:             # <<<<<<<<<<<<<<
  *             return (<bytes> bz3_strerror(self.state)).decode()
  *         return None
  */
   __pyx_t_1 = ((bz3_last_error(__pyx_v_self->state) != BZ3_OK) != 0);
   if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":200
+    /* "bz3/backends/cython/_bz3.pyx":211
  *     cpdef inline str error(self):
  *         if bz3_last_error(self.state) != BZ3_OK:
  *             return (<bytes> bz3_strerror(self.state)).decode()             # <<<<<<<<<<<<<<
  *         return None
  * 
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __Pyx_PyBytes_FromString(bz3_strerror(__pyx_v_self->state)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 200, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyBytes_FromString(bz3_strerror(__pyx_v_self->state)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 211, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     if (unlikely(__pyx_t_2 == Py_None)) {
       PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "decode");
-      __PYX_ERR(0, 200, __pyx_L1_error)
+      __PYX_ERR(0, 211, __pyx_L1_error)
     }
-    __pyx_t_3 = __Pyx_decode_bytes(((PyObject*)__pyx_t_2), 0, PY_SSIZE_T_MAX, NULL, NULL, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 200, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_decode_bytes(((PyObject*)__pyx_t_2), 0, PY_SSIZE_T_MAX, NULL, NULL, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 211, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_r = ((PyObject*)__pyx_t_3);
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "bz3/backends/cython/_bz3.pyx":199
+    /* "bz3/backends/cython/_bz3.pyx":210
  * 
  *     cpdef inline str error(self):
  *         if bz3_last_error(self.state) != BZ3_OK:             # <<<<<<<<<<<<<<
  *             return (<bytes> bz3_strerror(self.state)).decode()
  *         return None
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":201
+  /* "bz3/backends/cython/_bz3.pyx":212
  *         if bz3_last_error(self.state) != BZ3_OK:
  *             return (<bytes> bz3_strerror(self.state)).decode()
  *         return None             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_r = ((PyObject*)Py_None); __Pyx_INCREF(Py_None);
   goto __pyx_L0;
 
-  /* "bz3/backends/cython/_bz3.pyx":198
+  /* "bz3/backends/cython/_bz3.pyx":209
  *         return bytes(self.unused)
  * 
  *     cpdef inline str error(self):             # <<<<<<<<<<<<<<
  *         if bz3_last_error(self.state) != BZ3_OK:
  *             return (<bytes> bz3_strerror(self.state)).decode()
  */
 
@@ -5201,15 +5383,15 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("error", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_error(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 198, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_error(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 209, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -5218,15 +5400,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":126
+/* "bz3/backends/cython/_bz3.pyx":130
  *         bz3_state * state
  *         uint8_t * buffer
  *         readonly int32_t block_size             # <<<<<<<<<<<<<<
  *         bytearray unused  #
  *         bint have_magic_number
  */
 
@@ -5248,15 +5430,15 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_From_int32_t(__pyx_v_self->block_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 126, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int32_t(__pyx_v_self->block_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 130, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -5265,14 +5447,61 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
+/* "bz3/backends/cython/_bz3.pyx":133
+ *         bytearray unused  #
+ *         bint have_magic_number
+ *         readonly bint ignore_error # decode             # <<<<<<<<<<<<<<
+ * 
+ *     cdef inline int init_state(self, int32_t block_size) except -1:
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_12ignore_error_1__get__(PyObject *__pyx_v_self); /*proto*/
+static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_12ignore_error_1__get__(PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_12ignore_error___get__(((struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_12ignore_error___get__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__get__", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->ignore_error); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 133, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("bz3.backends.cython._bz3.BZ3Decompressor.ignore_error.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
 /* Python wrapper */
@@ -5300,15 +5529,15 @@
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
@@ -5357,15 +5586,15 @@
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
@@ -5380,15 +5609,15 @@
   __Pyx_AddTraceback("bz3.backends.cython._bz3.BZ3Decompressor.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":204
+/* "bz3/backends/cython/_bz3.pyx":215
  * 
  * 
  * def compress_file(object input, object output, int32_t block_size):             # <<<<<<<<<<<<<<
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  */
 
@@ -5427,40 +5656,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_input)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_output)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("compress_file", 1, 3, 3, 1); __PYX_ERR(0, 204, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("compress_file", 1, 3, 3, 1); __PYX_ERR(0, 215, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_block_size)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("compress_file", 1, 3, 3, 2); __PYX_ERR(0, 204, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("compress_file", 1, 3, 3, 2); __PYX_ERR(0, 215, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "compress_file") < 0)) __PYX_ERR(0, 204, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "compress_file") < 0)) __PYX_ERR(0, 215, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_input = values[0];
     __pyx_v_output = values[1];
-    __pyx_v_block_size = __Pyx_PyInt_As_int32_t(values[2]); if (unlikely((__pyx_v_block_size == ((int32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 204, __pyx_L3_error)
+    __pyx_v_block_size = __Pyx_PyInt_As_int32_t(values[2]); if (unlikely((__pyx_v_block_size == ((int32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 215, __pyx_L3_error)
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("compress_file", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 204, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("compress_file", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 215, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("bz3.backends.cython._bz3.compress_file", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_3bz3_8backends_6cython_4_bz3_compress_file(__pyx_self, __pyx_v_input, __pyx_v_output, __pyx_v_block_size);
 
@@ -5494,372 +5723,372 @@
   PyObject *__pyx_t_14 = NULL;
   PyObject *__pyx_t_15 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("compress_file", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":205
+  /* "bz3/backends/cython/_bz3.pyx":216
  * 
  * def compress_file(object input, object output, int32_t block_size):
  *     if not PyFile_Check(input):             # <<<<<<<<<<<<<<
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     if not PyFile_Check(output):
  */
   __pyx_t_1 = ((!(__pyx_f_3bz3_8backends_6cython_4_bz3_PyFile_Check(__pyx_v_input) != 0)) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":206
+    /* "bz3/backends/cython/_bz3.pyx":217
  * def compress_file(object input, object output, int32_t block_size):
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)             # <<<<<<<<<<<<<<
  *     if not PyFile_Check(output):
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
  */
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_input)), __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 206, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_input)), __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 217, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_input_except_a_file_like_object, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 206, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_input_except_a_file_like_object, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 217, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 206, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 217, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(0, 206, __pyx_L1_error)
+    __PYX_ERR(0, 217, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":205
+    /* "bz3/backends/cython/_bz3.pyx":216
  * 
  * def compress_file(object input, object output, int32_t block_size):
  *     if not PyFile_Check(input):             # <<<<<<<<<<<<<<
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     if not PyFile_Check(output):
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":207
+  /* "bz3/backends/cython/_bz3.pyx":218
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     if not PyFile_Check(output):             # <<<<<<<<<<<<<<
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
  *     cdef bz3_state *state = bz3_new(block_size)
  */
   __pyx_t_1 = ((!(__pyx_f_3bz3_8backends_6cython_4_bz3_PyFile_Check(__pyx_v_output) != 0)) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":208
+    /* "bz3/backends/cython/_bz3.pyx":219
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     if not PyFile_Check(output):
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)             # <<<<<<<<<<<<<<
  *     cdef bz3_state *state = bz3_new(block_size)
  *     if state == NULL:
  */
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_output)), __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 208, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_output)), __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 219, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_output_except_a_file_like_object, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 208, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_output_except_a_file_like_object, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 219, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 208, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 219, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(0, 208, __pyx_L1_error)
+    __PYX_ERR(0, 219, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":207
+    /* "bz3/backends/cython/_bz3.pyx":218
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     if not PyFile_Check(output):             # <<<<<<<<<<<<<<
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
  *     cdef bz3_state *state = bz3_new(block_size)
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":209
+  /* "bz3/backends/cython/_bz3.pyx":220
  *     if not PyFile_Check(output):
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
  *     cdef bz3_state *state = bz3_new(block_size)             # <<<<<<<<<<<<<<
  *     if state == NULL:
  *         raise MemoryError("Failed to create a block encoder state")
  */
   __pyx_v_state = bz3_new(__pyx_v_block_size);
 
-  /* "bz3/backends/cython/_bz3.pyx":210
+  /* "bz3/backends/cython/_bz3.pyx":221
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
  *     cdef bz3_state *state = bz3_new(block_size)
  *     if state == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError("Failed to create a block encoder state")
- *     cdef uint8_t * buffer = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
+ *     cdef uint8_t * buffer = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))
  */
   __pyx_t_1 = ((__pyx_v_state == NULL) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":211
+    /* "bz3/backends/cython/_bz3.pyx":222
  *     cdef bz3_state *state = bz3_new(block_size)
  *     if state == NULL:
  *         raise MemoryError("Failed to create a block encoder state")             # <<<<<<<<<<<<<<
- *     cdef uint8_t * buffer = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
+ *     cdef uint8_t * buffer = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))
  *     if buffer == NULL:
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 211, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 222, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(0, 211, __pyx_L1_error)
+    __PYX_ERR(0, 222, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":210
+    /* "bz3/backends/cython/_bz3.pyx":221
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
  *     cdef bz3_state *state = bz3_new(block_size)
  *     if state == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError("Failed to create a block encoder state")
- *     cdef uint8_t * buffer = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
+ *     cdef uint8_t * buffer = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":212
+  /* "bz3/backends/cython/_bz3.pyx":223
  *     if state == NULL:
  *         raise MemoryError("Failed to create a block encoder state")
- *     cdef uint8_t * buffer = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)             # <<<<<<<<<<<<<<
+ *     cdef uint8_t * buffer = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))             # <<<<<<<<<<<<<<
  *     if buffer == NULL:
  *         bz3_free(state)
  */
-  __pyx_v_buffer = ((uint8_t *)PyMem_Malloc(((__pyx_v_block_size + (((long)__pyx_v_block_size) / 50)) + 32)));
+  __pyx_v_buffer = ((uint8_t *)PyMem_Malloc(bz3_bound(__pyx_v_block_size)));
 
-  /* "bz3/backends/cython/_bz3.pyx":213
+  /* "bz3/backends/cython/_bz3.pyx":224
  *         raise MemoryError("Failed to create a block encoder state")
- *     cdef uint8_t * buffer = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
+ *     cdef uint8_t * buffer = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))
  *     if buffer == NULL:             # <<<<<<<<<<<<<<
  *         bz3_free(state)
  *         state = NULL
  */
   __pyx_t_1 = ((__pyx_v_buffer == NULL) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":214
- *     cdef uint8_t * buffer = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
+    /* "bz3/backends/cython/_bz3.pyx":225
+ *     cdef uint8_t * buffer = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))
  *     if buffer == NULL:
  *         bz3_free(state)             # <<<<<<<<<<<<<<
  *         state = NULL
  *         raise MemoryError
  */
     bz3_free(__pyx_v_state);
 
-    /* "bz3/backends/cython/_bz3.pyx":215
+    /* "bz3/backends/cython/_bz3.pyx":226
  *     if buffer == NULL:
  *         bz3_free(state)
  *         state = NULL             # <<<<<<<<<<<<<<
  *         raise MemoryError
  *     cdef bytes data
  */
     __pyx_v_state = NULL;
 
-    /* "bz3/backends/cython/_bz3.pyx":216
+    /* "bz3/backends/cython/_bz3.pyx":227
  *         bz3_free(state)
  *         state = NULL
  *         raise MemoryError             # <<<<<<<<<<<<<<
  *     cdef bytes data
  *     cdef int32_t new_size
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 216, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 227, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":213
+    /* "bz3/backends/cython/_bz3.pyx":224
  *         raise MemoryError("Failed to create a block encoder state")
- *     cdef uint8_t * buffer = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
+ *     cdef uint8_t * buffer = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))
  *     if buffer == NULL:             # <<<<<<<<<<<<<<
  *         bz3_free(state)
  *         state = NULL
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":221
+  /* "bz3/backends/cython/_bz3.pyx":232
  *     cdef uint8_t byteswap_buf[4]
  * 
  *     output.write(b"BZ3v1")             # <<<<<<<<<<<<<<
  *     write_neutral_s32(byteswap_buf, block_size)
  *     output.write(PyBytes_FromStringAndSize(<char*>&byteswap_buf[0], 4))  # magic header
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_write); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 221, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_write); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 232, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_n_b_BZ3v1) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_n_b_BZ3v1);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 221, __pyx_L1_error)
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 232, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":222
+  /* "bz3/backends/cython/_bz3.pyx":233
  * 
  *     output.write(b"BZ3v1")
  *     write_neutral_s32(byteswap_buf, block_size)             # <<<<<<<<<<<<<<
  *     output.write(PyBytes_FromStringAndSize(<char*>&byteswap_buf[0], 4))  # magic header
  *     cdef int32_t old_size
  */
   write_neutral_s32(__pyx_v_byteswap_buf, __pyx_v_block_size);
 
-  /* "bz3/backends/cython/_bz3.pyx":223
+  /* "bz3/backends/cython/_bz3.pyx":234
  *     output.write(b"BZ3v1")
  *     write_neutral_s32(byteswap_buf, block_size)
  *     output.write(PyBytes_FromStringAndSize(<char*>&byteswap_buf[0], 4))  # magic header             # <<<<<<<<<<<<<<
  *     cdef int32_t old_size
  *     try:
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_write); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 223, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_write); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 234, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = PyBytes_FromStringAndSize(((char *)(&(__pyx_v_byteswap_buf[0]))), 4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 223, __pyx_L1_error)
+  __pyx_t_4 = PyBytes_FromStringAndSize(((char *)(&(__pyx_v_byteswap_buf[0]))), 4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 234, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __pyx_t_5 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_5)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_5);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 223, __pyx_L1_error)
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 234, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":225
+  /* "bz3/backends/cython/_bz3.pyx":236
  *     output.write(PyBytes_FromStringAndSize(<char*>&byteswap_buf[0], 4))  # magic header
  *     cdef int32_t old_size
  *     try:             # <<<<<<<<<<<<<<
  *         while True:
  *             data = input.read(block_size)
  */
   /*try:*/ {
 
-    /* "bz3/backends/cython/_bz3.pyx":226
+    /* "bz3/backends/cython/_bz3.pyx":237
  *     cdef int32_t old_size
  *     try:
  *         while True:             # <<<<<<<<<<<<<<
  *             data = input.read(block_size)
  *             if not data:
  */
     while (1) {
 
-      /* "bz3/backends/cython/_bz3.pyx":227
+      /* "bz3/backends/cython/_bz3.pyx":238
  *     try:
  *         while True:
  *             data = input.read(block_size)             # <<<<<<<<<<<<<<
  *             if not data:
  *                 break
  */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 227, __pyx_L8_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 238, __pyx_L8_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = __Pyx_PyInt_From_int32_t(__pyx_v_block_size); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 227, __pyx_L8_error)
+      __pyx_t_4 = __Pyx_PyInt_From_int32_t(__pyx_v_block_size); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 238, __pyx_L8_error)
       __Pyx_GOTREF(__pyx_t_4);
       __pyx_t_5 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_5)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
           __Pyx_INCREF(__pyx_t_5);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_3, function);
         }
       }
       __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 227, __pyx_L8_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 238, __pyx_L8_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 227, __pyx_L8_error)
+      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 238, __pyx_L8_error)
       __Pyx_XDECREF_SET(__pyx_v_data, ((PyObject*)__pyx_t_2));
       __pyx_t_2 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":228
+      /* "bz3/backends/cython/_bz3.pyx":239
  *         while True:
  *             data = input.read(block_size)
  *             if not data:             # <<<<<<<<<<<<<<
  *                 break
  *             old_size = <int32_t>PyBytes_GET_SIZE(data)
  */
       __pyx_t_1 = (__pyx_v_data != Py_None)&&(PyBytes_GET_SIZE(__pyx_v_data) != 0);
       __pyx_t_6 = ((!__pyx_t_1) != 0);
       if (__pyx_t_6) {
 
-        /* "bz3/backends/cython/_bz3.pyx":229
+        /* "bz3/backends/cython/_bz3.pyx":240
  *             data = input.read(block_size)
  *             if not data:
  *                 break             # <<<<<<<<<<<<<<
  *             old_size = <int32_t>PyBytes_GET_SIZE(data)
  *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t>old_size)
  */
         goto __pyx_L11_break;
 
-        /* "bz3/backends/cython/_bz3.pyx":228
+        /* "bz3/backends/cython/_bz3.pyx":239
  *         while True:
  *             data = input.read(block_size)
  *             if not data:             # <<<<<<<<<<<<<<
  *                 break
  *             old_size = <int32_t>PyBytes_GET_SIZE(data)
  */
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":230
+      /* "bz3/backends/cython/_bz3.pyx":241
  *             if not data:
  *                 break
  *             old_size = <int32_t>PyBytes_GET_SIZE(data)             # <<<<<<<<<<<<<<
  *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t>old_size)
  *             with nogil:
  */
       __pyx_v_old_size = ((int32_t)PyBytes_GET_SIZE(__pyx_v_data));
 
-      /* "bz3/backends/cython/_bz3.pyx":231
+      /* "bz3/backends/cython/_bz3.pyx":242
  *                 break
  *             old_size = <int32_t>PyBytes_GET_SIZE(data)
  *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t>old_size)             # <<<<<<<<<<<<<<
  *             with nogil:
  *                 new_size = bz3_encode_block(state, buffer, old_size)
  */
       (void)(memcpy(__pyx_v_buffer, PyBytes_AS_STRING(__pyx_v_data), ((size_t)__pyx_v_old_size)));
 
-      /* "bz3/backends/cython/_bz3.pyx":232
+      /* "bz3/backends/cython/_bz3.pyx":243
  *             old_size = <int32_t>PyBytes_GET_SIZE(data)
  *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t>old_size)
  *             with nogil:             # <<<<<<<<<<<<<<
  *                 new_size = bz3_encode_block(state, buffer, old_size)
  *             if new_size == -1:
  */
       {
           #ifdef WITH_THREAD
           PyThreadState *_save;
           Py_UNBLOCK_THREADS
           __Pyx_FastGIL_Remember();
           #endif
           /*try:*/ {
 
-            /* "bz3/backends/cython/_bz3.pyx":233
+            /* "bz3/backends/cython/_bz3.pyx":244
  *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t>old_size)
  *             with nogil:
  *                 new_size = bz3_encode_block(state, buffer, old_size)             # <<<<<<<<<<<<<<
  *             if new_size == -1:
  *                 raise ValueError("Failed to encode a block: %s" % bz3_strerror(state))
  */
             __pyx_v_new_size = bz3_encode_block(__pyx_v_state, __pyx_v_buffer, __pyx_v_old_size);
           }
 
-          /* "bz3/backends/cython/_bz3.pyx":232
+          /* "bz3/backends/cython/_bz3.pyx":243
  *             old_size = <int32_t>PyBytes_GET_SIZE(data)
  *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t>old_size)
  *             with nogil:             # <<<<<<<<<<<<<<
  *                 new_size = bz3_encode_block(state, buffer, old_size)
  *             if new_size == -1:
  */
           /*finally:*/ {
@@ -5870,240 +6099,249 @@
               #endif
               goto __pyx_L17;
             }
             __pyx_L17:;
           }
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":234
+      /* "bz3/backends/cython/_bz3.pyx":245
  *             with nogil:
  *                 new_size = bz3_encode_block(state, buffer, old_size)
  *             if new_size == -1:             # <<<<<<<<<<<<<<
  *                 raise ValueError("Failed to encode a block: %s" % bz3_strerror(state))
  *             write_neutral_s32(byteswap_buf, new_size)
  */
       __pyx_t_6 = ((__pyx_v_new_size == -1L) != 0);
       if (unlikely(__pyx_t_6)) {
 
-        /* "bz3/backends/cython/_bz3.pyx":235
+        /* "bz3/backends/cython/_bz3.pyx":246
  *                 new_size = bz3_encode_block(state, buffer, old_size)
  *             if new_size == -1:
  *                 raise ValueError("Failed to encode a block: %s" % bz3_strerror(state))             # <<<<<<<<<<<<<<
  *             write_neutral_s32(byteswap_buf, new_size)
  *             output.write(PyBytes_FromStringAndSize(<char*>&byteswap_buf[0], 4))
  */
-        __pyx_t_2 = __Pyx_PyBytes_FromString(bz3_strerror(__pyx_v_state)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 235, __pyx_L8_error)
+        __pyx_t_2 = __Pyx_PyBytes_FromString(bz3_strerror(__pyx_v_state)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 246, __pyx_L8_error)
         __Pyx_GOTREF(__pyx_t_2);
-        __pyx_t_3 = PyUnicode_Format(__pyx_kp_u_Failed_to_encode_a_block_s, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 235, __pyx_L8_error)
+        __pyx_t_3 = PyUnicode_Format(__pyx_kp_u_Failed_to_encode_a_block_s, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 246, __pyx_L8_error)
         __Pyx_GOTREF(__pyx_t_3);
         __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 235, __pyx_L8_error)
+        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 246, __pyx_L8_error)
         __Pyx_GOTREF(__pyx_t_2);
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
         __Pyx_Raise(__pyx_t_2, 0, 0, 0);
         __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-        __PYX_ERR(0, 235, __pyx_L8_error)
+        __PYX_ERR(0, 246, __pyx_L8_error)
 
-        /* "bz3/backends/cython/_bz3.pyx":234
+        /* "bz3/backends/cython/_bz3.pyx":245
  *             with nogil:
  *                 new_size = bz3_encode_block(state, buffer, old_size)
  *             if new_size == -1:             # <<<<<<<<<<<<<<
  *                 raise ValueError("Failed to encode a block: %s" % bz3_strerror(state))
  *             write_neutral_s32(byteswap_buf, new_size)
  */
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":236
+      /* "bz3/backends/cython/_bz3.pyx":247
  *             if new_size == -1:
  *                 raise ValueError("Failed to encode a block: %s" % bz3_strerror(state))
  *             write_neutral_s32(byteswap_buf, new_size)             # <<<<<<<<<<<<<<
  *             output.write(PyBytes_FromStringAndSize(<char*>&byteswap_buf[0], 4))
  *             write_neutral_s32(byteswap_buf, old_size)
  */
       write_neutral_s32(__pyx_v_byteswap_buf, __pyx_v_new_size);
 
-      /* "bz3/backends/cython/_bz3.pyx":237
+      /* "bz3/backends/cython/_bz3.pyx":248
  *                 raise ValueError("Failed to encode a block: %s" % bz3_strerror(state))
  *             write_neutral_s32(byteswap_buf, new_size)
  *             output.write(PyBytes_FromStringAndSize(<char*>&byteswap_buf[0], 4))             # <<<<<<<<<<<<<<
  *             write_neutral_s32(byteswap_buf, old_size)
  *             output.write(PyBytes_FromStringAndSize(<char*>&byteswap_buf[0], 4))
  */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_write); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 237, __pyx_L8_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_write); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 248, __pyx_L8_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyBytes_FromStringAndSize(((char *)(&(__pyx_v_byteswap_buf[0]))), 4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 237, __pyx_L8_error)
+      __pyx_t_4 = PyBytes_FromStringAndSize(((char *)(&(__pyx_v_byteswap_buf[0]))), 4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 248, __pyx_L8_error)
       __Pyx_GOTREF(__pyx_t_4);
       __pyx_t_5 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_5)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
           __Pyx_INCREF(__pyx_t_5);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_3, function);
         }
       }
       __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 237, __pyx_L8_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 248, __pyx_L8_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":238
+      /* "bz3/backends/cython/_bz3.pyx":249
  *             write_neutral_s32(byteswap_buf, new_size)
  *             output.write(PyBytes_FromStringAndSize(<char*>&byteswap_buf[0], 4))
  *             write_neutral_s32(byteswap_buf, old_size)             # <<<<<<<<<<<<<<
  *             output.write(PyBytes_FromStringAndSize(<char*>&byteswap_buf[0], 4))
  *             output.write(PyBytes_FromStringAndSize(<char*>buffer, new_size))
  */
       write_neutral_s32(__pyx_v_byteswap_buf, __pyx_v_old_size);
 
-      /* "bz3/backends/cython/_bz3.pyx":239
+      /* "bz3/backends/cython/_bz3.pyx":250
  *             output.write(PyBytes_FromStringAndSize(<char*>&byteswap_buf[0], 4))
  *             write_neutral_s32(byteswap_buf, old_size)
  *             output.write(PyBytes_FromStringAndSize(<char*>&byteswap_buf[0], 4))             # <<<<<<<<<<<<<<
  *             output.write(PyBytes_FromStringAndSize(<char*>buffer, new_size))
  *             output.flush()
  */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_write); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 239, __pyx_L8_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_write); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 250, __pyx_L8_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyBytes_FromStringAndSize(((char *)(&(__pyx_v_byteswap_buf[0]))), 4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 239, __pyx_L8_error)
+      __pyx_t_4 = PyBytes_FromStringAndSize(((char *)(&(__pyx_v_byteswap_buf[0]))), 4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 250, __pyx_L8_error)
       __Pyx_GOTREF(__pyx_t_4);
       __pyx_t_5 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_5)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
           __Pyx_INCREF(__pyx_t_5);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_3, function);
         }
       }
       __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 239, __pyx_L8_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 250, __pyx_L8_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":240
+      /* "bz3/backends/cython/_bz3.pyx":251
  *             write_neutral_s32(byteswap_buf, old_size)
  *             output.write(PyBytes_FromStringAndSize(<char*>&byteswap_buf[0], 4))
  *             output.write(PyBytes_FromStringAndSize(<char*>buffer, new_size))             # <<<<<<<<<<<<<<
  *             output.flush()
  *     finally:
  */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_write); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 240, __pyx_L8_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_write); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 251, __pyx_L8_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyBytes_FromStringAndSize(((char *)__pyx_v_buffer), __pyx_v_new_size); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 240, __pyx_L8_error)
+      __pyx_t_4 = PyBytes_FromStringAndSize(((char *)__pyx_v_buffer), __pyx_v_new_size); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 251, __pyx_L8_error)
       __Pyx_GOTREF(__pyx_t_4);
       __pyx_t_5 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_5)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
           __Pyx_INCREF(__pyx_t_5);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_3, function);
         }
       }
       __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 240, __pyx_L8_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 251, __pyx_L8_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":241
+      /* "bz3/backends/cython/_bz3.pyx":252
  *             output.write(PyBytes_FromStringAndSize(<char*>&byteswap_buf[0], 4))
  *             output.write(PyBytes_FromStringAndSize(<char*>buffer, new_size))
  *             output.flush()             # <<<<<<<<<<<<<<
  *     finally:
  *         output.flush()
  */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_flush); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 241, __pyx_L8_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_flush); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 252, __pyx_L8_error)
       __Pyx_GOTREF(__pyx_t_3);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_3, function);
         }
       }
       __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 241, __pyx_L8_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 252, __pyx_L8_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     }
     __pyx_L11_break:;
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":243
+  /* "bz3/backends/cython/_bz3.pyx":254
  *             output.flush()
  *     finally:
  *         output.flush()             # <<<<<<<<<<<<<<
  *         bz3_free(state)
  *         state = NULL
  */
   /*finally:*/ {
     /*normal exit:*/{
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_flush); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 243, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_flush); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 254, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_3, function);
         }
       }
       __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 243, __pyx_L1_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 254, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":244
+      /* "bz3/backends/cython/_bz3.pyx":255
  *     finally:
  *         output.flush()
  *         bz3_free(state)             # <<<<<<<<<<<<<<
  *         state = NULL
  *         PyMem_Free(buffer)
  */
       bz3_free(__pyx_v_state);
 
-      /* "bz3/backends/cython/_bz3.pyx":245
+      /* "bz3/backends/cython/_bz3.pyx":256
  *         output.flush()
  *         bz3_free(state)
  *         state = NULL             # <<<<<<<<<<<<<<
  *         PyMem_Free(buffer)
- * 
+ *         buffer = NULL
  */
       __pyx_v_state = NULL;
 
-      /* "bz3/backends/cython/_bz3.pyx":246
+      /* "bz3/backends/cython/_bz3.pyx":257
  *         bz3_free(state)
  *         state = NULL
  *         PyMem_Free(buffer)             # <<<<<<<<<<<<<<
+ *         buffer = NULL
  * 
- * def decompress_file(object input, object output):
  */
       PyMem_Free(__pyx_v_buffer);
+
+      /* "bz3/backends/cython/_bz3.pyx":258
+ *         state = NULL
+ *         PyMem_Free(buffer)
+ *         buffer = NULL             # <<<<<<<<<<<<<<
+ * 
+ * def decompress_file(object input, object output):
+ */
+      __pyx_v_buffer = NULL;
       goto __pyx_L9;
     }
     __pyx_L8_error:;
     /*exception exit:*/{
       __Pyx_PyThreadState_declare
       __Pyx_PyThreadState_assign
       __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
@@ -6118,66 +6356,75 @@
       __Pyx_XGOTREF(__pyx_t_12);
       __Pyx_XGOTREF(__pyx_t_13);
       __Pyx_XGOTREF(__pyx_t_14);
       __Pyx_XGOTREF(__pyx_t_15);
       __pyx_t_7 = __pyx_lineno; __pyx_t_8 = __pyx_clineno; __pyx_t_9 = __pyx_filename;
       {
 
-        /* "bz3/backends/cython/_bz3.pyx":243
+        /* "bz3/backends/cython/_bz3.pyx":254
  *             output.flush()
  *     finally:
  *         output.flush()             # <<<<<<<<<<<<<<
  *         bz3_free(state)
  *         state = NULL
  */
-        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_flush); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 243, __pyx_L20_error)
+        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_flush); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 254, __pyx_L20_error)
         __Pyx_GOTREF(__pyx_t_3);
         __pyx_t_4 = NULL;
         if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
           __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
           if (likely(__pyx_t_4)) {
             PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
             __Pyx_INCREF(__pyx_t_4);
             __Pyx_INCREF(function);
             __Pyx_DECREF_SET(__pyx_t_3, function);
           }
         }
         __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
         __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 243, __pyx_L20_error)
+        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 254, __pyx_L20_error)
         __Pyx_GOTREF(__pyx_t_2);
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
         __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-        /* "bz3/backends/cython/_bz3.pyx":244
+        /* "bz3/backends/cython/_bz3.pyx":255
  *     finally:
  *         output.flush()
  *         bz3_free(state)             # <<<<<<<<<<<<<<
  *         state = NULL
  *         PyMem_Free(buffer)
  */
         bz3_free(__pyx_v_state);
 
-        /* "bz3/backends/cython/_bz3.pyx":245
+        /* "bz3/backends/cython/_bz3.pyx":256
  *         output.flush()
  *         bz3_free(state)
  *         state = NULL             # <<<<<<<<<<<<<<
  *         PyMem_Free(buffer)
- * 
+ *         buffer = NULL
  */
         __pyx_v_state = NULL;
 
-        /* "bz3/backends/cython/_bz3.pyx":246
+        /* "bz3/backends/cython/_bz3.pyx":257
  *         bz3_free(state)
  *         state = NULL
  *         PyMem_Free(buffer)             # <<<<<<<<<<<<<<
+ *         buffer = NULL
  * 
- * def decompress_file(object input, object output):
  */
         PyMem_Free(__pyx_v_buffer);
+
+        /* "bz3/backends/cython/_bz3.pyx":258
+ *         state = NULL
+ *         PyMem_Free(buffer)
+ *         buffer = NULL             # <<<<<<<<<<<<<<
+ * 
+ * def decompress_file(object input, object output):
+ */
+        __pyx_v_buffer = NULL;
       }
       if (PY_MAJOR_VERSION >= 3) {
         __Pyx_XGIVEREF(__pyx_t_13);
         __Pyx_XGIVEREF(__pyx_t_14);
         __Pyx_XGIVEREF(__pyx_t_15);
         __Pyx_ExceptionReset(__pyx_t_13, __pyx_t_14, __pyx_t_15);
       }
@@ -6200,15 +6447,15 @@
       __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
       __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
       goto __pyx_L1_error;
     }
     __pyx_L9:;
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":204
+  /* "bz3/backends/cython/_bz3.pyx":215
  * 
  * 
  * def compress_file(object input, object output, int32_t block_size):             # <<<<<<<<<<<<<<
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  */
 
@@ -6225,16 +6472,16 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_data);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":248
- *         PyMem_Free(buffer)
+/* "bz3/backends/cython/_bz3.pyx":260
+ *         buffer = NULL
  * 
  * def decompress_file(object input, object output):             # <<<<<<<<<<<<<<
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  */
 
 /* Python wrapper */
@@ -6269,32 +6516,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_input)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_output)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decompress_file", 1, 2, 2, 1); __PYX_ERR(0, 248, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decompress_file", 1, 2, 2, 1); __PYX_ERR(0, 260, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress_file") < 0)) __PYX_ERR(0, 248, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress_file") < 0)) __PYX_ERR(0, 260, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_input = values[0];
     __pyx_v_output = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decompress_file", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 248, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decompress_file", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 260, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("bz3.backends.cython._bz3.decompress_file", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_3bz3_8backends_6cython_4_bz3_2decompress_file(__pyx_self, __pyx_v_input, __pyx_v_output);
 
@@ -6329,192 +6576,192 @@
   PyObject *__pyx_t_14 = NULL;
   PyObject *__pyx_t_15 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decompress_file", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":249
+  /* "bz3/backends/cython/_bz3.pyx":261
  * 
  * def decompress_file(object input, object output):
  *     if not PyFile_Check(input):             # <<<<<<<<<<<<<<
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     if not PyFile_Check(output):
  */
   __pyx_t_1 = ((!(__pyx_f_3bz3_8backends_6cython_4_bz3_PyFile_Check(__pyx_v_input) != 0)) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":250
+    /* "bz3/backends/cython/_bz3.pyx":262
  * def decompress_file(object input, object output):
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)             # <<<<<<<<<<<<<<
  *     if not PyFile_Check(output):
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
  */
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_input)), __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 250, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_input)), __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 262, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_input_except_a_file_like_object, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 250, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_input_except_a_file_like_object, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 262, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 250, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 262, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(0, 250, __pyx_L1_error)
+    __PYX_ERR(0, 262, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":249
+    /* "bz3/backends/cython/_bz3.pyx":261
  * 
  * def decompress_file(object input, object output):
  *     if not PyFile_Check(input):             # <<<<<<<<<<<<<<
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     if not PyFile_Check(output):
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":251
+  /* "bz3/backends/cython/_bz3.pyx":263
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     if not PyFile_Check(output):             # <<<<<<<<<<<<<<
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
  *     cdef bytes data
  */
   __pyx_t_1 = ((!(__pyx_f_3bz3_8backends_6cython_4_bz3_PyFile_Check(__pyx_v_output) != 0)) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":252
+    /* "bz3/backends/cython/_bz3.pyx":264
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     if not PyFile_Check(output):
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)             # <<<<<<<<<<<<<<
  *     cdef bytes data
  *     cdef int32_t block_size
  */
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_output)), __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 252, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_output)), __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 264, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_output_except_a_file_like_object, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 252, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_output_except_a_file_like_object, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 264, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 252, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 264, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(0, 252, __pyx_L1_error)
+    __PYX_ERR(0, 264, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":251
+    /* "bz3/backends/cython/_bz3.pyx":263
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     if not PyFile_Check(output):             # <<<<<<<<<<<<<<
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
  *     cdef bytes data
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":255
+  /* "bz3/backends/cython/_bz3.pyx":267
  *     cdef bytes data
  *     cdef int32_t block_size
  *     data = input.read(9) # magic and block_size type: bytes len = 9             # <<<<<<<<<<<<<<
  *     if PyBytes_GET_SIZE(data) < 9:
  *         raise ValueError("Invalid file. Reason: Smaller than magic header")
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 255, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 267, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_int_9) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_int_9);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 255, __pyx_L1_error)
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 267, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 255, __pyx_L1_error)
+  if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 267, __pyx_L1_error)
   __pyx_v_data = ((PyObject*)__pyx_t_2);
   __pyx_t_2 = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":256
+  /* "bz3/backends/cython/_bz3.pyx":268
  *     cdef int32_t block_size
  *     data = input.read(9) # magic and block_size type: bytes len = 9
  *     if PyBytes_GET_SIZE(data) < 9:             # <<<<<<<<<<<<<<
  *         raise ValueError("Invalid file. Reason: Smaller than magic header")
  *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:
  */
   __pyx_t_1 = ((PyBytes_GET_SIZE(__pyx_v_data) < 9) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":257
+    /* "bz3/backends/cython/_bz3.pyx":269
  *     data = input.read(9) # magic and block_size type: bytes len = 9
  *     if PyBytes_GET_SIZE(data) < 9:
  *         raise ValueError("Invalid file. Reason: Smaller than magic header")             # <<<<<<<<<<<<<<
  *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:
  *         raise ValueError("Invalid signature")
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 257, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 269, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(0, 257, __pyx_L1_error)
+    __PYX_ERR(0, 269, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":256
+    /* "bz3/backends/cython/_bz3.pyx":268
  *     cdef int32_t block_size
  *     data = input.read(9) # magic and block_size type: bytes len = 9
  *     if PyBytes_GET_SIZE(data) < 9:             # <<<<<<<<<<<<<<
  *         raise ValueError("Invalid file. Reason: Smaller than magic header")
  *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":258
+  /* "bz3/backends/cython/_bz3.pyx":270
  *     if PyBytes_GET_SIZE(data) < 9:
  *         raise ValueError("Invalid file. Reason: Smaller than magic header")
  *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:             # <<<<<<<<<<<<<<
  *         raise ValueError("Invalid signature")
  *     block_size = read_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(data)[5]))
  */
   __pyx_t_1 = ((strncmp(PyBytes_AS_STRING(__pyx_v_data), __pyx_v_3bz3_8backends_6cython_4_bz3_magic, 5) != 0) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":259
+    /* "bz3/backends/cython/_bz3.pyx":271
  *         raise ValueError("Invalid file. Reason: Smaller than magic header")
  *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:
  *         raise ValueError("Invalid signature")             # <<<<<<<<<<<<<<
  *     block_size = read_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(data)[5]))
  *     if block_size < KiB(65) or block_size > MiB(511):
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 259, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 271, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(0, 259, __pyx_L1_error)
+    __PYX_ERR(0, 271, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":258
+    /* "bz3/backends/cython/_bz3.pyx":270
  *     if PyBytes_GET_SIZE(data) < 9:
  *         raise ValueError("Invalid file. Reason: Smaller than magic header")
  *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:             # <<<<<<<<<<<<<<
  *         raise ValueError("Invalid signature")
  *     block_size = read_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(data)[5]))
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":260
+  /* "bz3/backends/cython/_bz3.pyx":272
  *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:
  *         raise ValueError("Invalid signature")
  *     block_size = read_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(data)[5]))             # <<<<<<<<<<<<<<
  *     if block_size < KiB(65) or block_size > MiB(511):
  *         raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  */
   __pyx_v_block_size = read_neutral_s32(((uint8_t *)(&(PyBytes_AS_STRING(__pyx_v_data)[5]))));
 
-  /* "bz3/backends/cython/_bz3.pyx":261
+  /* "bz3/backends/cython/_bz3.pyx":273
  *         raise ValueError("Invalid signature")
  *     block_size = read_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(data)[5]))
  *     if block_size < KiB(65) or block_size > MiB(511):             # <<<<<<<<<<<<<<
  *         raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  *     cdef bz3_state *state = bz3_new(block_size)
  */
   __pyx_t_5 = ((__pyx_v_block_size < KiB(65)) != 0);
@@ -6524,546 +6771,595 @@
     goto __pyx_L8_bool_binop_done;
   }
   __pyx_t_5 = ((__pyx_v_block_size > MiB(0x1FF)) != 0);
   __pyx_t_1 = __pyx_t_5;
   __pyx_L8_bool_binop_done:;
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":262
+    /* "bz3/backends/cython/_bz3.pyx":274
  *     block_size = read_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(data)[5]))
  *     if block_size < KiB(65) or block_size > MiB(511):
  *         raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")             # <<<<<<<<<<<<<<
  *     cdef bz3_state *state = bz3_new(block_size)
  *     if state == NULL:
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 262, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 274, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(0, 262, __pyx_L1_error)
+    __PYX_ERR(0, 274, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":261
+    /* "bz3/backends/cython/_bz3.pyx":273
  *         raise ValueError("Invalid signature")
  *     block_size = read_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(data)[5]))
  *     if block_size < KiB(65) or block_size > MiB(511):             # <<<<<<<<<<<<<<
  *         raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  *     cdef bz3_state *state = bz3_new(block_size)
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":263
+  /* "bz3/backends/cython/_bz3.pyx":275
  *     if block_size < KiB(65) or block_size > MiB(511):
  *         raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  *     cdef bz3_state *state = bz3_new(block_size)             # <<<<<<<<<<<<<<
  *     if state == NULL:
  *         raise MemoryError("Failed to create a block encoder state")
  */
   __pyx_v_state = bz3_new(__pyx_v_block_size);
 
-  /* "bz3/backends/cython/_bz3.pyx":264
+  /* "bz3/backends/cython/_bz3.pyx":276
  *         raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  *     cdef bz3_state *state = bz3_new(block_size)
  *     if state == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError("Failed to create a block encoder state")
- *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+ *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  */
   __pyx_t_1 = ((__pyx_v_state == NULL) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":265
+    /* "bz3/backends/cython/_bz3.pyx":277
  *     cdef bz3_state *state = bz3_new(block_size)
  *     if state == NULL:
  *         raise MemoryError("Failed to create a block encoder state")             # <<<<<<<<<<<<<<
- *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+ *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  *     if buffer == NULL:
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 265, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 277, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(0, 265, __pyx_L1_error)
+    __PYX_ERR(0, 277, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":264
+    /* "bz3/backends/cython/_bz3.pyx":276
  *         raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  *     cdef bz3_state *state = bz3_new(block_size)
  *     if state == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError("Failed to create a block encoder state")
- *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+ *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":266
+  /* "bz3/backends/cython/_bz3.pyx":278
  *     if state == NULL:
  *         raise MemoryError("Failed to create a block encoder state")
- *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)             # <<<<<<<<<<<<<<
+ *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))             # <<<<<<<<<<<<<<
  *     if buffer == NULL:
  *         bz3_free(state)
  */
-  __pyx_v_buffer = ((uint8_t *)PyMem_Malloc(((__pyx_v_block_size + (((long)__pyx_v_block_size) / 50)) + 32)));
+  __pyx_v_buffer = ((uint8_t *)PyMem_Malloc(bz3_bound(__pyx_v_block_size)));
 
-  /* "bz3/backends/cython/_bz3.pyx":267
+  /* "bz3/backends/cython/_bz3.pyx":279
  *         raise MemoryError("Failed to create a block encoder state")
- *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+ *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  *     if buffer == NULL:             # <<<<<<<<<<<<<<
  *         bz3_free(state)
  *         state = NULL
  */
   __pyx_t_1 = ((__pyx_v_buffer == NULL) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":268
- *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+    /* "bz3/backends/cython/_bz3.pyx":280
+ *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  *     if buffer == NULL:
  *         bz3_free(state)             # <<<<<<<<<<<<<<
  *         state = NULL
  *         raise MemoryError("Failed to allocate memory")
  */
     bz3_free(__pyx_v_state);
 
-    /* "bz3/backends/cython/_bz3.pyx":269
+    /* "bz3/backends/cython/_bz3.pyx":281
  *     if buffer == NULL:
  *         bz3_free(state)
  *         state = NULL             # <<<<<<<<<<<<<<
  *         raise MemoryError("Failed to allocate memory")
  *     cdef int32_t new_size, old_size, code
  */
     __pyx_v_state = NULL;
 
-    /* "bz3/backends/cython/_bz3.pyx":270
+    /* "bz3/backends/cython/_bz3.pyx":282
  *         bz3_free(state)
  *         state = NULL
  *         raise MemoryError("Failed to allocate memory")             # <<<<<<<<<<<<<<
  *     cdef int32_t new_size, old_size, code
  * 
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 270, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 282, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(0, 270, __pyx_L1_error)
+    __PYX_ERR(0, 282, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":267
+    /* "bz3/backends/cython/_bz3.pyx":279
  *         raise MemoryError("Failed to create a block encoder state")
- *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+ *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  *     if buffer == NULL:             # <<<<<<<<<<<<<<
  *         bz3_free(state)
  *         state = NULL
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":273
+  /* "bz3/backends/cython/_bz3.pyx":285
  *     cdef int32_t new_size, old_size, code
  * 
  *     try:             # <<<<<<<<<<<<<<
  *         while True:
  *             data = input.read(4)
  */
   /*try:*/ {
 
-    /* "bz3/backends/cython/_bz3.pyx":274
+    /* "bz3/backends/cython/_bz3.pyx":286
  * 
  *     try:
  *         while True:             # <<<<<<<<<<<<<<
  *             data = input.read(4)
  *             if PyBytes_GET_SIZE(data) < 4:
  */
     while (1) {
 
-      /* "bz3/backends/cython/_bz3.pyx":275
+      /* "bz3/backends/cython/_bz3.pyx":287
  *     try:
  *         while True:
  *             data = input.read(4)             # <<<<<<<<<<<<<<
  *             if PyBytes_GET_SIZE(data) < 4:
  *                 break
  */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 275, __pyx_L13_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 287, __pyx_L13_error)
       __Pyx_GOTREF(__pyx_t_3);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_3, function);
         }
       }
       __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_int_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_int_4);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 275, __pyx_L13_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 287, __pyx_L13_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 275, __pyx_L13_error)
+      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 287, __pyx_L13_error)
       __Pyx_DECREF_SET(__pyx_v_data, ((PyObject*)__pyx_t_2));
       __pyx_t_2 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":276
+      /* "bz3/backends/cython/_bz3.pyx":288
  *         while True:
  *             data = input.read(4)
  *             if PyBytes_GET_SIZE(data) < 4:             # <<<<<<<<<<<<<<
  *                 break
  *             new_size = read_neutral_s32(<uint8_t*>PyBytes_AS_STRING(data))
  */
       __pyx_t_1 = ((PyBytes_GET_SIZE(__pyx_v_data) < 4) != 0);
       if (__pyx_t_1) {
 
-        /* "bz3/backends/cython/_bz3.pyx":277
+        /* "bz3/backends/cython/_bz3.pyx":289
  *             data = input.read(4)
  *             if PyBytes_GET_SIZE(data) < 4:
  *                 break             # <<<<<<<<<<<<<<
  *             new_size = read_neutral_s32(<uint8_t*>PyBytes_AS_STRING(data))
  *             data = input.read(4)
  */
         goto __pyx_L16_break;
 
-        /* "bz3/backends/cython/_bz3.pyx":276
+        /* "bz3/backends/cython/_bz3.pyx":288
  *         while True:
  *             data = input.read(4)
  *             if PyBytes_GET_SIZE(data) < 4:             # <<<<<<<<<<<<<<
  *                 break
  *             new_size = read_neutral_s32(<uint8_t*>PyBytes_AS_STRING(data))
  */
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":278
+      /* "bz3/backends/cython/_bz3.pyx":290
  *             if PyBytes_GET_SIZE(data) < 4:
  *                 break
  *             new_size = read_neutral_s32(<uint8_t*>PyBytes_AS_STRING(data))             # <<<<<<<<<<<<<<
  *             data = input.read(4)
  *             if PyBytes_GET_SIZE(data) < 4:
  */
       __pyx_v_new_size = read_neutral_s32(((uint8_t *)PyBytes_AS_STRING(__pyx_v_data)));
 
-      /* "bz3/backends/cython/_bz3.pyx":279
+      /* "bz3/backends/cython/_bz3.pyx":291
  *                 break
  *             new_size = read_neutral_s32(<uint8_t*>PyBytes_AS_STRING(data))
  *             data = input.read(4)             # <<<<<<<<<<<<<<
  *             if PyBytes_GET_SIZE(data) < 4:
  *                 break
  */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 279, __pyx_L13_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 291, __pyx_L13_error)
       __Pyx_GOTREF(__pyx_t_3);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_3, function);
         }
       }
       __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_int_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_int_4);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 279, __pyx_L13_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 291, __pyx_L13_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 279, __pyx_L13_error)
+      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 291, __pyx_L13_error)
       __Pyx_DECREF_SET(__pyx_v_data, ((PyObject*)__pyx_t_2));
       __pyx_t_2 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":280
+      /* "bz3/backends/cython/_bz3.pyx":292
  *             new_size = read_neutral_s32(<uint8_t*>PyBytes_AS_STRING(data))
  *             data = input.read(4)
  *             if PyBytes_GET_SIZE(data) < 4:             # <<<<<<<<<<<<<<
  *                 break
  *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
  */
       __pyx_t_1 = ((PyBytes_GET_SIZE(__pyx_v_data) < 4) != 0);
       if (__pyx_t_1) {
 
-        /* "bz3/backends/cython/_bz3.pyx":281
+        /* "bz3/backends/cython/_bz3.pyx":293
  *             data = input.read(4)
  *             if PyBytes_GET_SIZE(data) < 4:
  *                 break             # <<<<<<<<<<<<<<
  *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
- *             data = input.read(new_size) # type: bytes
+ *             if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):
  */
         goto __pyx_L16_break;
 
-        /* "bz3/backends/cython/_bz3.pyx":280
+        /* "bz3/backends/cython/_bz3.pyx":292
  *             new_size = read_neutral_s32(<uint8_t*>PyBytes_AS_STRING(data))
  *             data = input.read(4)
  *             if PyBytes_GET_SIZE(data) < 4:             # <<<<<<<<<<<<<<
  *                 break
  *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
  */
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":282
+      /* "bz3/backends/cython/_bz3.pyx":294
  *             if PyBytes_GET_SIZE(data) < 4:
  *                 break
  *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))             # <<<<<<<<<<<<<<
+ *             if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):
+ *                 raise ValueError("Failed to decode a block: Inconsistent headers.")
+ */
+      __pyx_v_old_size = read_neutral_s32(((uint8_t *)PyBytes_AS_STRING(__pyx_v_data)));
+
+      /* "bz3/backends/cython/_bz3.pyx":295
+ *                 break
+ *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
+ *             if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):             # <<<<<<<<<<<<<<
+ *                 raise ValueError("Failed to decode a block: Inconsistent headers.")
+ *             data = input.read(new_size) # type: bytes
+ */
+      __pyx_t_5 = ((__pyx_v_old_size > ((int32_t)bz3_bound(__pyx_v_block_size))) != 0);
+      if (!__pyx_t_5) {
+      } else {
+        __pyx_t_1 = __pyx_t_5;
+        goto __pyx_L20_bool_binop_done;
+      }
+      __pyx_t_5 = ((__pyx_v_new_size > ((int32_t)bz3_bound(__pyx_v_block_size))) != 0);
+      __pyx_t_1 = __pyx_t_5;
+      __pyx_L20_bool_binop_done:;
+      if (unlikely(__pyx_t_1)) {
+
+        /* "bz3/backends/cython/_bz3.pyx":296
+ *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
+ *             if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):
+ *                 raise ValueError("Failed to decode a block: Inconsistent headers.")             # <<<<<<<<<<<<<<
  *             data = input.read(new_size) # type: bytes
  *             if PyBytes_GET_SIZE(data) < new_size:
  */
-      __pyx_v_old_size = read_neutral_s32(((uint8_t *)PyBytes_AS_STRING(__pyx_v_data)));
+        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 296, __pyx_L13_error)
+        __Pyx_GOTREF(__pyx_t_2);
+        __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+        __PYX_ERR(0, 296, __pyx_L13_error)
 
-      /* "bz3/backends/cython/_bz3.pyx":283
+        /* "bz3/backends/cython/_bz3.pyx":295
  *                 break
  *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
+ *             if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):             # <<<<<<<<<<<<<<
+ *                 raise ValueError("Failed to decode a block: Inconsistent headers.")
+ *             data = input.read(new_size) # type: bytes
+ */
+      }
+
+      /* "bz3/backends/cython/_bz3.pyx":297
+ *             if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):
+ *                 raise ValueError("Failed to decode a block: Inconsistent headers.")
  *             data = input.read(new_size) # type: bytes             # <<<<<<<<<<<<<<
  *             if PyBytes_GET_SIZE(data) < new_size:
  *                 break
  */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 283, __pyx_L13_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 297, __pyx_L13_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = __Pyx_PyInt_From_int32_t(__pyx_v_new_size); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 283, __pyx_L13_error)
+      __pyx_t_4 = __Pyx_PyInt_From_int32_t(__pyx_v_new_size); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 297, __pyx_L13_error)
       __Pyx_GOTREF(__pyx_t_4);
       __pyx_t_6 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_6)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
           __Pyx_INCREF(__pyx_t_6);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_3, function);
         }
       }
       __pyx_t_2 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_6, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
       __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 283, __pyx_L13_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 297, __pyx_L13_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 283, __pyx_L13_error)
+      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 297, __pyx_L13_error)
       __Pyx_DECREF_SET(__pyx_v_data, ((PyObject*)__pyx_t_2));
       __pyx_t_2 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":284
- *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
+      /* "bz3/backends/cython/_bz3.pyx":298
+ *                 raise ValueError("Failed to decode a block: Inconsistent headers.")
  *             data = input.read(new_size) # type: bytes
  *             if PyBytes_GET_SIZE(data) < new_size:             # <<<<<<<<<<<<<<
  *                 break
  *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
  */
       __pyx_t_1 = ((PyBytes_GET_SIZE(__pyx_v_data) < __pyx_v_new_size) != 0);
       if (__pyx_t_1) {
 
-        /* "bz3/backends/cython/_bz3.pyx":285
+        /* "bz3/backends/cython/_bz3.pyx":299
  *             data = input.read(new_size) # type: bytes
  *             if PyBytes_GET_SIZE(data) < new_size:
  *                 break             # <<<<<<<<<<<<<<
  *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
  *             with nogil:
  */
         goto __pyx_L16_break;
 
-        /* "bz3/backends/cython/_bz3.pyx":284
- *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
+        /* "bz3/backends/cython/_bz3.pyx":298
+ *                 raise ValueError("Failed to decode a block: Inconsistent headers.")
  *             data = input.read(new_size) # type: bytes
  *             if PyBytes_GET_SIZE(data) < new_size:             # <<<<<<<<<<<<<<
  *                 break
  *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
  */
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":286
+      /* "bz3/backends/cython/_bz3.pyx":300
  *             if PyBytes_GET_SIZE(data) < new_size:
  *                 break
  *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)             # <<<<<<<<<<<<<<
  *             with nogil:
  *                 code = bz3_decode_block(state, buffer, new_size, old_size)
  */
       (void)(memcpy(__pyx_v_buffer, PyBytes_AS_STRING(__pyx_v_data), ((size_t)__pyx_v_new_size)));
 
-      /* "bz3/backends/cython/_bz3.pyx":287
+      /* "bz3/backends/cython/_bz3.pyx":301
  *                 break
  *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
  *             with nogil:             # <<<<<<<<<<<<<<
  *                 code = bz3_decode_block(state, buffer, new_size, old_size)
  *             if code == -1:
  */
       {
           #ifdef WITH_THREAD
           PyThreadState *_save;
           Py_UNBLOCK_THREADS
           __Pyx_FastGIL_Remember();
           #endif
           /*try:*/ {
 
-            /* "bz3/backends/cython/_bz3.pyx":288
+            /* "bz3/backends/cython/_bz3.pyx":302
  *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
  *             with nogil:
  *                 code = bz3_decode_block(state, buffer, new_size, old_size)             # <<<<<<<<<<<<<<
  *             if code == -1:
  *                 raise ValueError("Failed to decode a block: %s" % bz3_strerror(state))
  */
             __pyx_v_code = bz3_decode_block(__pyx_v_state, __pyx_v_buffer, __pyx_v_new_size, __pyx_v_old_size);
           }
 
-          /* "bz3/backends/cython/_bz3.pyx":287
+          /* "bz3/backends/cython/_bz3.pyx":301
  *                 break
  *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
  *             with nogil:             # <<<<<<<<<<<<<<
  *                 code = bz3_decode_block(state, buffer, new_size, old_size)
  *             if code == -1:
  */
           /*finally:*/ {
             /*normal exit:*/{
               #ifdef WITH_THREAD
               __Pyx_FastGIL_Forget();
               Py_BLOCK_THREADS
               #endif
-              goto __pyx_L24;
+              goto __pyx_L27;
             }
-            __pyx_L24:;
+            __pyx_L27:;
           }
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":289
+      /* "bz3/backends/cython/_bz3.pyx":303
  *             with nogil:
  *                 code = bz3_decode_block(state, buffer, new_size, old_size)
  *             if code == -1:             # <<<<<<<<<<<<<<
  *                 raise ValueError("Failed to decode a block: %s" % bz3_strerror(state))
  *             output.write(PyBytes_FromStringAndSize(<char*>buffer, old_size))
  */
       __pyx_t_1 = ((__pyx_v_code == -1L) != 0);
       if (unlikely(__pyx_t_1)) {
 
-        /* "bz3/backends/cython/_bz3.pyx":290
+        /* "bz3/backends/cython/_bz3.pyx":304
  *                 code = bz3_decode_block(state, buffer, new_size, old_size)
  *             if code == -1:
  *                 raise ValueError("Failed to decode a block: %s" % bz3_strerror(state))             # <<<<<<<<<<<<<<
  *             output.write(PyBytes_FromStringAndSize(<char*>buffer, old_size))
  *             output.flush()
  */
-        __pyx_t_2 = __Pyx_PyBytes_FromString(bz3_strerror(__pyx_v_state)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 290, __pyx_L13_error)
+        __pyx_t_2 = __Pyx_PyBytes_FromString(bz3_strerror(__pyx_v_state)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 304, __pyx_L13_error)
         __Pyx_GOTREF(__pyx_t_2);
-        __pyx_t_3 = PyUnicode_Format(__pyx_kp_u_Failed_to_decode_a_block_s, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 290, __pyx_L13_error)
+        __pyx_t_3 = PyUnicode_Format(__pyx_kp_u_Failed_to_decode_a_block_s, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 304, __pyx_L13_error)
         __Pyx_GOTREF(__pyx_t_3);
         __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 290, __pyx_L13_error)
+        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 304, __pyx_L13_error)
         __Pyx_GOTREF(__pyx_t_2);
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
         __Pyx_Raise(__pyx_t_2, 0, 0, 0);
         __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-        __PYX_ERR(0, 290, __pyx_L13_error)
+        __PYX_ERR(0, 304, __pyx_L13_error)
 
-        /* "bz3/backends/cython/_bz3.pyx":289
+        /* "bz3/backends/cython/_bz3.pyx":303
  *             with nogil:
  *                 code = bz3_decode_block(state, buffer, new_size, old_size)
  *             if code == -1:             # <<<<<<<<<<<<<<
  *                 raise ValueError("Failed to decode a block: %s" % bz3_strerror(state))
  *             output.write(PyBytes_FromStringAndSize(<char*>buffer, old_size))
  */
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":291
+      /* "bz3/backends/cython/_bz3.pyx":305
  *             if code == -1:
  *                 raise ValueError("Failed to decode a block: %s" % bz3_strerror(state))
  *             output.write(PyBytes_FromStringAndSize(<char*>buffer, old_size))             # <<<<<<<<<<<<<<
  *             output.flush()
  *     finally:
  */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_write); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 291, __pyx_L13_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_write); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 305, __pyx_L13_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyBytes_FromStringAndSize(((char *)__pyx_v_buffer), __pyx_v_old_size); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 291, __pyx_L13_error)
+      __pyx_t_4 = PyBytes_FromStringAndSize(((char *)__pyx_v_buffer), __pyx_v_old_size); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 305, __pyx_L13_error)
       __Pyx_GOTREF(__pyx_t_4);
       __pyx_t_6 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_6)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
           __Pyx_INCREF(__pyx_t_6);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_3, function);
         }
       }
       __pyx_t_2 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_6, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
       __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 291, __pyx_L13_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 305, __pyx_L13_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":292
+      /* "bz3/backends/cython/_bz3.pyx":306
  *                 raise ValueError("Failed to decode a block: %s" % bz3_strerror(state))
  *             output.write(PyBytes_FromStringAndSize(<char*>buffer, old_size))
  *             output.flush()             # <<<<<<<<<<<<<<
  *     finally:
  *         output.flush()
  */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_flush); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 292, __pyx_L13_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_flush); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 306, __pyx_L13_error)
       __Pyx_GOTREF(__pyx_t_3);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_3, function);
         }
       }
       __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 292, __pyx_L13_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 306, __pyx_L13_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     }
     __pyx_L16_break:;
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":294
+  /* "bz3/backends/cython/_bz3.pyx":308
  *             output.flush()
  *     finally:
  *         output.flush()             # <<<<<<<<<<<<<<
  *         bz3_free(state)
  *         state = NULL
  */
   /*finally:*/ {
     /*normal exit:*/{
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_flush); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 294, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_flush); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 308, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_3, function);
         }
       }
       __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 294, __pyx_L1_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 308, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":295
+      /* "bz3/backends/cython/_bz3.pyx":309
  *     finally:
  *         output.flush()
  *         bz3_free(state)             # <<<<<<<<<<<<<<
  *         state = NULL
  *         PyMem_Free(buffer)
  */
       bz3_free(__pyx_v_state);
 
-      /* "bz3/backends/cython/_bz3.pyx":296
+      /* "bz3/backends/cython/_bz3.pyx":310
  *         output.flush()
  *         bz3_free(state)
  *         state = NULL             # <<<<<<<<<<<<<<
  *         PyMem_Free(buffer)
- * 
+ *         buffer = NULL
  */
       __pyx_v_state = NULL;
 
-      /* "bz3/backends/cython/_bz3.pyx":297
+      /* "bz3/backends/cython/_bz3.pyx":311
  *         bz3_free(state)
  *         state = NULL
  *         PyMem_Free(buffer)             # <<<<<<<<<<<<<<
+ *         buffer = NULL
  * 
- * cpdef inline bint test_file(object input, bint should_raise = False) except? 0:
  */
       PyMem_Free(__pyx_v_buffer);
+
+      /* "bz3/backends/cython/_bz3.pyx":312
+ *         state = NULL
+ *         PyMem_Free(buffer)
+ *         buffer = NULL             # <<<<<<<<<<<<<<
+ * 
+ * def recover_file(object input, object output):
+ */
+      __pyx_v_buffer = NULL;
       goto __pyx_L14;
     }
     __pyx_L13_error:;
     /*exception exit:*/{
       __Pyx_PyThreadState_declare
       __Pyx_PyThreadState_assign
       __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
@@ -7078,81 +7374,90 @@
       __Pyx_XGOTREF(__pyx_t_12);
       __Pyx_XGOTREF(__pyx_t_13);
       __Pyx_XGOTREF(__pyx_t_14);
       __Pyx_XGOTREF(__pyx_t_15);
       __pyx_t_7 = __pyx_lineno; __pyx_t_8 = __pyx_clineno; __pyx_t_9 = __pyx_filename;
       {
 
-        /* "bz3/backends/cython/_bz3.pyx":294
+        /* "bz3/backends/cython/_bz3.pyx":308
  *             output.flush()
  *     finally:
  *         output.flush()             # <<<<<<<<<<<<<<
  *         bz3_free(state)
  *         state = NULL
  */
-        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_flush); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 294, __pyx_L27_error)
+        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_flush); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 308, __pyx_L30_error)
         __Pyx_GOTREF(__pyx_t_3);
         __pyx_t_4 = NULL;
         if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
           __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
           if (likely(__pyx_t_4)) {
             PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
             __Pyx_INCREF(__pyx_t_4);
             __Pyx_INCREF(function);
             __Pyx_DECREF_SET(__pyx_t_3, function);
           }
         }
         __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
         __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 294, __pyx_L27_error)
+        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 308, __pyx_L30_error)
         __Pyx_GOTREF(__pyx_t_2);
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
         __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-        /* "bz3/backends/cython/_bz3.pyx":295
+        /* "bz3/backends/cython/_bz3.pyx":309
  *     finally:
  *         output.flush()
  *         bz3_free(state)             # <<<<<<<<<<<<<<
  *         state = NULL
  *         PyMem_Free(buffer)
  */
         bz3_free(__pyx_v_state);
 
-        /* "bz3/backends/cython/_bz3.pyx":296
+        /* "bz3/backends/cython/_bz3.pyx":310
  *         output.flush()
  *         bz3_free(state)
  *         state = NULL             # <<<<<<<<<<<<<<
  *         PyMem_Free(buffer)
- * 
+ *         buffer = NULL
  */
         __pyx_v_state = NULL;
 
-        /* "bz3/backends/cython/_bz3.pyx":297
+        /* "bz3/backends/cython/_bz3.pyx":311
  *         bz3_free(state)
  *         state = NULL
  *         PyMem_Free(buffer)             # <<<<<<<<<<<<<<
+ *         buffer = NULL
  * 
- * cpdef inline bint test_file(object input, bint should_raise = False) except? 0:
  */
         PyMem_Free(__pyx_v_buffer);
+
+        /* "bz3/backends/cython/_bz3.pyx":312
+ *         state = NULL
+ *         PyMem_Free(buffer)
+ *         buffer = NULL             # <<<<<<<<<<<<<<
+ * 
+ * def recover_file(object input, object output):
+ */
+        __pyx_v_buffer = NULL;
       }
       if (PY_MAJOR_VERSION >= 3) {
         __Pyx_XGIVEREF(__pyx_t_13);
         __Pyx_XGIVEREF(__pyx_t_14);
         __Pyx_XGIVEREF(__pyx_t_15);
         __Pyx_ExceptionReset(__pyx_t_13, __pyx_t_14, __pyx_t_15);
       }
       __Pyx_XGIVEREF(__pyx_t_10);
       __Pyx_XGIVEREF(__pyx_t_11);
       __Pyx_XGIVEREF(__pyx_t_12);
       __Pyx_ErrRestore(__pyx_t_10, __pyx_t_11, __pyx_t_12);
       __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
       __pyx_lineno = __pyx_t_7; __pyx_clineno = __pyx_t_8; __pyx_filename = __pyx_t_9;
       goto __pyx_L1_error;
-      __pyx_L27_error:;
+      __pyx_L30_error:;
       if (PY_MAJOR_VERSION >= 3) {
         __Pyx_XGIVEREF(__pyx_t_13);
         __Pyx_XGIVEREF(__pyx_t_14);
         __Pyx_XGIVEREF(__pyx_t_15);
         __Pyx_ExceptionReset(__pyx_t_13, __pyx_t_14, __pyx_t_15);
       }
       __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
@@ -7160,16 +7465,16 @@
       __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
       __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
       goto __pyx_L1_error;
     }
     __pyx_L14:;
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":248
- *         PyMem_Free(buffer)
+  /* "bz3/backends/cython/_bz3.pyx":260
+ *         buffer = NULL
  * 
  * def decompress_file(object input, object output):             # <<<<<<<<<<<<<<
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  */
 
   /* function exit code */
@@ -7185,23 +7490,1031 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_data);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":299
+/* "bz3/backends/cython/_bz3.pyx":314
+ *         buffer = NULL
+ * 
+ * def recover_file(object input, object output):             # <<<<<<<<<<<<<<
+ *     if not PyFile_Check(input):
+ *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_5recover_file(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3bz3_8backends_6cython_4_bz3_4recover_file[] = "recover_file(input, output)";
+static PyMethodDef __pyx_mdef_3bz3_8backends_6cython_4_bz3_5recover_file = {"recover_file", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3bz3_8backends_6cython_4_bz3_5recover_file, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3bz3_8backends_6cython_4_bz3_4recover_file};
+static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_5recover_file(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyObject *__pyx_v_input = 0;
+  PyObject *__pyx_v_output = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("recover_file (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_input,&__pyx_n_s_output,0};
+    PyObject* values[2] = {0,0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_input)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_output)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("recover_file", 1, 2, 2, 1); __PYX_ERR(0, 314, __pyx_L3_error)
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "recover_file") < 0)) __PYX_ERR(0, 314, __pyx_L3_error)
+      }
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+    }
+    __pyx_v_input = values[0];
+    __pyx_v_output = values[1];
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("recover_file", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 314, __pyx_L3_error)
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("bz3.backends.cython._bz3.recover_file", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3bz3_8backends_6cython_4_bz3_4recover_file(__pyx_self, __pyx_v_input, __pyx_v_output);
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_4recover_file(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_input, PyObject *__pyx_v_output) {
+  PyObject *__pyx_v_data = 0;
+  int32_t __pyx_v_block_size;
+  struct bz3_state *__pyx_v_state;
+  uint8_t *__pyx_v_buffer;
+  int32_t __pyx_v_new_size;
+  int32_t __pyx_v_old_size;
+  int32_t __pyx_v_code;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_5;
+  PyObject *__pyx_t_6 = NULL;
+  int __pyx_t_7;
+  int __pyx_t_8;
+  char const *__pyx_t_9;
+  PyObject *__pyx_t_10 = NULL;
+  PyObject *__pyx_t_11 = NULL;
+  PyObject *__pyx_t_12 = NULL;
+  PyObject *__pyx_t_13 = NULL;
+  PyObject *__pyx_t_14 = NULL;
+  PyObject *__pyx_t_15 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("recover_file", 0);
+
+  /* "bz3/backends/cython/_bz3.pyx":315
+ * 
+ * def recover_file(object input, object output):
+ *     if not PyFile_Check(input):             # <<<<<<<<<<<<<<
+ *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
+ *     if not PyFile_Check(output):
+ */
+  __pyx_t_1 = ((!(__pyx_f_3bz3_8backends_6cython_4_bz3_PyFile_Check(__pyx_v_input) != 0)) != 0);
+  if (unlikely(__pyx_t_1)) {
+
+    /* "bz3/backends/cython/_bz3.pyx":316
+ * def recover_file(object input, object output):
+ *     if not PyFile_Check(input):
+ *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)             # <<<<<<<<<<<<<<
+ *     if not PyFile_Check(output):
+ *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
+ */
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_input)), __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 316, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_input_except_a_file_like_object, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 316, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 316, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __PYX_ERR(0, 316, __pyx_L1_error)
+
+    /* "bz3/backends/cython/_bz3.pyx":315
+ * 
+ * def recover_file(object input, object output):
+ *     if not PyFile_Check(input):             # <<<<<<<<<<<<<<
+ *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
+ *     if not PyFile_Check(output):
+ */
+  }
+
+  /* "bz3/backends/cython/_bz3.pyx":317
+ *     if not PyFile_Check(input):
+ *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
+ *     if not PyFile_Check(output):             # <<<<<<<<<<<<<<
+ *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
+ *     cdef bytes data
+ */
+  __pyx_t_1 = ((!(__pyx_f_3bz3_8backends_6cython_4_bz3_PyFile_Check(__pyx_v_output) != 0)) != 0);
+  if (unlikely(__pyx_t_1)) {
+
+    /* "bz3/backends/cython/_bz3.pyx":318
+ *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
+ *     if not PyFile_Check(output):
+ *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)             # <<<<<<<<<<<<<<
+ *     cdef bytes data
+ *     cdef int32_t block_size
+ */
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_output)), __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 318, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_output_except_a_file_like_object, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 318, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 318, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __PYX_ERR(0, 318, __pyx_L1_error)
+
+    /* "bz3/backends/cython/_bz3.pyx":317
+ *     if not PyFile_Check(input):
+ *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
+ *     if not PyFile_Check(output):             # <<<<<<<<<<<<<<
+ *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
+ *     cdef bytes data
+ */
+  }
+
+  /* "bz3/backends/cython/_bz3.pyx":321
+ *     cdef bytes data
+ *     cdef int32_t block_size
+ *     data = input.read(9) # magic and block_size type: bytes len = 9             # <<<<<<<<<<<<<<
+ *     if PyBytes_GET_SIZE(data) < 9:
+ *         raise ValueError("Invalid file. Reason: Smaller than magic header")
+ */
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 321, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_4)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_4);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+    }
+  }
+  __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_int_9) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_int_9);
+  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 321, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 321, __pyx_L1_error)
+  __pyx_v_data = ((PyObject*)__pyx_t_2);
+  __pyx_t_2 = 0;
+
+  /* "bz3/backends/cython/_bz3.pyx":322
+ *     cdef int32_t block_size
+ *     data = input.read(9) # magic and block_size type: bytes len = 9
+ *     if PyBytes_GET_SIZE(data) < 9:             # <<<<<<<<<<<<<<
+ *         raise ValueError("Invalid file. Reason: Smaller than magic header")
+ *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:
+ */
+  __pyx_t_1 = ((PyBytes_GET_SIZE(__pyx_v_data) < 9) != 0);
+  if (unlikely(__pyx_t_1)) {
+
+    /* "bz3/backends/cython/_bz3.pyx":323
+ *     data = input.read(9) # magic and block_size type: bytes len = 9
+ *     if PyBytes_GET_SIZE(data) < 9:
+ *         raise ValueError("Invalid file. Reason: Smaller than magic header")             # <<<<<<<<<<<<<<
+ *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:
+ *         raise ValueError("Invalid signature")
+ */
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 323, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __PYX_ERR(0, 323, __pyx_L1_error)
+
+    /* "bz3/backends/cython/_bz3.pyx":322
+ *     cdef int32_t block_size
+ *     data = input.read(9) # magic and block_size type: bytes len = 9
+ *     if PyBytes_GET_SIZE(data) < 9:             # <<<<<<<<<<<<<<
+ *         raise ValueError("Invalid file. Reason: Smaller than magic header")
+ *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:
+ */
+  }
+
+  /* "bz3/backends/cython/_bz3.pyx":324
+ *     if PyBytes_GET_SIZE(data) < 9:
+ *         raise ValueError("Invalid file. Reason: Smaller than magic header")
+ *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:             # <<<<<<<<<<<<<<
+ *         raise ValueError("Invalid signature")
+ *     block_size = read_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(data)[5]))
+ */
+  __pyx_t_1 = ((strncmp(PyBytes_AS_STRING(__pyx_v_data), __pyx_v_3bz3_8backends_6cython_4_bz3_magic, 5) != 0) != 0);
+  if (unlikely(__pyx_t_1)) {
+
+    /* "bz3/backends/cython/_bz3.pyx":325
+ *         raise ValueError("Invalid file. Reason: Smaller than magic header")
+ *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:
+ *         raise ValueError("Invalid signature")             # <<<<<<<<<<<<<<
+ *     block_size = read_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(data)[5]))
+ *     if block_size < KiB(65) or block_size > MiB(511):
+ */
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 325, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __PYX_ERR(0, 325, __pyx_L1_error)
+
+    /* "bz3/backends/cython/_bz3.pyx":324
+ *     if PyBytes_GET_SIZE(data) < 9:
+ *         raise ValueError("Invalid file. Reason: Smaller than magic header")
+ *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:             # <<<<<<<<<<<<<<
+ *         raise ValueError("Invalid signature")
+ *     block_size = read_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(data)[5]))
+ */
+  }
+
+  /* "bz3/backends/cython/_bz3.pyx":326
+ *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:
+ *         raise ValueError("Invalid signature")
+ *     block_size = read_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(data)[5]))             # <<<<<<<<<<<<<<
+ *     if block_size < KiB(65) or block_size > MiB(511):
+ *         raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
+ */
+  __pyx_v_block_size = read_neutral_s32(((uint8_t *)(&(PyBytes_AS_STRING(__pyx_v_data)[5]))));
+
+  /* "bz3/backends/cython/_bz3.pyx":327
+ *         raise ValueError("Invalid signature")
+ *     block_size = read_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(data)[5]))
+ *     if block_size < KiB(65) or block_size > MiB(511):             # <<<<<<<<<<<<<<
+ *         raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
+ *     cdef bz3_state *state = bz3_new(block_size)
+ */
+  __pyx_t_5 = ((__pyx_v_block_size < KiB(65)) != 0);
+  if (!__pyx_t_5) {
+  } else {
+    __pyx_t_1 = __pyx_t_5;
+    goto __pyx_L8_bool_binop_done;
+  }
+  __pyx_t_5 = ((__pyx_v_block_size > MiB(0x1FF)) != 0);
+  __pyx_t_1 = __pyx_t_5;
+  __pyx_L8_bool_binop_done:;
+  if (unlikely(__pyx_t_1)) {
+
+    /* "bz3/backends/cython/_bz3.pyx":328
+ *     block_size = read_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(data)[5]))
+ *     if block_size < KiB(65) or block_size > MiB(511):
+ *         raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")             # <<<<<<<<<<<<<<
+ *     cdef bz3_state *state = bz3_new(block_size)
+ *     if state == NULL:
+ */
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 328, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __PYX_ERR(0, 328, __pyx_L1_error)
+
+    /* "bz3/backends/cython/_bz3.pyx":327
+ *         raise ValueError("Invalid signature")
+ *     block_size = read_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(data)[5]))
+ *     if block_size < KiB(65) or block_size > MiB(511):             # <<<<<<<<<<<<<<
+ *         raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
+ *     cdef bz3_state *state = bz3_new(block_size)
+ */
+  }
+
+  /* "bz3/backends/cython/_bz3.pyx":329
+ *     if block_size < KiB(65) or block_size > MiB(511):
+ *         raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
+ *     cdef bz3_state *state = bz3_new(block_size)             # <<<<<<<<<<<<<<
+ *     if state == NULL:
+ *         raise MemoryError("Failed to create a block encoder state")
+ */
+  __pyx_v_state = bz3_new(__pyx_v_block_size);
+
+  /* "bz3/backends/cython/_bz3.pyx":330
+ *         raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
+ *     cdef bz3_state *state = bz3_new(block_size)
+ *     if state == NULL:             # <<<<<<<<<<<<<<
+ *         raise MemoryError("Failed to create a block encoder state")
+ *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
+ */
+  __pyx_t_1 = ((__pyx_v_state == NULL) != 0);
+  if (unlikely(__pyx_t_1)) {
+
+    /* "bz3/backends/cython/_bz3.pyx":331
+ *     cdef bz3_state *state = bz3_new(block_size)
+ *     if state == NULL:
+ *         raise MemoryError("Failed to create a block encoder state")             # <<<<<<<<<<<<<<
+ *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
+ *     if buffer == NULL:
+ */
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 331, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __PYX_ERR(0, 331, __pyx_L1_error)
+
+    /* "bz3/backends/cython/_bz3.pyx":330
+ *         raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
+ *     cdef bz3_state *state = bz3_new(block_size)
+ *     if state == NULL:             # <<<<<<<<<<<<<<
+ *         raise MemoryError("Failed to create a block encoder state")
+ *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
+ */
+  }
+
+  /* "bz3/backends/cython/_bz3.pyx":332
+ *     if state == NULL:
+ *         raise MemoryError("Failed to create a block encoder state")
+ *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))             # <<<<<<<<<<<<<<
+ *     if buffer == NULL:
+ *         bz3_free(state)
+ */
+  __pyx_v_buffer = ((uint8_t *)PyMem_Malloc(bz3_bound(__pyx_v_block_size)));
+
+  /* "bz3/backends/cython/_bz3.pyx":333
+ *         raise MemoryError("Failed to create a block encoder state")
+ *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
+ *     if buffer == NULL:             # <<<<<<<<<<<<<<
+ *         bz3_free(state)
+ *         state = NULL
+ */
+  __pyx_t_1 = ((__pyx_v_buffer == NULL) != 0);
+  if (unlikely(__pyx_t_1)) {
+
+    /* "bz3/backends/cython/_bz3.pyx":334
+ *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
+ *     if buffer == NULL:
+ *         bz3_free(state)             # <<<<<<<<<<<<<<
+ *         state = NULL
+ *         raise MemoryError("Failed to allocate memory")
+ */
+    bz3_free(__pyx_v_state);
+
+    /* "bz3/backends/cython/_bz3.pyx":335
+ *     if buffer == NULL:
+ *         bz3_free(state)
+ *         state = NULL             # <<<<<<<<<<<<<<
+ *         raise MemoryError("Failed to allocate memory")
+ *     cdef int32_t new_size, old_size, code
+ */
+    __pyx_v_state = NULL;
+
+    /* "bz3/backends/cython/_bz3.pyx":336
+ *         bz3_free(state)
+ *         state = NULL
+ *         raise MemoryError("Failed to allocate memory")             # <<<<<<<<<<<<<<
+ *     cdef int32_t new_size, old_size, code
+ * 
+ */
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 336, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __PYX_ERR(0, 336, __pyx_L1_error)
+
+    /* "bz3/backends/cython/_bz3.pyx":333
+ *         raise MemoryError("Failed to create a block encoder state")
+ *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
+ *     if buffer == NULL:             # <<<<<<<<<<<<<<
+ *         bz3_free(state)
+ *         state = NULL
+ */
+  }
+
+  /* "bz3/backends/cython/_bz3.pyx":339
+ *     cdef int32_t new_size, old_size, code
+ * 
+ *     try:             # <<<<<<<<<<<<<<
+ *         while True:
+ *             data = input.read(4)
+ */
+  /*try:*/ {
+
+    /* "bz3/backends/cython/_bz3.pyx":340
+ * 
+ *     try:
+ *         while True:             # <<<<<<<<<<<<<<
+ *             data = input.read(4)
+ *             if PyBytes_GET_SIZE(data) < 4:
+ */
+    while (1) {
+
+      /* "bz3/backends/cython/_bz3.pyx":341
+ *     try:
+ *         while True:
+ *             data = input.read(4)             # <<<<<<<<<<<<<<
+ *             if PyBytes_GET_SIZE(data) < 4:
+ *                 break
+ */
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 341, __pyx_L13_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_4 = NULL;
+      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+        if (likely(__pyx_t_4)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+          __Pyx_INCREF(__pyx_t_4);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_3, function);
+        }
+      }
+      __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_int_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_int_4);
+      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 341, __pyx_L13_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 341, __pyx_L13_error)
+      __Pyx_DECREF_SET(__pyx_v_data, ((PyObject*)__pyx_t_2));
+      __pyx_t_2 = 0;
+
+      /* "bz3/backends/cython/_bz3.pyx":342
+ *         while True:
+ *             data = input.read(4)
+ *             if PyBytes_GET_SIZE(data) < 4:             # <<<<<<<<<<<<<<
+ *                 break
+ *             new_size = read_neutral_s32(<uint8_t*>PyBytes_AS_STRING(data))
+ */
+      __pyx_t_1 = ((PyBytes_GET_SIZE(__pyx_v_data) < 4) != 0);
+      if (__pyx_t_1) {
+
+        /* "bz3/backends/cython/_bz3.pyx":343
+ *             data = input.read(4)
+ *             if PyBytes_GET_SIZE(data) < 4:
+ *                 break             # <<<<<<<<<<<<<<
+ *             new_size = read_neutral_s32(<uint8_t*>PyBytes_AS_STRING(data))
+ *             data = input.read(4)
+ */
+        goto __pyx_L16_break;
+
+        /* "bz3/backends/cython/_bz3.pyx":342
+ *         while True:
+ *             data = input.read(4)
+ *             if PyBytes_GET_SIZE(data) < 4:             # <<<<<<<<<<<<<<
+ *                 break
+ *             new_size = read_neutral_s32(<uint8_t*>PyBytes_AS_STRING(data))
+ */
+      }
+
+      /* "bz3/backends/cython/_bz3.pyx":344
+ *             if PyBytes_GET_SIZE(data) < 4:
+ *                 break
+ *             new_size = read_neutral_s32(<uint8_t*>PyBytes_AS_STRING(data))             # <<<<<<<<<<<<<<
+ *             data = input.read(4)
+ *             if PyBytes_GET_SIZE(data) < 4:
+ */
+      __pyx_v_new_size = read_neutral_s32(((uint8_t *)PyBytes_AS_STRING(__pyx_v_data)));
+
+      /* "bz3/backends/cython/_bz3.pyx":345
+ *                 break
+ *             new_size = read_neutral_s32(<uint8_t*>PyBytes_AS_STRING(data))
+ *             data = input.read(4)             # <<<<<<<<<<<<<<
+ *             if PyBytes_GET_SIZE(data) < 4:
+ *                 break
+ */
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 345, __pyx_L13_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_4 = NULL;
+      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+        if (likely(__pyx_t_4)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+          __Pyx_INCREF(__pyx_t_4);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_3, function);
+        }
+      }
+      __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_int_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_int_4);
+      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 345, __pyx_L13_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 345, __pyx_L13_error)
+      __Pyx_DECREF_SET(__pyx_v_data, ((PyObject*)__pyx_t_2));
+      __pyx_t_2 = 0;
+
+      /* "bz3/backends/cython/_bz3.pyx":346
+ *             new_size = read_neutral_s32(<uint8_t*>PyBytes_AS_STRING(data))
+ *             data = input.read(4)
+ *             if PyBytes_GET_SIZE(data) < 4:             # <<<<<<<<<<<<<<
+ *                 break
+ *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
+ */
+      __pyx_t_1 = ((PyBytes_GET_SIZE(__pyx_v_data) < 4) != 0);
+      if (__pyx_t_1) {
+
+        /* "bz3/backends/cython/_bz3.pyx":347
+ *             data = input.read(4)
+ *             if PyBytes_GET_SIZE(data) < 4:
+ *                 break             # <<<<<<<<<<<<<<
+ *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
+ *             if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):
+ */
+        goto __pyx_L16_break;
+
+        /* "bz3/backends/cython/_bz3.pyx":346
+ *             new_size = read_neutral_s32(<uint8_t*>PyBytes_AS_STRING(data))
+ *             data = input.read(4)
+ *             if PyBytes_GET_SIZE(data) < 4:             # <<<<<<<<<<<<<<
+ *                 break
+ *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
+ */
+      }
+
+      /* "bz3/backends/cython/_bz3.pyx":348
+ *             if PyBytes_GET_SIZE(data) < 4:
+ *                 break
+ *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))             # <<<<<<<<<<<<<<
+ *             if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):
+ *                 raise ValueError("Failed to decode a block: Inconsistent headers.")
+ */
+      __pyx_v_old_size = read_neutral_s32(((uint8_t *)PyBytes_AS_STRING(__pyx_v_data)));
+
+      /* "bz3/backends/cython/_bz3.pyx":349
+ *                 break
+ *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
+ *             if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):             # <<<<<<<<<<<<<<
+ *                 raise ValueError("Failed to decode a block: Inconsistent headers.")
+ *             data = input.read(new_size) # type: bytes
+ */
+      __pyx_t_5 = ((__pyx_v_old_size > ((int32_t)bz3_bound(__pyx_v_block_size))) != 0);
+      if (!__pyx_t_5) {
+      } else {
+        __pyx_t_1 = __pyx_t_5;
+        goto __pyx_L20_bool_binop_done;
+      }
+      __pyx_t_5 = ((__pyx_v_new_size > ((int32_t)bz3_bound(__pyx_v_block_size))) != 0);
+      __pyx_t_1 = __pyx_t_5;
+      __pyx_L20_bool_binop_done:;
+      if (unlikely(__pyx_t_1)) {
+
+        /* "bz3/backends/cython/_bz3.pyx":350
+ *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
+ *             if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):
+ *                 raise ValueError("Failed to decode a block: Inconsistent headers.")             # <<<<<<<<<<<<<<
+ *             data = input.read(new_size) # type: bytes
+ *             if PyBytes_GET_SIZE(data) < new_size:
+ */
+        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 350, __pyx_L13_error)
+        __Pyx_GOTREF(__pyx_t_2);
+        __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+        __PYX_ERR(0, 350, __pyx_L13_error)
+
+        /* "bz3/backends/cython/_bz3.pyx":349
+ *                 break
+ *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
+ *             if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):             # <<<<<<<<<<<<<<
+ *                 raise ValueError("Failed to decode a block: Inconsistent headers.")
+ *             data = input.read(new_size) # type: bytes
+ */
+      }
+
+      /* "bz3/backends/cython/_bz3.pyx":351
+ *             if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):
+ *                 raise ValueError("Failed to decode a block: Inconsistent headers.")
+ *             data = input.read(new_size) # type: bytes             # <<<<<<<<<<<<<<
+ *             if PyBytes_GET_SIZE(data) < new_size:
+ *                 break
+ */
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 351, __pyx_L13_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_4 = __Pyx_PyInt_From_int32_t(__pyx_v_new_size); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 351, __pyx_L13_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_6 = NULL;
+      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+        __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
+        if (likely(__pyx_t_6)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+          __Pyx_INCREF(__pyx_t_6);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_3, function);
+        }
+      }
+      __pyx_t_2 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_6, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
+      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 351, __pyx_L13_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 351, __pyx_L13_error)
+      __Pyx_DECREF_SET(__pyx_v_data, ((PyObject*)__pyx_t_2));
+      __pyx_t_2 = 0;
+
+      /* "bz3/backends/cython/_bz3.pyx":352
+ *                 raise ValueError("Failed to decode a block: Inconsistent headers.")
+ *             data = input.read(new_size) # type: bytes
+ *             if PyBytes_GET_SIZE(data) < new_size:             # <<<<<<<<<<<<<<
+ *                 break
+ *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
+ */
+      __pyx_t_1 = ((PyBytes_GET_SIZE(__pyx_v_data) < __pyx_v_new_size) != 0);
+      if (__pyx_t_1) {
+
+        /* "bz3/backends/cython/_bz3.pyx":353
+ *             data = input.read(new_size) # type: bytes
+ *             if PyBytes_GET_SIZE(data) < new_size:
+ *                 break             # <<<<<<<<<<<<<<
+ *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
+ *             with nogil:
+ */
+        goto __pyx_L16_break;
+
+        /* "bz3/backends/cython/_bz3.pyx":352
+ *                 raise ValueError("Failed to decode a block: Inconsistent headers.")
+ *             data = input.read(new_size) # type: bytes
+ *             if PyBytes_GET_SIZE(data) < new_size:             # <<<<<<<<<<<<<<
+ *                 break
+ *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
+ */
+      }
+
+      /* "bz3/backends/cython/_bz3.pyx":354
+ *             if PyBytes_GET_SIZE(data) < new_size:
+ *                 break
+ *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)             # <<<<<<<<<<<<<<
+ *             with nogil:
+ *                 code = bz3_decode_block(state, buffer, new_size, old_size)
+ */
+      (void)(memcpy(__pyx_v_buffer, PyBytes_AS_STRING(__pyx_v_data), ((size_t)__pyx_v_new_size)));
+
+      /* "bz3/backends/cython/_bz3.pyx":355
+ *                 break
+ *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 code = bz3_decode_block(state, buffer, new_size, old_size)
+ *             if code == -1:
+ */
+      {
+          #ifdef WITH_THREAD
+          PyThreadState *_save;
+          Py_UNBLOCK_THREADS
+          __Pyx_FastGIL_Remember();
+          #endif
+          /*try:*/ {
+
+            /* "bz3/backends/cython/_bz3.pyx":356
+ *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
+ *             with nogil:
+ *                 code = bz3_decode_block(state, buffer, new_size, old_size)             # <<<<<<<<<<<<<<
+ *             if code == -1:
+ *                 fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(state))
+ */
+            __pyx_v_code = bz3_decode_block(__pyx_v_state, __pyx_v_buffer, __pyx_v_new_size, __pyx_v_old_size);
+          }
+
+          /* "bz3/backends/cython/_bz3.pyx":355
+ *                 break
+ *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
+ *             with nogil:             # <<<<<<<<<<<<<<
+ *                 code = bz3_decode_block(state, buffer, new_size, old_size)
+ *             if code == -1:
+ */
+          /*finally:*/ {
+            /*normal exit:*/{
+              #ifdef WITH_THREAD
+              __Pyx_FastGIL_Forget();
+              Py_BLOCK_THREADS
+              #endif
+              goto __pyx_L27;
+            }
+            __pyx_L27:;
+          }
+      }
+
+      /* "bz3/backends/cython/_bz3.pyx":357
+ *             with nogil:
+ *                 code = bz3_decode_block(state, buffer, new_size, old_size)
+ *             if code == -1:             # <<<<<<<<<<<<<<
+ *                 fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(state))
+ *             output.write(PyBytes_FromStringAndSize(<char*>buffer, old_size))
+ */
+      __pyx_t_1 = ((__pyx_v_code == -1L) != 0);
+      if (__pyx_t_1) {
+
+        /* "bz3/backends/cython/_bz3.pyx":358
+ *                 code = bz3_decode_block(state, buffer, new_size, old_size)
+ *             if code == -1:
+ *                 fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(state))             # <<<<<<<<<<<<<<
+ *             output.write(PyBytes_FromStringAndSize(<char*>buffer, old_size))
+ *             output.flush()
+ */
+        (void)(fprintf(stderr, ((char const *)"Writing invalid block: %s\n"), bz3_strerror(__pyx_v_state)));
+
+        /* "bz3/backends/cython/_bz3.pyx":357
+ *             with nogil:
+ *                 code = bz3_decode_block(state, buffer, new_size, old_size)
+ *             if code == -1:             # <<<<<<<<<<<<<<
+ *                 fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(state))
+ *             output.write(PyBytes_FromStringAndSize(<char*>buffer, old_size))
+ */
+      }
+
+      /* "bz3/backends/cython/_bz3.pyx":359
+ *             if code == -1:
+ *                 fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(state))
+ *             output.write(PyBytes_FromStringAndSize(<char*>buffer, old_size))             # <<<<<<<<<<<<<<
+ *             output.flush()
+ *     finally:
+ */
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_write); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 359, __pyx_L13_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_4 = PyBytes_FromStringAndSize(((char *)__pyx_v_buffer), __pyx_v_old_size); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 359, __pyx_L13_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_6 = NULL;
+      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+        __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
+        if (likely(__pyx_t_6)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+          __Pyx_INCREF(__pyx_t_6);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_3, function);
+        }
+      }
+      __pyx_t_2 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_6, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
+      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 359, __pyx_L13_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+      /* "bz3/backends/cython/_bz3.pyx":360
+ *                 fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(state))
+ *             output.write(PyBytes_FromStringAndSize(<char*>buffer, old_size))
+ *             output.flush()             # <<<<<<<<<<<<<<
+ *     finally:
+ *         output.flush()
+ */
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_flush); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 360, __pyx_L13_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_4 = NULL;
+      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+        if (likely(__pyx_t_4)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+          __Pyx_INCREF(__pyx_t_4);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_3, function);
+        }
+      }
+      __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 360, __pyx_L13_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    }
+    __pyx_L16_break:;
+  }
+
+  /* "bz3/backends/cython/_bz3.pyx":362
+ *             output.flush()
+ *     finally:
+ *         output.flush()             # <<<<<<<<<<<<<<
+ *         bz3_free(state)
+ *         state = NULL
+ */
+  /*finally:*/ {
+    /*normal exit:*/{
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_flush); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 362, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_4 = NULL;
+      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+        if (likely(__pyx_t_4)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+          __Pyx_INCREF(__pyx_t_4);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_3, function);
+        }
+      }
+      __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 362, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+      /* "bz3/backends/cython/_bz3.pyx":363
+ *     finally:
+ *         output.flush()
+ *         bz3_free(state)             # <<<<<<<<<<<<<<
+ *         state = NULL
+ *         PyMem_Free(buffer)
+ */
+      bz3_free(__pyx_v_state);
+
+      /* "bz3/backends/cython/_bz3.pyx":364
+ *         output.flush()
+ *         bz3_free(state)
+ *         state = NULL             # <<<<<<<<<<<<<<
+ *         PyMem_Free(buffer)
+ *         buffer = NULL
+ */
+      __pyx_v_state = NULL;
+
+      /* "bz3/backends/cython/_bz3.pyx":365
+ *         bz3_free(state)
+ *         state = NULL
+ *         PyMem_Free(buffer)             # <<<<<<<<<<<<<<
+ *         buffer = NULL
+ * 
+ */
+      PyMem_Free(__pyx_v_buffer);
+
+      /* "bz3/backends/cython/_bz3.pyx":366
+ *         state = NULL
  *         PyMem_Free(buffer)
+ *         buffer = NULL             # <<<<<<<<<<<<<<
+ * 
+ * cpdef inline bint test_file(object input, bint should_raise = False) except? 0:
+ */
+      __pyx_v_buffer = NULL;
+      goto __pyx_L14;
+    }
+    __pyx_L13_error:;
+    /*exception exit:*/{
+      __Pyx_PyThreadState_declare
+      __Pyx_PyThreadState_assign
+      __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
+      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_13, &__pyx_t_14, &__pyx_t_15);
+      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_10, &__pyx_t_11, &__pyx_t_12) < 0)) __Pyx_ErrFetch(&__pyx_t_10, &__pyx_t_11, &__pyx_t_12);
+      __Pyx_XGOTREF(__pyx_t_10);
+      __Pyx_XGOTREF(__pyx_t_11);
+      __Pyx_XGOTREF(__pyx_t_12);
+      __Pyx_XGOTREF(__pyx_t_13);
+      __Pyx_XGOTREF(__pyx_t_14);
+      __Pyx_XGOTREF(__pyx_t_15);
+      __pyx_t_7 = __pyx_lineno; __pyx_t_8 = __pyx_clineno; __pyx_t_9 = __pyx_filename;
+      {
+
+        /* "bz3/backends/cython/_bz3.pyx":362
+ *             output.flush()
+ *     finally:
+ *         output.flush()             # <<<<<<<<<<<<<<
+ *         bz3_free(state)
+ *         state = NULL
+ */
+        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_flush); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 362, __pyx_L30_error)
+        __Pyx_GOTREF(__pyx_t_3);
+        __pyx_t_4 = NULL;
+        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+          if (likely(__pyx_t_4)) {
+            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+            __Pyx_INCREF(__pyx_t_4);
+            __Pyx_INCREF(function);
+            __Pyx_DECREF_SET(__pyx_t_3, function);
+          }
+        }
+        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 362, __pyx_L30_error)
+        __Pyx_GOTREF(__pyx_t_2);
+        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+        /* "bz3/backends/cython/_bz3.pyx":363
+ *     finally:
+ *         output.flush()
+ *         bz3_free(state)             # <<<<<<<<<<<<<<
+ *         state = NULL
+ *         PyMem_Free(buffer)
+ */
+        bz3_free(__pyx_v_state);
+
+        /* "bz3/backends/cython/_bz3.pyx":364
+ *         output.flush()
+ *         bz3_free(state)
+ *         state = NULL             # <<<<<<<<<<<<<<
+ *         PyMem_Free(buffer)
+ *         buffer = NULL
+ */
+        __pyx_v_state = NULL;
+
+        /* "bz3/backends/cython/_bz3.pyx":365
+ *         bz3_free(state)
+ *         state = NULL
+ *         PyMem_Free(buffer)             # <<<<<<<<<<<<<<
+ *         buffer = NULL
+ * 
+ */
+        PyMem_Free(__pyx_v_buffer);
+
+        /* "bz3/backends/cython/_bz3.pyx":366
+ *         state = NULL
+ *         PyMem_Free(buffer)
+ *         buffer = NULL             # <<<<<<<<<<<<<<
+ * 
+ * cpdef inline bint test_file(object input, bint should_raise = False) except? 0:
+ */
+        __pyx_v_buffer = NULL;
+      }
+      if (PY_MAJOR_VERSION >= 3) {
+        __Pyx_XGIVEREF(__pyx_t_13);
+        __Pyx_XGIVEREF(__pyx_t_14);
+        __Pyx_XGIVEREF(__pyx_t_15);
+        __Pyx_ExceptionReset(__pyx_t_13, __pyx_t_14, __pyx_t_15);
+      }
+      __Pyx_XGIVEREF(__pyx_t_10);
+      __Pyx_XGIVEREF(__pyx_t_11);
+      __Pyx_XGIVEREF(__pyx_t_12);
+      __Pyx_ErrRestore(__pyx_t_10, __pyx_t_11, __pyx_t_12);
+      __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
+      __pyx_lineno = __pyx_t_7; __pyx_clineno = __pyx_t_8; __pyx_filename = __pyx_t_9;
+      goto __pyx_L1_error;
+      __pyx_L30_error:;
+      if (PY_MAJOR_VERSION >= 3) {
+        __Pyx_XGIVEREF(__pyx_t_13);
+        __Pyx_XGIVEREF(__pyx_t_14);
+        __Pyx_XGIVEREF(__pyx_t_15);
+        __Pyx_ExceptionReset(__pyx_t_13, __pyx_t_14, __pyx_t_15);
+      }
+      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
+      __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
+      __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
+      __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
+      goto __pyx_L1_error;
+    }
+    __pyx_L14:;
+  }
+
+  /* "bz3/backends/cython/_bz3.pyx":314
+ *         buffer = NULL
+ * 
+ * def recover_file(object input, object output):             # <<<<<<<<<<<<<<
+ *     if not PyFile_Check(input):
+ *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
+ */
+
+  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_AddTraceback("bz3.backends.cython._bz3.recover_file", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_data);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "bz3/backends/cython/_bz3.pyx":368
+ *         buffer = NULL
  * 
  * cpdef inline bint test_file(object input, bint should_raise = False) except? 0:             # <<<<<<<<<<<<<<
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  */
 
-static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_5test_file(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_7test_file(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static CYTHON_INLINE int __pyx_f_3bz3_8backends_6cython_4_bz3_test_file(PyObject *__pyx_v_input, CYTHON_UNUSED int __pyx_skip_dispatch, struct __pyx_opt_args_3bz3_8backends_6cython_4_bz3_test_file *__pyx_optional_args) {
   int __pyx_v_should_raise = ((int)0);
   PyObject *__pyx_v_data = 0;
   int32_t __pyx_v_block_size;
   struct bz3_state *__pyx_v_state;
   uint8_t *__pyx_v_buffer;
   int32_t __pyx_v_new_size;
@@ -7230,212 +8543,212 @@
   __Pyx_RefNannySetupContext("test_file", 0);
   if (__pyx_optional_args) {
     if (__pyx_optional_args->__pyx_n > 0) {
       __pyx_v_should_raise = __pyx_optional_args->should_raise;
     }
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":300
+  /* "bz3/backends/cython/_bz3.pyx":369
  * 
  * cpdef inline bint test_file(object input, bint should_raise = False) except? 0:
  *     if not PyFile_Check(input):             # <<<<<<<<<<<<<<
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     cdef bytes data
  */
   __pyx_t_1 = ((!(__pyx_f_3bz3_8backends_6cython_4_bz3_PyFile_Check(__pyx_v_input) != 0)) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":301
+    /* "bz3/backends/cython/_bz3.pyx":370
  * cpdef inline bint test_file(object input, bint should_raise = False) except? 0:
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)             # <<<<<<<<<<<<<<
  *     cdef bytes data
  *     cdef int32_t block_size
  */
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_input)), __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 301, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_input)), __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 370, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_input_except_a_file_like_object, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 301, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_input_except_a_file_like_object, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 370, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 301, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 370, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(0, 301, __pyx_L1_error)
+    __PYX_ERR(0, 370, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":300
+    /* "bz3/backends/cython/_bz3.pyx":369
  * 
  * cpdef inline bint test_file(object input, bint should_raise = False) except? 0:
  *     if not PyFile_Check(input):             # <<<<<<<<<<<<<<
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     cdef bytes data
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":304
+  /* "bz3/backends/cython/_bz3.pyx":373
  *     cdef bytes data
  *     cdef int32_t block_size
  *     data = input.read(9)  # magic and block_size type: bytes len = 9             # <<<<<<<<<<<<<<
  *     if PyBytes_GET_SIZE(data) < 9:
  *         if should_raise:
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 304, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 373, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_int_9) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_int_9);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 304, __pyx_L1_error)
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 373, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 304, __pyx_L1_error)
+  if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 373, __pyx_L1_error)
   __pyx_v_data = ((PyObject*)__pyx_t_2);
   __pyx_t_2 = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":305
+  /* "bz3/backends/cython/_bz3.pyx":374
  *     cdef int32_t block_size
  *     data = input.read(9)  # magic and block_size type: bytes len = 9
  *     if PyBytes_GET_SIZE(data) < 9:             # <<<<<<<<<<<<<<
  *         if should_raise:
  *             raise ValueError("Invalid file. Reason: Smaller than magic header")
  */
   __pyx_t_1 = ((PyBytes_GET_SIZE(__pyx_v_data) < 9) != 0);
   if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":306
+    /* "bz3/backends/cython/_bz3.pyx":375
  *     data = input.read(9)  # magic and block_size type: bytes len = 9
  *     if PyBytes_GET_SIZE(data) < 9:
  *         if should_raise:             # <<<<<<<<<<<<<<
  *             raise ValueError("Invalid file. Reason: Smaller than magic header")
  *         return 0
  */
     __pyx_t_1 = (__pyx_v_should_raise != 0);
     if (unlikely(__pyx_t_1)) {
 
-      /* "bz3/backends/cython/_bz3.pyx":307
+      /* "bz3/backends/cython/_bz3.pyx":376
  *     if PyBytes_GET_SIZE(data) < 9:
  *         if should_raise:
  *             raise ValueError("Invalid file. Reason: Smaller than magic header")             # <<<<<<<<<<<<<<
  *         return 0
  *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:
  */
-      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 307, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 376, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_Raise(__pyx_t_2, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-      __PYX_ERR(0, 307, __pyx_L1_error)
+      __PYX_ERR(0, 376, __pyx_L1_error)
 
-      /* "bz3/backends/cython/_bz3.pyx":306
+      /* "bz3/backends/cython/_bz3.pyx":375
  *     data = input.read(9)  # magic and block_size type: bytes len = 9
  *     if PyBytes_GET_SIZE(data) < 9:
  *         if should_raise:             # <<<<<<<<<<<<<<
  *             raise ValueError("Invalid file. Reason: Smaller than magic header")
  *         return 0
  */
     }
 
-    /* "bz3/backends/cython/_bz3.pyx":308
+    /* "bz3/backends/cython/_bz3.pyx":377
  *         if should_raise:
  *             raise ValueError("Invalid file. Reason: Smaller than magic header")
  *         return 0             # <<<<<<<<<<<<<<
  *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:
  *         if should_raise:
  */
     __pyx_r = 0;
     goto __pyx_L0;
 
-    /* "bz3/backends/cython/_bz3.pyx":305
+    /* "bz3/backends/cython/_bz3.pyx":374
  *     cdef int32_t block_size
  *     data = input.read(9)  # magic and block_size type: bytes len = 9
  *     if PyBytes_GET_SIZE(data) < 9:             # <<<<<<<<<<<<<<
  *         if should_raise:
  *             raise ValueError("Invalid file. Reason: Smaller than magic header")
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":309
+  /* "bz3/backends/cython/_bz3.pyx":378
  *             raise ValueError("Invalid file. Reason: Smaller than magic header")
  *         return 0
  *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:             # <<<<<<<<<<<<<<
  *         if should_raise:
  *             raise ValueError("Invalid signature")
  */
   __pyx_t_1 = ((strncmp(PyBytes_AS_STRING(__pyx_v_data), __pyx_v_3bz3_8backends_6cython_4_bz3_magic, 5) != 0) != 0);
   if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":310
+    /* "bz3/backends/cython/_bz3.pyx":379
  *         return 0
  *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:
  *         if should_raise:             # <<<<<<<<<<<<<<
  *             raise ValueError("Invalid signature")
  *         return 0
  */
     __pyx_t_1 = (__pyx_v_should_raise != 0);
     if (unlikely(__pyx_t_1)) {
 
-      /* "bz3/backends/cython/_bz3.pyx":311
+      /* "bz3/backends/cython/_bz3.pyx":380
  *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:
  *         if should_raise:
  *             raise ValueError("Invalid signature")             # <<<<<<<<<<<<<<
  *         return 0
  *     block_size = read_neutral_s32(<uint8_t *> &(PyBytes_AS_STRING(data)[5]))
  */
-      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 311, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 380, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_Raise(__pyx_t_2, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-      __PYX_ERR(0, 311, __pyx_L1_error)
+      __PYX_ERR(0, 380, __pyx_L1_error)
 
-      /* "bz3/backends/cython/_bz3.pyx":310
+      /* "bz3/backends/cython/_bz3.pyx":379
  *         return 0
  *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:
  *         if should_raise:             # <<<<<<<<<<<<<<
  *             raise ValueError("Invalid signature")
  *         return 0
  */
     }
 
-    /* "bz3/backends/cython/_bz3.pyx":312
+    /* "bz3/backends/cython/_bz3.pyx":381
  *         if should_raise:
  *             raise ValueError("Invalid signature")
  *         return 0             # <<<<<<<<<<<<<<
  *     block_size = read_neutral_s32(<uint8_t *> &(PyBytes_AS_STRING(data)[5]))
  *     if block_size < KiB(65) or block_size > MiB(511):
  */
     __pyx_r = 0;
     goto __pyx_L0;
 
-    /* "bz3/backends/cython/_bz3.pyx":309
+    /* "bz3/backends/cython/_bz3.pyx":378
  *             raise ValueError("Invalid file. Reason: Smaller than magic header")
  *         return 0
  *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:             # <<<<<<<<<<<<<<
  *         if should_raise:
  *             raise ValueError("Invalid signature")
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":313
+  /* "bz3/backends/cython/_bz3.pyx":382
  *             raise ValueError("Invalid signature")
  *         return 0
  *     block_size = read_neutral_s32(<uint8_t *> &(PyBytes_AS_STRING(data)[5]))             # <<<<<<<<<<<<<<
  *     if block_size < KiB(65) or block_size > MiB(511):
  *         if should_raise:
  */
   __pyx_v_block_size = read_neutral_s32(((uint8_t *)(&(PyBytes_AS_STRING(__pyx_v_data)[5]))));
 
-  /* "bz3/backends/cython/_bz3.pyx":314
+  /* "bz3/backends/cython/_bz3.pyx":383
  *         return 0
  *     block_size = read_neutral_s32(<uint8_t *> &(PyBytes_AS_STRING(data)[5]))
  *     if block_size < KiB(65) or block_size > MiB(511):             # <<<<<<<<<<<<<<
  *         if should_raise:
  *             raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  */
   __pyx_t_5 = ((__pyx_v_block_size < KiB(65)) != 0);
@@ -7445,506 +8758,575 @@
     goto __pyx_L9_bool_binop_done;
   }
   __pyx_t_5 = ((__pyx_v_block_size > MiB(0x1FF)) != 0);
   __pyx_t_1 = __pyx_t_5;
   __pyx_L9_bool_binop_done:;
   if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":315
+    /* "bz3/backends/cython/_bz3.pyx":384
  *     block_size = read_neutral_s32(<uint8_t *> &(PyBytes_AS_STRING(data)[5]))
  *     if block_size < KiB(65) or block_size > MiB(511):
  *         if should_raise:             # <<<<<<<<<<<<<<
  *             raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  *         return 0
  */
     __pyx_t_1 = (__pyx_v_should_raise != 0);
     if (unlikely(__pyx_t_1)) {
 
-      /* "bz3/backends/cython/_bz3.pyx":316
+      /* "bz3/backends/cython/_bz3.pyx":385
  *     if block_size < KiB(65) or block_size > MiB(511):
  *         if should_raise:
  *             raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")             # <<<<<<<<<<<<<<
  *         return 0
  *     cdef bz3_state *state = bz3_new(block_size)
  */
-      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 316, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 385, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_Raise(__pyx_t_2, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-      __PYX_ERR(0, 316, __pyx_L1_error)
+      __PYX_ERR(0, 385, __pyx_L1_error)
 
-      /* "bz3/backends/cython/_bz3.pyx":315
+      /* "bz3/backends/cython/_bz3.pyx":384
  *     block_size = read_neutral_s32(<uint8_t *> &(PyBytes_AS_STRING(data)[5]))
  *     if block_size < KiB(65) or block_size > MiB(511):
  *         if should_raise:             # <<<<<<<<<<<<<<
  *             raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  *         return 0
  */
     }
 
-    /* "bz3/backends/cython/_bz3.pyx":317
+    /* "bz3/backends/cython/_bz3.pyx":386
  *         if should_raise:
  *             raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  *         return 0             # <<<<<<<<<<<<<<
  *     cdef bz3_state *state = bz3_new(block_size)
  *     if state == NULL:
  */
     __pyx_r = 0;
     goto __pyx_L0;
 
-    /* "bz3/backends/cython/_bz3.pyx":314
+    /* "bz3/backends/cython/_bz3.pyx":383
  *         return 0
  *     block_size = read_neutral_s32(<uint8_t *> &(PyBytes_AS_STRING(data)[5]))
  *     if block_size < KiB(65) or block_size > MiB(511):             # <<<<<<<<<<<<<<
  *         if should_raise:
  *             raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":318
+  /* "bz3/backends/cython/_bz3.pyx":387
  *             raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  *         return 0
  *     cdef bz3_state *state = bz3_new(block_size)             # <<<<<<<<<<<<<<
  *     if state == NULL:
  *         raise MemoryError("Failed to create a block encoder state")
  */
   __pyx_v_state = bz3_new(__pyx_v_block_size);
 
-  /* "bz3/backends/cython/_bz3.pyx":319
+  /* "bz3/backends/cython/_bz3.pyx":388
  *         return 0
  *     cdef bz3_state *state = bz3_new(block_size)
  *     if state == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError("Failed to create a block encoder state")
- *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+ *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  */
   __pyx_t_1 = ((__pyx_v_state == NULL) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":320
+    /* "bz3/backends/cython/_bz3.pyx":389
  *     cdef bz3_state *state = bz3_new(block_size)
  *     if state == NULL:
  *         raise MemoryError("Failed to create a block encoder state")             # <<<<<<<<<<<<<<
- *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+ *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  *     if buffer == NULL:
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 320, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 389, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(0, 320, __pyx_L1_error)
+    __PYX_ERR(0, 389, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":319
+    /* "bz3/backends/cython/_bz3.pyx":388
  *         return 0
  *     cdef bz3_state *state = bz3_new(block_size)
  *     if state == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError("Failed to create a block encoder state")
- *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+ *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":321
+  /* "bz3/backends/cython/_bz3.pyx":390
  *     if state == NULL:
  *         raise MemoryError("Failed to create a block encoder state")
- *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)             # <<<<<<<<<<<<<<
+ *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))             # <<<<<<<<<<<<<<
  *     if buffer == NULL:
  *         bz3_free(state)
  */
-  __pyx_v_buffer = ((uint8_t *)PyMem_Malloc(((__pyx_v_block_size + (((long)__pyx_v_block_size) / 50)) + 32)));
+  __pyx_v_buffer = ((uint8_t *)PyMem_Malloc(bz3_bound(__pyx_v_block_size)));
 
-  /* "bz3/backends/cython/_bz3.pyx":322
+  /* "bz3/backends/cython/_bz3.pyx":391
  *         raise MemoryError("Failed to create a block encoder state")
- *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+ *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  *     if buffer == NULL:             # <<<<<<<<<<<<<<
  *         bz3_free(state)
  *         state = NULL
  */
   __pyx_t_1 = ((__pyx_v_buffer == NULL) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":323
- *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+    /* "bz3/backends/cython/_bz3.pyx":392
+ *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  *     if buffer == NULL:
  *         bz3_free(state)             # <<<<<<<<<<<<<<
  *         state = NULL
  *         raise MemoryError("Failed to allocate memory")
  */
     bz3_free(__pyx_v_state);
 
-    /* "bz3/backends/cython/_bz3.pyx":324
+    /* "bz3/backends/cython/_bz3.pyx":393
  *     if buffer == NULL:
  *         bz3_free(state)
  *         state = NULL             # <<<<<<<<<<<<<<
  *         raise MemoryError("Failed to allocate memory")
  *     cdef int32_t new_size, old_size, code
  */
     __pyx_v_state = NULL;
 
-    /* "bz3/backends/cython/_bz3.pyx":325
+    /* "bz3/backends/cython/_bz3.pyx":394
  *         bz3_free(state)
  *         state = NULL
  *         raise MemoryError("Failed to allocate memory")             # <<<<<<<<<<<<<<
  *     cdef int32_t new_size, old_size, code
  * 
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 325, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 394, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(0, 325, __pyx_L1_error)
+    __PYX_ERR(0, 394, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":322
+    /* "bz3/backends/cython/_bz3.pyx":391
  *         raise MemoryError("Failed to create a block encoder state")
- *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+ *     cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  *     if buffer == NULL:             # <<<<<<<<<<<<<<
  *         bz3_free(state)
  *         state = NULL
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":328
+  /* "bz3/backends/cython/_bz3.pyx":397
  *     cdef int32_t new_size, old_size, code
  * 
  *     try:             # <<<<<<<<<<<<<<
  *         while True:
  *             data = input.read(4)
  */
   /*try:*/ {
 
-    /* "bz3/backends/cython/_bz3.pyx":329
+    /* "bz3/backends/cython/_bz3.pyx":398
  * 
  *     try:
  *         while True:             # <<<<<<<<<<<<<<
  *             data = input.read(4)
  *             if PyBytes_GET_SIZE(data) < 4:
  */
     while (1) {
 
-      /* "bz3/backends/cython/_bz3.pyx":330
+      /* "bz3/backends/cython/_bz3.pyx":399
  *     try:
  *         while True:
  *             data = input.read(4)             # <<<<<<<<<<<<<<
  *             if PyBytes_GET_SIZE(data) < 4:
  *                 break
  */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 330, __pyx_L15_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 399, __pyx_L15_error)
       __Pyx_GOTREF(__pyx_t_3);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_3, function);
         }
       }
       __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_int_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_int_4);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 330, __pyx_L15_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 399, __pyx_L15_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 330, __pyx_L15_error)
+      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 399, __pyx_L15_error)
       __Pyx_DECREF_SET(__pyx_v_data, ((PyObject*)__pyx_t_2));
       __pyx_t_2 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":331
+      /* "bz3/backends/cython/_bz3.pyx":400
  *         while True:
  *             data = input.read(4)
  *             if PyBytes_GET_SIZE(data) < 4:             # <<<<<<<<<<<<<<
  *                 break
  *             new_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
  */
       __pyx_t_1 = ((PyBytes_GET_SIZE(__pyx_v_data) < 4) != 0);
       if (__pyx_t_1) {
 
-        /* "bz3/backends/cython/_bz3.pyx":332
+        /* "bz3/backends/cython/_bz3.pyx":401
  *             data = input.read(4)
  *             if PyBytes_GET_SIZE(data) < 4:
  *                 break             # <<<<<<<<<<<<<<
  *             new_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
  *             data = input.read(4)
  */
         goto __pyx_L18_break;
 
-        /* "bz3/backends/cython/_bz3.pyx":331
+        /* "bz3/backends/cython/_bz3.pyx":400
  *         while True:
  *             data = input.read(4)
  *             if PyBytes_GET_SIZE(data) < 4:             # <<<<<<<<<<<<<<
  *                 break
  *             new_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
  */
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":333
+      /* "bz3/backends/cython/_bz3.pyx":402
  *             if PyBytes_GET_SIZE(data) < 4:
  *                 break
  *             new_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))             # <<<<<<<<<<<<<<
  *             data = input.read(4)
  *             if PyBytes_GET_SIZE(data) < 4:
  */
       __pyx_v_new_size = read_neutral_s32(((uint8_t *)PyBytes_AS_STRING(__pyx_v_data)));
 
-      /* "bz3/backends/cython/_bz3.pyx":334
+      /* "bz3/backends/cython/_bz3.pyx":403
  *                 break
  *             new_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
  *             data = input.read(4)             # <<<<<<<<<<<<<<
  *             if PyBytes_GET_SIZE(data) < 4:
  *                 break
  */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 334, __pyx_L15_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 403, __pyx_L15_error)
       __Pyx_GOTREF(__pyx_t_3);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_3, function);
         }
       }
       __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_int_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_int_4);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 334, __pyx_L15_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 403, __pyx_L15_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 334, __pyx_L15_error)
+      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 403, __pyx_L15_error)
       __Pyx_DECREF_SET(__pyx_v_data, ((PyObject*)__pyx_t_2));
       __pyx_t_2 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":335
+      /* "bz3/backends/cython/_bz3.pyx":404
  *             new_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
  *             data = input.read(4)
  *             if PyBytes_GET_SIZE(data) < 4:             # <<<<<<<<<<<<<<
  *                 break
  *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
  */
       __pyx_t_1 = ((PyBytes_GET_SIZE(__pyx_v_data) < 4) != 0);
       if (__pyx_t_1) {
 
-        /* "bz3/backends/cython/_bz3.pyx":336
+        /* "bz3/backends/cython/_bz3.pyx":405
  *             data = input.read(4)
  *             if PyBytes_GET_SIZE(data) < 4:
  *                 break             # <<<<<<<<<<<<<<
  *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
- *             data = input.read(new_size)  # type: bytes
+ *             if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):
  */
         goto __pyx_L18_break;
 
-        /* "bz3/backends/cython/_bz3.pyx":335
+        /* "bz3/backends/cython/_bz3.pyx":404
  *             new_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
  *             data = input.read(4)
  *             if PyBytes_GET_SIZE(data) < 4:             # <<<<<<<<<<<<<<
  *                 break
  *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
  */
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":337
+      /* "bz3/backends/cython/_bz3.pyx":406
  *             if PyBytes_GET_SIZE(data) < 4:
  *                 break
  *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))             # <<<<<<<<<<<<<<
+ *             if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):
+ *                 if should_raise:
+ */
+      __pyx_v_old_size = read_neutral_s32(((uint8_t *)PyBytes_AS_STRING(__pyx_v_data)));
+
+      /* "bz3/backends/cython/_bz3.pyx":407
+ *                 break
+ *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
+ *             if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):             # <<<<<<<<<<<<<<
+ *                 if should_raise:
+ *                     raise ValueError("Failed to decode a block: Inconsistent headers.")
+ */
+      __pyx_t_5 = ((__pyx_v_old_size > ((int32_t)bz3_bound(__pyx_v_block_size))) != 0);
+      if (!__pyx_t_5) {
+      } else {
+        __pyx_t_1 = __pyx_t_5;
+        goto __pyx_L22_bool_binop_done;
+      }
+      __pyx_t_5 = ((__pyx_v_new_size > ((int32_t)bz3_bound(__pyx_v_block_size))) != 0);
+      __pyx_t_1 = __pyx_t_5;
+      __pyx_L22_bool_binop_done:;
+      if (__pyx_t_1) {
+
+        /* "bz3/backends/cython/_bz3.pyx":408
+ *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
+ *             if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):
+ *                 if should_raise:             # <<<<<<<<<<<<<<
+ *                     raise ValueError("Failed to decode a block: Inconsistent headers.")
+ *                 return 0
+ */
+        __pyx_t_1 = (__pyx_v_should_raise != 0);
+        if (unlikely(__pyx_t_1)) {
+
+          /* "bz3/backends/cython/_bz3.pyx":409
+ *             if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):
+ *                 if should_raise:
+ *                     raise ValueError("Failed to decode a block: Inconsistent headers.")             # <<<<<<<<<<<<<<
+ *                 return 0
+ *             data = input.read(new_size)  # type: bytes
+ */
+          __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 409, __pyx_L15_error)
+          __Pyx_GOTREF(__pyx_t_2);
+          __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+          __PYX_ERR(0, 409, __pyx_L15_error)
+
+          /* "bz3/backends/cython/_bz3.pyx":408
+ *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
+ *             if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):
+ *                 if should_raise:             # <<<<<<<<<<<<<<
+ *                     raise ValueError("Failed to decode a block: Inconsistent headers.")
+ *                 return 0
+ */
+        }
+
+        /* "bz3/backends/cython/_bz3.pyx":410
+ *                 if should_raise:
+ *                     raise ValueError("Failed to decode a block: Inconsistent headers.")
+ *                 return 0             # <<<<<<<<<<<<<<
  *             data = input.read(new_size)  # type: bytes
  *             if PyBytes_GET_SIZE(data) < new_size:
  */
-      __pyx_v_old_size = read_neutral_s32(((uint8_t *)PyBytes_AS_STRING(__pyx_v_data)));
+        __pyx_r = 0;
+        goto __pyx_L14_return;
 
-      /* "bz3/backends/cython/_bz3.pyx":338
+        /* "bz3/backends/cython/_bz3.pyx":407
  *                 break
  *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
+ *             if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):             # <<<<<<<<<<<<<<
+ *                 if should_raise:
+ *                     raise ValueError("Failed to decode a block: Inconsistent headers.")
+ */
+      }
+
+      /* "bz3/backends/cython/_bz3.pyx":411
+ *                     raise ValueError("Failed to decode a block: Inconsistent headers.")
+ *                 return 0
  *             data = input.read(new_size)  # type: bytes             # <<<<<<<<<<<<<<
  *             if PyBytes_GET_SIZE(data) < new_size:
  *                 break
  */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 338, __pyx_L15_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 411, __pyx_L15_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = __Pyx_PyInt_From_int32_t(__pyx_v_new_size); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 338, __pyx_L15_error)
+      __pyx_t_4 = __Pyx_PyInt_From_int32_t(__pyx_v_new_size); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 411, __pyx_L15_error)
       __Pyx_GOTREF(__pyx_t_4);
       __pyx_t_6 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_6)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
           __Pyx_INCREF(__pyx_t_6);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_3, function);
         }
       }
       __pyx_t_2 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_6, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
       __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 338, __pyx_L15_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 411, __pyx_L15_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 338, __pyx_L15_error)
+      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 411, __pyx_L15_error)
       __Pyx_DECREF_SET(__pyx_v_data, ((PyObject*)__pyx_t_2));
       __pyx_t_2 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":339
- *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
+      /* "bz3/backends/cython/_bz3.pyx":412
+ *                 return 0
  *             data = input.read(new_size)  # type: bytes
  *             if PyBytes_GET_SIZE(data) < new_size:             # <<<<<<<<<<<<<<
  *                 break
  *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
  */
       __pyx_t_1 = ((PyBytes_GET_SIZE(__pyx_v_data) < __pyx_v_new_size) != 0);
       if (__pyx_t_1) {
 
-        /* "bz3/backends/cython/_bz3.pyx":340
+        /* "bz3/backends/cython/_bz3.pyx":413
  *             data = input.read(new_size)  # type: bytes
  *             if PyBytes_GET_SIZE(data) < new_size:
  *                 break             # <<<<<<<<<<<<<<
  *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
  *             with nogil:
  */
         goto __pyx_L18_break;
 
-        /* "bz3/backends/cython/_bz3.pyx":339
- *             old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
+        /* "bz3/backends/cython/_bz3.pyx":412
+ *                 return 0
  *             data = input.read(new_size)  # type: bytes
  *             if PyBytes_GET_SIZE(data) < new_size:             # <<<<<<<<<<<<<<
  *                 break
  *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
  */
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":341
+      /* "bz3/backends/cython/_bz3.pyx":414
  *             if PyBytes_GET_SIZE(data) < new_size:
  *                 break
  *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)             # <<<<<<<<<<<<<<
  *             with nogil:
  *                 code = bz3_decode_block(state, buffer, new_size, old_size)
  */
       (void)(memcpy(__pyx_v_buffer, PyBytes_AS_STRING(__pyx_v_data), ((size_t)__pyx_v_new_size)));
 
-      /* "bz3/backends/cython/_bz3.pyx":342
+      /* "bz3/backends/cython/_bz3.pyx":415
  *                 break
  *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
  *             with nogil:             # <<<<<<<<<<<<<<
  *                 code = bz3_decode_block(state, buffer, new_size, old_size)
  *             # print(f"newsize {new_size} oldsize {old_size}") # todo
  */
       {
           #ifdef WITH_THREAD
           PyThreadState *_save;
           Py_UNBLOCK_THREADS
           __Pyx_FastGIL_Remember();
           #endif
           /*try:*/ {
 
-            /* "bz3/backends/cython/_bz3.pyx":343
+            /* "bz3/backends/cython/_bz3.pyx":416
  *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
  *             with nogil:
  *                 code = bz3_decode_block(state, buffer, new_size, old_size)             # <<<<<<<<<<<<<<
  *             # print(f"newsize {new_size} oldsize {old_size}") # todo
  *             if code == -1:
  */
             __pyx_v_code = bz3_decode_block(__pyx_v_state, __pyx_v_buffer, __pyx_v_new_size, __pyx_v_old_size);
           }
 
-          /* "bz3/backends/cython/_bz3.pyx":342
+          /* "bz3/backends/cython/_bz3.pyx":415
  *                 break
  *             memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
  *             with nogil:             # <<<<<<<<<<<<<<
  *                 code = bz3_decode_block(state, buffer, new_size, old_size)
  *             # print(f"newsize {new_size} oldsize {old_size}") # todo
  */
           /*finally:*/ {
             /*normal exit:*/{
               #ifdef WITH_THREAD
               __Pyx_FastGIL_Forget();
               Py_BLOCK_THREADS
               #endif
-              goto __pyx_L26;
+              goto __pyx_L30;
             }
-            __pyx_L26:;
+            __pyx_L30:;
           }
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":345
+      /* "bz3/backends/cython/_bz3.pyx":418
  *                 code = bz3_decode_block(state, buffer, new_size, old_size)
  *             # print(f"newsize {new_size} oldsize {old_size}") # todo
  *             if code == -1:             # <<<<<<<<<<<<<<
  *                 if should_raise:
  *                     raise ValueError("Failed to decode a block: %s" % bz3_strerror(state))
  */
       __pyx_t_1 = ((__pyx_v_code == -1L) != 0);
       if (__pyx_t_1) {
 
-        /* "bz3/backends/cython/_bz3.pyx":346
+        /* "bz3/backends/cython/_bz3.pyx":419
  *             # print(f"newsize {new_size} oldsize {old_size}") # todo
  *             if code == -1:
  *                 if should_raise:             # <<<<<<<<<<<<<<
  *                     raise ValueError("Failed to decode a block: %s" % bz3_strerror(state))
  *                 return 0
  */
         __pyx_t_1 = (__pyx_v_should_raise != 0);
         if (unlikely(__pyx_t_1)) {
 
-          /* "bz3/backends/cython/_bz3.pyx":347
+          /* "bz3/backends/cython/_bz3.pyx":420
  *             if code == -1:
  *                 if should_raise:
  *                     raise ValueError("Failed to decode a block: %s" % bz3_strerror(state))             # <<<<<<<<<<<<<<
  *                 return 0
  *         return 1
  */
-          __pyx_t_2 = __Pyx_PyBytes_FromString(bz3_strerror(__pyx_v_state)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 347, __pyx_L15_error)
+          __pyx_t_2 = __Pyx_PyBytes_FromString(bz3_strerror(__pyx_v_state)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 420, __pyx_L15_error)
           __Pyx_GOTREF(__pyx_t_2);
-          __pyx_t_3 = PyUnicode_Format(__pyx_kp_u_Failed_to_decode_a_block_s, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 347, __pyx_L15_error)
+          __pyx_t_3 = PyUnicode_Format(__pyx_kp_u_Failed_to_decode_a_block_s, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 420, __pyx_L15_error)
           __Pyx_GOTREF(__pyx_t_3);
           __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-          __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 347, __pyx_L15_error)
+          __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 420, __pyx_L15_error)
           __Pyx_GOTREF(__pyx_t_2);
           __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
           __Pyx_Raise(__pyx_t_2, 0, 0, 0);
           __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-          __PYX_ERR(0, 347, __pyx_L15_error)
+          __PYX_ERR(0, 420, __pyx_L15_error)
 
-          /* "bz3/backends/cython/_bz3.pyx":346
+          /* "bz3/backends/cython/_bz3.pyx":419
  *             # print(f"newsize {new_size} oldsize {old_size}") # todo
  *             if code == -1:
  *                 if should_raise:             # <<<<<<<<<<<<<<
  *                     raise ValueError("Failed to decode a block: %s" % bz3_strerror(state))
  *                 return 0
  */
         }
 
-        /* "bz3/backends/cython/_bz3.pyx":348
+        /* "bz3/backends/cython/_bz3.pyx":421
  *                 if should_raise:
  *                     raise ValueError("Failed to decode a block: %s" % bz3_strerror(state))
  *                 return 0             # <<<<<<<<<<<<<<
  *         return 1
  *     finally:
  */
         __pyx_r = 0;
         goto __pyx_L14_return;
 
-        /* "bz3/backends/cython/_bz3.pyx":345
+        /* "bz3/backends/cython/_bz3.pyx":418
  *                 code = bz3_decode_block(state, buffer, new_size, old_size)
  *             # print(f"newsize {new_size} oldsize {old_size}") # todo
  *             if code == -1:             # <<<<<<<<<<<<<<
  *                 if should_raise:
  *                     raise ValueError("Failed to decode a block: %s" % bz3_strerror(state))
  */
       }
     }
     __pyx_L18_break:;
 
-    /* "bz3/backends/cython/_bz3.pyx":349
+    /* "bz3/backends/cython/_bz3.pyx":422
  *                     raise ValueError("Failed to decode a block: %s" % bz3_strerror(state))
  *                 return 0
  *         return 1             # <<<<<<<<<<<<<<
  *     finally:
  *         bz3_free(state)
  */
     __pyx_r = 1;
     goto __pyx_L14_return;
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":351
+  /* "bz3/backends/cython/_bz3.pyx":424
  *         return 1
  *     finally:
  *         bz3_free(state)             # <<<<<<<<<<<<<<
  *         state = NULL
  *         PyMem_Free(buffer)
  */
   /*finally:*/ {
@@ -7965,31 +9347,40 @@
       __Pyx_XGOTREF(__pyx_t_13);
       __Pyx_XGOTREF(__pyx_t_14);
       __Pyx_XGOTREF(__pyx_t_15);
       __pyx_t_7 = __pyx_lineno; __pyx_t_8 = __pyx_clineno; __pyx_t_9 = __pyx_filename;
       {
         bz3_free(__pyx_v_state);
 
-        /* "bz3/backends/cython/_bz3.pyx":352
+        /* "bz3/backends/cython/_bz3.pyx":425
  *     finally:
  *         bz3_free(state)
  *         state = NULL             # <<<<<<<<<<<<<<
  *         PyMem_Free(buffer)
- * 
+ *         buffer = NULL
  */
         __pyx_v_state = NULL;
 
-        /* "bz3/backends/cython/_bz3.pyx":353
+        /* "bz3/backends/cython/_bz3.pyx":426
  *         bz3_free(state)
  *         state = NULL
  *         PyMem_Free(buffer)             # <<<<<<<<<<<<<<
+ *         buffer = NULL
  * 
- * cpdef inline size_t bound(size_t input_size) nogil:
  */
         PyMem_Free(__pyx_v_buffer);
+
+        /* "bz3/backends/cython/_bz3.pyx":427
+ *         state = NULL
+ *         PyMem_Free(buffer)
+ *         buffer = NULL             # <<<<<<<<<<<<<<
+ * 
+ * cpdef inline size_t bound(size_t input_size) nogil:
+ */
+        __pyx_v_buffer = NULL;
       }
       if (PY_MAJOR_VERSION >= 3) {
         __Pyx_XGIVEREF(__pyx_t_13);
         __Pyx_XGIVEREF(__pyx_t_14);
         __Pyx_XGIVEREF(__pyx_t_15);
         __Pyx_ExceptionReset(__pyx_t_13, __pyx_t_14, __pyx_t_15);
       }
@@ -8000,47 +9391,56 @@
       __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
       __pyx_lineno = __pyx_t_7; __pyx_clineno = __pyx_t_8; __pyx_filename = __pyx_t_9;
       goto __pyx_L1_error;
     }
     __pyx_L14_return: {
       __pyx_t_1 = __pyx_r;
 
-      /* "bz3/backends/cython/_bz3.pyx":351
+      /* "bz3/backends/cython/_bz3.pyx":424
  *         return 1
  *     finally:
  *         bz3_free(state)             # <<<<<<<<<<<<<<
  *         state = NULL
  *         PyMem_Free(buffer)
  */
       bz3_free(__pyx_v_state);
 
-      /* "bz3/backends/cython/_bz3.pyx":352
+      /* "bz3/backends/cython/_bz3.pyx":425
  *     finally:
  *         bz3_free(state)
  *         state = NULL             # <<<<<<<<<<<<<<
  *         PyMem_Free(buffer)
- * 
+ *         buffer = NULL
  */
       __pyx_v_state = NULL;
 
-      /* "bz3/backends/cython/_bz3.pyx":353
+      /* "bz3/backends/cython/_bz3.pyx":426
  *         bz3_free(state)
  *         state = NULL
  *         PyMem_Free(buffer)             # <<<<<<<<<<<<<<
+ *         buffer = NULL
  * 
- * cpdef inline size_t bound(size_t input_size) nogil:
  */
       PyMem_Free(__pyx_v_buffer);
+
+      /* "bz3/backends/cython/_bz3.pyx":427
+ *         state = NULL
+ *         PyMem_Free(buffer)
+ *         buffer = NULL             # <<<<<<<<<<<<<<
+ * 
+ * cpdef inline size_t bound(size_t input_size) nogil:
+ */
+      __pyx_v_buffer = NULL;
       __pyx_r = __pyx_t_1;
       goto __pyx_L0;
     }
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":299
- *         PyMem_Free(buffer)
+  /* "bz3/backends/cython/_bz3.pyx":368
+ *         buffer = NULL
  * 
  * cpdef inline bint test_file(object input, bint should_raise = False) except? 0:             # <<<<<<<<<<<<<<
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  */
 
   /* function exit code */
@@ -8054,17 +9454,17 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_data);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* Python wrapper */
-static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_5test_file(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_3bz3_8backends_6cython_4_bz3_4test_file[] = "test_file(input, bool should_raise=False) -> bool";
-static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_5test_file(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_7test_file(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3bz3_8backends_6cython_4_bz3_6test_file[] = "test_file(input, bool should_raise=False) -> bool";
+static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_7test_file(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_input = 0;
   int __pyx_v_should_raise;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -8092,62 +9492,62 @@
         case  1:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_should_raise);
           if (value) { values[1] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "test_file") < 0)) __PYX_ERR(0, 299, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "test_file") < 0)) __PYX_ERR(0, 368, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     __pyx_v_input = values[0];
     if (values[1]) {
-      __pyx_v_should_raise = __Pyx_PyObject_IsTrue(values[1]); if (unlikely((__pyx_v_should_raise == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 299, __pyx_L3_error)
+      __pyx_v_should_raise = __Pyx_PyObject_IsTrue(values[1]); if (unlikely((__pyx_v_should_raise == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 368, __pyx_L3_error)
     } else {
       __pyx_v_should_raise = ((int)0);
     }
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("test_file", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 299, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("test_file", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 368, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("bz3.backends.cython._bz3.test_file", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_3bz3_8backends_6cython_4_bz3_4test_file(__pyx_self, __pyx_v_input, __pyx_v_should_raise);
+  __pyx_r = __pyx_pf_3bz3_8backends_6cython_4_bz3_6test_file(__pyx_self, __pyx_v_input, __pyx_v_should_raise);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_4test_file(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_input, int __pyx_v_should_raise) {
+static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_6test_file(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_input, int __pyx_v_should_raise) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   struct __pyx_opt_args_3bz3_8backends_6cython_4_bz3_test_file __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("test_file", 0);
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_2.__pyx_n = 1;
   __pyx_t_2.should_raise = __pyx_v_should_raise;
-  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_test_file(__pyx_v_input, 0, &__pyx_t_2); if (unlikely(__pyx_t_1 == ((int)0) && PyErr_Occurred())) __PYX_ERR(0, 299, __pyx_L1_error)
-  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 299, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_test_file(__pyx_v_input, 0, &__pyx_t_2); if (unlikely(__pyx_t_1 == ((int)0) && PyErr_Occurred())) __PYX_ERR(0, 368, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 368, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -8156,86 +9556,86 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":355
- *         PyMem_Free(buffer)
+/* "bz3/backends/cython/_bz3.pyx":429
+ *         buffer = NULL
  * 
  * cpdef inline size_t bound(size_t input_size) nogil:             # <<<<<<<<<<<<<<
  *     return bz3_bound(input_size)
  * 
  */
 
-static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_7bound(PyObject *__pyx_self, PyObject *__pyx_arg_input_size); /*proto*/
+static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_9bound(PyObject *__pyx_self, PyObject *__pyx_arg_input_size); /*proto*/
 static CYTHON_INLINE size_t __pyx_f_3bz3_8backends_6cython_4_bz3_bound(size_t __pyx_v_input_size, CYTHON_UNUSED int __pyx_skip_dispatch) {
   size_t __pyx_r;
 
-  /* "bz3/backends/cython/_bz3.pyx":356
+  /* "bz3/backends/cython/_bz3.pyx":430
  * 
  * cpdef inline size_t bound(size_t input_size) nogil:
  *     return bz3_bound(input_size)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = bz3_bound(__pyx_v_input_size);
   goto __pyx_L0;
 
-  /* "bz3/backends/cython/_bz3.pyx":355
- *         PyMem_Free(buffer)
+  /* "bz3/backends/cython/_bz3.pyx":429
+ *         buffer = NULL
  * 
  * cpdef inline size_t bound(size_t input_size) nogil:             # <<<<<<<<<<<<<<
  *     return bz3_bound(input_size)
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
 /* Python wrapper */
-static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_7bound(PyObject *__pyx_self, PyObject *__pyx_arg_input_size); /*proto*/
-static char __pyx_doc_3bz3_8backends_6cython_4_bz3_6bound[] = "bound(size_t input_size) -> size_t";
-static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_7bound(PyObject *__pyx_self, PyObject *__pyx_arg_input_size) {
+static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_9bound(PyObject *__pyx_self, PyObject *__pyx_arg_input_size); /*proto*/
+static char __pyx_doc_3bz3_8backends_6cython_4_bz3_8bound[] = "bound(size_t input_size) -> size_t";
+static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_9bound(PyObject *__pyx_self, PyObject *__pyx_arg_input_size) {
   size_t __pyx_v_input_size;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("bound (wrapper)", 0);
   assert(__pyx_arg_input_size); {
-    __pyx_v_input_size = __Pyx_PyInt_As_size_t(__pyx_arg_input_size); if (unlikely((__pyx_v_input_size == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 355, __pyx_L3_error)
+    __pyx_v_input_size = __Pyx_PyInt_As_size_t(__pyx_arg_input_size); if (unlikely((__pyx_v_input_size == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 429, __pyx_L3_error)
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   __Pyx_AddTraceback("bz3.backends.cython._bz3.bound", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_3bz3_8backends_6cython_4_bz3_6bound(__pyx_self, ((size_t)__pyx_v_input_size));
+  __pyx_r = __pyx_pf_3bz3_8backends_6cython_4_bz3_8bound(__pyx_self, ((size_t)__pyx_v_input_size));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_6bound(CYTHON_UNUSED PyObject *__pyx_self, size_t __pyx_v_input_size) {
+static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_8bound(CYTHON_UNUSED PyObject *__pyx_self, size_t __pyx_v_input_size) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("bound", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_FromSize_t(__pyx_f_3bz3_8backends_6cython_4_bz3_bound(__pyx_v_input_size, 0)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 355, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_FromSize_t(__pyx_f_3bz3_8backends_6cython_4_bz3_bound(__pyx_v_input_size, 0)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 429, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -8244,23 +9644,23 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":359
+/* "bz3/backends/cython/_bz3.pyx":433
  * 
  * 
  * cpdef inline size_t compress_into(const uint8_t[::1] data, uint8_t[::1] out, uint32_t block_size = 1000000) except? 0:             # <<<<<<<<<<<<<<
  *     cdef:
  *         size_t out_size = <size_t>out.shape[0]
  */
 
-static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_9compress_into(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_11compress_into(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static CYTHON_INLINE size_t __pyx_f_3bz3_8backends_6cython_4_bz3_compress_into(__Pyx_memviewslice __pyx_v_data, __Pyx_memviewslice __pyx_v_out, CYTHON_UNUSED int __pyx_skip_dispatch, struct __pyx_opt_args_3bz3_8backends_6cython_4_bz3_compress_into *__pyx_optional_args) {
   uint32_t __pyx_v_block_size = ((uint32_t)0xF4240);
   size_t __pyx_v_out_size;
   int __pyx_v_bzerr;
   size_t __pyx_r;
   __Pyx_RefNannyDeclarations
   Py_ssize_t __pyx_t_1;
@@ -8274,51 +9674,51 @@
   __Pyx_RefNannySetupContext("compress_into", 0);
   if (__pyx_optional_args) {
     if (__pyx_optional_args->__pyx_n > 0) {
       __pyx_v_block_size = __pyx_optional_args->block_size;
     }
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":361
+  /* "bz3/backends/cython/_bz3.pyx":435
  * cpdef inline size_t compress_into(const uint8_t[::1] data, uint8_t[::1] out, uint32_t block_size = 1000000) except? 0:
  *     cdef:
  *         size_t out_size = <size_t>out.shape[0]             # <<<<<<<<<<<<<<
  *         int bzerr
  *     with nogil:
  */
   __pyx_v_out_size = ((size_t)(__pyx_v_out.shape[0]));
 
-  /* "bz3/backends/cython/_bz3.pyx":363
+  /* "bz3/backends/cython/_bz3.pyx":437
  *         size_t out_size = <size_t>out.shape[0]
  *         int bzerr
  *     with nogil:             # <<<<<<<<<<<<<<
  *         bzerr = bz3_compress(block_size, &data[0], &out[0], <size_t>data.shape[0], &out_size)
  *     if bzerr != BZ3_OK:
  */
   {
       #ifdef WITH_THREAD
       PyThreadState *_save;
       Py_UNBLOCK_THREADS
       __Pyx_FastGIL_Remember();
       #endif
       /*try:*/ {
 
-        /* "bz3/backends/cython/_bz3.pyx":364
+        /* "bz3/backends/cython/_bz3.pyx":438
  *         int bzerr
  *     with nogil:
  *         bzerr = bz3_compress(block_size, &data[0], &out[0], <size_t>data.shape[0], &out_size)             # <<<<<<<<<<<<<<
  *     if bzerr != BZ3_OK:
  *         raise ValueError(f"bz3_compress() failed with error code {bzerr}")
  */
         __pyx_t_1 = 0;
         __pyx_t_2 = 0;
         __pyx_v_bzerr = bz3_compress(__pyx_v_block_size, (&(*((uint8_t const  *) ( /* dim=0 */ ((char *) (((uint8_t const  *) __pyx_v_data.data) + __pyx_t_1)) )))), (&(*((uint8_t *) ( /* dim=0 */ ((char *) (((uint8_t *) __pyx_v_out.data) + __pyx_t_2)) )))), ((size_t)(__pyx_v_data.shape[0])), (&__pyx_v_out_size));
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":363
+      /* "bz3/backends/cython/_bz3.pyx":437
  *         size_t out_size = <size_t>out.shape[0]
  *         int bzerr
  *     with nogil:             # <<<<<<<<<<<<<<
  *         bzerr = bz3_compress(block_size, &data[0], &out[0], <size_t>data.shape[0], &out_size)
  *     if bzerr != BZ3_OK:
  */
       /*finally:*/ {
@@ -8329,63 +9729,63 @@
           #endif
           goto __pyx_L5;
         }
         __pyx_L5:;
       }
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":365
+  /* "bz3/backends/cython/_bz3.pyx":439
  *     with nogil:
  *         bzerr = bz3_compress(block_size, &data[0], &out[0], <size_t>data.shape[0], &out_size)
  *     if bzerr != BZ3_OK:             # <<<<<<<<<<<<<<
  *         raise ValueError(f"bz3_compress() failed with error code {bzerr}")
  *     return out_size
  */
   __pyx_t_3 = ((__pyx_v_bzerr != BZ3_OK) != 0);
   if (unlikely(__pyx_t_3)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":366
+    /* "bz3/backends/cython/_bz3.pyx":440
  *         bzerr = bz3_compress(block_size, &data[0], &out[0], <size_t>data.shape[0], &out_size)
  *     if bzerr != BZ3_OK:
  *         raise ValueError(f"bz3_compress() failed with error code {bzerr}")             # <<<<<<<<<<<<<<
  *     return out_size
  * 
  */
-    __pyx_t_4 = __Pyx_PyUnicode_From_int(__pyx_v_bzerr, 0, ' ', 'd'); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 366, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyUnicode_From_int(__pyx_v_bzerr, 0, ' ', 'd'); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 440, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = __Pyx_PyUnicode_Concat(__pyx_kp_u_bz3_compress_failed_with_error_c, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 366, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyUnicode_Concat(__pyx_kp_u_bz3_compress_failed_with_error_c, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 440, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 366, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 440, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_Raise(__pyx_t_4, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __PYX_ERR(0, 366, __pyx_L1_error)
+    __PYX_ERR(0, 440, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":365
+    /* "bz3/backends/cython/_bz3.pyx":439
  *     with nogil:
  *         bzerr = bz3_compress(block_size, &data[0], &out[0], <size_t>data.shape[0], &out_size)
  *     if bzerr != BZ3_OK:             # <<<<<<<<<<<<<<
  *         raise ValueError(f"bz3_compress() failed with error code {bzerr}")
  *     return out_size
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":367
+  /* "bz3/backends/cython/_bz3.pyx":441
  *     if bzerr != BZ3_OK:
  *         raise ValueError(f"bz3_compress() failed with error code {bzerr}")
  *     return out_size             # <<<<<<<<<<<<<<
  * 
  * cpdef inline size_t decompress_into(const uint8_t[::1] data, uint8_t[::1] out) except? 0:
  */
   __pyx_r = __pyx_v_out_size;
   goto __pyx_L0;
 
-  /* "bz3/backends/cython/_bz3.pyx":359
+  /* "bz3/backends/cython/_bz3.pyx":433
  * 
  * 
  * cpdef inline size_t compress_into(const uint8_t[::1] data, uint8_t[::1] out, uint32_t block_size = 1000000) except? 0:             # <<<<<<<<<<<<<<
  *     cdef:
  *         size_t out_size = <size_t>out.shape[0]
  */
 
@@ -8397,17 +9797,17 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* Python wrapper */
-static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_9compress_into(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_3bz3_8backends_6cython_4_bz3_8compress_into[] = "compress_into(const uint8_t[::1] data, uint8_t[::1] out, uint32_t block_size=1000000) -> size_t";
-static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_9compress_into(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_11compress_into(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3bz3_8backends_6cython_4_bz3_10compress_into[] = "compress_into(const uint8_t[::1] data, uint8_t[::1] out, uint32_t block_size=1000000) -> size_t";
+static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_11compress_into(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   __Pyx_memviewslice __pyx_v_data = { 0, 0, { 0 }, { 0 }, { 0 } };
   __Pyx_memviewslice __pyx_v_out = { 0, 0, { 0 }, { 0 }, { 0 } };
   uint32_t __pyx_v_block_size;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
@@ -8434,76 +9834,76 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("compress_into", 0, 2, 3, 1); __PYX_ERR(0, 359, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("compress_into", 0, 2, 3, 1); __PYX_ERR(0, 433, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_block_size);
           if (value) { values[2] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "compress_into") < 0)) __PYX_ERR(0, 359, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "compress_into") < 0)) __PYX_ERR(0, 433, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
-    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t__const__(values[0], 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 359, __pyx_L3_error)
-    __pyx_v_out = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_out.memview)) __PYX_ERR(0, 359, __pyx_L3_error)
+    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t__const__(values[0], 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 433, __pyx_L3_error)
+    __pyx_v_out = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_out.memview)) __PYX_ERR(0, 433, __pyx_L3_error)
     if (values[2]) {
-      __pyx_v_block_size = __Pyx_PyInt_As_uint32_t(values[2]); if (unlikely((__pyx_v_block_size == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 359, __pyx_L3_error)
+      __pyx_v_block_size = __Pyx_PyInt_As_uint32_t(values[2]); if (unlikely((__pyx_v_block_size == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 433, __pyx_L3_error)
     } else {
       __pyx_v_block_size = ((uint32_t)0xF4240);
     }
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("compress_into", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 359, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("compress_into", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 433, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("bz3.backends.cython._bz3.compress_into", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_3bz3_8backends_6cython_4_bz3_8compress_into(__pyx_self, __pyx_v_data, __pyx_v_out, __pyx_v_block_size);
+  __pyx_r = __pyx_pf_3bz3_8backends_6cython_4_bz3_10compress_into(__pyx_self, __pyx_v_data, __pyx_v_out, __pyx_v_block_size);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_8compress_into(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_data, __Pyx_memviewslice __pyx_v_out, uint32_t __pyx_v_block_size) {
+static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_10compress_into(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_data, __Pyx_memviewslice __pyx_v_out, uint32_t __pyx_v_block_size) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   size_t __pyx_t_1;
   struct __pyx_opt_args_3bz3_8backends_6cython_4_bz3_compress_into __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("compress_into", 0);
   __Pyx_XDECREF(__pyx_r);
-  if (unlikely(!__pyx_v_data.memview)) { __Pyx_RaiseUnboundLocalError("data"); __PYX_ERR(0, 359, __pyx_L1_error) }
-  if (unlikely(!__pyx_v_out.memview)) { __Pyx_RaiseUnboundLocalError("out"); __PYX_ERR(0, 359, __pyx_L1_error) }
+  if (unlikely(!__pyx_v_data.memview)) { __Pyx_RaiseUnboundLocalError("data"); __PYX_ERR(0, 433, __pyx_L1_error) }
+  if (unlikely(!__pyx_v_out.memview)) { __Pyx_RaiseUnboundLocalError("out"); __PYX_ERR(0, 433, __pyx_L1_error) }
   __pyx_t_2.__pyx_n = 1;
   __pyx_t_2.block_size = __pyx_v_block_size;
-  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_compress_into(__pyx_v_data, __pyx_v_out, 0, &__pyx_t_2); if (unlikely(__pyx_t_1 == ((size_t)0) && PyErr_Occurred())) __PYX_ERR(0, 359, __pyx_L1_error)
-  __pyx_t_3 = __Pyx_PyInt_FromSize_t(__pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 359, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_compress_into(__pyx_v_data, __pyx_v_out, 0, &__pyx_t_2); if (unlikely(__pyx_t_1 == ((size_t)0) && PyErr_Occurred())) __PYX_ERR(0, 433, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_FromSize_t(__pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 433, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -8514,23 +9914,23 @@
   __PYX_XDEC_MEMVIEW(&__pyx_v_data, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_v_out, 1);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":369
+/* "bz3/backends/cython/_bz3.pyx":443
  *     return out_size
  * 
  * cpdef inline size_t decompress_into(const uint8_t[::1] data, uint8_t[::1] out) except? 0:             # <<<<<<<<<<<<<<
  *     cdef:
  *         size_t out_size = <size_t>out.shape[0]
  */
 
-static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_11decompress_into(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_13decompress_into(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static CYTHON_INLINE size_t __pyx_f_3bz3_8backends_6cython_4_bz3_decompress_into(__Pyx_memviewslice __pyx_v_data, __Pyx_memviewslice __pyx_v_out, CYTHON_UNUSED int __pyx_skip_dispatch) {
   size_t __pyx_v_out_size;
   int __pyx_v_bzerr;
   size_t __pyx_r;
   __Pyx_RefNannyDeclarations
   Py_ssize_t __pyx_t_1;
   Py_ssize_t __pyx_t_2;
@@ -8538,51 +9938,51 @@
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decompress_into", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":371
+  /* "bz3/backends/cython/_bz3.pyx":445
  * cpdef inline size_t decompress_into(const uint8_t[::1] data, uint8_t[::1] out) except? 0:
  *     cdef:
  *         size_t out_size = <size_t>out.shape[0]             # <<<<<<<<<<<<<<
  *         int bzerr
  *     with nogil:
  */
   __pyx_v_out_size = ((size_t)(__pyx_v_out.shape[0]));
 
-  /* "bz3/backends/cython/_bz3.pyx":373
+  /* "bz3/backends/cython/_bz3.pyx":447
  *         size_t out_size = <size_t>out.shape[0]
  *         int bzerr
  *     with nogil:             # <<<<<<<<<<<<<<
  *         bzerr = bz3_decompress(&data[0], &out[0], <size_t>data.shape[0], &out_size)
  *     if bzerr != BZ3_OK:
  */
   {
       #ifdef WITH_THREAD
       PyThreadState *_save;
       Py_UNBLOCK_THREADS
       __Pyx_FastGIL_Remember();
       #endif
       /*try:*/ {
 
-        /* "bz3/backends/cython/_bz3.pyx":374
+        /* "bz3/backends/cython/_bz3.pyx":448
  *         int bzerr
  *     with nogil:
  *         bzerr = bz3_decompress(&data[0], &out[0], <size_t>data.shape[0], &out_size)             # <<<<<<<<<<<<<<
  *     if bzerr != BZ3_OK:
  *         raise ValueError(f"bz3_decompress() failed with error code {bzerr}")
  */
         __pyx_t_1 = 0;
         __pyx_t_2 = 0;
         __pyx_v_bzerr = bz3_decompress((&(*((uint8_t const  *) ( /* dim=0 */ ((char *) (((uint8_t const  *) __pyx_v_data.data) + __pyx_t_1)) )))), (&(*((uint8_t *) ( /* dim=0 */ ((char *) (((uint8_t *) __pyx_v_out.data) + __pyx_t_2)) )))), ((size_t)(__pyx_v_data.shape[0])), (&__pyx_v_out_size));
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":373
+      /* "bz3/backends/cython/_bz3.pyx":447
  *         size_t out_size = <size_t>out.shape[0]
  *         int bzerr
  *     with nogil:             # <<<<<<<<<<<<<<
  *         bzerr = bz3_decompress(&data[0], &out[0], <size_t>data.shape[0], &out_size)
  *     if bzerr != BZ3_OK:
  */
       /*finally:*/ {
@@ -8593,63 +9993,63 @@
           #endif
           goto __pyx_L5;
         }
         __pyx_L5:;
       }
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":375
+  /* "bz3/backends/cython/_bz3.pyx":449
  *     with nogil:
  *         bzerr = bz3_decompress(&data[0], &out[0], <size_t>data.shape[0], &out_size)
  *     if bzerr != BZ3_OK:             # <<<<<<<<<<<<<<
  *         raise ValueError(f"bz3_decompress() failed with error code {bzerr}")
  *     return out_size
  */
   __pyx_t_3 = ((__pyx_v_bzerr != BZ3_OK) != 0);
   if (unlikely(__pyx_t_3)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":376
+    /* "bz3/backends/cython/_bz3.pyx":450
  *         bzerr = bz3_decompress(&data[0], &out[0], <size_t>data.shape[0], &out_size)
  *     if bzerr != BZ3_OK:
  *         raise ValueError(f"bz3_decompress() failed with error code {bzerr}")             # <<<<<<<<<<<<<<
  *     return out_size
  * 
  */
-    __pyx_t_4 = __Pyx_PyUnicode_From_int(__pyx_v_bzerr, 0, ' ', 'd'); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 376, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyUnicode_From_int(__pyx_v_bzerr, 0, ' ', 'd'); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 450, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = __Pyx_PyUnicode_Concat(__pyx_kp_u_bz3_decompress_failed_with_error, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 376, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyUnicode_Concat(__pyx_kp_u_bz3_decompress_failed_with_error, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 450, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 376, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 450, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_Raise(__pyx_t_4, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __PYX_ERR(0, 376, __pyx_L1_error)
+    __PYX_ERR(0, 450, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":375
+    /* "bz3/backends/cython/_bz3.pyx":449
  *     with nogil:
  *         bzerr = bz3_decompress(&data[0], &out[0], <size_t>data.shape[0], &out_size)
  *     if bzerr != BZ3_OK:             # <<<<<<<<<<<<<<
  *         raise ValueError(f"bz3_decompress() failed with error code {bzerr}")
  *     return out_size
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":377
+  /* "bz3/backends/cython/_bz3.pyx":451
  *     if bzerr != BZ3_OK:
  *         raise ValueError(f"bz3_decompress() failed with error code {bzerr}")
  *     return out_size             # <<<<<<<<<<<<<<
  * 
  * cpdef inline str libversion():
  */
   __pyx_r = __pyx_v_out_size;
   goto __pyx_L0;
 
-  /* "bz3/backends/cython/_bz3.pyx":369
+  /* "bz3/backends/cython/_bz3.pyx":443
  *     return out_size
  * 
  * cpdef inline size_t decompress_into(const uint8_t[::1] data, uint8_t[::1] out) except? 0:             # <<<<<<<<<<<<<<
  *     cdef:
  *         size_t out_size = <size_t>out.shape[0]
  */
 
@@ -8661,17 +10061,17 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* Python wrapper */
-static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_11decompress_into(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_3bz3_8backends_6cython_4_bz3_10decompress_into[] = "decompress_into(const uint8_t[::1] data, uint8_t[::1] out) -> size_t";
-static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_11decompress_into(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_13decompress_into(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3bz3_8backends_6cython_4_bz3_12decompress_into[] = "decompress_into(const uint8_t[::1] data, uint8_t[::1] out) -> size_t";
+static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_13decompress_into(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   __Pyx_memviewslice __pyx_v_data = { 0, 0, { 0 }, { 0 }, { 0 } };
   __Pyx_memviewslice __pyx_v_out = { 0, 0, { 0 }, { 0 }, { 0 } };
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -8695,58 +10095,58 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decompress_into", 1, 2, 2, 1); __PYX_ERR(0, 369, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decompress_into", 1, 2, 2, 1); __PYX_ERR(0, 443, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress_into") < 0)) __PYX_ERR(0, 369, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress_into") < 0)) __PYX_ERR(0, 443, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
-    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t__const__(values[0], 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 369, __pyx_L3_error)
-    __pyx_v_out = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_out.memview)) __PYX_ERR(0, 369, __pyx_L3_error)
+    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t__const__(values[0], 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 443, __pyx_L3_error)
+    __pyx_v_out = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_out.memview)) __PYX_ERR(0, 443, __pyx_L3_error)
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decompress_into", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 369, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decompress_into", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 443, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("bz3.backends.cython._bz3.decompress_into", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_3bz3_8backends_6cython_4_bz3_10decompress_into(__pyx_self, __pyx_v_data, __pyx_v_out);
+  __pyx_r = __pyx_pf_3bz3_8backends_6cython_4_bz3_12decompress_into(__pyx_self, __pyx_v_data, __pyx_v_out);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_10decompress_into(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_data, __Pyx_memviewslice __pyx_v_out) {
+static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_12decompress_into(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_data, __Pyx_memviewslice __pyx_v_out) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   size_t __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decompress_into", 0);
   __Pyx_XDECREF(__pyx_r);
-  if (unlikely(!__pyx_v_data.memview)) { __Pyx_RaiseUnboundLocalError("data"); __PYX_ERR(0, 369, __pyx_L1_error) }
-  if (unlikely(!__pyx_v_out.memview)) { __Pyx_RaiseUnboundLocalError("out"); __PYX_ERR(0, 369, __pyx_L1_error) }
-  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_decompress_into(__pyx_v_data, __pyx_v_out, 0); if (unlikely(__pyx_t_1 == ((size_t)0) && PyErr_Occurred())) __PYX_ERR(0, 369, __pyx_L1_error)
-  __pyx_t_2 = __Pyx_PyInt_FromSize_t(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 369, __pyx_L1_error)
+  if (unlikely(!__pyx_v_data.memview)) { __Pyx_RaiseUnboundLocalError("data"); __PYX_ERR(0, 443, __pyx_L1_error) }
+  if (unlikely(!__pyx_v_out.memview)) { __Pyx_RaiseUnboundLocalError("out"); __PYX_ERR(0, 443, __pyx_L1_error) }
+  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_decompress_into(__pyx_v_data, __pyx_v_out, 0); if (unlikely(__pyx_t_1 == ((size_t)0) && PyErr_Occurred())) __PYX_ERR(0, 443, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_FromSize_t(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 443, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -8757,55 +10157,55 @@
   __PYX_XDEC_MEMVIEW(&__pyx_v_data, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_v_out, 1);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":379
+/* "bz3/backends/cython/_bz3.pyx":453
  *     return out_size
  * 
  * cpdef inline str libversion():             # <<<<<<<<<<<<<<
  *     return (<bytes>bz3_version()).decode()
  * 
  */
 
-static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_13libversion(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_15libversion(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
 static CYTHON_INLINE PyObject *__pyx_f_3bz3_8backends_6cython_4_bz3_libversion(CYTHON_UNUSED int __pyx_skip_dispatch) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("libversion", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":380
+  /* "bz3/backends/cython/_bz3.pyx":454
  * 
  * cpdef inline str libversion():
  *     return (<bytes>bz3_version()).decode()             # <<<<<<<<<<<<<<
  * 
  * # openmp
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyBytes_FromString(bz3_version()); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 380, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyBytes_FromString(bz3_version()); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 454, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (unlikely(__pyx_t_1 == Py_None)) {
     PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "decode");
-    __PYX_ERR(0, 380, __pyx_L1_error)
+    __PYX_ERR(0, 454, __pyx_L1_error)
   }
-  __pyx_t_2 = __Pyx_decode_bytes(((PyObject*)__pyx_t_1), 0, PY_SSIZE_T_MAX, NULL, NULL, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 380, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_decode_bytes(((PyObject*)__pyx_t_1), 0, PY_SSIZE_T_MAX, NULL, NULL, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 454, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = ((PyObject*)__pyx_t_2);
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "bz3/backends/cython/_bz3.pyx":379
+  /* "bz3/backends/cython/_bz3.pyx":453
  *     return out_size
  * 
  * cpdef inline str libversion():             # <<<<<<<<<<<<<<
  *     return (<bytes>bz3_version()).decode()
  * 
  */
 
@@ -8818,37 +10218,37 @@
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* Python wrapper */
-static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_13libversion(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
-static char __pyx_doc_3bz3_8backends_6cython_4_bz3_12libversion[] = "libversion() -> unicode";
-static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_13libversion(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
+static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_15libversion(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static char __pyx_doc_3bz3_8backends_6cython_4_bz3_14libversion[] = "libversion() -> unicode";
+static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_15libversion(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("libversion (wrapper)", 0);
-  __pyx_r = __pyx_pf_3bz3_8backends_6cython_4_bz3_12libversion(__pyx_self);
+  __pyx_r = __pyx_pf_3bz3_8backends_6cython_4_bz3_14libversion(__pyx_self);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_12libversion(CYTHON_UNUSED PyObject *__pyx_self) {
+static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_14libversion(CYTHON_UNUSED PyObject *__pyx_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("libversion", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_libversion(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 379, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_libversion(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 453, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -8857,15 +10257,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":386
+/* "bz3/backends/cython/_bz3.pyx":460
  * 
  * 
  * cdef void bz3_encode_blocks(bz3_state ** states, uint8_t ** buffers, int32_t *sizes, int32_t numthreads):             # <<<<<<<<<<<<<<
  *     # sizes: read and write
  *     cdef int32_t i
  */
 
@@ -8873,15 +10273,15 @@
   int32_t __pyx_v_i;
   __Pyx_RefNannyDeclarations
   int32_t __pyx_t_1;
   int32_t __pyx_t_2;
   int32_t __pyx_t_3;
   __Pyx_RefNannySetupContext("bz3_encode_blocks", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":389
+  /* "bz3/backends/cython/_bz3.pyx":463
  *     # sizes: read and write
  *     cdef int32_t i
  *     for i in prange(numthreads, nogil=True, schedule="static", num_threads=numthreads):             # <<<<<<<<<<<<<<
  *         sizes[i] = bz3_encode_block(states[i], buffers[i], sizes[i])
  * 
  */
   {
@@ -8910,15 +10310,15 @@
                     #ifdef _OPENMP
                     #pragma omp for firstprivate(__pyx_v_i) lastprivate(__pyx_v_i) schedule(static)
                     #endif /* _OPENMP */
                     for (__pyx_t_2 = 0; __pyx_t_2 < __pyx_t_3; __pyx_t_2++){
                         {
                             __pyx_v_i = (int32_t)(0 + 1 * __pyx_t_2);
 
-                            /* "bz3/backends/cython/_bz3.pyx":390
+                            /* "bz3/backends/cython/_bz3.pyx":464
  *     cdef int32_t i
  *     for i in prange(numthreads, nogil=True, schedule="static", num_threads=numthreads):
  *         sizes[i] = bz3_encode_block(states[i], buffers[i], sizes[i])             # <<<<<<<<<<<<<<
  * 
  * 
  */
                             (__pyx_v_sizes[__pyx_v_i]) = bz3_encode_block((__pyx_v_states[__pyx_v_i]), (__pyx_v_buffers[__pyx_v_i]), (__pyx_v_sizes[__pyx_v_i]));
@@ -8931,15 +10331,15 @@
             #undef likely
             #undef unlikely
             #define likely(x)   __builtin_expect(!!(x), 1)
             #define unlikely(x) __builtin_expect(!!(x), 0)
         #endif
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":389
+      /* "bz3/backends/cython/_bz3.pyx":463
  *     # sizes: read and write
  *     cdef int32_t i
  *     for i in prange(numthreads, nogil=True, schedule="static", num_threads=numthreads):             # <<<<<<<<<<<<<<
  *         sizes[i] = bz3_encode_block(states[i], buffers[i], sizes[i])
  * 
  */
       /*finally:*/ {
@@ -8950,27 +10350,27 @@
           #endif
           goto __pyx_L5;
         }
         __pyx_L5:;
       }
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":386
+  /* "bz3/backends/cython/_bz3.pyx":460
  * 
  * 
  * cdef void bz3_encode_blocks(bz3_state ** states, uint8_t ** buffers, int32_t *sizes, int32_t numthreads):             # <<<<<<<<<<<<<<
  *     # sizes: read and write
  *     cdef int32_t i
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "bz3/backends/cython/_bz3.pyx":407
+/* "bz3/backends/cython/_bz3.pyx":481
  *         readonly uint32_t numthreads  # how many threads to use
  * 
  *     def __cinit__(self, int32_t block_size, uint32_t numthreads):             # <<<<<<<<<<<<<<
  *         if block_size < KiB(65) or block_size > MiB(511):
  *             raise ValueError("Block size must be between 65 KiB and 511 MiB")
  */
 
@@ -9004,32 +10404,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_block_size)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_numthreads)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 2, 2, 1); __PYX_ERR(0, 407, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 2, 2, 1); __PYX_ERR(0, 481, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 407, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 481, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
-    __pyx_v_block_size = __Pyx_PyInt_As_int32_t(values[0]); if (unlikely((__pyx_v_block_size == ((int32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 407, __pyx_L3_error)
-    __pyx_v_numthreads = __Pyx_PyInt_As_uint32_t(values[1]); if (unlikely((__pyx_v_numthreads == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 407, __pyx_L3_error)
+    __pyx_v_block_size = __Pyx_PyInt_As_int32_t(values[0]); if (unlikely((__pyx_v_block_size == ((int32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 481, __pyx_L3_error)
+    __pyx_v_numthreads = __Pyx_PyInt_As_uint32_t(values[1]); if (unlikely((__pyx_v_numthreads == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 481, __pyx_L3_error)
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 407, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 481, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("bz3.backends.cython._bz3.BZ3OmpCompressor.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor___cinit__(((struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *)__pyx_v_self), __pyx_v_block_size, __pyx_v_numthreads);
 
@@ -9054,15 +10454,15 @@
   PyObject *__pyx_t_10 = NULL;
   PyObject *__pyx_t_11 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__cinit__", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":408
+  /* "bz3/backends/cython/_bz3.pyx":482
  * 
  *     def __cinit__(self, int32_t block_size, uint32_t numthreads):
  *         if block_size < KiB(65) or block_size > MiB(511):             # <<<<<<<<<<<<<<
  *             raise ValueError("Block size must be between 65 KiB and 511 MiB")
  *         self.block_size = block_size
  */
   __pyx_t_2 = ((__pyx_v_block_size < KiB(65)) != 0);
@@ -9072,266 +10472,383 @@
     goto __pyx_L4_bool_binop_done;
   }
   __pyx_t_2 = ((__pyx_v_block_size > MiB(0x1FF)) != 0);
   __pyx_t_1 = __pyx_t_2;
   __pyx_L4_bool_binop_done:;
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":409
+    /* "bz3/backends/cython/_bz3.pyx":483
  *     def __cinit__(self, int32_t block_size, uint32_t numthreads):
  *         if block_size < KiB(65) or block_size > MiB(511):
  *             raise ValueError("Block size must be between 65 KiB and 511 MiB")             # <<<<<<<<<<<<<<
  *         self.block_size = block_size
- *         self.states = <bz3_state **>PyMem_Malloc(sizeof(bz3_state *) * numthreads) # prepare the array
+ *         self.states = <bz3_state **>PyMem_Calloc(<size_t>numthreads, sizeof(bz3_state *)) # prepare the array
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 409, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 483, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(0, 409, __pyx_L1_error)
+    __PYX_ERR(0, 483, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":408
+    /* "bz3/backends/cython/_bz3.pyx":482
  * 
  *     def __cinit__(self, int32_t block_size, uint32_t numthreads):
  *         if block_size < KiB(65) or block_size > MiB(511):             # <<<<<<<<<<<<<<
  *             raise ValueError("Block size must be between 65 KiB and 511 MiB")
  *         self.block_size = block_size
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":410
+  /* "bz3/backends/cython/_bz3.pyx":484
  *         if block_size < KiB(65) or block_size > MiB(511):
  *             raise ValueError("Block size must be between 65 KiB and 511 MiB")
  *         self.block_size = block_size             # <<<<<<<<<<<<<<
- *         self.states = <bz3_state **>PyMem_Malloc(sizeof(bz3_state *) * numthreads) # prepare the array
+ *         self.states = <bz3_state **>PyMem_Calloc(<size_t>numthreads, sizeof(bz3_state *)) # prepare the array
  *         if not self.states:
  */
   __pyx_v_self->block_size = __pyx_v_block_size;
 
-  /* "bz3/backends/cython/_bz3.pyx":411
+  /* "bz3/backends/cython/_bz3.pyx":485
  *             raise ValueError("Block size must be between 65 KiB and 511 MiB")
  *         self.block_size = block_size
- *         self.states = <bz3_state **>PyMem_Malloc(sizeof(bz3_state *) * numthreads) # prepare the array             # <<<<<<<<<<<<<<
+ *         self.states = <bz3_state **>PyMem_Calloc(<size_t>numthreads, sizeof(bz3_state *)) # prepare the array             # <<<<<<<<<<<<<<
  *         if not self.states:
  *             raise MemoryError
  */
-  __pyx_v_self->states = ((struct bz3_state **)PyMem_Malloc(((sizeof(struct bz3_state *)) * __pyx_v_numthreads)));
+  __pyx_v_self->states = ((struct bz3_state **)PyMem_Calloc(((size_t)__pyx_v_numthreads), (sizeof(struct bz3_state *))));
 
-  /* "bz3/backends/cython/_bz3.pyx":412
+  /* "bz3/backends/cython/_bz3.pyx":486
  *         self.block_size = block_size
- *         self.states = <bz3_state **>PyMem_Malloc(sizeof(bz3_state *) * numthreads) # prepare the array
+ *         self.states = <bz3_state **>PyMem_Calloc(<size_t>numthreads, sizeof(bz3_state *)) # prepare the array
  *         if not self.states:             # <<<<<<<<<<<<<<
  *             raise MemoryError
- *         self.buffers = <uint8_t **>PyMem_Malloc(sizeof(uint8_t *) * numthreads)
+ *         MEMLOG("PyMem_Malloc %p\n", self.states)
  */
   __pyx_t_1 = ((!(__pyx_v_self->states != 0)) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":413
- *         self.states = <bz3_state **>PyMem_Malloc(sizeof(bz3_state *) * numthreads) # prepare the array
+    /* "bz3/backends/cython/_bz3.pyx":487
+ *         self.states = <bz3_state **>PyMem_Calloc(<size_t>numthreads, sizeof(bz3_state *)) # prepare the array
  *         if not self.states:
  *             raise MemoryError             # <<<<<<<<<<<<<<
- *         self.buffers = <uint8_t **>PyMem_Malloc(sizeof(uint8_t *) * numthreads)
- *         if not self.buffers:
+ *         MEMLOG("PyMem_Malloc %p\n", self.states)
+ *         self.buffers = <uint8_t **>PyMem_Calloc(<size_t>numthreads, sizeof(uint8_t *))
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 413, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 487, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":412
+    /* "bz3/backends/cython/_bz3.pyx":486
  *         self.block_size = block_size
- *         self.states = <bz3_state **>PyMem_Malloc(sizeof(bz3_state *) * numthreads) # prepare the array
+ *         self.states = <bz3_state **>PyMem_Calloc(<size_t>numthreads, sizeof(bz3_state *)) # prepare the array
  *         if not self.states:             # <<<<<<<<<<<<<<
  *             raise MemoryError
- *         self.buffers = <uint8_t **>PyMem_Malloc(sizeof(uint8_t *) * numthreads)
+ *         MEMLOG("PyMem_Malloc %p\n", self.states)
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":414
+  /* "bz3/backends/cython/_bz3.pyx":488
  *         if not self.states:
  *             raise MemoryError
- *         self.buffers = <uint8_t **>PyMem_Malloc(sizeof(uint8_t *) * numthreads)             # <<<<<<<<<<<<<<
+ *         MEMLOG("PyMem_Malloc %p\n", self.states)             # <<<<<<<<<<<<<<
+ *         self.buffers = <uint8_t **>PyMem_Calloc(<size_t>numthreads, sizeof(uint8_t *))
  *         if not self.buffers:
- *             PyMem_Free(self.states)
  */
-  __pyx_v_self->buffers = ((uint8_t **)PyMem_Malloc(((sizeof(uint8_t *)) * __pyx_v_numthreads)));
+  MEMLOG(((char const *)"PyMem_Malloc %p\n"), __pyx_v_self->states);
 
-  /* "bz3/backends/cython/_bz3.pyx":415
+  /* "bz3/backends/cython/_bz3.pyx":489
  *             raise MemoryError
- *         self.buffers = <uint8_t **>PyMem_Malloc(sizeof(uint8_t *) * numthreads)
+ *         MEMLOG("PyMem_Malloc %p\n", self.states)
+ *         self.buffers = <uint8_t **>PyMem_Calloc(<size_t>numthreads, sizeof(uint8_t *))             # <<<<<<<<<<<<<<
+ *         if not self.buffers:
+ *             PyMem_Free(self.states)
+ */
+  __pyx_v_self->buffers = ((uint8_t **)PyMem_Calloc(((size_t)__pyx_v_numthreads), (sizeof(uint8_t *))));
+
+  /* "bz3/backends/cython/_bz3.pyx":490
+ *         MEMLOG("PyMem_Malloc %p\n", self.states)
+ *         self.buffers = <uint8_t **>PyMem_Calloc(<size_t>numthreads, sizeof(uint8_t *))
  *         if not self.buffers:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.states)
- *             raise MemoryError
+ *             self.states = NULL
  */
   __pyx_t_1 = ((!(__pyx_v_self->buffers != 0)) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":416
- *         self.buffers = <uint8_t **>PyMem_Malloc(sizeof(uint8_t *) * numthreads)
+    /* "bz3/backends/cython/_bz3.pyx":491
+ *         self.buffers = <uint8_t **>PyMem_Calloc(<size_t>numthreads, sizeof(uint8_t *))
  *         if not self.buffers:
  *             PyMem_Free(self.states)             # <<<<<<<<<<<<<<
+ *             self.states = NULL
  *             raise MemoryError
- *         self.sizes = <int32_t *>PyMem_Malloc(sizeof(int32_t) * numthreads)
  */
     PyMem_Free(__pyx_v_self->states);
 
-    /* "bz3/backends/cython/_bz3.pyx":417
+    /* "bz3/backends/cython/_bz3.pyx":492
  *         if not self.buffers:
  *             PyMem_Free(self.states)
+ *             self.states = NULL             # <<<<<<<<<<<<<<
+ *             raise MemoryError
+ *         MEMLOG("PyMem_Malloc %p\n", self.buffers)
+ */
+    __pyx_v_self->states = NULL;
+
+    /* "bz3/backends/cython/_bz3.pyx":493
+ *             PyMem_Free(self.states)
+ *             self.states = NULL
  *             raise MemoryError             # <<<<<<<<<<<<<<
+ *         MEMLOG("PyMem_Malloc %p\n", self.buffers)
  *         self.sizes = <int32_t *>PyMem_Malloc(sizeof(int32_t) * numthreads)
- *         if not self.sizes:
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 417, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 493, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":415
- *             raise MemoryError
- *         self.buffers = <uint8_t **>PyMem_Malloc(sizeof(uint8_t *) * numthreads)
+    /* "bz3/backends/cython/_bz3.pyx":490
+ *         MEMLOG("PyMem_Malloc %p\n", self.states)
+ *         self.buffers = <uint8_t **>PyMem_Calloc(<size_t>numthreads, sizeof(uint8_t *))
  *         if not self.buffers:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.states)
- *             raise MemoryError
+ *             self.states = NULL
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":418
- *             PyMem_Free(self.states)
+  /* "bz3/backends/cython/_bz3.pyx":494
+ *             self.states = NULL
  *             raise MemoryError
+ *         MEMLOG("PyMem_Malloc %p\n", self.buffers)             # <<<<<<<<<<<<<<
+ *         self.sizes = <int32_t *>PyMem_Malloc(sizeof(int32_t) * numthreads)
+ *         if not self.sizes:
+ */
+  MEMLOG(((char const *)"PyMem_Malloc %p\n"), __pyx_v_self->buffers);
+
+  /* "bz3/backends/cython/_bz3.pyx":495
+ *             raise MemoryError
+ *         MEMLOG("PyMem_Malloc %p\n", self.buffers)
  *         self.sizes = <int32_t *>PyMem_Malloc(sizeof(int32_t) * numthreads)             # <<<<<<<<<<<<<<
  *         if not self.sizes:
  *             PyMem_Free(self.states)
  */
   __pyx_v_self->sizes = ((int32_t *)PyMem_Malloc(((sizeof(int32_t)) * __pyx_v_numthreads)));
 
-  /* "bz3/backends/cython/_bz3.pyx":419
- *             raise MemoryError
+  /* "bz3/backends/cython/_bz3.pyx":496
+ *         MEMLOG("PyMem_Malloc %p\n", self.buffers)
  *         self.sizes = <int32_t *>PyMem_Malloc(sizeof(int32_t) * numthreads)
  *         if not self.sizes:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.states)
- *             PyMem_Free(self.buffers)
+ *             MEMLOG("PyMem_Free %p\n", self.states)
  */
   __pyx_t_1 = ((!(__pyx_v_self->sizes != 0)) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":420
+    /* "bz3/backends/cython/_bz3.pyx":497
  *         self.sizes = <int32_t *>PyMem_Malloc(sizeof(int32_t) * numthreads)
  *         if not self.sizes:
  *             PyMem_Free(self.states)             # <<<<<<<<<<<<<<
- *             PyMem_Free(self.buffers)
- *             raise MemoryError
+ *             MEMLOG("PyMem_Free %p\n", self.states)
+ *             self.states = NULL
  */
     PyMem_Free(__pyx_v_self->states);
 
-    /* "bz3/backends/cython/_bz3.pyx":421
+    /* "bz3/backends/cython/_bz3.pyx":498
  *         if not self.sizes:
  *             PyMem_Free(self.states)
+ *             MEMLOG("PyMem_Free %p\n", self.states)             # <<<<<<<<<<<<<<
+ *             self.states = NULL
+ *             PyMem_Free(self.buffers)
+ */
+    MEMLOG(((char const *)"PyMem_Free %p\n"), __pyx_v_self->states);
+
+    /* "bz3/backends/cython/_bz3.pyx":499
+ *             PyMem_Free(self.states)
+ *             MEMLOG("PyMem_Free %p\n", self.states)
+ *             self.states = NULL             # <<<<<<<<<<<<<<
+ *             PyMem_Free(self.buffers)
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
+ */
+    __pyx_v_self->states = NULL;
+
+    /* "bz3/backends/cython/_bz3.pyx":500
+ *             MEMLOG("PyMem_Free %p\n", self.states)
+ *             self.states = NULL
  *             PyMem_Free(self.buffers)             # <<<<<<<<<<<<<<
- *             raise MemoryError
- *         self.old_sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
+ *             self.buffers = NULL
  */
     PyMem_Free(__pyx_v_self->buffers);
 
-    /* "bz3/backends/cython/_bz3.pyx":422
- *             PyMem_Free(self.states)
+    /* "bz3/backends/cython/_bz3.pyx":501
+ *             self.states = NULL
+ *             PyMem_Free(self.buffers)
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)             # <<<<<<<<<<<<<<
+ *             self.buffers = NULL
+ *             raise MemoryError
+ */
+    MEMLOG(((char const *)"PyMem_Free %p\n"), __pyx_v_self->buffers);
+
+    /* "bz3/backends/cython/_bz3.pyx":502
  *             PyMem_Free(self.buffers)
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
+ *             self.buffers = NULL             # <<<<<<<<<<<<<<
+ *             raise MemoryError
+ *         MEMLOG("PyMem_Malloc %p\n", self.sizes)
+ */
+    __pyx_v_self->buffers = NULL;
+
+    /* "bz3/backends/cython/_bz3.pyx":503
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
+ *             self.buffers = NULL
  *             raise MemoryError             # <<<<<<<<<<<<<<
+ *         MEMLOG("PyMem_Malloc %p\n", self.sizes)
  *         self.old_sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
- *         if not self.old_sizes:
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 422, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 503, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":419
- *             raise MemoryError
+    /* "bz3/backends/cython/_bz3.pyx":496
+ *         MEMLOG("PyMem_Malloc %p\n", self.buffers)
  *         self.sizes = <int32_t *>PyMem_Malloc(sizeof(int32_t) * numthreads)
  *         if not self.sizes:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.states)
- *             PyMem_Free(self.buffers)
+ *             MEMLOG("PyMem_Free %p\n", self.states)
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":423
- *             PyMem_Free(self.buffers)
+  /* "bz3/backends/cython/_bz3.pyx":504
+ *             self.buffers = NULL
  *             raise MemoryError
+ *         MEMLOG("PyMem_Malloc %p\n", self.sizes)             # <<<<<<<<<<<<<<
+ *         self.old_sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
+ *         if not self.old_sizes:
+ */
+  MEMLOG(((char const *)"PyMem_Malloc %p\n"), __pyx_v_self->sizes);
+
+  /* "bz3/backends/cython/_bz3.pyx":505
+ *             raise MemoryError
+ *         MEMLOG("PyMem_Malloc %p\n", self.sizes)
  *         self.old_sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)             # <<<<<<<<<<<<<<
  *         if not self.old_sizes:
  *             PyMem_Free(self.states)
  */
   __pyx_v_self->old_sizes = ((int32_t *)PyMem_Malloc(((sizeof(int32_t)) * __pyx_v_numthreads)));
 
-  /* "bz3/backends/cython/_bz3.pyx":424
- *             raise MemoryError
+  /* "bz3/backends/cython/_bz3.pyx":506
+ *         MEMLOG("PyMem_Malloc %p\n", self.sizes)
  *         self.old_sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
  *         if not self.old_sizes:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.states)
- *             PyMem_Free(self.buffers)
+ *             MEMLOG("PyMem_Free %p\n", self.states)
  */
   __pyx_t_1 = ((!(__pyx_v_self->old_sizes != 0)) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":425
+    /* "bz3/backends/cython/_bz3.pyx":507
  *         self.old_sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
  *         if not self.old_sizes:
  *             PyMem_Free(self.states)             # <<<<<<<<<<<<<<
- *             PyMem_Free(self.buffers)
- *             PyMem_Free(self.sizes)
+ *             MEMLOG("PyMem_Free %p\n", self.states)
+ *             self.states = NULL
  */
     PyMem_Free(__pyx_v_self->states);
 
-    /* "bz3/backends/cython/_bz3.pyx":426
+    /* "bz3/backends/cython/_bz3.pyx":508
  *         if not self.old_sizes:
  *             PyMem_Free(self.states)
+ *             MEMLOG("PyMem_Free %p\n", self.states)             # <<<<<<<<<<<<<<
+ *             self.states = NULL
+ *             PyMem_Free(self.buffers)
+ */
+    MEMLOG(((char const *)"PyMem_Free %p\n"), __pyx_v_self->states);
+
+    /* "bz3/backends/cython/_bz3.pyx":509
+ *             PyMem_Free(self.states)
+ *             MEMLOG("PyMem_Free %p\n", self.states)
+ *             self.states = NULL             # <<<<<<<<<<<<<<
+ *             PyMem_Free(self.buffers)
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
+ */
+    __pyx_v_self->states = NULL;
+
+    /* "bz3/backends/cython/_bz3.pyx":510
+ *             MEMLOG("PyMem_Free %p\n", self.states)
+ *             self.states = NULL
  *             PyMem_Free(self.buffers)             # <<<<<<<<<<<<<<
- *             PyMem_Free(self.sizes)
- *             raise MemoryError
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
+ *             self.buffers = NULL
  */
     PyMem_Free(__pyx_v_self->buffers);
 
-    /* "bz3/backends/cython/_bz3.pyx":427
- *             PyMem_Free(self.states)
+    /* "bz3/backends/cython/_bz3.pyx":511
+ *             self.states = NULL
  *             PyMem_Free(self.buffers)
- *             PyMem_Free(self.sizes)             # <<<<<<<<<<<<<<
- *             raise MemoryError
- *         memset(self.states, 0, sizeof(bz3_state *) * numthreads)
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)             # <<<<<<<<<<<<<<
+ *             self.buffers = NULL
+ *             PyMem_Free(self.sizes)
  */
-    PyMem_Free(__pyx_v_self->sizes);
+    MEMLOG(((char const *)"PyMem_Free %p\n"), __pyx_v_self->buffers);
 
-    /* "bz3/backends/cython/_bz3.pyx":428
+    /* "bz3/backends/cython/_bz3.pyx":512
  *             PyMem_Free(self.buffers)
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
+ *             self.buffers = NULL             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.sizes)
- *             raise MemoryError             # <<<<<<<<<<<<<<
- *         memset(self.states, 0, sizeof(bz3_state *) * numthreads)
- *         memset(self.buffers, 0, sizeof(uint8_t *) * numthreads)
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)
+ */
+    __pyx_v_self->buffers = NULL;
+
+    /* "bz3/backends/cython/_bz3.pyx":513
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
+ *             self.buffers = NULL
+ *             PyMem_Free(self.sizes)             # <<<<<<<<<<<<<<
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)
+ *             self.sizes = NULL
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 428, __pyx_L1_error)
+    PyMem_Free(__pyx_v_self->sizes);
 
-    /* "bz3/backends/cython/_bz3.pyx":424
+    /* "bz3/backends/cython/_bz3.pyx":514
+ *             self.buffers = NULL
+ *             PyMem_Free(self.sizes)
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)             # <<<<<<<<<<<<<<
+ *             self.sizes = NULL
  *             raise MemoryError
- *         self.old_sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
- *         if not self.old_sizes:             # <<<<<<<<<<<<<<
- *             PyMem_Free(self.states)
- *             PyMem_Free(self.buffers)
  */
-  }
+    MEMLOG(((char const *)"PyMem_Free %p\n"), __pyx_v_self->sizes);
 
-  /* "bz3/backends/cython/_bz3.pyx":429
+    /* "bz3/backends/cython/_bz3.pyx":515
  *             PyMem_Free(self.sizes)
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)
+ *             self.sizes = NULL             # <<<<<<<<<<<<<<
  *             raise MemoryError
- *         memset(self.states, 0, sizeof(bz3_state *) * numthreads)             # <<<<<<<<<<<<<<
- *         memset(self.buffers, 0, sizeof(uint8_t *) * numthreads)
+ *         MEMLOG("PyMem_Malloc %p\n", self.old_sizes)
+ */
+    __pyx_v_self->sizes = NULL;
+
+    /* "bz3/backends/cython/_bz3.pyx":516
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)
+ *             self.sizes = NULL
+ *             raise MemoryError             # <<<<<<<<<<<<<<
+ *         MEMLOG("PyMem_Malloc %p\n", self.old_sizes)
  * 
  */
-  (void)(memset(__pyx_v_self->states, 0, ((sizeof(struct bz3_state *)) * __pyx_v_numthreads)));
+    PyErr_NoMemory(); __PYX_ERR(0, 516, __pyx_L1_error)
 
-  /* "bz3/backends/cython/_bz3.pyx":430
+    /* "bz3/backends/cython/_bz3.pyx":506
+ *         MEMLOG("PyMem_Malloc %p\n", self.sizes)
+ *         self.old_sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
+ *         if not self.old_sizes:             # <<<<<<<<<<<<<<
+ *             PyMem_Free(self.states)
+ *             MEMLOG("PyMem_Free %p\n", self.states)
+ */
+  }
+
+  /* "bz3/backends/cython/_bz3.pyx":517
+ *             self.sizes = NULL
  *             raise MemoryError
- *         memset(self.states, 0, sizeof(bz3_state *) * numthreads)
- *         memset(self.buffers, 0, sizeof(uint8_t *) * numthreads)             # <<<<<<<<<<<<<<
+ *         MEMLOG("PyMem_Malloc %p\n", self.old_sizes)             # <<<<<<<<<<<<<<
  * 
  *         cdef uint32_t i
  */
-  (void)(memset(__pyx_v_self->buffers, 0, ((sizeof(uint8_t *)) * __pyx_v_numthreads)));
+  MEMLOG(((char const *)"PyMem_Malloc %p\n"), __pyx_v_self->old_sizes);
 
-  /* "bz3/backends/cython/_bz3.pyx":433
+  /* "bz3/backends/cython/_bz3.pyx":520
  * 
  *         cdef uint32_t i
  *         try:             # <<<<<<<<<<<<<<
  *             for i in range(numthreads):
  *                 self.states[i] = bz3_new(block_size)
  */
   {
@@ -9339,257 +10856,347 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_4, &__pyx_t_5, &__pyx_t_6);
     __Pyx_XGOTREF(__pyx_t_4);
     __Pyx_XGOTREF(__pyx_t_5);
     __Pyx_XGOTREF(__pyx_t_6);
     /*try:*/ {
 
-      /* "bz3/backends/cython/_bz3.pyx":434
+      /* "bz3/backends/cython/_bz3.pyx":521
  *         cdef uint32_t i
  *         try:
  *             for i in range(numthreads):             # <<<<<<<<<<<<<<
  *                 self.states[i] = bz3_new(block_size)
  *                 if self.states[i] == NULL:
  */
       __pyx_t_7 = __pyx_v_numthreads;
       __pyx_t_8 = __pyx_t_7;
       for (__pyx_t_9 = 0; __pyx_t_9 < __pyx_t_8; __pyx_t_9+=1) {
         __pyx_v_i = __pyx_t_9;
 
-        /* "bz3/backends/cython/_bz3.pyx":435
+        /* "bz3/backends/cython/_bz3.pyx":522
  *         try:
  *             for i in range(numthreads):
  *                 self.states[i] = bz3_new(block_size)             # <<<<<<<<<<<<<<
  *                 if self.states[i] == NULL:
  *                     raise MemoryError("Failed to create a block encoder state")  # todo
  */
         (__pyx_v_self->states[__pyx_v_i]) = bz3_new(__pyx_v_block_size);
 
-        /* "bz3/backends/cython/_bz3.pyx":436
+        /* "bz3/backends/cython/_bz3.pyx":523
  *             for i in range(numthreads):
  *                 self.states[i] = bz3_new(block_size)
  *                 if self.states[i] == NULL:             # <<<<<<<<<<<<<<
  *                     raise MemoryError("Failed to create a block encoder state")  # todo
- *                 self.buffers[i] = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
+ *                 MEMLOG("bz3_new %p\n", self.states[i])
  */
         __pyx_t_1 = (((__pyx_v_self->states[__pyx_v_i]) == NULL) != 0);
         if (unlikely(__pyx_t_1)) {
 
-          /* "bz3/backends/cython/_bz3.pyx":437
+          /* "bz3/backends/cython/_bz3.pyx":524
  *                 self.states[i] = bz3_new(block_size)
  *                 if self.states[i] == NULL:
  *                     raise MemoryError("Failed to create a block encoder state")  # todo             # <<<<<<<<<<<<<<
- *                 self.buffers[i] = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
- *                 if self.buffers[i] == NULL:
+ *                 MEMLOG("bz3_new %p\n", self.states[i])
+ *                 self.buffers[i] = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))
  */
-          __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 437, __pyx_L10_error)
+          __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 524, __pyx_L10_error)
           __Pyx_GOTREF(__pyx_t_3);
           __Pyx_Raise(__pyx_t_3, 0, 0, 0);
           __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-          __PYX_ERR(0, 437, __pyx_L10_error)
+          __PYX_ERR(0, 524, __pyx_L10_error)
 
-          /* "bz3/backends/cython/_bz3.pyx":436
+          /* "bz3/backends/cython/_bz3.pyx":523
  *             for i in range(numthreads):
  *                 self.states[i] = bz3_new(block_size)
  *                 if self.states[i] == NULL:             # <<<<<<<<<<<<<<
  *                     raise MemoryError("Failed to create a block encoder state")  # todo
- *                 self.buffers[i] = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
+ *                 MEMLOG("bz3_new %p\n", self.states[i])
  */
         }
 
-        /* "bz3/backends/cython/_bz3.pyx":438
+        /* "bz3/backends/cython/_bz3.pyx":525
  *                 if self.states[i] == NULL:
  *                     raise MemoryError("Failed to create a block encoder state")  # todo
- *                 self.buffers[i] = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)             # <<<<<<<<<<<<<<
+ *                 MEMLOG("bz3_new %p\n", self.states[i])             # <<<<<<<<<<<<<<
+ *                 self.buffers[i] = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))
  *                 if self.buffers[i] == NULL:
- *                     raise MemoryError("Failed to allocate memory")
  */
-        (__pyx_v_self->buffers[__pyx_v_i]) = ((uint8_t *)PyMem_Malloc(((__pyx_v_block_size + (((long)__pyx_v_block_size) / 50)) + 32)));
+        MEMLOG(((char const *)"bz3_new %p\n"), (__pyx_v_self->states[__pyx_v_i]));
 
-        /* "bz3/backends/cython/_bz3.pyx":439
+        /* "bz3/backends/cython/_bz3.pyx":526
  *                     raise MemoryError("Failed to create a block encoder state")  # todo
- *                 self.buffers[i] = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
+ *                 MEMLOG("bz3_new %p\n", self.states[i])
+ *                 self.buffers[i] = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))             # <<<<<<<<<<<<<<
+ *                 if self.buffers[i] == NULL:
+ *                     raise MemoryError("Failed to allocate memory")
+ */
+        (__pyx_v_self->buffers[__pyx_v_i]) = ((uint8_t *)PyMem_Malloc(bz3_bound(__pyx_v_block_size)));
+
+        /* "bz3/backends/cython/_bz3.pyx":527
+ *                 MEMLOG("bz3_new %p\n", self.states[i])
+ *                 self.buffers[i] = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))
  *                 if self.buffers[i] == NULL:             # <<<<<<<<<<<<<<
  *                     raise MemoryError("Failed to allocate memory")
- *         except:
+ *                 MEMLOG("PyMem_Malloc %p\n", self.buffers[i])
  */
         __pyx_t_1 = (((__pyx_v_self->buffers[__pyx_v_i]) == NULL) != 0);
         if (unlikely(__pyx_t_1)) {
 
-          /* "bz3/backends/cython/_bz3.pyx":440
- *                 self.buffers[i] = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
+          /* "bz3/backends/cython/_bz3.pyx":528
+ *                 self.buffers[i] = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))
  *                 if self.buffers[i] == NULL:
  *                     raise MemoryError("Failed to allocate memory")             # <<<<<<<<<<<<<<
+ *                 MEMLOG("PyMem_Malloc %p\n", self.buffers[i])
  *         except:
- *             self.free_states()
  */
-          __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 440, __pyx_L10_error)
+          __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 528, __pyx_L10_error)
           __Pyx_GOTREF(__pyx_t_3);
           __Pyx_Raise(__pyx_t_3, 0, 0, 0);
           __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-          __PYX_ERR(0, 440, __pyx_L10_error)
+          __PYX_ERR(0, 528, __pyx_L10_error)
 
-          /* "bz3/backends/cython/_bz3.pyx":439
- *                     raise MemoryError("Failed to create a block encoder state")  # todo
- *                 self.buffers[i] = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
+          /* "bz3/backends/cython/_bz3.pyx":527
+ *                 MEMLOG("bz3_new %p\n", self.states[i])
+ *                 self.buffers[i] = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))
  *                 if self.buffers[i] == NULL:             # <<<<<<<<<<<<<<
  *                     raise MemoryError("Failed to allocate memory")
- *         except:
+ *                 MEMLOG("PyMem_Malloc %p\n", self.buffers[i])
  */
         }
+
+        /* "bz3/backends/cython/_bz3.pyx":529
+ *                 if self.buffers[i] == NULL:
+ *                     raise MemoryError("Failed to allocate memory")
+ *                 MEMLOG("PyMem_Malloc %p\n", self.buffers[i])             # <<<<<<<<<<<<<<
+ *         except:
+ *             self.free_states()
+ */
+        MEMLOG(((char const *)"PyMem_Malloc %p\n"), (__pyx_v_self->buffers[__pyx_v_i]));
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":433
+      /* "bz3/backends/cython/_bz3.pyx":520
  * 
  *         cdef uint32_t i
  *         try:             # <<<<<<<<<<<<<<
  *             for i in range(numthreads):
  *                 self.states[i] = bz3_new(block_size)
  */
     }
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
     goto __pyx_L15_try_end;
     __pyx_L10_error:;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-    /* "bz3/backends/cython/_bz3.pyx":441
- *                 if self.buffers[i] == NULL:
+    /* "bz3/backends/cython/_bz3.pyx":530
  *                     raise MemoryError("Failed to allocate memory")
+ *                 MEMLOG("PyMem_Malloc %p\n", self.buffers[i])
  *         except:             # <<<<<<<<<<<<<<
  *             self.free_states()
  *             self.free_buffers()
  */
     /*except:*/ {
       __Pyx_AddTraceback("bz3.backends.cython._bz3.BZ3OmpCompressor.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_3, &__pyx_t_10, &__pyx_t_11) < 0) __PYX_ERR(0, 441, __pyx_L12_except_error)
+      if (__Pyx_GetException(&__pyx_t_3, &__pyx_t_10, &__pyx_t_11) < 0) __PYX_ERR(0, 530, __pyx_L12_except_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_GOTREF(__pyx_t_10);
       __Pyx_GOTREF(__pyx_t_11);
 
-      /* "bz3/backends/cython/_bz3.pyx":442
- *                     raise MemoryError("Failed to allocate memory")
+      /* "bz3/backends/cython/_bz3.pyx":531
+ *                 MEMLOG("PyMem_Malloc %p\n", self.buffers[i])
  *         except:
  *             self.free_states()             # <<<<<<<<<<<<<<
  *             self.free_buffers()
  *             PyMem_Free(self.states)
  */
       __pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_free_states(__pyx_v_self);
 
-      /* "bz3/backends/cython/_bz3.pyx":443
+      /* "bz3/backends/cython/_bz3.pyx":532
  *         except:
  *             self.free_states()
  *             self.free_buffers()             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.states)
- *             PyMem_Free(self.buffers)
+ *             MEMLOG("PyMem_Free %p\n", self.states)
  */
       __pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_free_buffers(__pyx_v_self);
 
-      /* "bz3/backends/cython/_bz3.pyx":444
+      /* "bz3/backends/cython/_bz3.pyx":533
  *             self.free_states()
  *             self.free_buffers()
  *             PyMem_Free(self.states)             # <<<<<<<<<<<<<<
- *             PyMem_Free(self.buffers)
- *             PyMem_Free(self.sizes)
+ *             MEMLOG("PyMem_Free %p\n", self.states)
+ *             self.states = NULL
  */
       PyMem_Free(__pyx_v_self->states);
 
-      /* "bz3/backends/cython/_bz3.pyx":445
+      /* "bz3/backends/cython/_bz3.pyx":534
  *             self.free_buffers()
  *             PyMem_Free(self.states)
+ *             MEMLOG("PyMem_Free %p\n", self.states)             # <<<<<<<<<<<<<<
+ *             self.states = NULL
+ *             PyMem_Free(self.buffers)
+ */
+      MEMLOG(((char const *)"PyMem_Free %p\n"), __pyx_v_self->states);
+
+      /* "bz3/backends/cython/_bz3.pyx":535
+ *             PyMem_Free(self.states)
+ *             MEMLOG("PyMem_Free %p\n", self.states)
+ *             self.states = NULL             # <<<<<<<<<<<<<<
+ *             PyMem_Free(self.buffers)
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
+ */
+      __pyx_v_self->states = NULL;
+
+      /* "bz3/backends/cython/_bz3.pyx":536
+ *             MEMLOG("PyMem_Free %p\n", self.states)
+ *             self.states = NULL
  *             PyMem_Free(self.buffers)             # <<<<<<<<<<<<<<
- *             PyMem_Free(self.sizes)
- *             PyMem_Free(self.old_sizes)
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
+ *             self.buffers = NULL
  */
       PyMem_Free(__pyx_v_self->buffers);
 
-      /* "bz3/backends/cython/_bz3.pyx":446
- *             PyMem_Free(self.states)
+      /* "bz3/backends/cython/_bz3.pyx":537
+ *             self.states = NULL
  *             PyMem_Free(self.buffers)
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)             # <<<<<<<<<<<<<<
+ *             self.buffers = NULL
+ *             PyMem_Free(self.sizes)
+ */
+      MEMLOG(((char const *)"PyMem_Free %p\n"), __pyx_v_self->buffers);
+
+      /* "bz3/backends/cython/_bz3.pyx":538
+ *             PyMem_Free(self.buffers)
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
+ *             self.buffers = NULL             # <<<<<<<<<<<<<<
+ *             PyMem_Free(self.sizes)
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)
+ */
+      __pyx_v_self->buffers = NULL;
+
+      /* "bz3/backends/cython/_bz3.pyx":539
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
+ *             self.buffers = NULL
  *             PyMem_Free(self.sizes)             # <<<<<<<<<<<<<<
- *             PyMem_Free(self.old_sizes)
- *             raise
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)
+ *             self.sizes = NULL
  */
       PyMem_Free(__pyx_v_self->sizes);
 
-      /* "bz3/backends/cython/_bz3.pyx":447
- *             PyMem_Free(self.buffers)
+      /* "bz3/backends/cython/_bz3.pyx":540
+ *             self.buffers = NULL
  *             PyMem_Free(self.sizes)
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)             # <<<<<<<<<<<<<<
+ *             self.sizes = NULL
+ *             PyMem_Free(self.old_sizes)
+ */
+      MEMLOG(((char const *)"PyMem_Free %p\n"), __pyx_v_self->sizes);
+
+      /* "bz3/backends/cython/_bz3.pyx":541
+ *             PyMem_Free(self.sizes)
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)
+ *             self.sizes = NULL             # <<<<<<<<<<<<<<
+ *             PyMem_Free(self.old_sizes)
+ *             MEMLOG("PyMem_Free %p\n", self.old_sizes)
+ */
+      __pyx_v_self->sizes = NULL;
+
+      /* "bz3/backends/cython/_bz3.pyx":542
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)
+ *             self.sizes = NULL
  *             PyMem_Free(self.old_sizes)             # <<<<<<<<<<<<<<
- *             raise
- *         self.uncompressed = bytearray()
+ *             MEMLOG("PyMem_Free %p\n", self.old_sizes)
+ *             self.old_sizes = NULL
  */
       PyMem_Free(__pyx_v_self->old_sizes);
 
-      /* "bz3/backends/cython/_bz3.pyx":448
- *             PyMem_Free(self.sizes)
+      /* "bz3/backends/cython/_bz3.pyx":543
+ *             self.sizes = NULL
+ *             PyMem_Free(self.old_sizes)
+ *             MEMLOG("PyMem_Free %p\n", self.old_sizes)             # <<<<<<<<<<<<<<
+ *             self.old_sizes = NULL
+ *             raise
+ */
+      MEMLOG(((char const *)"PyMem_Free %p\n"), __pyx_v_self->old_sizes);
+
+      /* "bz3/backends/cython/_bz3.pyx":544
  *             PyMem_Free(self.old_sizes)
+ *             MEMLOG("PyMem_Free %p\n", self.old_sizes)
+ *             self.old_sizes = NULL             # <<<<<<<<<<<<<<
+ *             raise
+ *         self.uncompressed = bytearray()
+ */
+      __pyx_v_self->old_sizes = NULL;
+
+      /* "bz3/backends/cython/_bz3.pyx":545
+ *             MEMLOG("PyMem_Free %p\n", self.old_sizes)
+ *             self.old_sizes = NULL
  *             raise             # <<<<<<<<<<<<<<
  *         self.uncompressed = bytearray()
  *         self.have_magic_number = 0 # magic number
  */
       __Pyx_GIVEREF(__pyx_t_3);
       __Pyx_GIVEREF(__pyx_t_10);
       __Pyx_XGIVEREF(__pyx_t_11);
       __Pyx_ErrRestoreWithState(__pyx_t_3, __pyx_t_10, __pyx_t_11);
       __pyx_t_3 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; 
-      __PYX_ERR(0, 448, __pyx_L12_except_error)
+      __PYX_ERR(0, 545, __pyx_L12_except_error)
     }
     __pyx_L12_except_error:;
 
-    /* "bz3/backends/cython/_bz3.pyx":433
+    /* "bz3/backends/cython/_bz3.pyx":520
  * 
  *         cdef uint32_t i
  *         try:             # <<<<<<<<<<<<<<
  *             for i in range(numthreads):
  *                 self.states[i] = bz3_new(block_size)
  */
     __Pyx_XGIVEREF(__pyx_t_4);
     __Pyx_XGIVEREF(__pyx_t_5);
     __Pyx_XGIVEREF(__pyx_t_6);
     __Pyx_ExceptionReset(__pyx_t_4, __pyx_t_5, __pyx_t_6);
     goto __pyx_L1_error;
     __pyx_L15_try_end:;
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":449
- *             PyMem_Free(self.old_sizes)
+  /* "bz3/backends/cython/_bz3.pyx":546
+ *             self.old_sizes = NULL
  *             raise
  *         self.uncompressed = bytearray()             # <<<<<<<<<<<<<<
  *         self.have_magic_number = 0 # magic number
  *         self.numthreads = numthreads
  */
-  __pyx_t_11 = __Pyx_PyObject_CallNoArg(((PyObject *)(&PyByteArray_Type))); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 449, __pyx_L1_error)
+  __pyx_t_11 = __Pyx_PyObject_CallNoArg(((PyObject *)(&PyByteArray_Type))); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 546, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_11);
   __Pyx_GIVEREF(__pyx_t_11);
   __Pyx_GOTREF(__pyx_v_self->uncompressed);
   __Pyx_DECREF(__pyx_v_self->uncompressed);
   __pyx_v_self->uncompressed = ((PyObject*)__pyx_t_11);
   __pyx_t_11 = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":450
+  /* "bz3/backends/cython/_bz3.pyx":547
  *             raise
  *         self.uncompressed = bytearray()
  *         self.have_magic_number = 0 # magic number             # <<<<<<<<<<<<<<
  *         self.numthreads = numthreads
  * 
  */
   __pyx_v_self->have_magic_number = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":451
+  /* "bz3/backends/cython/_bz3.pyx":548
  *         self.uncompressed = bytearray()
  *         self.have_magic_number = 0 # magic number
  *         self.numthreads = numthreads             # <<<<<<<<<<<<<<
  * 
  *     cdef inline void free_states(self):
  */
   __pyx_v_self->numthreads = __pyx_v_numthreads;
 
-  /* "bz3/backends/cython/_bz3.pyx":407
+  /* "bz3/backends/cython/_bz3.pyx":481
  *         readonly uint32_t numthreads  # how many threads to use
  * 
  *     def __cinit__(self, int32_t block_size, uint32_t numthreads):             # <<<<<<<<<<<<<<
  *         if block_size < KiB(65) or block_size > MiB(511):
  *             raise ValueError("Block size must be between 65 KiB and 511 MiB")
  */
 
@@ -9603,174 +11210,230 @@
   __Pyx_AddTraceback("bz3.backends.cython._bz3.BZ3OmpCompressor.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":453
+/* "bz3/backends/cython/_bz3.pyx":550
  *         self.numthreads = numthreads
  * 
  *     cdef inline void free_states(self):             # <<<<<<<<<<<<<<
  *         cdef uint32_t i
- *         for i in range(self.numthreads):
+ *         if self.states:
  */
 
 static CYTHON_INLINE void __pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_free_states(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *__pyx_v_self) {
   uint32_t __pyx_v_i;
   __Pyx_RefNannyDeclarations
-  uint32_t __pyx_t_1;
+  int __pyx_t_1;
   uint32_t __pyx_t_2;
   uint32_t __pyx_t_3;
-  int __pyx_t_4;
+  uint32_t __pyx_t_4;
   __Pyx_RefNannySetupContext("free_states", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":455
+  /* "bz3/backends/cython/_bz3.pyx":552
  *     cdef inline void free_states(self):
  *         cdef uint32_t i
- *         for i in range(self.numthreads):             # <<<<<<<<<<<<<<
- *             if self.states[i]:
- *                 bz3_free(self.states[i])
+ *         if self.states:             # <<<<<<<<<<<<<<
+ *             for i in range(self.numthreads):
+ *                 if self.states[i]:
  */
-  __pyx_t_1 = __pyx_v_self->numthreads;
-  __pyx_t_2 = __pyx_t_1;
-  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
-    __pyx_v_i = __pyx_t_3;
+  __pyx_t_1 = (__pyx_v_self->states != 0);
+  if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":456
+    /* "bz3/backends/cython/_bz3.pyx":553
  *         cdef uint32_t i
- *         for i in range(self.numthreads):
- *             if self.states[i]:             # <<<<<<<<<<<<<<
- *                 bz3_free(self.states[i])
- *                 self.states[i] = NULL
+ *         if self.states:
+ *             for i in range(self.numthreads):             # <<<<<<<<<<<<<<
+ *                 if self.states[i]:
+ *                     bz3_free(self.states[i])
  */
-    __pyx_t_4 = ((__pyx_v_self->states[__pyx_v_i]) != 0);
-    if (__pyx_t_4) {
+    __pyx_t_2 = __pyx_v_self->numthreads;
+    __pyx_t_3 = __pyx_t_2;
+    for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
+      __pyx_v_i = __pyx_t_4;
 
-      /* "bz3/backends/cython/_bz3.pyx":457
- *         for i in range(self.numthreads):
- *             if self.states[i]:
- *                 bz3_free(self.states[i])             # <<<<<<<<<<<<<<
- *                 self.states[i] = NULL
- * 
+      /* "bz3/backends/cython/_bz3.pyx":554
+ *         if self.states:
+ *             for i in range(self.numthreads):
+ *                 if self.states[i]:             # <<<<<<<<<<<<<<
+ *                     bz3_free(self.states[i])
+ *                     MEMLOG("bz3_free %p\n", self.states[i])
  */
-      bz3_free((__pyx_v_self->states[__pyx_v_i]));
+      __pyx_t_1 = ((__pyx_v_self->states[__pyx_v_i]) != 0);
+      if (__pyx_t_1) {
 
-      /* "bz3/backends/cython/_bz3.pyx":458
- *             if self.states[i]:
- *                 bz3_free(self.states[i])
- *                 self.states[i] = NULL             # <<<<<<<<<<<<<<
+        /* "bz3/backends/cython/_bz3.pyx":555
+ *             for i in range(self.numthreads):
+ *                 if self.states[i]:
+ *                     bz3_free(self.states[i])             # <<<<<<<<<<<<<<
+ *                     MEMLOG("bz3_free %p\n", self.states[i])
+ *                     self.states[i] = NULL
+ */
+        bz3_free((__pyx_v_self->states[__pyx_v_i]));
+
+        /* "bz3/backends/cython/_bz3.pyx":556
+ *                 if self.states[i]:
+ *                     bz3_free(self.states[i])
+ *                     MEMLOG("bz3_free %p\n", self.states[i])             # <<<<<<<<<<<<<<
+ *                     self.states[i] = NULL
+ * 
+ */
+        MEMLOG(((char const *)"bz3_free %p\n"), (__pyx_v_self->states[__pyx_v_i]));
+
+        /* "bz3/backends/cython/_bz3.pyx":557
+ *                     bz3_free(self.states[i])
+ *                     MEMLOG("bz3_free %p\n", self.states[i])
+ *                     self.states[i] = NULL             # <<<<<<<<<<<<<<
  * 
  *     cdef inline void free_buffers(self):
  */
-      (__pyx_v_self->states[__pyx_v_i]) = NULL;
+        (__pyx_v_self->states[__pyx_v_i]) = NULL;
 
-      /* "bz3/backends/cython/_bz3.pyx":456
- *         cdef uint32_t i
- *         for i in range(self.numthreads):
- *             if self.states[i]:             # <<<<<<<<<<<<<<
- *                 bz3_free(self.states[i])
- *                 self.states[i] = NULL
+        /* "bz3/backends/cython/_bz3.pyx":554
+ *         if self.states:
+ *             for i in range(self.numthreads):
+ *                 if self.states[i]:             # <<<<<<<<<<<<<<
+ *                     bz3_free(self.states[i])
+ *                     MEMLOG("bz3_free %p\n", self.states[i])
  */
+      }
     }
+
+    /* "bz3/backends/cython/_bz3.pyx":552
+ *     cdef inline void free_states(self):
+ *         cdef uint32_t i
+ *         if self.states:             # <<<<<<<<<<<<<<
+ *             for i in range(self.numthreads):
+ *                 if self.states[i]:
+ */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":453
+  /* "bz3/backends/cython/_bz3.pyx":550
  *         self.numthreads = numthreads
  * 
  *     cdef inline void free_states(self):             # <<<<<<<<<<<<<<
  *         cdef uint32_t i
- *         for i in range(self.numthreads):
+ *         if self.states:
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "bz3/backends/cython/_bz3.pyx":460
- *                 self.states[i] = NULL
+/* "bz3/backends/cython/_bz3.pyx":559
+ *                     self.states[i] = NULL
  * 
  *     cdef inline void free_buffers(self):             # <<<<<<<<<<<<<<
  *         cdef uint32_t i
- *         for i in range(self.numthreads):
+ *         if self.buffers:
  */
 
 static CYTHON_INLINE void __pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_free_buffers(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *__pyx_v_self) {
   uint32_t __pyx_v_i;
   __Pyx_RefNannyDeclarations
-  uint32_t __pyx_t_1;
+  int __pyx_t_1;
   uint32_t __pyx_t_2;
   uint32_t __pyx_t_3;
-  int __pyx_t_4;
+  uint32_t __pyx_t_4;
   __Pyx_RefNannySetupContext("free_buffers", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":462
+  /* "bz3/backends/cython/_bz3.pyx":561
  *     cdef inline void free_buffers(self):
  *         cdef uint32_t i
- *         for i in range(self.numthreads):             # <<<<<<<<<<<<<<
- *             if self.buffers[i]:
- *                 PyMem_Free(self.buffers[i])
+ *         if self.buffers:             # <<<<<<<<<<<<<<
+ *             for i in range(self.numthreads):
+ *                 if self.buffers[i]:
  */
-  __pyx_t_1 = __pyx_v_self->numthreads;
-  __pyx_t_2 = __pyx_t_1;
-  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
-    __pyx_v_i = __pyx_t_3;
+  __pyx_t_1 = (__pyx_v_self->buffers != 0);
+  if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":463
+    /* "bz3/backends/cython/_bz3.pyx":562
  *         cdef uint32_t i
- *         for i in range(self.numthreads):
- *             if self.buffers[i]:             # <<<<<<<<<<<<<<
- *                 PyMem_Free(self.buffers[i])
- *                 self.buffers[i] = NULL
+ *         if self.buffers:
+ *             for i in range(self.numthreads):             # <<<<<<<<<<<<<<
+ *                 if self.buffers[i]:
+ *                     PyMem_Free(self.buffers[i])
  */
-    __pyx_t_4 = ((__pyx_v_self->buffers[__pyx_v_i]) != 0);
-    if (__pyx_t_4) {
+    __pyx_t_2 = __pyx_v_self->numthreads;
+    __pyx_t_3 = __pyx_t_2;
+    for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
+      __pyx_v_i = __pyx_t_4;
 
-      /* "bz3/backends/cython/_bz3.pyx":464
- *         for i in range(self.numthreads):
- *             if self.buffers[i]:
- *                 PyMem_Free(self.buffers[i])             # <<<<<<<<<<<<<<
- *                 self.buffers[i] = NULL
- * 
+      /* "bz3/backends/cython/_bz3.pyx":563
+ *         if self.buffers:
+ *             for i in range(self.numthreads):
+ *                 if self.buffers[i]:             # <<<<<<<<<<<<<<
+ *                     PyMem_Free(self.buffers[i])
+ *                     MEMLOG("PyMem_Free %p\n", self.buffers[i])
  */
-      PyMem_Free((__pyx_v_self->buffers[__pyx_v_i]));
+      __pyx_t_1 = ((__pyx_v_self->buffers[__pyx_v_i]) != 0);
+      if (__pyx_t_1) {
 
-      /* "bz3/backends/cython/_bz3.pyx":465
- *             if self.buffers[i]:
- *                 PyMem_Free(self.buffers[i])
- *                 self.buffers[i] = NULL             # <<<<<<<<<<<<<<
+        /* "bz3/backends/cython/_bz3.pyx":564
+ *             for i in range(self.numthreads):
+ *                 if self.buffers[i]:
+ *                     PyMem_Free(self.buffers[i])             # <<<<<<<<<<<<<<
+ *                     MEMLOG("PyMem_Free %p\n", self.buffers[i])
+ *                     self.buffers[i] = NULL
+ */
+        PyMem_Free((__pyx_v_self->buffers[__pyx_v_i]));
+
+        /* "bz3/backends/cython/_bz3.pyx":565
+ *                 if self.buffers[i]:
+ *                     PyMem_Free(self.buffers[i])
+ *                     MEMLOG("PyMem_Free %p\n", self.buffers[i])             # <<<<<<<<<<<<<<
+ *                     self.buffers[i] = NULL
+ * 
+ */
+        MEMLOG(((char const *)"PyMem_Free %p\n"), (__pyx_v_self->buffers[__pyx_v_i]));
+
+        /* "bz3/backends/cython/_bz3.pyx":566
+ *                     PyMem_Free(self.buffers[i])
+ *                     MEMLOG("PyMem_Free %p\n", self.buffers[i])
+ *                     self.buffers[i] = NULL             # <<<<<<<<<<<<<<
  * 
  *     def __dealloc__(self):
  */
-      (__pyx_v_self->buffers[__pyx_v_i]) = NULL;
+        (__pyx_v_self->buffers[__pyx_v_i]) = NULL;
 
-      /* "bz3/backends/cython/_bz3.pyx":463
- *         cdef uint32_t i
- *         for i in range(self.numthreads):
- *             if self.buffers[i]:             # <<<<<<<<<<<<<<
- *                 PyMem_Free(self.buffers[i])
- *                 self.buffers[i] = NULL
+        /* "bz3/backends/cython/_bz3.pyx":563
+ *         if self.buffers:
+ *             for i in range(self.numthreads):
+ *                 if self.buffers[i]:             # <<<<<<<<<<<<<<
+ *                     PyMem_Free(self.buffers[i])
+ *                     MEMLOG("PyMem_Free %p\n", self.buffers[i])
  */
+      }
     }
+
+    /* "bz3/backends/cython/_bz3.pyx":561
+ *     cdef inline void free_buffers(self):
+ *         cdef uint32_t i
+ *         if self.buffers:             # <<<<<<<<<<<<<<
+ *             for i in range(self.numthreads):
+ *                 if self.buffers[i]:
+ */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":460
- *                 self.states[i] = NULL
+  /* "bz3/backends/cython/_bz3.pyx":559
+ *                     self.states[i] = NULL
  * 
  *     cdef inline void free_buffers(self):             # <<<<<<<<<<<<<<
  *         cdef uint32_t i
- *         for i in range(self.numthreads):
+ *         if self.buffers:
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "bz3/backends/cython/_bz3.pyx":467
- *                 self.buffers[i] = NULL
+/* "bz3/backends/cython/_bz3.pyx":568
+ *                     self.buffers[i] = NULL
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         cdef uint32_t i
  *         self.free_states()
  */
 
 /* Python wrapper */
@@ -9785,158 +11448,230 @@
 }
 
 static void __pyx_pf_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_2__dealloc__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":469
+  /* "bz3/backends/cython/_bz3.pyx":570
  *     def __dealloc__(self):
  *         cdef uint32_t i
  *         self.free_states()             # <<<<<<<<<<<<<<
  *         self.free_buffers()
  *         if self.states:
  */
   __pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_free_states(__pyx_v_self);
 
-  /* "bz3/backends/cython/_bz3.pyx":470
+  /* "bz3/backends/cython/_bz3.pyx":571
  *         cdef uint32_t i
  *         self.free_states()
  *         self.free_buffers()             # <<<<<<<<<<<<<<
  *         if self.states:
  *             PyMem_Free(self.states)
  */
   __pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_free_buffers(__pyx_v_self);
 
-  /* "bz3/backends/cython/_bz3.pyx":471
+  /* "bz3/backends/cython/_bz3.pyx":572
  *         self.free_states()
  *         self.free_buffers()
  *         if self.states:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.states)
- *         if self.buffers:
+ *             MEMLOG("PyMem_Free %p\n", self.states)
  */
   __pyx_t_1 = (__pyx_v_self->states != 0);
   if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":472
+    /* "bz3/backends/cython/_bz3.pyx":573
  *         self.free_buffers()
  *         if self.states:
  *             PyMem_Free(self.states)             # <<<<<<<<<<<<<<
+ *             MEMLOG("PyMem_Free %p\n", self.states)
+ *             self.states = NULL
+ */
+    PyMem_Free(__pyx_v_self->states);
+
+    /* "bz3/backends/cython/_bz3.pyx":574
+ *         if self.states:
+ *             PyMem_Free(self.states)
+ *             MEMLOG("PyMem_Free %p\n", self.states)             # <<<<<<<<<<<<<<
+ *             self.states = NULL
+ *         if self.buffers:
+ */
+    MEMLOG(((char const *)"PyMem_Free %p\n"), __pyx_v_self->states);
+
+    /* "bz3/backends/cython/_bz3.pyx":575
+ *             PyMem_Free(self.states)
+ *             MEMLOG("PyMem_Free %p\n", self.states)
+ *             self.states = NULL             # <<<<<<<<<<<<<<
  *         if self.buffers:
  *             PyMem_Free(self.buffers)
  */
-    PyMem_Free(__pyx_v_self->states);
+    __pyx_v_self->states = NULL;
 
-    /* "bz3/backends/cython/_bz3.pyx":471
+    /* "bz3/backends/cython/_bz3.pyx":572
  *         self.free_states()
  *         self.free_buffers()
  *         if self.states:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.states)
- *         if self.buffers:
+ *             MEMLOG("PyMem_Free %p\n", self.states)
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":473
- *         if self.states:
- *             PyMem_Free(self.states)
+  /* "bz3/backends/cython/_bz3.pyx":576
+ *             MEMLOG("PyMem_Free %p\n", self.states)
+ *             self.states = NULL
  *         if self.buffers:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.buffers)
- *         if self.sizes:
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
  */
   __pyx_t_1 = (__pyx_v_self->buffers != 0);
   if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":474
- *             PyMem_Free(self.states)
+    /* "bz3/backends/cython/_bz3.pyx":577
+ *             self.states = NULL
  *         if self.buffers:
  *             PyMem_Free(self.buffers)             # <<<<<<<<<<<<<<
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
+ *             self.buffers = NULL
+ */
+    PyMem_Free(__pyx_v_self->buffers);
+
+    /* "bz3/backends/cython/_bz3.pyx":578
+ *         if self.buffers:
+ *             PyMem_Free(self.buffers)
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)             # <<<<<<<<<<<<<<
+ *             self.buffers = NULL
+ *         if self.sizes:
+ */
+    MEMLOG(((char const *)"PyMem_Free %p\n"), __pyx_v_self->buffers);
+
+    /* "bz3/backends/cython/_bz3.pyx":579
+ *             PyMem_Free(self.buffers)
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
+ *             self.buffers = NULL             # <<<<<<<<<<<<<<
  *         if self.sizes:
  *             PyMem_Free(self.sizes)
  */
-    PyMem_Free(__pyx_v_self->buffers);
+    __pyx_v_self->buffers = NULL;
 
-    /* "bz3/backends/cython/_bz3.pyx":473
- *         if self.states:
- *             PyMem_Free(self.states)
+    /* "bz3/backends/cython/_bz3.pyx":576
+ *             MEMLOG("PyMem_Free %p\n", self.states)
+ *             self.states = NULL
  *         if self.buffers:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.buffers)
- *         if self.sizes:
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":475
- *         if self.buffers:
- *             PyMem_Free(self.buffers)
+  /* "bz3/backends/cython/_bz3.pyx":580
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
+ *             self.buffers = NULL
  *         if self.sizes:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.sizes)
- *         if self.old_sizes:
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)
  */
   __pyx_t_1 = (__pyx_v_self->sizes != 0);
   if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":476
- *             PyMem_Free(self.buffers)
+    /* "bz3/backends/cython/_bz3.pyx":581
+ *             self.buffers = NULL
  *         if self.sizes:
  *             PyMem_Free(self.sizes)             # <<<<<<<<<<<<<<
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)
+ *             self.sizes = NULL
+ */
+    PyMem_Free(__pyx_v_self->sizes);
+
+    /* "bz3/backends/cython/_bz3.pyx":582
+ *         if self.sizes:
+ *             PyMem_Free(self.sizes)
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)             # <<<<<<<<<<<<<<
+ *             self.sizes = NULL
+ *         if self.old_sizes:
+ */
+    MEMLOG(((char const *)"PyMem_Free %p\n"), __pyx_v_self->sizes);
+
+    /* "bz3/backends/cython/_bz3.pyx":583
+ *             PyMem_Free(self.sizes)
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)
+ *             self.sizes = NULL             # <<<<<<<<<<<<<<
  *         if self.old_sizes:
  *             PyMem_Free(self.old_sizes)
  */
-    PyMem_Free(__pyx_v_self->sizes);
+    __pyx_v_self->sizes = NULL;
 
-    /* "bz3/backends/cython/_bz3.pyx":475
- *         if self.buffers:
- *             PyMem_Free(self.buffers)
+    /* "bz3/backends/cython/_bz3.pyx":580
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
+ *             self.buffers = NULL
  *         if self.sizes:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.sizes)
- *         if self.old_sizes:
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":477
- *         if self.sizes:
- *             PyMem_Free(self.sizes)
+  /* "bz3/backends/cython/_bz3.pyx":584
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)
+ *             self.sizes = NULL
  *         if self.old_sizes:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.old_sizes)
- * 
+ *             MEMLOG("PyMem_Free %p\n", self.old_sizes)
  */
   __pyx_t_1 = (__pyx_v_self->old_sizes != 0);
   if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":478
- *             PyMem_Free(self.sizes)
+    /* "bz3/backends/cython/_bz3.pyx":585
+ *             self.sizes = NULL
  *         if self.old_sizes:
  *             PyMem_Free(self.old_sizes)             # <<<<<<<<<<<<<<
+ *             MEMLOG("PyMem_Free %p\n", self.old_sizes)
+ *             self.old_sizes = NULL
+ */
+    PyMem_Free(__pyx_v_self->old_sizes);
+
+    /* "bz3/backends/cython/_bz3.pyx":586
+ *         if self.old_sizes:
+ *             PyMem_Free(self.old_sizes)
+ *             MEMLOG("PyMem_Free %p\n", self.old_sizes)             # <<<<<<<<<<<<<<
+ *             self.old_sizes = NULL
+ * 
+ */
+    MEMLOG(((char const *)"PyMem_Free %p\n"), __pyx_v_self->old_sizes);
+
+    /* "bz3/backends/cython/_bz3.pyx":587
+ *             PyMem_Free(self.old_sizes)
+ *             MEMLOG("PyMem_Free %p\n", self.old_sizes)
+ *             self.old_sizes = NULL             # <<<<<<<<<<<<<<
  * 
  *     cpdef inline bytes compress(self, const uint8_t[::1] data):
  */
-    PyMem_Free(__pyx_v_self->old_sizes);
+    __pyx_v_self->old_sizes = NULL;
 
-    /* "bz3/backends/cython/_bz3.pyx":477
- *         if self.sizes:
- *             PyMem_Free(self.sizes)
+    /* "bz3/backends/cython/_bz3.pyx":584
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)
+ *             self.sizes = NULL
  *         if self.old_sizes:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.old_sizes)
- * 
+ *             MEMLOG("PyMem_Free %p\n", self.old_sizes)
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":467
- *                 self.buffers[i] = NULL
+  /* "bz3/backends/cython/_bz3.pyx":568
+ *                     self.buffers[i] = NULL
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         cdef uint32_t i
  *         self.free_states()
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "bz3/backends/cython/_bz3.pyx":480
- *             PyMem_Free(self.old_sizes)
+/* "bz3/backends/cython/_bz3.pyx":589
+ *             self.old_sizes = NULL
  * 
  *     cpdef inline bytes compress(self, const uint8_t[::1] data):             # <<<<<<<<<<<<<<
  *         cdef Py_ssize_t input_size = data.shape[0]
  *         cdef int32_t new_size
  */
 
 static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_5compress(PyObject *__pyx_v_self, PyObject *__pyx_arg_data); /*proto*/
@@ -9957,351 +11692,351 @@
   uint32_t __pyx_t_8;
   int32_t __pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("compress", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":481
+  /* "bz3/backends/cython/_bz3.pyx":590
  * 
  *     cpdef inline bytes compress(self, const uint8_t[::1] data):
  *         cdef Py_ssize_t input_size = data.shape[0]             # <<<<<<<<<<<<<<
  *         cdef int32_t new_size
  *         cdef bytearray ret = bytearray()
  */
   __pyx_v_input_size = (__pyx_v_data.shape[0]);
 
-  /* "bz3/backends/cython/_bz3.pyx":483
+  /* "bz3/backends/cython/_bz3.pyx":592
  *         cdef Py_ssize_t input_size = data.shape[0]
  *         cdef int32_t new_size
  *         cdef bytearray ret = bytearray()             # <<<<<<<<<<<<<<
  *         cdef int32_t all_blocks_size = self.block_size * self.numthreads
  *         if not self.have_magic_number:
  */
-  __pyx_t_1 = __Pyx_PyObject_CallNoArg(((PyObject *)(&PyByteArray_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 483, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_CallNoArg(((PyObject *)(&PyByteArray_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 592, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_ret = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":484
+  /* "bz3/backends/cython/_bz3.pyx":593
  *         cdef int32_t new_size
  *         cdef bytearray ret = bytearray()
  *         cdef int32_t all_blocks_size = self.block_size * self.numthreads             # <<<<<<<<<<<<<<
  *         if not self.have_magic_number:
  *             # if PyByteArray_Resize(ret, 9) < 0:
  */
   __pyx_v_all_blocks_size = (__pyx_v_self->block_size * __pyx_v_self->numthreads);
 
-  /* "bz3/backends/cython/_bz3.pyx":485
+  /* "bz3/backends/cython/_bz3.pyx":594
  *         cdef bytearray ret = bytearray()
  *         cdef int32_t all_blocks_size = self.block_size * self.numthreads
  *         if not self.have_magic_number:             # <<<<<<<<<<<<<<
  *             # if PyByteArray_Resize(ret, 9) < 0:
  *             #     raise
  */
   __pyx_t_2 = ((!(__pyx_v_self->have_magic_number != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "bz3/backends/cython/_bz3.pyx":489
+    /* "bz3/backends/cython/_bz3.pyx":598
  *             #     raise
  *             # memcpy(PyByteArray_AS_STRING(ret), magic, 5)
  *             ret.extend(<bytes>magic[:5]+b"\x00\x00\x00\x00")  # 9 bytes             # <<<<<<<<<<<<<<
  *             write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[5]), self.block_size)
  *             self.have_magic_number = 1
  */
-    __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_3bz3_8backends_6cython_4_bz3_magic + 0, 5 - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 489, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_3bz3_8backends_6cython_4_bz3_magic + 0, 5 - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 598, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = PyNumber_Add(__pyx_t_1, __pyx_kp_b__4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 489, __pyx_L1_error)
+    __pyx_t_3 = PyNumber_Add(__pyx_t_1, __pyx_kp_b__4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 598, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = __Pyx_CallUnboundCMethod1(&__pyx_umethod_PyByteArray_Type_extend, __pyx_v_ret, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 489, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_CallUnboundCMethod1(&__pyx_umethod_PyByteArray_Type_extend, __pyx_v_ret, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 598, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "bz3/backends/cython/_bz3.pyx":490
+    /* "bz3/backends/cython/_bz3.pyx":599
  *             # memcpy(PyByteArray_AS_STRING(ret), magic, 5)
  *             ret.extend(<bytes>magic[:5]+b"\x00\x00\x00\x00")  # 9 bytes
  *             write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[5]), self.block_size)             # <<<<<<<<<<<<<<
  *             self.have_magic_number = 1
  *         cdef uint32_t i
  */
     write_neutral_s32(((uint8_t *)(&(PyByteArray_AS_STRING(__pyx_v_ret)[5]))), __pyx_v_self->block_size);
 
-    /* "bz3/backends/cython/_bz3.pyx":491
+    /* "bz3/backends/cython/_bz3.pyx":600
  *             ret.extend(<bytes>magic[:5]+b"\x00\x00\x00\x00")  # 9 bytes
  *             write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[5]), self.block_size)
  *             self.have_magic_number = 1             # <<<<<<<<<<<<<<
  *         cdef uint32_t i
  *         if input_size > 0:
  */
     __pyx_v_self->have_magic_number = 1;
 
-    /* "bz3/backends/cython/_bz3.pyx":485
+    /* "bz3/backends/cython/_bz3.pyx":594
  *         cdef bytearray ret = bytearray()
  *         cdef int32_t all_blocks_size = self.block_size * self.numthreads
  *         if not self.have_magic_number:             # <<<<<<<<<<<<<<
  *             # if PyByteArray_Resize(ret, 9) < 0:
  *             #     raise
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":493
+  /* "bz3/backends/cython/_bz3.pyx":602
  *             self.have_magic_number = 1
  *         cdef uint32_t i
  *         if input_size > 0:             # <<<<<<<<<<<<<<
  *             # if PyByteArray_Resize(self.uncompressed, input_size+PyByteArray_GET_SIZE(self.uncompressed)) < 0:
  *             #     raise
  */
   __pyx_t_2 = ((__pyx_v_input_size > 0) != 0);
   if (__pyx_t_2) {
 
-    /* "bz3/backends/cython/_bz3.pyx":497
+    /* "bz3/backends/cython/_bz3.pyx":606
  *             #     raise
  *             # memcpy(&(PyByteArray_AS_STRING(self.uncompressed)[PyByteArray_GET_SIZE(self.uncompressed)-input_size]), &data[0], input_size) # todo? direct copy to bytearray
  *             self.uncompressed.extend(data)             # <<<<<<<<<<<<<<
  *             if PyByteArray_GET_SIZE(self.uncompressed) >= all_blocks_size:  # able to perform a compress
  *                 while PyByteArray_GET_SIZE(self.uncompressed) >= all_blocks_size:  # ensure fill all blocks
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->uncompressed, __pyx_n_s_extend); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 497, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->uncompressed, __pyx_n_s_extend); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 606, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __pyx_memoryview_fromslice(__pyx_v_data, 1, (PyObject *(*)(char *)) __pyx_memview_get_nn_uint8_t__const__, (int (*)(char *, PyObject *)) NULL, 0);; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 497, __pyx_L1_error)
+    __pyx_t_4 = __pyx_memoryview_fromslice(__pyx_v_data, 1, (PyObject *(*)(char *)) __pyx_memview_get_nn_uint8_t__const__, (int (*)(char *, PyObject *)) NULL, 0);; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 606, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_5 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
     __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 497, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 606, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "bz3/backends/cython/_bz3.pyx":498
+    /* "bz3/backends/cython/_bz3.pyx":607
  *             # memcpy(&(PyByteArray_AS_STRING(self.uncompressed)[PyByteArray_GET_SIZE(self.uncompressed)-input_size]), &data[0], input_size) # todo? direct copy to bytearray
  *             self.uncompressed.extend(data)
  *             if PyByteArray_GET_SIZE(self.uncompressed) >= all_blocks_size:  # able to perform a compress             # <<<<<<<<<<<<<<
  *                 while PyByteArray_GET_SIZE(self.uncompressed) >= all_blocks_size:  # ensure fill all blocks
  *                     for i in range(self.numthreads):
  */
     __pyx_t_1 = __pyx_v_self->uncompressed;
     __Pyx_INCREF(__pyx_t_1);
     __pyx_t_2 = ((PyByteArray_GET_SIZE(__pyx_t_1) >= __pyx_v_all_blocks_size) != 0);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     if (__pyx_t_2) {
 
-      /* "bz3/backends/cython/_bz3.pyx":499
+      /* "bz3/backends/cython/_bz3.pyx":608
  *             self.uncompressed.extend(data)
  *             if PyByteArray_GET_SIZE(self.uncompressed) >= all_blocks_size:  # able to perform a compress
  *                 while PyByteArray_GET_SIZE(self.uncompressed) >= all_blocks_size:  # ensure fill all blocks             # <<<<<<<<<<<<<<
  *                     for i in range(self.numthreads):
  *                         self.sizes[i] = self.block_size  # fill the sizes array
  */
       while (1) {
         __pyx_t_1 = __pyx_v_self->uncompressed;
         __Pyx_INCREF(__pyx_t_1);
         __pyx_t_2 = ((PyByteArray_GET_SIZE(__pyx_t_1) >= __pyx_v_all_blocks_size) != 0);
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
         if (!__pyx_t_2) break;
 
-        /* "bz3/backends/cython/_bz3.pyx":500
+        /* "bz3/backends/cython/_bz3.pyx":609
  *             if PyByteArray_GET_SIZE(self.uncompressed) >= all_blocks_size:  # able to perform a compress
  *                 while PyByteArray_GET_SIZE(self.uncompressed) >= all_blocks_size:  # ensure fill all blocks
  *                     for i in range(self.numthreads):             # <<<<<<<<<<<<<<
  *                         self.sizes[i] = self.block_size  # fill the sizes array
  *                         memcpy(self.buffers[i], &PyByteArray_AS_STRING(self.uncompressed)[i*self.block_size], <size_t>self.block_size)
  */
         __pyx_t_6 = __pyx_v_self->numthreads;
         __pyx_t_7 = __pyx_t_6;
         for (__pyx_t_8 = 0; __pyx_t_8 < __pyx_t_7; __pyx_t_8+=1) {
           __pyx_v_i = __pyx_t_8;
 
-          /* "bz3/backends/cython/_bz3.pyx":501
+          /* "bz3/backends/cython/_bz3.pyx":610
  *                 while PyByteArray_GET_SIZE(self.uncompressed) >= all_blocks_size:  # ensure fill all blocks
  *                     for i in range(self.numthreads):
  *                         self.sizes[i] = self.block_size  # fill the sizes array             # <<<<<<<<<<<<<<
  *                         memcpy(self.buffers[i], &PyByteArray_AS_STRING(self.uncompressed)[i*self.block_size], <size_t>self.block_size)
  *                         # make a copy
  */
           __pyx_t_9 = __pyx_v_self->block_size;
           (__pyx_v_self->sizes[__pyx_v_i]) = __pyx_t_9;
 
-          /* "bz3/backends/cython/_bz3.pyx":502
+          /* "bz3/backends/cython/_bz3.pyx":611
  *                     for i in range(self.numthreads):
  *                         self.sizes[i] = self.block_size  # fill the sizes array
  *                         memcpy(self.buffers[i], &PyByteArray_AS_STRING(self.uncompressed)[i*self.block_size], <size_t>self.block_size)             # <<<<<<<<<<<<<<
  *                         # make a copy
  *                     bz3_encode_blocks(self.states, self.buffers, self.sizes, <int32_t>self.numthreads)
  */
           __pyx_t_1 = __pyx_v_self->uncompressed;
           __Pyx_INCREF(__pyx_t_1);
           (void)(memcpy((__pyx_v_self->buffers[__pyx_v_i]), (&(PyByteArray_AS_STRING(__pyx_t_1)[(__pyx_v_i * __pyx_v_self->block_size)])), ((size_t)__pyx_v_self->block_size)));
           __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
         }
 
-        /* "bz3/backends/cython/_bz3.pyx":504
+        /* "bz3/backends/cython/_bz3.pyx":613
  *                         memcpy(self.buffers[i], &PyByteArray_AS_STRING(self.uncompressed)[i*self.block_size], <size_t>self.block_size)
  *                         # make a copy
  *                     bz3_encode_blocks(self.states, self.buffers, self.sizes, <int32_t>self.numthreads)             # <<<<<<<<<<<<<<
  *                     for i in range(self.numthreads):
  *                         if bz3_last_error(self.states[i]) != BZ3_OK:
  */
         __pyx_f_3bz3_8backends_6cython_4_bz3_bz3_encode_blocks(__pyx_v_self->states, __pyx_v_self->buffers, __pyx_v_self->sizes, ((int32_t)__pyx_v_self->numthreads));
 
-        /* "bz3/backends/cython/_bz3.pyx":505
+        /* "bz3/backends/cython/_bz3.pyx":614
  *                         # make a copy
  *                     bz3_encode_blocks(self.states, self.buffers, self.sizes, <int32_t>self.numthreads)
  *                     for i in range(self.numthreads):             # <<<<<<<<<<<<<<
  *                         if bz3_last_error(self.states[i]) != BZ3_OK:
  *                             raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.states[i]))
  */
         __pyx_t_6 = __pyx_v_self->numthreads;
         __pyx_t_7 = __pyx_t_6;
         for (__pyx_t_8 = 0; __pyx_t_8 < __pyx_t_7; __pyx_t_8+=1) {
           __pyx_v_i = __pyx_t_8;
 
-          /* "bz3/backends/cython/_bz3.pyx":506
+          /* "bz3/backends/cython/_bz3.pyx":615
  *                     bz3_encode_blocks(self.states, self.buffers, self.sizes, <int32_t>self.numthreads)
  *                     for i in range(self.numthreads):
  *                         if bz3_last_error(self.states[i]) != BZ3_OK:             # <<<<<<<<<<<<<<
  *                             raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.states[i]))
  *                         # if PyByteArray_Resize(ret, PyByteArray_GET_SIZE(ret) + new_size + 8) < 0:
  */
           __pyx_t_2 = ((bz3_last_error((__pyx_v_self->states[__pyx_v_i])) != BZ3_OK) != 0);
           if (unlikely(__pyx_t_2)) {
 
-            /* "bz3/backends/cython/_bz3.pyx":507
+            /* "bz3/backends/cython/_bz3.pyx":616
  *                     for i in range(self.numthreads):
  *                         if bz3_last_error(self.states[i]) != BZ3_OK:
  *                             raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.states[i]))             # <<<<<<<<<<<<<<
  *                         # if PyByteArray_Resize(ret, PyByteArray_GET_SIZE(ret) + new_size + 8) < 0:
  *                         #     raise
  */
-            __pyx_t_1 = __Pyx_PyBytes_FromString(bz3_strerror((__pyx_v_self->states[__pyx_v_i]))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 507, __pyx_L1_error)
+            __pyx_t_1 = __Pyx_PyBytes_FromString(bz3_strerror((__pyx_v_self->states[__pyx_v_i]))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 616, __pyx_L1_error)
             __Pyx_GOTREF(__pyx_t_1);
-            __pyx_t_3 = PyUnicode_Format(__pyx_kp_u_Failed_to_encode_a_block_s, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 507, __pyx_L1_error)
+            __pyx_t_3 = PyUnicode_Format(__pyx_kp_u_Failed_to_encode_a_block_s, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 616, __pyx_L1_error)
             __Pyx_GOTREF(__pyx_t_3);
             __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-            __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 507, __pyx_L1_error)
+            __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 616, __pyx_L1_error)
             __Pyx_GOTREF(__pyx_t_1);
             __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
             __Pyx_Raise(__pyx_t_1, 0, 0, 0);
             __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-            __PYX_ERR(0, 507, __pyx_L1_error)
+            __PYX_ERR(0, 616, __pyx_L1_error)
 
-            /* "bz3/backends/cython/_bz3.pyx":506
+            /* "bz3/backends/cython/_bz3.pyx":615
  *                     bz3_encode_blocks(self.states, self.buffers, self.sizes, <int32_t>self.numthreads)
  *                     for i in range(self.numthreads):
  *                         if bz3_last_error(self.states[i]) != BZ3_OK:             # <<<<<<<<<<<<<<
  *                             raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.states[i]))
  *                         # if PyByteArray_Resize(ret, PyByteArray_GET_SIZE(ret) + new_size + 8) < 0:
  */
           }
 
-          /* "bz3/backends/cython/_bz3.pyx":510
+          /* "bz3/backends/cython/_bz3.pyx":619
  *                         # if PyByteArray_Resize(ret, PyByteArray_GET_SIZE(ret) + new_size + 8) < 0:
  *                         #     raise
  *                         ret.extend((self.sizes[i] + 8)*b"\x00")             # <<<<<<<<<<<<<<
  *                         write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-self.sizes[i]-8]), self.sizes[i])
  *                         write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-self.sizes[i]-4]), self.block_size)
  */
-          __pyx_t_1 = __Pyx_PyInt_From_long(((__pyx_v_self->sizes[__pyx_v_i]) + 8)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 510, __pyx_L1_error)
+          __pyx_t_1 = __Pyx_PyInt_From_long(((__pyx_v_self->sizes[__pyx_v_i]) + 8)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 619, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_1);
-          __pyx_t_3 = PyNumber_Multiply(__pyx_t_1, __pyx_kp_b__5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 510, __pyx_L1_error)
+          __pyx_t_3 = PyNumber_Multiply(__pyx_t_1, __pyx_kp_b__5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 619, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_3);
           __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-          __pyx_t_1 = __Pyx_CallUnboundCMethod1(&__pyx_umethod_PyByteArray_Type_extend, __pyx_v_ret, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 510, __pyx_L1_error)
+          __pyx_t_1 = __Pyx_CallUnboundCMethod1(&__pyx_umethod_PyByteArray_Type_extend, __pyx_v_ret, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 619, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_1);
           __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
           __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-          /* "bz3/backends/cython/_bz3.pyx":511
+          /* "bz3/backends/cython/_bz3.pyx":620
  *                         #     raise
  *                         ret.extend((self.sizes[i] + 8)*b"\x00")
  *                         write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-self.sizes[i]-8]), self.sizes[i])             # <<<<<<<<<<<<<<
  *                         write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-self.sizes[i]-4]), self.block_size)
  *                         memcpy(&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-self.sizes[i]]), self.buffers[i], <size_t>self.sizes[i])
  */
           write_neutral_s32(((uint8_t *)(&(PyByteArray_AS_STRING(__pyx_v_ret)[((PyByteArray_GET_SIZE(__pyx_v_ret) - (__pyx_v_self->sizes[__pyx_v_i])) - 8)]))), (__pyx_v_self->sizes[__pyx_v_i]));
 
-          /* "bz3/backends/cython/_bz3.pyx":512
+          /* "bz3/backends/cython/_bz3.pyx":621
  *                         ret.extend((self.sizes[i] + 8)*b"\x00")
  *                         write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-self.sizes[i]-8]), self.sizes[i])
  *                         write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-self.sizes[i]-4]), self.block_size)             # <<<<<<<<<<<<<<
  *                         memcpy(&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-self.sizes[i]]), self.buffers[i], <size_t>self.sizes[i])
  * 
  */
           write_neutral_s32(((uint8_t *)(&(PyByteArray_AS_STRING(__pyx_v_ret)[((PyByteArray_GET_SIZE(__pyx_v_ret) - (__pyx_v_self->sizes[__pyx_v_i])) - 4)]))), __pyx_v_self->block_size);
 
-          /* "bz3/backends/cython/_bz3.pyx":513
+          /* "bz3/backends/cython/_bz3.pyx":622
  *                         write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-self.sizes[i]-8]), self.sizes[i])
  *                         write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-self.sizes[i]-4]), self.block_size)
  *                         memcpy(&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-self.sizes[i]]), self.buffers[i], <size_t>self.sizes[i])             # <<<<<<<<<<<<<<
  * 
  *                     del self.uncompressed[:all_blocks_size]
  */
           (void)(memcpy((&(PyByteArray_AS_STRING(__pyx_v_ret)[(PyByteArray_GET_SIZE(__pyx_v_ret) - (__pyx_v_self->sizes[__pyx_v_i]))])), (__pyx_v_self->buffers[__pyx_v_i]), ((size_t)(__pyx_v_self->sizes[__pyx_v_i]))));
         }
 
-        /* "bz3/backends/cython/_bz3.pyx":515
+        /* "bz3/backends/cython/_bz3.pyx":624
  *                         memcpy(&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-self.sizes[i]]), self.buffers[i], <size_t>self.sizes[i])
  * 
  *                     del self.uncompressed[:all_blocks_size]             # <<<<<<<<<<<<<<
  *             return bytes(ret)
  * 
  */
         if (unlikely(__pyx_v_self->uncompressed == Py_None)) {
           PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
-          __PYX_ERR(0, 515, __pyx_L1_error)
+          __PYX_ERR(0, 624, __pyx_L1_error)
         }
-        if (__Pyx_PyObject_DelSlice(__pyx_v_self->uncompressed, 0, __pyx_v_all_blocks_size, NULL, NULL, NULL, 0, 1, 0) < 0) __PYX_ERR(0, 515, __pyx_L1_error)
+        if (__Pyx_PyObject_DelSlice(__pyx_v_self->uncompressed, 0, __pyx_v_all_blocks_size, NULL, NULL, NULL, 0, 1, 0) < 0) __PYX_ERR(0, 624, __pyx_L1_error)
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":498
+      /* "bz3/backends/cython/_bz3.pyx":607
  *             # memcpy(&(PyByteArray_AS_STRING(self.uncompressed)[PyByteArray_GET_SIZE(self.uncompressed)-input_size]), &data[0], input_size) # todo? direct copy to bytearray
  *             self.uncompressed.extend(data)
  *             if PyByteArray_GET_SIZE(self.uncompressed) >= all_blocks_size:  # able to perform a compress             # <<<<<<<<<<<<<<
  *                 while PyByteArray_GET_SIZE(self.uncompressed) >= all_blocks_size:  # ensure fill all blocks
  *                     for i in range(self.numthreads):
  */
     }
 
-    /* "bz3/backends/cython/_bz3.pyx":516
+    /* "bz3/backends/cython/_bz3.pyx":625
  * 
  *                     del self.uncompressed[:all_blocks_size]
  *             return bytes(ret)             # <<<<<<<<<<<<<<
  * 
  *     cpdef inline bytes flush(self):
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_ret); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 516, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_ret); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 625, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __pyx_r = ((PyObject*)__pyx_t_1);
     __pyx_t_1 = 0;
     goto __pyx_L0;
 
-    /* "bz3/backends/cython/_bz3.pyx":493
+    /* "bz3/backends/cython/_bz3.pyx":602
  *             self.have_magic_number = 1
  *         cdef uint32_t i
  *         if input_size > 0:             # <<<<<<<<<<<<<<
  *             # if PyByteArray_Resize(self.uncompressed, input_size+PyByteArray_GET_SIZE(self.uncompressed)) < 0:
  *             #     raise
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":480
- *             PyMem_Free(self.old_sizes)
+  /* "bz3/backends/cython/_bz3.pyx":589
+ *             self.old_sizes = NULL
  * 
  *     cpdef inline bytes compress(self, const uint8_t[::1] data):             # <<<<<<<<<<<<<<
  *         cdef Py_ssize_t input_size = data.shape[0]
  *         cdef int32_t new_size
  */
 
   /* function exit code */
@@ -10329,15 +12064,15 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("compress (wrapper)", 0);
   assert(__pyx_arg_data); {
-    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t__const__(__pyx_arg_data, 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 480, __pyx_L3_error)
+    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t__const__(__pyx_arg_data, 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 589, __pyx_L3_error)
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   __Pyx_AddTraceback("bz3.backends.cython._bz3.BZ3OmpCompressor.compress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
@@ -10353,16 +12088,16 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("compress", 0);
   __Pyx_XDECREF(__pyx_r);
-  if (unlikely(!__pyx_v_data.memview)) { __Pyx_RaiseUnboundLocalError("data"); __PYX_ERR(0, 480, __pyx_L1_error) }
-  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_compress(__pyx_v_self, __pyx_v_data, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 480, __pyx_L1_error)
+  if (unlikely(!__pyx_v_data.memview)) { __Pyx_RaiseUnboundLocalError("data"); __PYX_ERR(0, 589, __pyx_L1_error) }
+  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_compress(__pyx_v_self, __pyx_v_data, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 589, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -10372,15 +12107,15 @@
   __pyx_L0:;
   __PYX_XDEC_MEMVIEW(&__pyx_v_data, 1);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":518
+/* "bz3/backends/cython/_bz3.pyx":627
  *             return bytes(ret)
  * 
  *     cpdef inline bytes flush(self):             # <<<<<<<<<<<<<<
  *         cdef bytearray ret = bytearray()
  *         cdef int32_t new_size
  */
 
@@ -10401,303 +12136,303 @@
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("flush", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":519
+  /* "bz3/backends/cython/_bz3.pyx":628
  * 
  *     cpdef inline bytes flush(self):
  *         cdef bytearray ret = bytearray()             # <<<<<<<<<<<<<<
  *         cdef int32_t new_size
  *         cdef int32_t remain_size = <int32_t>PyByteArray_GET_SIZE(self.uncompressed)
  */
-  __pyx_t_1 = __Pyx_PyObject_CallNoArg(((PyObject *)(&PyByteArray_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 519, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_CallNoArg(((PyObject *)(&PyByteArray_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 628, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_ret = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":521
+  /* "bz3/backends/cython/_bz3.pyx":630
  *         cdef bytearray ret = bytearray()
  *         cdef int32_t new_size
  *         cdef int32_t remain_size = <int32_t>PyByteArray_GET_SIZE(self.uncompressed)             # <<<<<<<<<<<<<<
  *         cdef:
  *             int i = 0  # thread count
  */
   __pyx_t_1 = __pyx_v_self->uncompressed;
   __Pyx_INCREF(__pyx_t_1);
   __pyx_v_remain_size = ((int32_t)PyByteArray_GET_SIZE(__pyx_t_1));
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":523
+  /* "bz3/backends/cython/_bz3.pyx":632
  *         cdef int32_t remain_size = <int32_t>PyByteArray_GET_SIZE(self.uncompressed)
  *         cdef:
  *             int i = 0  # thread count             # <<<<<<<<<<<<<<
  *             int j
  *         if self.uncompressed:  # will perform a compress
  */
   __pyx_v_i = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":525
+  /* "bz3/backends/cython/_bz3.pyx":634
  *             int i = 0  # thread count
  *             int j
  *         if self.uncompressed:  # will perform a compress             # <<<<<<<<<<<<<<
  *             while self.block_size * (i+1) < remain_size:
  *                 memcpy(self.buffers[i],
  */
   __pyx_t_2 = (__pyx_v_self->uncompressed != Py_None)&&(PyByteArray_GET_SIZE(__pyx_v_self->uncompressed) != 0);
   if (__pyx_t_2) {
 
-    /* "bz3/backends/cython/_bz3.pyx":526
+    /* "bz3/backends/cython/_bz3.pyx":635
  *             int j
  *         if self.uncompressed:  # will perform a compress
  *             while self.block_size * (i+1) < remain_size:             # <<<<<<<<<<<<<<
  *                 memcpy(self.buffers[i],
  *                        &PyByteArray_AS_STRING(self.uncompressed)[i*self.block_size],
  */
     while (1) {
       __pyx_t_2 = (((__pyx_v_self->block_size * (__pyx_v_i + 1)) < __pyx_v_remain_size) != 0);
       if (!__pyx_t_2) break;
 
-      /* "bz3/backends/cython/_bz3.pyx":528
+      /* "bz3/backends/cython/_bz3.pyx":637
  *             while self.block_size * (i+1) < remain_size:
  *                 memcpy(self.buffers[i],
  *                        &PyByteArray_AS_STRING(self.uncompressed)[i*self.block_size],             # <<<<<<<<<<<<<<
  *                        <size_t>self.block_size)
  *                 self.sizes[i] = self.old_sizes[i] = self.block_size
  */
       __pyx_t_1 = __pyx_v_self->uncompressed;
       __Pyx_INCREF(__pyx_t_1);
 
-      /* "bz3/backends/cython/_bz3.pyx":527
+      /* "bz3/backends/cython/_bz3.pyx":636
  *         if self.uncompressed:  # will perform a compress
  *             while self.block_size * (i+1) < remain_size:
  *                 memcpy(self.buffers[i],             # <<<<<<<<<<<<<<
  *                        &PyByteArray_AS_STRING(self.uncompressed)[i*self.block_size],
  *                        <size_t>self.block_size)
  */
       (void)(memcpy((__pyx_v_self->buffers[__pyx_v_i]), (&(PyByteArray_AS_STRING(__pyx_t_1)[(__pyx_v_i * __pyx_v_self->block_size)])), ((size_t)__pyx_v_self->block_size)));
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":530
+      /* "bz3/backends/cython/_bz3.pyx":639
  *                        &PyByteArray_AS_STRING(self.uncompressed)[i*self.block_size],
  *                        <size_t>self.block_size)
  *                 self.sizes[i] = self.old_sizes[i] = self.block_size             # <<<<<<<<<<<<<<
  *                 # old_sizes[i] = self.block_size
  *                 i += 1
  */
       __pyx_t_3 = __pyx_v_self->block_size;
       (__pyx_v_self->sizes[__pyx_v_i]) = __pyx_t_3;
       (__pyx_v_self->old_sizes[__pyx_v_i]) = __pyx_t_3;
 
-      /* "bz3/backends/cython/_bz3.pyx":532
+      /* "bz3/backends/cython/_bz3.pyx":641
  *                 self.sizes[i] = self.old_sizes[i] = self.block_size
  *                 # old_sizes[i] = self.block_size
  *                 i += 1             # <<<<<<<<<<<<<<
  *             memcpy(self.buffers[i],
  *                    &PyByteArray_AS_STRING(self.uncompressed)[i * self.block_size],
  */
       __pyx_v_i = (__pyx_v_i + 1);
     }
 
-    /* "bz3/backends/cython/_bz3.pyx":534
+    /* "bz3/backends/cython/_bz3.pyx":643
  *                 i += 1
  *             memcpy(self.buffers[i],
  *                    &PyByteArray_AS_STRING(self.uncompressed)[i * self.block_size],             # <<<<<<<<<<<<<<
  *                    <size_t> (remain_size-i*self.block_size))  # fill as many blocks as possible
  *             self.sizes[i] = self.old_sizes[i] = remain_size-i*self.block_size
  */
     __pyx_t_1 = __pyx_v_self->uncompressed;
     __Pyx_INCREF(__pyx_t_1);
 
-    /* "bz3/backends/cython/_bz3.pyx":533
+    /* "bz3/backends/cython/_bz3.pyx":642
  *                 # old_sizes[i] = self.block_size
  *                 i += 1
  *             memcpy(self.buffers[i],             # <<<<<<<<<<<<<<
  *                    &PyByteArray_AS_STRING(self.uncompressed)[i * self.block_size],
  *                    <size_t> (remain_size-i*self.block_size))  # fill as many blocks as possible
  */
     (void)(memcpy((__pyx_v_self->buffers[__pyx_v_i]), (&(PyByteArray_AS_STRING(__pyx_t_1)[(__pyx_v_i * __pyx_v_self->block_size)])), ((size_t)(__pyx_v_remain_size - (__pyx_v_i * __pyx_v_self->block_size)))));
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "bz3/backends/cython/_bz3.pyx":536
+    /* "bz3/backends/cython/_bz3.pyx":645
  *                    &PyByteArray_AS_STRING(self.uncompressed)[i * self.block_size],
  *                    <size_t> (remain_size-i*self.block_size))  # fill as many blocks as possible
  *             self.sizes[i] = self.old_sizes[i] = remain_size-i*self.block_size             # <<<<<<<<<<<<<<
  *             # old_sizes[i] = remain_size-i*self.block_size
  *             i += 1
  */
     __pyx_t_3 = (__pyx_v_remain_size - (__pyx_v_i * __pyx_v_self->block_size));
     (__pyx_v_self->sizes[__pyx_v_i]) = __pyx_t_3;
     (__pyx_v_self->old_sizes[__pyx_v_i]) = __pyx_t_3;
 
-    /* "bz3/backends/cython/_bz3.pyx":538
+    /* "bz3/backends/cython/_bz3.pyx":647
  *             self.sizes[i] = self.old_sizes[i] = remain_size-i*self.block_size
  *             # old_sizes[i] = remain_size-i*self.block_size
  *             i += 1             # <<<<<<<<<<<<<<
  *             bz3_encode_blocks(self.states, self.buffers, self.sizes, i)
  *             for j in range(i):  # state index
  */
     __pyx_v_i = (__pyx_v_i + 1);
 
-    /* "bz3/backends/cython/_bz3.pyx":539
+    /* "bz3/backends/cython/_bz3.pyx":648
  *             # old_sizes[i] = remain_size-i*self.block_size
  *             i += 1
  *             bz3_encode_blocks(self.states, self.buffers, self.sizes, i)             # <<<<<<<<<<<<<<
  *             for j in range(i):  # state index
  *                 if bz3_last_error(self.states[j]) != BZ3_OK:
  */
     __pyx_f_3bz3_8backends_6cython_4_bz3_bz3_encode_blocks(__pyx_v_self->states, __pyx_v_self->buffers, __pyx_v_self->sizes, __pyx_v_i);
 
-    /* "bz3/backends/cython/_bz3.pyx":540
+    /* "bz3/backends/cython/_bz3.pyx":649
  *             i += 1
  *             bz3_encode_blocks(self.states, self.buffers, self.sizes, i)
  *             for j in range(i):  # state index             # <<<<<<<<<<<<<<
  *                 if bz3_last_error(self.states[j]) != BZ3_OK:
  *                     raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.states[j]))
  */
     __pyx_t_4 = __pyx_v_i;
     __pyx_t_5 = __pyx_t_4;
     for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
       __pyx_v_j = __pyx_t_6;
 
-      /* "bz3/backends/cython/_bz3.pyx":541
+      /* "bz3/backends/cython/_bz3.pyx":650
  *             bz3_encode_blocks(self.states, self.buffers, self.sizes, i)
  *             for j in range(i):  # state index
  *                 if bz3_last_error(self.states[j]) != BZ3_OK:             # <<<<<<<<<<<<<<
  *                     raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.states[j]))
  * 
  */
       __pyx_t_2 = ((bz3_last_error((__pyx_v_self->states[__pyx_v_j])) != BZ3_OK) != 0);
       if (unlikely(__pyx_t_2)) {
 
-        /* "bz3/backends/cython/_bz3.pyx":542
+        /* "bz3/backends/cython/_bz3.pyx":651
  *             for j in range(i):  # state index
  *                 if bz3_last_error(self.states[j]) != BZ3_OK:
  *                     raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.states[j]))             # <<<<<<<<<<<<<<
  * 
  *                 ret.extend((self.sizes[j] + 8) * b"\x00")
  */
-        __pyx_t_1 = __Pyx_PyBytes_FromString(bz3_strerror((__pyx_v_self->states[__pyx_v_j]))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 542, __pyx_L1_error)
+        __pyx_t_1 = __Pyx_PyBytes_FromString(bz3_strerror((__pyx_v_self->states[__pyx_v_j]))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 651, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_1);
-        __pyx_t_7 = PyUnicode_Format(__pyx_kp_u_Failed_to_encode_a_block_s, __pyx_t_1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 542, __pyx_L1_error)
+        __pyx_t_7 = PyUnicode_Format(__pyx_kp_u_Failed_to_encode_a_block_s, __pyx_t_1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 651, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-        __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 542, __pyx_L1_error)
+        __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 651, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_Raise(__pyx_t_1, 0, 0, 0);
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-        __PYX_ERR(0, 542, __pyx_L1_error)
+        __PYX_ERR(0, 651, __pyx_L1_error)
 
-        /* "bz3/backends/cython/_bz3.pyx":541
+        /* "bz3/backends/cython/_bz3.pyx":650
  *             bz3_encode_blocks(self.states, self.buffers, self.sizes, i)
  *             for j in range(i):  # state index
  *                 if bz3_last_error(self.states[j]) != BZ3_OK:             # <<<<<<<<<<<<<<
  *                     raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.states[j]))
  * 
  */
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":544
+      /* "bz3/backends/cython/_bz3.pyx":653
  *                     raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.states[j]))
  * 
  *                 ret.extend((self.sizes[j] + 8) * b"\x00")             # <<<<<<<<<<<<<<
  *                 write_neutral_s32(<uint8_t *> &(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret) - self.sizes[j] - 8]),
  *                                   self.sizes[j])
  */
-      __pyx_t_1 = __Pyx_PyInt_From_long(((__pyx_v_self->sizes[__pyx_v_j]) + 8)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 544, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyInt_From_long(((__pyx_v_self->sizes[__pyx_v_j]) + 8)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 653, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_7 = PyNumber_Multiply(__pyx_t_1, __pyx_kp_b__5); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 544, __pyx_L1_error)
+      __pyx_t_7 = PyNumber_Multiply(__pyx_t_1, __pyx_kp_b__5); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 653, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_7);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __pyx_t_1 = __Pyx_CallUnboundCMethod1(&__pyx_umethod_PyByteArray_Type_extend, __pyx_v_ret, __pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 544, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_CallUnboundCMethod1(&__pyx_umethod_PyByteArray_Type_extend, __pyx_v_ret, __pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 653, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":545
+      /* "bz3/backends/cython/_bz3.pyx":654
  * 
  *                 ret.extend((self.sizes[j] + 8) * b"\x00")
  *                 write_neutral_s32(<uint8_t *> &(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret) - self.sizes[j] - 8]),             # <<<<<<<<<<<<<<
  *                                   self.sizes[j])
  *                 write_neutral_s32(<uint8_t *> &(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret) - self.sizes[j] - 4]),
  */
       write_neutral_s32(((uint8_t *)(&(PyByteArray_AS_STRING(__pyx_v_ret)[((PyByteArray_GET_SIZE(__pyx_v_ret) - (__pyx_v_self->sizes[__pyx_v_j])) - 8)]))), (__pyx_v_self->sizes[__pyx_v_j]));
 
-      /* "bz3/backends/cython/_bz3.pyx":547
+      /* "bz3/backends/cython/_bz3.pyx":656
  *                 write_neutral_s32(<uint8_t *> &(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret) - self.sizes[j] - 8]),
  *                                   self.sizes[j])
  *                 write_neutral_s32(<uint8_t *> &(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret) - self.sizes[j] - 4]),             # <<<<<<<<<<<<<<
  *                                   self.old_sizes[j])
  *                 memcpy(&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret) - self.sizes[j]]), self.buffers[j],
  */
       write_neutral_s32(((uint8_t *)(&(PyByteArray_AS_STRING(__pyx_v_ret)[((PyByteArray_GET_SIZE(__pyx_v_ret) - (__pyx_v_self->sizes[__pyx_v_j])) - 4)]))), (__pyx_v_self->old_sizes[__pyx_v_j]));
 
-      /* "bz3/backends/cython/_bz3.pyx":549
+      /* "bz3/backends/cython/_bz3.pyx":658
  *                 write_neutral_s32(<uint8_t *> &(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret) - self.sizes[j] - 4]),
  *                                   self.old_sizes[j])
  *                 memcpy(&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret) - self.sizes[j]]), self.buffers[j],             # <<<<<<<<<<<<<<
  *                        <size_t> self.sizes[j])
  * 
  */
       (void)(memcpy((&(PyByteArray_AS_STRING(__pyx_v_ret)[(PyByteArray_GET_SIZE(__pyx_v_ret) - (__pyx_v_self->sizes[__pyx_v_j]))])), (__pyx_v_self->buffers[__pyx_v_j]), ((size_t)(__pyx_v_self->sizes[__pyx_v_j]))));
     }
 
-    /* "bz3/backends/cython/_bz3.pyx":552
+    /* "bz3/backends/cython/_bz3.pyx":661
  *                        <size_t> self.sizes[j])
  * 
  *             self.uncompressed.clear()             # <<<<<<<<<<<<<<
  *         return bytes(ret)
  * 
  */
-    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->uncompressed, __pyx_n_s_clear); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 552, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->uncompressed, __pyx_n_s_clear); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 661, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __pyx_t_8 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
       __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
       if (likely(__pyx_t_8)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
         __Pyx_INCREF(__pyx_t_8);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_7, function);
       }
     }
     __pyx_t_1 = (__pyx_t_8) ? __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_8) : __Pyx_PyObject_CallNoArg(__pyx_t_7);
     __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 552, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 661, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "bz3/backends/cython/_bz3.pyx":525
+    /* "bz3/backends/cython/_bz3.pyx":634
  *             int i = 0  # thread count
  *             int j
  *         if self.uncompressed:  # will perform a compress             # <<<<<<<<<<<<<<
  *             while self.block_size * (i+1) < remain_size:
  *                 memcpy(self.buffers[i],
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":553
+  /* "bz3/backends/cython/_bz3.pyx":662
  * 
  *             self.uncompressed.clear()
  *         return bytes(ret)             # <<<<<<<<<<<<<<
  * 
  *     cpdef inline list error(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_ret); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 553, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_ret); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 662, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "bz3/backends/cython/_bz3.pyx":518
+  /* "bz3/backends/cython/_bz3.pyx":627
  *             return bytes(ret)
  * 
  *     cpdef inline bytes flush(self):             # <<<<<<<<<<<<<<
  *         cdef bytearray ret = bytearray()
  *         cdef int32_t new_size
  */
 
@@ -10734,15 +12469,15 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("flush", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_flush(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 518, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_flush(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 627, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -10751,15 +12486,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":555
+/* "bz3/backends/cython/_bz3.pyx":664
  *         return bytes(ret)
  * 
  *     cpdef inline list error(self):             # <<<<<<<<<<<<<<
  *         cdef uint32_t i
  *         cdef list ret = []
  */
 
@@ -10777,90 +12512,90 @@
   PyObject *__pyx_t_6 = NULL;
   int __pyx_t_7;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("error", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":557
+  /* "bz3/backends/cython/_bz3.pyx":666
  *     cpdef inline list error(self):
  *         cdef uint32_t i
  *         cdef list ret = []             # <<<<<<<<<<<<<<
  *         for i in range(self.numthreads):
  *             if bz3_last_error(self.states[i]) != BZ3_OK:
  */
-  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 557, __pyx_L1_error)
+  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 666, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_ret = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":558
+  /* "bz3/backends/cython/_bz3.pyx":667
  *         cdef uint32_t i
  *         cdef list ret = []
  *         for i in range(self.numthreads):             # <<<<<<<<<<<<<<
  *             if bz3_last_error(self.states[i]) != BZ3_OK:
  *                 ret.append((<bytes>bz3_strerror(self.states[i])).decode())
  */
   __pyx_t_2 = __pyx_v_self->numthreads;
   __pyx_t_3 = __pyx_t_2;
   for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
     __pyx_v_i = __pyx_t_4;
 
-    /* "bz3/backends/cython/_bz3.pyx":559
+    /* "bz3/backends/cython/_bz3.pyx":668
  *         cdef list ret = []
  *         for i in range(self.numthreads):
  *             if bz3_last_error(self.states[i]) != BZ3_OK:             # <<<<<<<<<<<<<<
  *                 ret.append((<bytes>bz3_strerror(self.states[i])).decode())
  *         return ret
  */
     __pyx_t_5 = ((bz3_last_error((__pyx_v_self->states[__pyx_v_i])) != BZ3_OK) != 0);
     if (__pyx_t_5) {
 
-      /* "bz3/backends/cython/_bz3.pyx":560
+      /* "bz3/backends/cython/_bz3.pyx":669
  *         for i in range(self.numthreads):
  *             if bz3_last_error(self.states[i]) != BZ3_OK:
  *                 ret.append((<bytes>bz3_strerror(self.states[i])).decode())             # <<<<<<<<<<<<<<
  *         return ret
  * 
  */
-      __pyx_t_1 = __Pyx_PyBytes_FromString(bz3_strerror((__pyx_v_self->states[__pyx_v_i]))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 560, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyBytes_FromString(bz3_strerror((__pyx_v_self->states[__pyx_v_i]))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 669, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
       if (unlikely(__pyx_t_1 == Py_None)) {
         PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "decode");
-        __PYX_ERR(0, 560, __pyx_L1_error)
+        __PYX_ERR(0, 669, __pyx_L1_error)
       }
-      __pyx_t_6 = __Pyx_decode_bytes(((PyObject*)__pyx_t_1), 0, PY_SSIZE_T_MAX, NULL, NULL, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 560, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_decode_bytes(((PyObject*)__pyx_t_1), 0, PY_SSIZE_T_MAX, NULL, NULL, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 669, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __pyx_t_7 = __Pyx_PyList_Append(__pyx_v_ret, __pyx_t_6); if (unlikely(__pyx_t_7 == ((int)-1))) __PYX_ERR(0, 560, __pyx_L1_error)
+      __pyx_t_7 = __Pyx_PyList_Append(__pyx_v_ret, __pyx_t_6); if (unlikely(__pyx_t_7 == ((int)-1))) __PYX_ERR(0, 669, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":559
+      /* "bz3/backends/cython/_bz3.pyx":668
  *         cdef list ret = []
  *         for i in range(self.numthreads):
  *             if bz3_last_error(self.states[i]) != BZ3_OK:             # <<<<<<<<<<<<<<
  *                 ret.append((<bytes>bz3_strerror(self.states[i])).decode())
  *         return ret
  */
     }
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":561
+  /* "bz3/backends/cython/_bz3.pyx":670
  *             if bz3_last_error(self.states[i]) != BZ3_OK:
  *                 ret.append((<bytes>bz3_strerror(self.states[i])).decode())
  *         return ret             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_ret);
   __pyx_r = __pyx_v_ret;
   goto __pyx_L0;
 
-  /* "bz3/backends/cython/_bz3.pyx":555
+  /* "bz3/backends/cython/_bz3.pyx":664
  *         return bytes(ret)
  * 
  *     cpdef inline list error(self):             # <<<<<<<<<<<<<<
  *         cdef uint32_t i
  *         cdef list ret = []
  */
 
@@ -10896,15 +12631,15 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("error", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_error(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 555, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_error(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 664, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -10913,15 +12648,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":402
+/* "bz3/backends/cython/_bz3.pyx":476
  *         int32_t * sizes   # compressed
  *         int32_t * old_sizes # origin size
  *         readonly int32_t block_size             # <<<<<<<<<<<<<<
  *         bytearray uncompressed
  *         bint have_magic_number
  */
 
@@ -10943,15 +12678,15 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_From_int32_t(__pyx_v_self->block_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 402, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int32_t(__pyx_v_self->block_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 476, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -10960,15 +12695,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":405
+/* "bz3/backends/cython/_bz3.pyx":479
  *         bytearray uncompressed
  *         bint have_magic_number
  *         readonly uint32_t numthreads  # how many threads to use             # <<<<<<<<<<<<<<
  * 
  *     def __cinit__(self, int32_t block_size, uint32_t numthreads):
  */
 
@@ -10990,15 +12725,15 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_From_uint32_t(__pyx_v_self->numthreads); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 405, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_uint32_t(__pyx_v_self->numthreads); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 479, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -11042,15 +12777,15 @@
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__15, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
@@ -11099,15 +12834,15 @@
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__15, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__16, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
@@ -11122,15 +12857,15 @@
   __Pyx_AddTraceback("bz3.backends.cython._bz3.BZ3OmpCompressor.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":564
+/* "bz3/backends/cython/_bz3.pyx":673
  * 
  * 
  * cdef void bz3_decode_blocks(bz3_state ** states, uint8_t ** buffers, int32_t* sizes, int32_t* orig_size, int32_t numthreads):             # <<<<<<<<<<<<<<
  *     cdef int32_t i
  *     for i in prange(numthreads, nogil=True, schedule='static', num_threads=numthreads):
  */
 
@@ -11138,15 +12873,15 @@
   int32_t __pyx_v_i;
   __Pyx_RefNannyDeclarations
   int32_t __pyx_t_1;
   int32_t __pyx_t_2;
   int32_t __pyx_t_3;
   __Pyx_RefNannySetupContext("bz3_decode_blocks", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":566
+  /* "bz3/backends/cython/_bz3.pyx":675
  * cdef void bz3_decode_blocks(bz3_state ** states, uint8_t ** buffers, int32_t* sizes, int32_t* orig_size, int32_t numthreads):
  *     cdef int32_t i
  *     for i in prange(numthreads, nogil=True, schedule='static', num_threads=numthreads):             # <<<<<<<<<<<<<<
  *         bz3_decode_block(states[i], buffers[i], sizes[i], orig_size[i])
  * 
  */
   {
@@ -11175,15 +12910,15 @@
                     #ifdef _OPENMP
                     #pragma omp for firstprivate(__pyx_v_i) lastprivate(__pyx_v_i) schedule(static)
                     #endif /* _OPENMP */
                     for (__pyx_t_2 = 0; __pyx_t_2 < __pyx_t_3; __pyx_t_2++){
                         {
                             __pyx_v_i = (int32_t)(0 + 1 * __pyx_t_2);
 
-                            /* "bz3/backends/cython/_bz3.pyx":567
+                            /* "bz3/backends/cython/_bz3.pyx":676
  *     cdef int32_t i
  *     for i in prange(numthreads, nogil=True, schedule='static', num_threads=numthreads):
  *         bz3_decode_block(states[i], buffers[i], sizes[i], orig_size[i])             # <<<<<<<<<<<<<<
  * 
  * 
  */
                             (void)(bz3_decode_block((__pyx_v_states[__pyx_v_i]), (__pyx_v_buffers[__pyx_v_i]), (__pyx_v_sizes[__pyx_v_i]), (__pyx_v_orig_size[__pyx_v_i])));
@@ -11196,15 +12931,15 @@
             #undef likely
             #undef unlikely
             #define likely(x)   __builtin_expect(!!(x), 1)
             #define unlikely(x) __builtin_expect(!!(x), 0)
         #endif
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":566
+      /* "bz3/backends/cython/_bz3.pyx":675
  * cdef void bz3_decode_blocks(bz3_state ** states, uint8_t ** buffers, int32_t* sizes, int32_t* orig_size, int32_t numthreads):
  *     cdef int32_t i
  *     for i in prange(numthreads, nogil=True, schedule='static', num_threads=numthreads):             # <<<<<<<<<<<<<<
  *         bz3_decode_block(states[i], buffers[i], sizes[i], orig_size[i])
  * 
  */
       /*finally:*/ {
@@ -11215,28 +12950,28 @@
           #endif
           goto __pyx_L5;
         }
         __pyx_L5:;
       }
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":564
+  /* "bz3/backends/cython/_bz3.pyx":673
  * 
  * 
  * cdef void bz3_decode_blocks(bz3_state ** states, uint8_t ** buffers, int32_t* sizes, int32_t* orig_size, int32_t numthreads):             # <<<<<<<<<<<<<<
  *     cdef int32_t i
  *     for i in prange(numthreads, nogil=True, schedule='static', num_threads=numthreads):
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "bz3/backends/cython/_bz3.pyx":584
- *         readonly uint32_t numthreads  # how many threads to use
+/* "bz3/backends/cython/_bz3.pyx":694
+ *         readonly bint ignore_error  # decode
  * 
  *     cdef inline int init_state(self, int32_t block_size) except -1:             # <<<<<<<<<<<<<<
  *         """should exec only once"""
  *         if not self.states:
  */
 
 static CYTHON_INLINE int __pyx_f_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_init_state(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *__pyx_v_self, int32_t __pyx_v_block_size) {
@@ -11254,344 +12989,362 @@
   PyObject *__pyx_t_9 = NULL;
   PyObject *__pyx_t_10 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("init_state", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":586
+  /* "bz3/backends/cython/_bz3.pyx":696
  *     cdef inline int init_state(self, int32_t block_size) except -1:
  *         """should exec only once"""
  *         if not self.states:             # <<<<<<<<<<<<<<
- *             self.states = <bz3_state **> PyMem_Malloc(sizeof(bz3_state *) * self.numthreads)  # prepare the array
+ *             self.states = <bz3_state **> PyMem_Calloc(self.numthreads, sizeof(bz3_state *))  # prepare the array
  *             if not self.states:
  */
   __pyx_t_1 = ((!(__pyx_v_self->states != 0)) != 0);
   if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":587
+    /* "bz3/backends/cython/_bz3.pyx":697
  *         """should exec only once"""
  *         if not self.states:
- *             self.states = <bz3_state **> PyMem_Malloc(sizeof(bz3_state *) * self.numthreads)  # prepare the array             # <<<<<<<<<<<<<<
+ *             self.states = <bz3_state **> PyMem_Calloc(self.numthreads, sizeof(bz3_state *))  # prepare the array             # <<<<<<<<<<<<<<
  *             if not self.states:
  *                 raise MemoryError
  */
-    __pyx_v_self->states = ((struct bz3_state **)PyMem_Malloc(((sizeof(struct bz3_state *)) * __pyx_v_self->numthreads)));
+    __pyx_v_self->states = ((struct bz3_state **)PyMem_Calloc(__pyx_v_self->numthreads, (sizeof(struct bz3_state *))));
 
-    /* "bz3/backends/cython/_bz3.pyx":588
+    /* "bz3/backends/cython/_bz3.pyx":698
  *         if not self.states:
- *             self.states = <bz3_state **> PyMem_Malloc(sizeof(bz3_state *) * self.numthreads)  # prepare the array
+ *             self.states = <bz3_state **> PyMem_Calloc(self.numthreads, sizeof(bz3_state *))  # prepare the array
  *             if not self.states:             # <<<<<<<<<<<<<<
  *                 raise MemoryError
- *         if not self.buffers:
+ *             MEMLOG("PyMem_Malloc %p\n", self.states)
  */
     __pyx_t_1 = ((!(__pyx_v_self->states != 0)) != 0);
     if (unlikely(__pyx_t_1)) {
 
-      /* "bz3/backends/cython/_bz3.pyx":589
- *             self.states = <bz3_state **> PyMem_Malloc(sizeof(bz3_state *) * self.numthreads)  # prepare the array
+      /* "bz3/backends/cython/_bz3.pyx":699
+ *             self.states = <bz3_state **> PyMem_Calloc(self.numthreads, sizeof(bz3_state *))  # prepare the array
  *             if not self.states:
  *                 raise MemoryError             # <<<<<<<<<<<<<<
+ *             MEMLOG("PyMem_Malloc %p\n", self.states)
  *         if not self.buffers:
- *             self.buffers = <uint8_t **> PyMem_Malloc(sizeof(uint8_t *) * self.numthreads)
  */
-      PyErr_NoMemory(); __PYX_ERR(0, 589, __pyx_L1_error)
+      PyErr_NoMemory(); __PYX_ERR(0, 699, __pyx_L1_error)
 
-      /* "bz3/backends/cython/_bz3.pyx":588
+      /* "bz3/backends/cython/_bz3.pyx":698
  *         if not self.states:
- *             self.states = <bz3_state **> PyMem_Malloc(sizeof(bz3_state *) * self.numthreads)  # prepare the array
+ *             self.states = <bz3_state **> PyMem_Calloc(self.numthreads, sizeof(bz3_state *))  # prepare the array
  *             if not self.states:             # <<<<<<<<<<<<<<
  *                 raise MemoryError
- *         if not self.buffers:
+ *             MEMLOG("PyMem_Malloc %p\n", self.states)
  */
     }
 
-    /* "bz3/backends/cython/_bz3.pyx":586
+    /* "bz3/backends/cython/_bz3.pyx":700
+ *             if not self.states:
+ *                 raise MemoryError
+ *             MEMLOG("PyMem_Malloc %p\n", self.states)             # <<<<<<<<<<<<<<
+ *         if not self.buffers:
+ *             self.buffers = <uint8_t **> PyMem_Calloc(self.numthreads, sizeof(uint8_t *))
+ */
+    MEMLOG(((char const *)"PyMem_Malloc %p\n"), __pyx_v_self->states);
+
+    /* "bz3/backends/cython/_bz3.pyx":696
  *     cdef inline int init_state(self, int32_t block_size) except -1:
  *         """should exec only once"""
  *         if not self.states:             # <<<<<<<<<<<<<<
- *             self.states = <bz3_state **> PyMem_Malloc(sizeof(bz3_state *) * self.numthreads)  # prepare the array
+ *             self.states = <bz3_state **> PyMem_Calloc(self.numthreads, sizeof(bz3_state *))  # prepare the array
  *             if not self.states:
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":590
- *             if not self.states:
+  /* "bz3/backends/cython/_bz3.pyx":701
  *                 raise MemoryError
+ *             MEMLOG("PyMem_Malloc %p\n", self.states)
  *         if not self.buffers:             # <<<<<<<<<<<<<<
- *             self.buffers = <uint8_t **> PyMem_Malloc(sizeof(uint8_t *) * self.numthreads)
+ *             self.buffers = <uint8_t **> PyMem_Calloc(self.numthreads, sizeof(uint8_t *))
  *             if not self.buffers:
  */
   __pyx_t_1 = ((!(__pyx_v_self->buffers != 0)) != 0);
   if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":591
- *                 raise MemoryError
+    /* "bz3/backends/cython/_bz3.pyx":702
+ *             MEMLOG("PyMem_Malloc %p\n", self.states)
  *         if not self.buffers:
- *             self.buffers = <uint8_t **> PyMem_Malloc(sizeof(uint8_t *) * self.numthreads)             # <<<<<<<<<<<<<<
+ *             self.buffers = <uint8_t **> PyMem_Calloc(self.numthreads, sizeof(uint8_t *))             # <<<<<<<<<<<<<<
  *             if not self.buffers:
  *                 raise MemoryError
  */
-    __pyx_v_self->buffers = ((uint8_t **)PyMem_Malloc(((sizeof(uint8_t *)) * __pyx_v_self->numthreads)));
+    __pyx_v_self->buffers = ((uint8_t **)PyMem_Calloc(__pyx_v_self->numthreads, (sizeof(uint8_t *))));
 
-    /* "bz3/backends/cython/_bz3.pyx":592
+    /* "bz3/backends/cython/_bz3.pyx":703
  *         if not self.buffers:
- *             self.buffers = <uint8_t **> PyMem_Malloc(sizeof(uint8_t *) * self.numthreads)
+ *             self.buffers = <uint8_t **> PyMem_Calloc(self.numthreads, sizeof(uint8_t *))
  *             if not self.buffers:             # <<<<<<<<<<<<<<
  *                 raise MemoryError
- * 
+ *             MEMLOG("PyMem_Malloc %p\n", self.buffers)
  */
     __pyx_t_1 = ((!(__pyx_v_self->buffers != 0)) != 0);
     if (unlikely(__pyx_t_1)) {
 
-      /* "bz3/backends/cython/_bz3.pyx":593
- *             self.buffers = <uint8_t **> PyMem_Malloc(sizeof(uint8_t *) * self.numthreads)
+      /* "bz3/backends/cython/_bz3.pyx":704
+ *             self.buffers = <uint8_t **> PyMem_Calloc(self.numthreads, sizeof(uint8_t *))
  *             if not self.buffers:
  *                 raise MemoryError             # <<<<<<<<<<<<<<
- * 
- *         memset(self.states, 0, sizeof(bz3_state *) * self.numthreads)
+ *             MEMLOG("PyMem_Malloc %p\n", self.buffers)
+ *         cdef uint32_t i
  */
-      PyErr_NoMemory(); __PYX_ERR(0, 593, __pyx_L1_error)
+      PyErr_NoMemory(); __PYX_ERR(0, 704, __pyx_L1_error)
 
-      /* "bz3/backends/cython/_bz3.pyx":592
+      /* "bz3/backends/cython/_bz3.pyx":703
  *         if not self.buffers:
- *             self.buffers = <uint8_t **> PyMem_Malloc(sizeof(uint8_t *) * self.numthreads)
+ *             self.buffers = <uint8_t **> PyMem_Calloc(self.numthreads, sizeof(uint8_t *))
  *             if not self.buffers:             # <<<<<<<<<<<<<<
  *                 raise MemoryError
- * 
+ *             MEMLOG("PyMem_Malloc %p\n", self.buffers)
  */
     }
 
-    /* "bz3/backends/cython/_bz3.pyx":590
- *             if not self.states:
- *                 raise MemoryError
- *         if not self.buffers:             # <<<<<<<<<<<<<<
- *             self.buffers = <uint8_t **> PyMem_Malloc(sizeof(uint8_t *) * self.numthreads)
+    /* "bz3/backends/cython/_bz3.pyx":705
  *             if not self.buffers:
- */
-  }
-
-  /* "bz3/backends/cython/_bz3.pyx":595
  *                 raise MemoryError
- * 
- *         memset(self.states, 0, sizeof(bz3_state *) * self.numthreads)             # <<<<<<<<<<<<<<
- *         memset(self.buffers, 0, sizeof(uint8_t *) * self.numthreads)
+ *             MEMLOG("PyMem_Malloc %p\n", self.buffers)             # <<<<<<<<<<<<<<
  *         cdef uint32_t i
+ *         try:
  */
-  (void)(memset(__pyx_v_self->states, 0, ((sizeof(struct bz3_state *)) * __pyx_v_self->numthreads)));
+    MEMLOG(((char const *)"PyMem_Malloc %p\n"), __pyx_v_self->buffers);
 
-  /* "bz3/backends/cython/_bz3.pyx":596
- * 
- *         memset(self.states, 0, sizeof(bz3_state *) * self.numthreads)
- *         memset(self.buffers, 0, sizeof(uint8_t *) * self.numthreads)             # <<<<<<<<<<<<<<
- *         cdef uint32_t i
- *         try:
+    /* "bz3/backends/cython/_bz3.pyx":701
+ *                 raise MemoryError
+ *             MEMLOG("PyMem_Malloc %p\n", self.states)
+ *         if not self.buffers:             # <<<<<<<<<<<<<<
+ *             self.buffers = <uint8_t **> PyMem_Calloc(self.numthreads, sizeof(uint8_t *))
+ *             if not self.buffers:
  */
-  (void)(memset(__pyx_v_self->buffers, 0, ((sizeof(uint8_t *)) * __pyx_v_self->numthreads)));
+  }
 
-  /* "bz3/backends/cython/_bz3.pyx":598
- *         memset(self.buffers, 0, sizeof(uint8_t *) * self.numthreads)
+  /* "bz3/backends/cython/_bz3.pyx":707
+ *             MEMLOG("PyMem_Malloc %p\n", self.buffers)
  *         cdef uint32_t i
  *         try:             # <<<<<<<<<<<<<<
  *             for i in range(self.numthreads):
  *                 self.states[i] = bz3_new(block_size)
  */
   {
     __Pyx_PyThreadState_declare
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_2, &__pyx_t_3, &__pyx_t_4);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_4);
     /*try:*/ {
 
-      /* "bz3/backends/cython/_bz3.pyx":599
+      /* "bz3/backends/cython/_bz3.pyx":708
  *         cdef uint32_t i
  *         try:
  *             for i in range(self.numthreads):             # <<<<<<<<<<<<<<
  *                 self.states[i] = bz3_new(block_size)
  *                 if self.states[i] == NULL:
  */
       __pyx_t_5 = __pyx_v_self->numthreads;
       __pyx_t_6 = __pyx_t_5;
       for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
         __pyx_v_i = __pyx_t_7;
 
-        /* "bz3/backends/cython/_bz3.pyx":600
+        /* "bz3/backends/cython/_bz3.pyx":709
  *         try:
  *             for i in range(self.numthreads):
  *                 self.states[i] = bz3_new(block_size)             # <<<<<<<<<<<<<<
  *                 if self.states[i] == NULL:
  *                     raise MemoryError("Failed to create a block encoder state")  # todo
  */
         (__pyx_v_self->states[__pyx_v_i]) = bz3_new(__pyx_v_block_size);
 
-        /* "bz3/backends/cython/_bz3.pyx":601
+        /* "bz3/backends/cython/_bz3.pyx":710
  *             for i in range(self.numthreads):
  *                 self.states[i] = bz3_new(block_size)
  *                 if self.states[i] == NULL:             # <<<<<<<<<<<<<<
  *                     raise MemoryError("Failed to create a block encoder state")  # todo
- *                 self.buffers[i] = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+ *                 MEMLOG("bz3_new %p\n", self.states[i])
  */
         __pyx_t_1 = (((__pyx_v_self->states[__pyx_v_i]) == NULL) != 0);
         if (unlikely(__pyx_t_1)) {
 
-          /* "bz3/backends/cython/_bz3.pyx":602
+          /* "bz3/backends/cython/_bz3.pyx":711
  *                 self.states[i] = bz3_new(block_size)
  *                 if self.states[i] == NULL:
  *                     raise MemoryError("Failed to create a block encoder state")  # todo             # <<<<<<<<<<<<<<
- *                 self.buffers[i] = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
- *                 if self.buffers[i] == NULL:
+ *                 MEMLOG("bz3_new %p\n", self.states[i])
+ *                 self.buffers[i] = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  */
-          __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 602, __pyx_L7_error)
+          __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 711, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_8);
           __Pyx_Raise(__pyx_t_8, 0, 0, 0);
           __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-          __PYX_ERR(0, 602, __pyx_L7_error)
+          __PYX_ERR(0, 711, __pyx_L7_error)
 
-          /* "bz3/backends/cython/_bz3.pyx":601
+          /* "bz3/backends/cython/_bz3.pyx":710
  *             for i in range(self.numthreads):
  *                 self.states[i] = bz3_new(block_size)
  *                 if self.states[i] == NULL:             # <<<<<<<<<<<<<<
  *                     raise MemoryError("Failed to create a block encoder state")  # todo
- *                 self.buffers[i] = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+ *                 MEMLOG("bz3_new %p\n", self.states[i])
  */
         }
 
-        /* "bz3/backends/cython/_bz3.pyx":603
+        /* "bz3/backends/cython/_bz3.pyx":712
  *                 if self.states[i] == NULL:
  *                     raise MemoryError("Failed to create a block encoder state")  # todo
- *                 self.buffers[i] = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)             # <<<<<<<<<<<<<<
+ *                 MEMLOG("bz3_new %p\n", self.states[i])             # <<<<<<<<<<<<<<
+ *                 self.buffers[i] = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  *                 if self.buffers[i] == NULL:
- *                     raise MemoryError("Failed to allocate memory")
  */
-        (__pyx_v_self->buffers[__pyx_v_i]) = ((uint8_t *)PyMem_Malloc(((__pyx_v_block_size + (((long)__pyx_v_block_size) / 50)) + 32)));
+        MEMLOG(((char const *)"bz3_new %p\n"), (__pyx_v_self->states[__pyx_v_i]));
 
-        /* "bz3/backends/cython/_bz3.pyx":604
+        /* "bz3/backends/cython/_bz3.pyx":713
  *                     raise MemoryError("Failed to create a block encoder state")  # todo
- *                 self.buffers[i] = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+ *                 MEMLOG("bz3_new %p\n", self.states[i])
+ *                 self.buffers[i] = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))             # <<<<<<<<<<<<<<
+ *                 if self.buffers[i] == NULL:
+ *                     raise MemoryError("Failed to allocate memory")
+ */
+        (__pyx_v_self->buffers[__pyx_v_i]) = ((uint8_t *)PyMem_Malloc(bz3_bound(__pyx_v_block_size)));
+
+        /* "bz3/backends/cython/_bz3.pyx":714
+ *                 MEMLOG("bz3_new %p\n", self.states[i])
+ *                 self.buffers[i] = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  *                 if self.buffers[i] == NULL:             # <<<<<<<<<<<<<<
  *                     raise MemoryError("Failed to allocate memory")
- *         except:
+ *                 MEMLOG("PyMem_Malloc %p\n", self.buffers[i])
  */
         __pyx_t_1 = (((__pyx_v_self->buffers[__pyx_v_i]) == NULL) != 0);
         if (unlikely(__pyx_t_1)) {
 
-          /* "bz3/backends/cython/_bz3.pyx":605
- *                 self.buffers[i] = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+          /* "bz3/backends/cython/_bz3.pyx":715
+ *                 self.buffers[i] = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  *                 if self.buffers[i] == NULL:
  *                     raise MemoryError("Failed to allocate memory")             # <<<<<<<<<<<<<<
+ *                 MEMLOG("PyMem_Malloc %p\n", self.buffers[i])
  *         except:
- *             self.free_states()
  */
-          __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 605, __pyx_L7_error)
+          __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 715, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_8);
           __Pyx_Raise(__pyx_t_8, 0, 0, 0);
           __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-          __PYX_ERR(0, 605, __pyx_L7_error)
+          __PYX_ERR(0, 715, __pyx_L7_error)
 
-          /* "bz3/backends/cython/_bz3.pyx":604
- *                     raise MemoryError("Failed to create a block encoder state")  # todo
- *                 self.buffers[i] = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
+          /* "bz3/backends/cython/_bz3.pyx":714
+ *                 MEMLOG("bz3_new %p\n", self.states[i])
+ *                 self.buffers[i] = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
  *                 if self.buffers[i] == NULL:             # <<<<<<<<<<<<<<
  *                     raise MemoryError("Failed to allocate memory")
- *         except:
+ *                 MEMLOG("PyMem_Malloc %p\n", self.buffers[i])
  */
         }
+
+        /* "bz3/backends/cython/_bz3.pyx":716
+ *                 if self.buffers[i] == NULL:
+ *                     raise MemoryError("Failed to allocate memory")
+ *                 MEMLOG("PyMem_Malloc %p\n", self.buffers[i])             # <<<<<<<<<<<<<<
+ *         except:
+ *             self.free_states()
+ */
+        MEMLOG(((char const *)"PyMem_Malloc %p\n"), (__pyx_v_self->buffers[__pyx_v_i]));
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":598
- *         memset(self.buffers, 0, sizeof(uint8_t *) * self.numthreads)
+      /* "bz3/backends/cython/_bz3.pyx":707
+ *             MEMLOG("PyMem_Malloc %p\n", self.buffers)
  *         cdef uint32_t i
  *         try:             # <<<<<<<<<<<<<<
  *             for i in range(self.numthreads):
  *                 self.states[i] = bz3_new(block_size)
  */
     }
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     goto __pyx_L12_try_end;
     __pyx_L7_error:;
     __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
 
-    /* "bz3/backends/cython/_bz3.pyx":606
- *                 if self.buffers[i] == NULL:
+    /* "bz3/backends/cython/_bz3.pyx":717
  *                     raise MemoryError("Failed to allocate memory")
+ *                 MEMLOG("PyMem_Malloc %p\n", self.buffers[i])
  *         except:             # <<<<<<<<<<<<<<
  *             self.free_states()
  *             self.free_buffers()
  */
     /*except:*/ {
       __Pyx_AddTraceback("bz3.backends.cython._bz3.BZ3OmpDecompressor.init_state", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_8, &__pyx_t_9, &__pyx_t_10) < 0) __PYX_ERR(0, 606, __pyx_L9_except_error)
+      if (__Pyx_GetException(&__pyx_t_8, &__pyx_t_9, &__pyx_t_10) < 0) __PYX_ERR(0, 717, __pyx_L9_except_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_GOTREF(__pyx_t_9);
       __Pyx_GOTREF(__pyx_t_10);
 
-      /* "bz3/backends/cython/_bz3.pyx":607
- *                     raise MemoryError("Failed to allocate memory")
+      /* "bz3/backends/cython/_bz3.pyx":718
+ *                 MEMLOG("PyMem_Malloc %p\n", self.buffers[i])
  *         except:
  *             self.free_states()             # <<<<<<<<<<<<<<
  *             self.free_buffers()
  *             raise
  */
       __pyx_f_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_free_states(__pyx_v_self);
 
-      /* "bz3/backends/cython/_bz3.pyx":608
+      /* "bz3/backends/cython/_bz3.pyx":719
  *         except:
  *             self.free_states()
  *             self.free_buffers()             # <<<<<<<<<<<<<<
  *             raise
  *         self.block_size = block_size
  */
       __pyx_f_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_free_buffers(__pyx_v_self);
 
-      /* "bz3/backends/cython/_bz3.pyx":609
+      /* "bz3/backends/cython/_bz3.pyx":720
  *             self.free_states()
  *             self.free_buffers()
  *             raise             # <<<<<<<<<<<<<<
  *         self.block_size = block_size
  * 
  */
       __Pyx_GIVEREF(__pyx_t_8);
       __Pyx_GIVEREF(__pyx_t_9);
       __Pyx_XGIVEREF(__pyx_t_10);
       __Pyx_ErrRestoreWithState(__pyx_t_8, __pyx_t_9, __pyx_t_10);
       __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0; 
-      __PYX_ERR(0, 609, __pyx_L9_except_error)
+      __PYX_ERR(0, 720, __pyx_L9_except_error)
     }
     __pyx_L9_except_error:;
 
-    /* "bz3/backends/cython/_bz3.pyx":598
- *         memset(self.buffers, 0, sizeof(uint8_t *) * self.numthreads)
+    /* "bz3/backends/cython/_bz3.pyx":707
+ *             MEMLOG("PyMem_Malloc %p\n", self.buffers)
  *         cdef uint32_t i
  *         try:             # <<<<<<<<<<<<<<
  *             for i in range(self.numthreads):
  *                 self.states[i] = bz3_new(block_size)
  */
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_XGIVEREF(__pyx_t_4);
     __Pyx_ExceptionReset(__pyx_t_2, __pyx_t_3, __pyx_t_4);
     goto __pyx_L1_error;
     __pyx_L12_try_end:;
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":610
+  /* "bz3/backends/cython/_bz3.pyx":721
  *             self.free_buffers()
  *             raise
  *         self.block_size = block_size             # <<<<<<<<<<<<<<
  * 
- *     def __cinit__(self,  uint32_t numthreads):
+ *     def __cinit__(self,  uint32_t numthreads, bint ignore_error = False):
  */
   __pyx_v_self->block_size = __pyx_v_block_size;
 
-  /* "bz3/backends/cython/_bz3.pyx":584
- *         readonly uint32_t numthreads  # how many threads to use
+  /* "bz3/backends/cython/_bz3.pyx":694
+ *         readonly bint ignore_error  # decode
  * 
  *     cdef inline int init_state(self, int32_t block_size) except -1:             # <<<<<<<<<<<<<<
  *         """should exec only once"""
  *         if not self.states:
  */
 
   /* function exit code */
@@ -11604,381 +13357,518 @@
   __Pyx_AddTraceback("bz3.backends.cython._bz3.BZ3OmpDecompressor.init_state", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":612
+/* "bz3/backends/cython/_bz3.pyx":723
  *         self.block_size = block_size
  * 
- *     def __cinit__(self,  uint32_t numthreads):             # <<<<<<<<<<<<<<
- *         self.unused = bytearray()
- *         self.have_magic_number = 0 # magic number
+ *     def __cinit__(self,  uint32_t numthreads, bint ignore_error = False):             # <<<<<<<<<<<<<<
+ *         self.states = NULL
+ *         self.buffers = NULL
  */
 
 /* Python wrapper */
 static int __pyx_pw_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static int __pyx_pw_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   uint32_t __pyx_v_numthreads;
+  int __pyx_v_ignore_error;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
   {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_numthreads,0};
-    PyObject* values[1] = {0};
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_numthreads,&__pyx_n_s_ignore_error,0};
+    PyObject* values[2] = {0,0};
     if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
       const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
       switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = PyDict_Size(__pyx_kwds);
       switch (pos_args) {
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_numthreads)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (kw_args > 0) {
+          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ignore_error);
+          if (value) { values[1] = value; kw_args--; }
+        }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 612, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 723, __pyx_L3_error)
       }
-    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
-      goto __pyx_L5_argtuple_error;
     } else {
-      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+    }
+    __pyx_v_numthreads = __Pyx_PyInt_As_uint32_t(values[0]); if (unlikely((__pyx_v_numthreads == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 723, __pyx_L3_error)
+    if (values[1]) {
+      __pyx_v_ignore_error = __Pyx_PyObject_IsTrue(values[1]); if (unlikely((__pyx_v_ignore_error == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 723, __pyx_L3_error)
+    } else {
+      __pyx_v_ignore_error = ((int)0);
     }
-    __pyx_v_numthreads = __Pyx_PyInt_As_uint32_t(values[0]); if (unlikely((__pyx_v_numthreads == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 612, __pyx_L3_error)
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 612, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 723, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("bz3.backends.cython._bz3.BZ3OmpDecompressor.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor___cinit__(((struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *)__pyx_v_self), __pyx_v_numthreads);
+  __pyx_r = __pyx_pf_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor___cinit__(((struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *)__pyx_v_self), __pyx_v_numthreads, __pyx_v_ignore_error);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static int __pyx_pf_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor___cinit__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *__pyx_v_self, uint32_t __pyx_v_numthreads) {
+static int __pyx_pf_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor___cinit__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *__pyx_v_self, uint32_t __pyx_v_numthreads, int __pyx_v_ignore_error) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__cinit__", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":613
+  /* "bz3/backends/cython/_bz3.pyx":724
  * 
- *     def __cinit__(self,  uint32_t numthreads):
+ *     def __cinit__(self,  uint32_t numthreads, bint ignore_error = False):
+ *         self.states = NULL             # <<<<<<<<<<<<<<
+ *         self.buffers = NULL
+ *         self.unused = bytearray()
+ */
+  __pyx_v_self->states = NULL;
+
+  /* "bz3/backends/cython/_bz3.pyx":725
+ *     def __cinit__(self,  uint32_t numthreads, bint ignore_error = False):
+ *         self.states = NULL
+ *         self.buffers = NULL             # <<<<<<<<<<<<<<
+ *         self.unused = bytearray()
+ *         self.have_magic_number = 0 # magic number
+ */
+  __pyx_v_self->buffers = NULL;
+
+  /* "bz3/backends/cython/_bz3.pyx":726
+ *         self.states = NULL
+ *         self.buffers = NULL
  *         self.unused = bytearray()             # <<<<<<<<<<<<<<
  *         self.have_magic_number = 0 # magic number
  *         self.numthreads = numthreads
  */
-  __pyx_t_1 = __Pyx_PyObject_CallNoArg(((PyObject *)(&PyByteArray_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 613, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_CallNoArg(((PyObject *)(&PyByteArray_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 726, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __Pyx_GOTREF(__pyx_v_self->unused);
   __Pyx_DECREF(__pyx_v_self->unused);
   __pyx_v_self->unused = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":614
- *     def __cinit__(self,  uint32_t numthreads):
+  /* "bz3/backends/cython/_bz3.pyx":727
+ *         self.buffers = NULL
  *         self.unused = bytearray()
  *         self.have_magic_number = 0 # magic number             # <<<<<<<<<<<<<<
  *         self.numthreads = numthreads
- * 
+ *         self.ignore_error = ignore_error
  */
   __pyx_v_self->have_magic_number = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":615
+  /* "bz3/backends/cython/_bz3.pyx":728
  *         self.unused = bytearray()
  *         self.have_magic_number = 0 # magic number
  *         self.numthreads = numthreads             # <<<<<<<<<<<<<<
+ *         self.ignore_error = ignore_error
  * 
- *         self.sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
  */
   __pyx_v_self->numthreads = __pyx_v_numthreads;
 
-  /* "bz3/backends/cython/_bz3.pyx":617
+  /* "bz3/backends/cython/_bz3.pyx":729
+ *         self.have_magic_number = 0 # magic number
  *         self.numthreads = numthreads
+ *         self.ignore_error = ignore_error             # <<<<<<<<<<<<<<
+ * 
+ *         self.sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
+ */
+  __pyx_v_self->ignore_error = __pyx_v_ignore_error;
+
+  /* "bz3/backends/cython/_bz3.pyx":731
+ *         self.ignore_error = ignore_error
  * 
  *         self.sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)             # <<<<<<<<<<<<<<
  *         if not self.sizes:
  *             raise MemoryError
  */
   __pyx_v_self->sizes = ((int32_t *)PyMem_Malloc(((sizeof(int32_t)) * __pyx_v_numthreads)));
 
-  /* "bz3/backends/cython/_bz3.pyx":618
+  /* "bz3/backends/cython/_bz3.pyx":732
  * 
  *         self.sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
  *         if not self.sizes:             # <<<<<<<<<<<<<<
  *             raise MemoryError
- *         self.old_sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
+ *         MEMLOG("PyMem_Malloc %p\n", self.sizes)
  */
   __pyx_t_2 = ((!(__pyx_v_self->sizes != 0)) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":619
+    /* "bz3/backends/cython/_bz3.pyx":733
  *         self.sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
  *         if not self.sizes:
  *             raise MemoryError             # <<<<<<<<<<<<<<
+ *         MEMLOG("PyMem_Malloc %p\n", self.sizes)
  *         self.old_sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
- *         if not self.old_sizes:
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 619, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 733, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":618
+    /* "bz3/backends/cython/_bz3.pyx":732
  * 
  *         self.sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
  *         if not self.sizes:             # <<<<<<<<<<<<<<
  *             raise MemoryError
- *         self.old_sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
+ *         MEMLOG("PyMem_Malloc %p\n", self.sizes)
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":620
+  /* "bz3/backends/cython/_bz3.pyx":734
  *         if not self.sizes:
  *             raise MemoryError
+ *         MEMLOG("PyMem_Malloc %p\n", self.sizes)             # <<<<<<<<<<<<<<
+ *         self.old_sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
+ *         if not self.old_sizes:
+ */
+  MEMLOG(((char const *)"PyMem_Malloc %p\n"), __pyx_v_self->sizes);
+
+  /* "bz3/backends/cython/_bz3.pyx":735
+ *             raise MemoryError
+ *         MEMLOG("PyMem_Malloc %p\n", self.sizes)
  *         self.old_sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)             # <<<<<<<<<<<<<<
  *         if not self.old_sizes:
  *             PyMem_Free(self.sizes)
  */
   __pyx_v_self->old_sizes = ((int32_t *)PyMem_Malloc(((sizeof(int32_t)) * __pyx_v_numthreads)));
 
-  /* "bz3/backends/cython/_bz3.pyx":621
- *             raise MemoryError
+  /* "bz3/backends/cython/_bz3.pyx":736
+ *         MEMLOG("PyMem_Malloc %p\n", self.sizes)
  *         self.old_sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
  *         if not self.old_sizes:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.sizes)
- *             raise MemoryError
+ *             self.sizes = NULL
  */
   __pyx_t_2 = ((!(__pyx_v_self->old_sizes != 0)) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "bz3/backends/cython/_bz3.pyx":622
+    /* "bz3/backends/cython/_bz3.pyx":737
  *         self.old_sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
  *         if not self.old_sizes:
  *             PyMem_Free(self.sizes)             # <<<<<<<<<<<<<<
+ *             self.sizes = NULL
  *             raise MemoryError
- * 
  */
     PyMem_Free(__pyx_v_self->sizes);
 
-    /* "bz3/backends/cython/_bz3.pyx":623
+    /* "bz3/backends/cython/_bz3.pyx":738
  *         if not self.old_sizes:
  *             PyMem_Free(self.sizes)
+ *             self.sizes = NULL             # <<<<<<<<<<<<<<
+ *             raise MemoryError
+ *         MEMLOG("PyMem_Malloc %p\n", self.old_sizes)
+ */
+    __pyx_v_self->sizes = NULL;
+
+    /* "bz3/backends/cython/_bz3.pyx":739
+ *             PyMem_Free(self.sizes)
+ *             self.sizes = NULL
  *             raise MemoryError             # <<<<<<<<<<<<<<
- * 
- *     cdef inline void free_states(self):
+ *         MEMLOG("PyMem_Malloc %p\n", self.old_sizes)
+ *         MEMLOG("BZ3OmpDecompressor __cinit__ %p\n", <void*>self)
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 623, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 739, __pyx_L1_error)
 
-    /* "bz3/backends/cython/_bz3.pyx":621
- *             raise MemoryError
+    /* "bz3/backends/cython/_bz3.pyx":736
+ *         MEMLOG("PyMem_Malloc %p\n", self.sizes)
  *         self.old_sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
  *         if not self.old_sizes:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.sizes)
- *             raise MemoryError
+ *             self.sizes = NULL
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":612
+  /* "bz3/backends/cython/_bz3.pyx":740
+ *             self.sizes = NULL
+ *             raise MemoryError
+ *         MEMLOG("PyMem_Malloc %p\n", self.old_sizes)             # <<<<<<<<<<<<<<
+ *         MEMLOG("BZ3OmpDecompressor __cinit__ %p\n", <void*>self)
+ * 
+ */
+  MEMLOG(((char const *)"PyMem_Malloc %p\n"), __pyx_v_self->old_sizes);
+
+  /* "bz3/backends/cython/_bz3.pyx":741
+ *             raise MemoryError
+ *         MEMLOG("PyMem_Malloc %p\n", self.old_sizes)
+ *         MEMLOG("BZ3OmpDecompressor __cinit__ %p\n", <void*>self)             # <<<<<<<<<<<<<<
+ * 
+ *     cdef inline void free_states(self):
+ */
+  MEMLOG(((char const *)"BZ3OmpDecompressor __cinit__ %p\n"), ((void *)__pyx_v_self));
+
+  /* "bz3/backends/cython/_bz3.pyx":723
  *         self.block_size = block_size
  * 
- *     def __cinit__(self,  uint32_t numthreads):             # <<<<<<<<<<<<<<
- *         self.unused = bytearray()
- *         self.have_magic_number = 0 # magic number
+ *     def __cinit__(self,  uint32_t numthreads, bint ignore_error = False):             # <<<<<<<<<<<<<<
+ *         self.states = NULL
+ *         self.buffers = NULL
  */
 
   /* function exit code */
   __pyx_r = 0;
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("bz3.backends.cython._bz3.BZ3OmpDecompressor.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":625
- *             raise MemoryError
+/* "bz3/backends/cython/_bz3.pyx":743
+ *         MEMLOG("BZ3OmpDecompressor __cinit__ %p\n", <void*>self)
  * 
  *     cdef inline void free_states(self):             # <<<<<<<<<<<<<<
  *         cdef uint32_t i
- *         for i in range(self.numthreads):
+ *         if self.states: # statesinit_states
  */
 
 static CYTHON_INLINE void __pyx_f_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_free_states(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *__pyx_v_self) {
   uint32_t __pyx_v_i;
   __Pyx_RefNannyDeclarations
-  uint32_t __pyx_t_1;
+  int __pyx_t_1;
   uint32_t __pyx_t_2;
   uint32_t __pyx_t_3;
-  int __pyx_t_4;
+  uint32_t __pyx_t_4;
   __Pyx_RefNannySetupContext("free_states", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":627
+  /* "bz3/backends/cython/_bz3.pyx":745
  *     cdef inline void free_states(self):
  *         cdef uint32_t i
- *         for i in range(self.numthreads):             # <<<<<<<<<<<<<<
- *             if self.states[i]:
- *                 bz3_free(self.states[i])
+ *         if self.states: # statesinit_states             # <<<<<<<<<<<<<<
+ *             for i in range(self.numthreads):
+ *                 if self.states[i]:
  */
-  __pyx_t_1 = __pyx_v_self->numthreads;
-  __pyx_t_2 = __pyx_t_1;
-  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
-    __pyx_v_i = __pyx_t_3;
+  __pyx_t_1 = (__pyx_v_self->states != 0);
+  if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":628
+    /* "bz3/backends/cython/_bz3.pyx":746
  *         cdef uint32_t i
- *         for i in range(self.numthreads):
- *             if self.states[i]:             # <<<<<<<<<<<<<<
- *                 bz3_free(self.states[i])
- *                 self.states[i] = NULL
+ *         if self.states: # statesinit_states
+ *             for i in range(self.numthreads):             # <<<<<<<<<<<<<<
+ *                 if self.states[i]:
+ *                     bz3_free(self.states[i])
  */
-    __pyx_t_4 = ((__pyx_v_self->states[__pyx_v_i]) != 0);
-    if (__pyx_t_4) {
+    __pyx_t_2 = __pyx_v_self->numthreads;
+    __pyx_t_3 = __pyx_t_2;
+    for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
+      __pyx_v_i = __pyx_t_4;
 
-      /* "bz3/backends/cython/_bz3.pyx":629
- *         for i in range(self.numthreads):
- *             if self.states[i]:
- *                 bz3_free(self.states[i])             # <<<<<<<<<<<<<<
- *                 self.states[i] = NULL
- * 
+      /* "bz3/backends/cython/_bz3.pyx":747
+ *         if self.states: # statesinit_states
+ *             for i in range(self.numthreads):
+ *                 if self.states[i]:             # <<<<<<<<<<<<<<
+ *                     bz3_free(self.states[i])
+ *                     MEMLOG("bz3_free %p\n", self.states[i])
  */
-      bz3_free((__pyx_v_self->states[__pyx_v_i]));
+      __pyx_t_1 = ((__pyx_v_self->states[__pyx_v_i]) != 0);
+      if (__pyx_t_1) {
 
-      /* "bz3/backends/cython/_bz3.pyx":630
- *             if self.states[i]:
- *                 bz3_free(self.states[i])
- *                 self.states[i] = NULL             # <<<<<<<<<<<<<<
+        /* "bz3/backends/cython/_bz3.pyx":748
+ *             for i in range(self.numthreads):
+ *                 if self.states[i]:
+ *                     bz3_free(self.states[i])             # <<<<<<<<<<<<<<
+ *                     MEMLOG("bz3_free %p\n", self.states[i])
+ *                     self.states[i] = NULL
+ */
+        bz3_free((__pyx_v_self->states[__pyx_v_i]));
+
+        /* "bz3/backends/cython/_bz3.pyx":749
+ *                 if self.states[i]:
+ *                     bz3_free(self.states[i])
+ *                     MEMLOG("bz3_free %p\n", self.states[i])             # <<<<<<<<<<<<<<
+ *                     self.states[i] = NULL
+ * 
+ */
+        MEMLOG(((char const *)"bz3_free %p\n"), (__pyx_v_self->states[__pyx_v_i]));
+
+        /* "bz3/backends/cython/_bz3.pyx":750
+ *                     bz3_free(self.states[i])
+ *                     MEMLOG("bz3_free %p\n", self.states[i])
+ *                     self.states[i] = NULL             # <<<<<<<<<<<<<<
  * 
  *     cdef inline void free_buffers(self):
  */
-      (__pyx_v_self->states[__pyx_v_i]) = NULL;
+        (__pyx_v_self->states[__pyx_v_i]) = NULL;
 
-      /* "bz3/backends/cython/_bz3.pyx":628
- *         cdef uint32_t i
- *         for i in range(self.numthreads):
- *             if self.states[i]:             # <<<<<<<<<<<<<<
- *                 bz3_free(self.states[i])
- *                 self.states[i] = NULL
+        /* "bz3/backends/cython/_bz3.pyx":747
+ *         if self.states: # statesinit_states
+ *             for i in range(self.numthreads):
+ *                 if self.states[i]:             # <<<<<<<<<<<<<<
+ *                     bz3_free(self.states[i])
+ *                     MEMLOG("bz3_free %p\n", self.states[i])
  */
+      }
     }
+
+    /* "bz3/backends/cython/_bz3.pyx":745
+ *     cdef inline void free_states(self):
+ *         cdef uint32_t i
+ *         if self.states: # statesinit_states             # <<<<<<<<<<<<<<
+ *             for i in range(self.numthreads):
+ *                 if self.states[i]:
+ */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":625
- *             raise MemoryError
+  /* "bz3/backends/cython/_bz3.pyx":743
+ *         MEMLOG("BZ3OmpDecompressor __cinit__ %p\n", <void*>self)
  * 
  *     cdef inline void free_states(self):             # <<<<<<<<<<<<<<
  *         cdef uint32_t i
- *         for i in range(self.numthreads):
+ *         if self.states: # statesinit_states
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "bz3/backends/cython/_bz3.pyx":632
- *                 self.states[i] = NULL
+/* "bz3/backends/cython/_bz3.pyx":752
+ *                     self.states[i] = NULL
  * 
  *     cdef inline void free_buffers(self):             # <<<<<<<<<<<<<<
- *         cdef uint32_t i
- *         for i in range(self.numthreads):
+ *         cdef uint32_t i # statesinit_states
+ *         if self.buffers: # statesinit_states
  */
 
 static CYTHON_INLINE void __pyx_f_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_free_buffers(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *__pyx_v_self) {
   uint32_t __pyx_v_i;
   __Pyx_RefNannyDeclarations
-  uint32_t __pyx_t_1;
+  int __pyx_t_1;
   uint32_t __pyx_t_2;
   uint32_t __pyx_t_3;
-  int __pyx_t_4;
+  uint32_t __pyx_t_4;
   __Pyx_RefNannySetupContext("free_buffers", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":634
+  /* "bz3/backends/cython/_bz3.pyx":754
  *     cdef inline void free_buffers(self):
- *         cdef uint32_t i
- *         for i in range(self.numthreads):             # <<<<<<<<<<<<<<
- *             if self.buffers[i]:
- *                 PyMem_Free(self.buffers[i])
+ *         cdef uint32_t i # statesinit_states
+ *         if self.buffers: # statesinit_states             # <<<<<<<<<<<<<<
+ *             for i in range(self.numthreads):
+ *                 if self.buffers[i]:
  */
-  __pyx_t_1 = __pyx_v_self->numthreads;
-  __pyx_t_2 = __pyx_t_1;
-  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
-    __pyx_v_i = __pyx_t_3;
+  __pyx_t_1 = (__pyx_v_self->buffers != 0);
+  if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":635
- *         cdef uint32_t i
- *         for i in range(self.numthreads):
- *             if self.buffers[i]:             # <<<<<<<<<<<<<<
- *                 PyMem_Free(self.buffers[i])
- *                 self.buffers[i] = NULL
+    /* "bz3/backends/cython/_bz3.pyx":755
+ *         cdef uint32_t i # statesinit_states
+ *         if self.buffers: # statesinit_states
+ *             for i in range(self.numthreads):             # <<<<<<<<<<<<<<
+ *                 if self.buffers[i]:
+ *                     PyMem_Free(self.buffers[i])
  */
-    __pyx_t_4 = ((__pyx_v_self->buffers[__pyx_v_i]) != 0);
-    if (__pyx_t_4) {
+    __pyx_t_2 = __pyx_v_self->numthreads;
+    __pyx_t_3 = __pyx_t_2;
+    for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
+      __pyx_v_i = __pyx_t_4;
 
-      /* "bz3/backends/cython/_bz3.pyx":636
- *         for i in range(self.numthreads):
- *             if self.buffers[i]:
- *                 PyMem_Free(self.buffers[i])             # <<<<<<<<<<<<<<
- *                 self.buffers[i] = NULL
- * 
+      /* "bz3/backends/cython/_bz3.pyx":756
+ *         if self.buffers: # statesinit_states
+ *             for i in range(self.numthreads):
+ *                 if self.buffers[i]:             # <<<<<<<<<<<<<<
+ *                     PyMem_Free(self.buffers[i])
+ *                     MEMLOG("PyMem_Free %p\n", self.buffers[i])
  */
-      PyMem_Free((__pyx_v_self->buffers[__pyx_v_i]));
+      __pyx_t_1 = ((__pyx_v_self->buffers[__pyx_v_i]) != 0);
+      if (__pyx_t_1) {
 
-      /* "bz3/backends/cython/_bz3.pyx":637
- *             if self.buffers[i]:
- *                 PyMem_Free(self.buffers[i])
- *                 self.buffers[i] = NULL             # <<<<<<<<<<<<<<
+        /* "bz3/backends/cython/_bz3.pyx":757
+ *             for i in range(self.numthreads):
+ *                 if self.buffers[i]:
+ *                     PyMem_Free(self.buffers[i])             # <<<<<<<<<<<<<<
+ *                     MEMLOG("PyMem_Free %p\n", self.buffers[i])
+ *                     self.buffers[i] = NULL
+ */
+        PyMem_Free((__pyx_v_self->buffers[__pyx_v_i]));
+
+        /* "bz3/backends/cython/_bz3.pyx":758
+ *                 if self.buffers[i]:
+ *                     PyMem_Free(self.buffers[i])
+ *                     MEMLOG("PyMem_Free %p\n", self.buffers[i])             # <<<<<<<<<<<<<<
+ *                     self.buffers[i] = NULL
+ * 
+ */
+        MEMLOG(((char const *)"PyMem_Free %p\n"), (__pyx_v_self->buffers[__pyx_v_i]));
+
+        /* "bz3/backends/cython/_bz3.pyx":759
+ *                     PyMem_Free(self.buffers[i])
+ *                     MEMLOG("PyMem_Free %p\n", self.buffers[i])
+ *                     self.buffers[i] = NULL             # <<<<<<<<<<<<<<
  * 
  *     def __dealloc__(self):
  */
-      (__pyx_v_self->buffers[__pyx_v_i]) = NULL;
+        (__pyx_v_self->buffers[__pyx_v_i]) = NULL;
 
-      /* "bz3/backends/cython/_bz3.pyx":635
- *         cdef uint32_t i
- *         for i in range(self.numthreads):
- *             if self.buffers[i]:             # <<<<<<<<<<<<<<
- *                 PyMem_Free(self.buffers[i])
- *                 self.buffers[i] = NULL
+        /* "bz3/backends/cython/_bz3.pyx":756
+ *         if self.buffers: # statesinit_states
+ *             for i in range(self.numthreads):
+ *                 if self.buffers[i]:             # <<<<<<<<<<<<<<
+ *                     PyMem_Free(self.buffers[i])
+ *                     MEMLOG("PyMem_Free %p\n", self.buffers[i])
  */
+      }
     }
+
+    /* "bz3/backends/cython/_bz3.pyx":754
+ *     cdef inline void free_buffers(self):
+ *         cdef uint32_t i # statesinit_states
+ *         if self.buffers: # statesinit_states             # <<<<<<<<<<<<<<
+ *             for i in range(self.numthreads):
+ *                 if self.buffers[i]:
+ */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":632
- *                 self.states[i] = NULL
+  /* "bz3/backends/cython/_bz3.pyx":752
+ *                     self.states[i] = NULL
  * 
  *     cdef inline void free_buffers(self):             # <<<<<<<<<<<<<<
- *         cdef uint32_t i
- *         for i in range(self.numthreads):
+ *         cdef uint32_t i # statesinit_states
+ *         if self.buffers: # statesinit_states
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "bz3/backends/cython/_bz3.pyx":639
- *                 self.buffers[i] = NULL
+/* "bz3/backends/cython/_bz3.pyx":761
+ *                     self.buffers[i] = NULL
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         self.free_states()
  *         self.free_buffers()
  */
 
 /* Python wrapper */
@@ -11993,158 +13883,239 @@
 }
 
 static void __pyx_pf_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_2__dealloc__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":640
+  /* "bz3/backends/cython/_bz3.pyx":762
  * 
  *     def __dealloc__(self):
  *         self.free_states()             # <<<<<<<<<<<<<<
  *         self.free_buffers()
  *         if self.states:
  */
   __pyx_f_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_free_states(__pyx_v_self);
 
-  /* "bz3/backends/cython/_bz3.pyx":641
+  /* "bz3/backends/cython/_bz3.pyx":763
  *     def __dealloc__(self):
  *         self.free_states()
  *         self.free_buffers()             # <<<<<<<<<<<<<<
  *         if self.states:
  *             PyMem_Free(self.states)
  */
   __pyx_f_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_free_buffers(__pyx_v_self);
 
-  /* "bz3/backends/cython/_bz3.pyx":642
+  /* "bz3/backends/cython/_bz3.pyx":764
  *         self.free_states()
  *         self.free_buffers()
  *         if self.states:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.states)
- *         if self.buffers:
+ *             MEMLOG("PyMem_Free %p\n", self.states)
  */
   __pyx_t_1 = (__pyx_v_self->states != 0);
   if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":643
+    /* "bz3/backends/cython/_bz3.pyx":765
  *         self.free_buffers()
  *         if self.states:
  *             PyMem_Free(self.states)             # <<<<<<<<<<<<<<
+ *             MEMLOG("PyMem_Free %p\n", self.states)
+ *             self.states = NULL
+ */
+    PyMem_Free(__pyx_v_self->states);
+
+    /* "bz3/backends/cython/_bz3.pyx":766
+ *         if self.states:
+ *             PyMem_Free(self.states)
+ *             MEMLOG("PyMem_Free %p\n", self.states)             # <<<<<<<<<<<<<<
+ *             self.states = NULL
+ *         if self.buffers:
+ */
+    MEMLOG(((char const *)"PyMem_Free %p\n"), __pyx_v_self->states);
+
+    /* "bz3/backends/cython/_bz3.pyx":767
+ *             PyMem_Free(self.states)
+ *             MEMLOG("PyMem_Free %p\n", self.states)
+ *             self.states = NULL             # <<<<<<<<<<<<<<
  *         if self.buffers:
  *             PyMem_Free(self.buffers)
  */
-    PyMem_Free(__pyx_v_self->states);
+    __pyx_v_self->states = NULL;
 
-    /* "bz3/backends/cython/_bz3.pyx":642
+    /* "bz3/backends/cython/_bz3.pyx":764
  *         self.free_states()
  *         self.free_buffers()
  *         if self.states:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.states)
- *         if self.buffers:
+ *             MEMLOG("PyMem_Free %p\n", self.states)
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":644
- *         if self.states:
- *             PyMem_Free(self.states)
+  /* "bz3/backends/cython/_bz3.pyx":768
+ *             MEMLOG("PyMem_Free %p\n", self.states)
+ *             self.states = NULL
  *         if self.buffers:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.buffers)
- *         if self.sizes:
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
  */
   __pyx_t_1 = (__pyx_v_self->buffers != 0);
   if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":645
- *             PyMem_Free(self.states)
+    /* "bz3/backends/cython/_bz3.pyx":769
+ *             self.states = NULL
  *         if self.buffers:
  *             PyMem_Free(self.buffers)             # <<<<<<<<<<<<<<
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
+ *             self.buffers = NULL
+ */
+    PyMem_Free(__pyx_v_self->buffers);
+
+    /* "bz3/backends/cython/_bz3.pyx":770
+ *         if self.buffers:
+ *             PyMem_Free(self.buffers)
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)             # <<<<<<<<<<<<<<
+ *             self.buffers = NULL
+ *         if self.sizes:
+ */
+    MEMLOG(((char const *)"PyMem_Free %p\n"), __pyx_v_self->buffers);
+
+    /* "bz3/backends/cython/_bz3.pyx":771
+ *             PyMem_Free(self.buffers)
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
+ *             self.buffers = NULL             # <<<<<<<<<<<<<<
  *         if self.sizes:
  *             PyMem_Free(self.sizes)
  */
-    PyMem_Free(__pyx_v_self->buffers);
+    __pyx_v_self->buffers = NULL;
 
-    /* "bz3/backends/cython/_bz3.pyx":644
- *         if self.states:
- *             PyMem_Free(self.states)
+    /* "bz3/backends/cython/_bz3.pyx":768
+ *             MEMLOG("PyMem_Free %p\n", self.states)
+ *             self.states = NULL
  *         if self.buffers:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.buffers)
- *         if self.sizes:
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":646
- *         if self.buffers:
- *             PyMem_Free(self.buffers)
+  /* "bz3/backends/cython/_bz3.pyx":772
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
+ *             self.buffers = NULL
  *         if self.sizes:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.sizes)
- *         if self.old_sizes:
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)
  */
   __pyx_t_1 = (__pyx_v_self->sizes != 0);
   if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":647
- *             PyMem_Free(self.buffers)
+    /* "bz3/backends/cython/_bz3.pyx":773
+ *             self.buffers = NULL
  *         if self.sizes:
  *             PyMem_Free(self.sizes)             # <<<<<<<<<<<<<<
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)
+ *             self.sizes = NULL
+ */
+    PyMem_Free(__pyx_v_self->sizes);
+
+    /* "bz3/backends/cython/_bz3.pyx":774
+ *         if self.sizes:
+ *             PyMem_Free(self.sizes)
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)             # <<<<<<<<<<<<<<
+ *             self.sizes = NULL
+ *         if self.old_sizes:
+ */
+    MEMLOG(((char const *)"PyMem_Free %p\n"), __pyx_v_self->sizes);
+
+    /* "bz3/backends/cython/_bz3.pyx":775
+ *             PyMem_Free(self.sizes)
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)
+ *             self.sizes = NULL             # <<<<<<<<<<<<<<
  *         if self.old_sizes:
  *             PyMem_Free(self.old_sizes)
  */
-    PyMem_Free(__pyx_v_self->sizes);
+    __pyx_v_self->sizes = NULL;
 
-    /* "bz3/backends/cython/_bz3.pyx":646
- *         if self.buffers:
- *             PyMem_Free(self.buffers)
+    /* "bz3/backends/cython/_bz3.pyx":772
+ *             MEMLOG("PyMem_Free %p\n", self.buffers)
+ *             self.buffers = NULL
  *         if self.sizes:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.sizes)
- *         if self.old_sizes:
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":648
- *         if self.sizes:
- *             PyMem_Free(self.sizes)
+  /* "bz3/backends/cython/_bz3.pyx":776
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)
+ *             self.sizes = NULL
  *         if self.old_sizes:             # <<<<<<<<<<<<<<
  *             PyMem_Free(self.old_sizes)
- * 
+ *             MEMLOG("PyMem_Free %p\n", self.old_sizes)
  */
   __pyx_t_1 = (__pyx_v_self->old_sizes != 0);
   if (__pyx_t_1) {
 
-    /* "bz3/backends/cython/_bz3.pyx":649
- *             PyMem_Free(self.sizes)
+    /* "bz3/backends/cython/_bz3.pyx":777
+ *             self.sizes = NULL
  *         if self.old_sizes:
  *             PyMem_Free(self.old_sizes)             # <<<<<<<<<<<<<<
- * 
- *     cpdef inline bytes decompress(self, const uint8_t[::1] data):
+ *             MEMLOG("PyMem_Free %p\n", self.old_sizes)
+ *             self.old_sizes = NULL
  */
     PyMem_Free(__pyx_v_self->old_sizes);
 
-    /* "bz3/backends/cython/_bz3.pyx":648
- *         if self.sizes:
- *             PyMem_Free(self.sizes)
- *         if self.old_sizes:             # <<<<<<<<<<<<<<
+    /* "bz3/backends/cython/_bz3.pyx":778
+ *         if self.old_sizes:
+ *             PyMem_Free(self.old_sizes)
+ *             MEMLOG("PyMem_Free %p\n", self.old_sizes)             # <<<<<<<<<<<<<<
+ *             self.old_sizes = NULL
+ *         MEMLOG("BZ3OmpDecompressor __dealloc__ %p\n", <void *> self)
+ */
+    MEMLOG(((char const *)"PyMem_Free %p\n"), __pyx_v_self->old_sizes);
+
+    /* "bz3/backends/cython/_bz3.pyx":779
  *             PyMem_Free(self.old_sizes)
+ *             MEMLOG("PyMem_Free %p\n", self.old_sizes)
+ *             self.old_sizes = NULL             # <<<<<<<<<<<<<<
+ *         MEMLOG("BZ3OmpDecompressor __dealloc__ %p\n", <void *> self)
  * 
  */
+    __pyx_v_self->old_sizes = NULL;
+
+    /* "bz3/backends/cython/_bz3.pyx":776
+ *             MEMLOG("PyMem_Free %p\n", self.sizes)
+ *             self.sizes = NULL
+ *         if self.old_sizes:             # <<<<<<<<<<<<<<
+ *             PyMem_Free(self.old_sizes)
+ *             MEMLOG("PyMem_Free %p\n", self.old_sizes)
+ */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":639
- *                 self.buffers[i] = NULL
+  /* "bz3/backends/cython/_bz3.pyx":780
+ *             MEMLOG("PyMem_Free %p\n", self.old_sizes)
+ *             self.old_sizes = NULL
+ *         MEMLOG("BZ3OmpDecompressor __dealloc__ %p\n", <void *> self)             # <<<<<<<<<<<<<<
+ * 
+ *     cpdef inline bytes decompress(self, const uint8_t[::1] data):
+ */
+  MEMLOG(((char const *)"BZ3OmpDecompressor __dealloc__ %p\n"), ((void *)__pyx_v_self));
+
+  /* "bz3/backends/cython/_bz3.pyx":761
+ *                     self.buffers[i] = NULL
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         self.free_states()
  *         self.free_buffers()
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "bz3/backends/cython/_bz3.pyx":651
- *             PyMem_Free(self.old_sizes)
+/* "bz3/backends/cython/_bz3.pyx":782
+ *         MEMLOG("BZ3OmpDecompressor __dealloc__ %p\n", <void *> self)
  * 
  *     cpdef inline bytes decompress(self, const uint8_t[::1] data):             # <<<<<<<<<<<<<<
  *         cdef Py_ssize_t input_size = data.shape[0]
  *         cdef int32_t code
  */
 
 static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_5decompress(PyObject *__pyx_v_self, PyObject *__pyx_arg_data); /*proto*/
@@ -12170,93 +14141,93 @@
   uint32_t __pyx_t_9;
   uint32_t __pyx_t_10;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decompress", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":652
+  /* "bz3/backends/cython/_bz3.pyx":783
  * 
  *     cpdef inline bytes decompress(self, const uint8_t[::1] data):
  *         cdef Py_ssize_t input_size = data.shape[0]             # <<<<<<<<<<<<<<
  *         cdef int32_t code
  *         cdef bytearray ret = bytearray()
  */
   __pyx_v_input_size = (__pyx_v_data.shape[0]);
 
-  /* "bz3/backends/cython/_bz3.pyx":654
+  /* "bz3/backends/cython/_bz3.pyx":785
  *         cdef Py_ssize_t input_size = data.shape[0]
  *         cdef int32_t code
  *         cdef bytearray ret = bytearray()             # <<<<<<<<<<<<<<
  *         cdef int32_t  block_size
  *         cdef uint32_t i, thread_count, j, should_delete=0
  */
-  __pyx_t_1 = __Pyx_PyObject_CallNoArg(((PyObject *)(&PyByteArray_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 654, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_CallNoArg(((PyObject *)(&PyByteArray_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 785, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_ret = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":656
+  /* "bz3/backends/cython/_bz3.pyx":787
  *         cdef bytearray ret = bytearray()
  *         cdef int32_t  block_size
  *         cdef uint32_t i, thread_count, j, should_delete=0             # <<<<<<<<<<<<<<
  *         cdef int should_break = 0
  *         if input_size > 0:
  */
   __pyx_v_should_delete = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":657
+  /* "bz3/backends/cython/_bz3.pyx":788
  *         cdef int32_t  block_size
  *         cdef uint32_t i, thread_count, j, should_delete=0
  *         cdef int should_break = 0             # <<<<<<<<<<<<<<
  *         if input_size > 0:
  *             # if PyByteArray_Resize(self.unused, input_size+PyByteArray_GET_SIZE(self.unused)) < 0:
  */
   __pyx_v_should_break = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":658
+  /* "bz3/backends/cython/_bz3.pyx":789
  *         cdef uint32_t i, thread_count, j, should_delete=0
  *         cdef int should_break = 0
  *         if input_size > 0:             # <<<<<<<<<<<<<<
  *             # if PyByteArray_Resize(self.unused, input_size+PyByteArray_GET_SIZE(self.unused)) < 0:
  *             #     raise
  */
   __pyx_t_2 = ((__pyx_v_input_size > 0) != 0);
   if (__pyx_t_2) {
 
-    /* "bz3/backends/cython/_bz3.pyx":662
+    /* "bz3/backends/cython/_bz3.pyx":793
  *             #     raise
  *             # memcpy(&(PyByteArray_AS_STRING(self.unused)[PyByteArray_GET_SIZE(self.unused)-input_size]), &data[0], input_size) # self.unused.extend
  *             self.unused.extend(data) # read header             # <<<<<<<<<<<<<<
  *             if PyByteArray_GET_SIZE(self.unused) > 9 and not self.have_magic_number: # 9 bytes magic number
  *                 if strncmp(PyByteArray_AS_STRING(self.unused), magic, 5) != 0:
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->unused, __pyx_n_s_extend); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 662, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->unused, __pyx_n_s_extend); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 793, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __pyx_memoryview_fromslice(__pyx_v_data, 1, (PyObject *(*)(char *)) __pyx_memview_get_nn_uint8_t__const__, (int (*)(char *, PyObject *)) NULL, 0);; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 662, __pyx_L1_error)
+    __pyx_t_4 = __pyx_memoryview_fromslice(__pyx_v_data, 1, (PyObject *(*)(char *)) __pyx_memview_get_nn_uint8_t__const__, (int (*)(char *, PyObject *)) NULL, 0);; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 793, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_5 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
     __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 662, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 793, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "bz3/backends/cython/_bz3.pyx":663
+    /* "bz3/backends/cython/_bz3.pyx":794
  *             # memcpy(&(PyByteArray_AS_STRING(self.unused)[PyByteArray_GET_SIZE(self.unused)-input_size]), &data[0], input_size) # self.unused.extend
  *             self.unused.extend(data) # read header
  *             if PyByteArray_GET_SIZE(self.unused) > 9 and not self.have_magic_number: # 9 bytes magic number             # <<<<<<<<<<<<<<
  *                 if strncmp(PyByteArray_AS_STRING(self.unused), magic, 5) != 0:
  *                     raise ValueError("Invalid signature")
  */
     __pyx_t_1 = __pyx_v_self->unused;
@@ -12269,62 +14240,62 @@
       goto __pyx_L5_bool_binop_done;
     }
     __pyx_t_6 = ((!(__pyx_v_self->have_magic_number != 0)) != 0);
     __pyx_t_2 = __pyx_t_6;
     __pyx_L5_bool_binop_done:;
     if (__pyx_t_2) {
 
-      /* "bz3/backends/cython/_bz3.pyx":664
+      /* "bz3/backends/cython/_bz3.pyx":795
  *             self.unused.extend(data) # read header
  *             if PyByteArray_GET_SIZE(self.unused) > 9 and not self.have_magic_number: # 9 bytes magic number
  *                 if strncmp(PyByteArray_AS_STRING(self.unused), magic, 5) != 0:             # <<<<<<<<<<<<<<
  *                     raise ValueError("Invalid signature")
  *                 block_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[5]))
  */
       __pyx_t_1 = __pyx_v_self->unused;
       __Pyx_INCREF(__pyx_t_1);
       __pyx_t_2 = ((strncmp(PyByteArray_AS_STRING(__pyx_t_1), __pyx_v_3bz3_8backends_6cython_4_bz3_magic, 5) != 0) != 0);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       if (unlikely(__pyx_t_2)) {
 
-        /* "bz3/backends/cython/_bz3.pyx":665
+        /* "bz3/backends/cython/_bz3.pyx":796
  *             if PyByteArray_GET_SIZE(self.unused) > 9 and not self.have_magic_number: # 9 bytes magic number
  *                 if strncmp(PyByteArray_AS_STRING(self.unused), magic, 5) != 0:
  *                     raise ValueError("Invalid signature")             # <<<<<<<<<<<<<<
  *                 block_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[5]))
  *                 if block_size  < KiB(65) or block_size >MiB(511):
  */
-        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 665, __pyx_L1_error)
+        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 796, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_Raise(__pyx_t_1, 0, 0, 0);
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-        __PYX_ERR(0, 665, __pyx_L1_error)
+        __PYX_ERR(0, 796, __pyx_L1_error)
 
-        /* "bz3/backends/cython/_bz3.pyx":664
+        /* "bz3/backends/cython/_bz3.pyx":795
  *             self.unused.extend(data) # read header
  *             if PyByteArray_GET_SIZE(self.unused) > 9 and not self.have_magic_number: # 9 bytes magic number
  *                 if strncmp(PyByteArray_AS_STRING(self.unused), magic, 5) != 0:             # <<<<<<<<<<<<<<
  *                     raise ValueError("Invalid signature")
  *                 block_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[5]))
  */
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":666
+      /* "bz3/backends/cython/_bz3.pyx":797
  *                 if strncmp(PyByteArray_AS_STRING(self.unused), magic, 5) != 0:
  *                     raise ValueError("Invalid signature")
  *                 block_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[5]))             # <<<<<<<<<<<<<<
  *                 if block_size  < KiB(65) or block_size >MiB(511):
  *                     raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  */
       __pyx_t_1 = __pyx_v_self->unused;
       __Pyx_INCREF(__pyx_t_1);
       __pyx_v_block_size = read_neutral_s32(((uint8_t *)(&(PyByteArray_AS_STRING(__pyx_t_1)[5]))));
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":667
+      /* "bz3/backends/cython/_bz3.pyx":798
  *                     raise ValueError("Invalid signature")
  *                 block_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[5]))
  *                 if block_size  < KiB(65) or block_size >MiB(511):             # <<<<<<<<<<<<<<
  *                     raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  *                 self.init_state(block_size)
  */
       __pyx_t_6 = ((__pyx_v_block_size < KiB(65)) != 0);
@@ -12334,395 +14305,467 @@
         goto __pyx_L9_bool_binop_done;
       }
       __pyx_t_6 = ((__pyx_v_block_size > MiB(0x1FF)) != 0);
       __pyx_t_2 = __pyx_t_6;
       __pyx_L9_bool_binop_done:;
       if (unlikely(__pyx_t_2)) {
 
-        /* "bz3/backends/cython/_bz3.pyx":668
+        /* "bz3/backends/cython/_bz3.pyx":799
  *                 block_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[5]))
  *                 if block_size  < KiB(65) or block_size >MiB(511):
  *                     raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")             # <<<<<<<<<<<<<<
  *                 self.init_state(block_size)
  *                 del self.unused[:9]
  */
-        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 668, __pyx_L1_error)
+        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 799, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_Raise(__pyx_t_1, 0, 0, 0);
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-        __PYX_ERR(0, 668, __pyx_L1_error)
+        __PYX_ERR(0, 799, __pyx_L1_error)
 
-        /* "bz3/backends/cython/_bz3.pyx":667
+        /* "bz3/backends/cython/_bz3.pyx":798
  *                     raise ValueError("Invalid signature")
  *                 block_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[5]))
  *                 if block_size  < KiB(65) or block_size >MiB(511):             # <<<<<<<<<<<<<<
  *                     raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  *                 self.init_state(block_size)
  */
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":669
+      /* "bz3/backends/cython/_bz3.pyx":800
  *                 if block_size  < KiB(65) or block_size >MiB(511):
  *                     raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  *                 self.init_state(block_size)             # <<<<<<<<<<<<<<
  *                 del self.unused[:9]
  *                 self.have_magic_number = 1
  */
-      __pyx_t_7 = __pyx_f_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_init_state(__pyx_v_self, __pyx_v_block_size); if (unlikely(__pyx_t_7 == ((int)-1))) __PYX_ERR(0, 669, __pyx_L1_error)
+      __pyx_t_7 = __pyx_f_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_init_state(__pyx_v_self, __pyx_v_block_size); if (unlikely(__pyx_t_7 == ((int)-1))) __PYX_ERR(0, 800, __pyx_L1_error)
 
-      /* "bz3/backends/cython/_bz3.pyx":670
+      /* "bz3/backends/cython/_bz3.pyx":801
  *                     raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
  *                 self.init_state(block_size)
  *                 del self.unused[:9]             # <<<<<<<<<<<<<<
  *                 self.have_magic_number = 1
  *             # block
  */
       if (unlikely(__pyx_v_self->unused == Py_None)) {
         PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
-        __PYX_ERR(0, 670, __pyx_L1_error)
+        __PYX_ERR(0, 801, __pyx_L1_error)
       }
-      if (__Pyx_PyObject_DelSlice(__pyx_v_self->unused, 0, 9, NULL, NULL, NULL, 0, 1, 0) < 0) __PYX_ERR(0, 670, __pyx_L1_error)
+      if (__Pyx_PyObject_DelSlice(__pyx_v_self->unused, 0, 9, NULL, NULL, NULL, 0, 1, 0) < 0) __PYX_ERR(0, 801, __pyx_L1_error)
 
-      /* "bz3/backends/cython/_bz3.pyx":671
+      /* "bz3/backends/cython/_bz3.pyx":802
  *                 self.init_state(block_size)
  *                 del self.unused[:9]
  *                 self.have_magic_number = 1             # <<<<<<<<<<<<<<
  *             # block
  *             while not should_break:
  */
       __pyx_v_self->have_magic_number = 1;
 
-      /* "bz3/backends/cython/_bz3.pyx":663
+      /* "bz3/backends/cython/_bz3.pyx":794
  *             # memcpy(&(PyByteArray_AS_STRING(self.unused)[PyByteArray_GET_SIZE(self.unused)-input_size]), &data[0], input_size) # self.unused.extend
  *             self.unused.extend(data) # read header
  *             if PyByteArray_GET_SIZE(self.unused) > 9 and not self.have_magic_number: # 9 bytes magic number             # <<<<<<<<<<<<<<
  *                 if strncmp(PyByteArray_AS_STRING(self.unused), magic, 5) != 0:
  *                     raise ValueError("Invalid signature")
  */
     }
 
-    /* "bz3/backends/cython/_bz3.pyx":673
+    /* "bz3/backends/cython/_bz3.pyx":804
  *                 self.have_magic_number = 1
  *             # block
  *             while not should_break:             # <<<<<<<<<<<<<<
  *                 thread_count = 0  # thread
  *                 # should_delete = 0 # self.unused
  */
     while (1) {
       __pyx_t_2 = ((!(__pyx_v_should_break != 0)) != 0);
       if (!__pyx_t_2) break;
 
-      /* "bz3/backends/cython/_bz3.pyx":674
+      /* "bz3/backends/cython/_bz3.pyx":805
  *             # block
  *             while not should_break:
  *                 thread_count = 0  # thread             # <<<<<<<<<<<<<<
  *                 # should_delete = 0 # self.unused
  *                 for i in range(self.numthreads):
  */
       __pyx_v_thread_count = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":676
+      /* "bz3/backends/cython/_bz3.pyx":807
  *                 thread_count = 0  # thread
  *                 # should_delete = 0 # self.unused
  *                 for i in range(self.numthreads):             # <<<<<<<<<<<<<<
  *                     if (PyByteArray_GET_SIZE(self.unused)-should_delete)<8: # 8 byte header
  *                         should_break = 1
  */
       __pyx_t_8 = __pyx_v_self->numthreads;
       __pyx_t_9 = __pyx_t_8;
       for (__pyx_t_10 = 0; __pyx_t_10 < __pyx_t_9; __pyx_t_10+=1) {
         __pyx_v_i = __pyx_t_10;
 
-        /* "bz3/backends/cython/_bz3.pyx":677
+        /* "bz3/backends/cython/_bz3.pyx":808
  *                 # should_delete = 0 # self.unused
  *                 for i in range(self.numthreads):
  *                     if (PyByteArray_GET_SIZE(self.unused)-should_delete)<8: # 8 byte header             # <<<<<<<<<<<<<<
  *                         should_break = 1
  *                         break
  */
         __pyx_t_1 = __pyx_v_self->unused;
         __Pyx_INCREF(__pyx_t_1);
         __pyx_t_2 = (((PyByteArray_GET_SIZE(__pyx_t_1) - __pyx_v_should_delete) < 8) != 0);
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
         if (__pyx_t_2) {
 
-          /* "bz3/backends/cython/_bz3.pyx":678
+          /* "bz3/backends/cython/_bz3.pyx":809
  *                 for i in range(self.numthreads):
  *                     if (PyByteArray_GET_SIZE(self.unused)-should_delete)<8: # 8 byte header
  *                         should_break = 1             # <<<<<<<<<<<<<<
  *                         break
  *                     self.sizes[i] = read_neutral_s32(<uint8_t*>&PyByteArray_AS_STRING(self.unused)[should_delete]) # todo gcc warning but bytes is const
  */
           __pyx_v_should_break = 1;
 
-          /* "bz3/backends/cython/_bz3.pyx":679
+          /* "bz3/backends/cython/_bz3.pyx":810
  *                     if (PyByteArray_GET_SIZE(self.unused)-should_delete)<8: # 8 byte header
  *                         should_break = 1
  *                         break             # <<<<<<<<<<<<<<
  *                     self.sizes[i] = read_neutral_s32(<uint8_t*>&PyByteArray_AS_STRING(self.unused)[should_delete]) # todo gcc warning but bytes is const
  *                     self.old_sizes[i] = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[should_delete+4]))
  */
           goto __pyx_L14_break;
 
-          /* "bz3/backends/cython/_bz3.pyx":677
+          /* "bz3/backends/cython/_bz3.pyx":808
  *                 # should_delete = 0 # self.unused
  *                 for i in range(self.numthreads):
  *                     if (PyByteArray_GET_SIZE(self.unused)-should_delete)<8: # 8 byte header             # <<<<<<<<<<<<<<
  *                         should_break = 1
  *                         break
  */
         }
 
-        /* "bz3/backends/cython/_bz3.pyx":680
+        /* "bz3/backends/cython/_bz3.pyx":811
  *                         should_break = 1
  *                         break
  *                     self.sizes[i] = read_neutral_s32(<uint8_t*>&PyByteArray_AS_STRING(self.unused)[should_delete]) # todo gcc warning but bytes is const             # <<<<<<<<<<<<<<
  *                     self.old_sizes[i] = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[should_delete+4]))
- *                     if (PyByteArray_GET_SIZE(self.unused)-should_delete) < self.sizes[i]+8: #
+ *                     if self.old_sizes[i] > <int32_t>bz3_bound(self.block_size) or self.sizes[i] > <int32_t>bz3_bound(self.block_size):
  */
         __pyx_t_1 = __pyx_v_self->unused;
         __Pyx_INCREF(__pyx_t_1);
         (__pyx_v_self->sizes[__pyx_v_i]) = read_neutral_s32(((uint8_t *)(&(PyByteArray_AS_STRING(__pyx_t_1)[__pyx_v_should_delete]))));
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-        /* "bz3/backends/cython/_bz3.pyx":681
+        /* "bz3/backends/cython/_bz3.pyx":812
  *                         break
  *                     self.sizes[i] = read_neutral_s32(<uint8_t*>&PyByteArray_AS_STRING(self.unused)[should_delete]) # todo gcc warning but bytes is const
  *                     self.old_sizes[i] = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[should_delete+4]))             # <<<<<<<<<<<<<<
- *                     if (PyByteArray_GET_SIZE(self.unused)-should_delete) < self.sizes[i]+8: #
- *                         should_break = 1
+ *                     if self.old_sizes[i] > <int32_t>bz3_bound(self.block_size) or self.sizes[i] > <int32_t>bz3_bound(self.block_size):
+ *                         raise ValueError("Failed to decode a block: Inconsistent headers.")
  */
         __pyx_t_1 = __pyx_v_self->unused;
         __Pyx_INCREF(__pyx_t_1);
         (__pyx_v_self->old_sizes[__pyx_v_i]) = read_neutral_s32(((uint8_t *)(&(PyByteArray_AS_STRING(__pyx_t_1)[(__pyx_v_should_delete + 4)]))));
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-        /* "bz3/backends/cython/_bz3.pyx":682
+        /* "bz3/backends/cython/_bz3.pyx":813
+ *                     self.sizes[i] = read_neutral_s32(<uint8_t*>&PyByteArray_AS_STRING(self.unused)[should_delete]) # todo gcc warning but bytes is const
+ *                     self.old_sizes[i] = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[should_delete+4]))
+ *                     if self.old_sizes[i] > <int32_t>bz3_bound(self.block_size) or self.sizes[i] > <int32_t>bz3_bound(self.block_size):             # <<<<<<<<<<<<<<
+ *                         raise ValueError("Failed to decode a block: Inconsistent headers.")
+ *                     if (PyByteArray_GET_SIZE(self.unused)-should_delete) < self.sizes[i]+8: #
+ */
+        __pyx_t_6 = (((__pyx_v_self->old_sizes[__pyx_v_i]) > ((int32_t)bz3_bound(__pyx_v_self->block_size))) != 0);
+        if (!__pyx_t_6) {
+        } else {
+          __pyx_t_2 = __pyx_t_6;
+          goto __pyx_L17_bool_binop_done;
+        }
+        __pyx_t_6 = (((__pyx_v_self->sizes[__pyx_v_i]) > ((int32_t)bz3_bound(__pyx_v_self->block_size))) != 0);
+        __pyx_t_2 = __pyx_t_6;
+        __pyx_L17_bool_binop_done:;
+        if (unlikely(__pyx_t_2)) {
+
+          /* "bz3/backends/cython/_bz3.pyx":814
+ *                     self.old_sizes[i] = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[should_delete+4]))
+ *                     if self.old_sizes[i] > <int32_t>bz3_bound(self.block_size) or self.sizes[i] > <int32_t>bz3_bound(self.block_size):
+ *                         raise ValueError("Failed to decode a block: Inconsistent headers.")             # <<<<<<<<<<<<<<
+ *                     if (PyByteArray_GET_SIZE(self.unused)-should_delete) < self.sizes[i]+8: #
+ *                         should_break = 1
+ */
+          __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 814, __pyx_L1_error)
+          __Pyx_GOTREF(__pyx_t_1);
+          __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+          __PYX_ERR(0, 814, __pyx_L1_error)
+
+          /* "bz3/backends/cython/_bz3.pyx":813
  *                     self.sizes[i] = read_neutral_s32(<uint8_t*>&PyByteArray_AS_STRING(self.unused)[should_delete]) # todo gcc warning but bytes is const
  *                     self.old_sizes[i] = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[should_delete+4]))
+ *                     if self.old_sizes[i] > <int32_t>bz3_bound(self.block_size) or self.sizes[i] > <int32_t>bz3_bound(self.block_size):             # <<<<<<<<<<<<<<
+ *                         raise ValueError("Failed to decode a block: Inconsistent headers.")
+ *                     if (PyByteArray_GET_SIZE(self.unused)-should_delete) < self.sizes[i]+8: #
+ */
+        }
+
+        /* "bz3/backends/cython/_bz3.pyx":815
+ *                     if self.old_sizes[i] > <int32_t>bz3_bound(self.block_size) or self.sizes[i] > <int32_t>bz3_bound(self.block_size):
+ *                         raise ValueError("Failed to decode a block: Inconsistent headers.")
  *                     if (PyByteArray_GET_SIZE(self.unused)-should_delete) < self.sizes[i]+8: #             # <<<<<<<<<<<<<<
  *                         should_break = 1
  *                         break
  */
         __pyx_t_1 = __pyx_v_self->unused;
         __Pyx_INCREF(__pyx_t_1);
         __pyx_t_2 = (((PyByteArray_GET_SIZE(__pyx_t_1) - __pyx_v_should_delete) < ((__pyx_v_self->sizes[__pyx_v_i]) + 8)) != 0);
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
         if (__pyx_t_2) {
 
-          /* "bz3/backends/cython/_bz3.pyx":683
- *                     self.old_sizes[i] = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[should_delete+4]))
+          /* "bz3/backends/cython/_bz3.pyx":816
+ *                         raise ValueError("Failed to decode a block: Inconsistent headers.")
  *                     if (PyByteArray_GET_SIZE(self.unused)-should_delete) < self.sizes[i]+8: #
  *                         should_break = 1             # <<<<<<<<<<<<<<
  *                         break
  *                     memcpy(self.buffers[i], &(PyByteArray_AS_STRING(self.unused)[should_delete+8]), <size_t>self.sizes[i])
  */
           __pyx_v_should_break = 1;
 
-          /* "bz3/backends/cython/_bz3.pyx":684
+          /* "bz3/backends/cython/_bz3.pyx":817
  *                     if (PyByteArray_GET_SIZE(self.unused)-should_delete) < self.sizes[i]+8: #
  *                         should_break = 1
  *                         break             # <<<<<<<<<<<<<<
  *                     memcpy(self.buffers[i], &(PyByteArray_AS_STRING(self.unused)[should_delete+8]), <size_t>self.sizes[i])
  *                     should_delete += (self.sizes[i] + 8)
  */
           goto __pyx_L14_break;
 
-          /* "bz3/backends/cython/_bz3.pyx":682
- *                     self.sizes[i] = read_neutral_s32(<uint8_t*>&PyByteArray_AS_STRING(self.unused)[should_delete]) # todo gcc warning but bytes is const
- *                     self.old_sizes[i] = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[should_delete+4]))
+          /* "bz3/backends/cython/_bz3.pyx":815
+ *                     if self.old_sizes[i] > <int32_t>bz3_bound(self.block_size) or self.sizes[i] > <int32_t>bz3_bound(self.block_size):
+ *                         raise ValueError("Failed to decode a block: Inconsistent headers.")
  *                     if (PyByteArray_GET_SIZE(self.unused)-should_delete) < self.sizes[i]+8: #             # <<<<<<<<<<<<<<
  *                         should_break = 1
  *                         break
  */
         }
 
-        /* "bz3/backends/cython/_bz3.pyx":685
+        /* "bz3/backends/cython/_bz3.pyx":818
  *                         should_break = 1
  *                         break
  *                     memcpy(self.buffers[i], &(PyByteArray_AS_STRING(self.unused)[should_delete+8]), <size_t>self.sizes[i])             # <<<<<<<<<<<<<<
  *                     should_delete += (self.sizes[i] + 8)
  *                     thread_count += 1
  */
         __pyx_t_1 = __pyx_v_self->unused;
         __Pyx_INCREF(__pyx_t_1);
         (void)(memcpy((__pyx_v_self->buffers[__pyx_v_i]), (&(PyByteArray_AS_STRING(__pyx_t_1)[(__pyx_v_should_delete + 8)])), ((size_t)(__pyx_v_self->sizes[__pyx_v_i]))));
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-        /* "bz3/backends/cython/_bz3.pyx":686
+        /* "bz3/backends/cython/_bz3.pyx":819
  *                         break
  *                     memcpy(self.buffers[i], &(PyByteArray_AS_STRING(self.unused)[should_delete+8]), <size_t>self.sizes[i])
  *                     should_delete += (self.sizes[i] + 8)             # <<<<<<<<<<<<<<
  *                     thread_count += 1
  *                 if thread_count:  # blockdecodejb
  */
         __pyx_v_should_delete = (__pyx_v_should_delete + ((__pyx_v_self->sizes[__pyx_v_i]) + 8));
 
-        /* "bz3/backends/cython/_bz3.pyx":687
+        /* "bz3/backends/cython/_bz3.pyx":820
  *                     memcpy(self.buffers[i], &(PyByteArray_AS_STRING(self.unused)[should_delete+8]), <size_t>self.sizes[i])
  *                     should_delete += (self.sizes[i] + 8)
  *                     thread_count += 1             # <<<<<<<<<<<<<<
  *                 if thread_count:  # blockdecodejb
  *                     bz3_decode_blocks(self.states, self.buffers, self.sizes, self.old_sizes, <int32_t>thread_count)
  */
         __pyx_v_thread_count = (__pyx_v_thread_count + 1);
       }
       __pyx_L14_break:;
 
-      /* "bz3/backends/cython/_bz3.pyx":688
+      /* "bz3/backends/cython/_bz3.pyx":821
  *                     should_delete += (self.sizes[i] + 8)
  *                     thread_count += 1
  *                 if thread_count:  # blockdecodejb             # <<<<<<<<<<<<<<
  *                     bz3_decode_blocks(self.states, self.buffers, self.sizes, self.old_sizes, <int32_t>thread_count)
  *                 for j in range(thread_count):
  */
       __pyx_t_2 = (__pyx_v_thread_count != 0);
       if (__pyx_t_2) {
 
-        /* "bz3/backends/cython/_bz3.pyx":689
+        /* "bz3/backends/cython/_bz3.pyx":822
  *                     thread_count += 1
  *                 if thread_count:  # blockdecodejb
  *                     bz3_decode_blocks(self.states, self.buffers, self.sizes, self.old_sizes, <int32_t>thread_count)             # <<<<<<<<<<<<<<
  *                 for j in range(thread_count):
  *                     if bz3_last_error(self.states[j]) != BZ3_OK:
  */
         __pyx_f_3bz3_8backends_6cython_4_bz3_bz3_decode_blocks(__pyx_v_self->states, __pyx_v_self->buffers, __pyx_v_self->sizes, __pyx_v_self->old_sizes, ((int32_t)__pyx_v_thread_count));
 
-        /* "bz3/backends/cython/_bz3.pyx":688
+        /* "bz3/backends/cython/_bz3.pyx":821
  *                     should_delete += (self.sizes[i] + 8)
  *                     thread_count += 1
  *                 if thread_count:  # blockdecodejb             # <<<<<<<<<<<<<<
  *                     bz3_decode_blocks(self.states, self.buffers, self.sizes, self.old_sizes, <int32_t>thread_count)
  *                 for j in range(thread_count):
  */
       }
 
-      /* "bz3/backends/cython/_bz3.pyx":690
+      /* "bz3/backends/cython/_bz3.pyx":823
  *                 if thread_count:  # blockdecodejb
  *                     bz3_decode_blocks(self.states, self.buffers, self.sizes, self.old_sizes, <int32_t>thread_count)
  *                 for j in range(thread_count):             # <<<<<<<<<<<<<<
  *                     if bz3_last_error(self.states[j]) != BZ3_OK:
- *                         raise ValueError("Failed to decode data: %s" % bz3_strerror(self.states[j]))
+ *                         if self.ignore_error:
  */
       __pyx_t_8 = __pyx_v_thread_count;
       __pyx_t_9 = __pyx_t_8;
       for (__pyx_t_10 = 0; __pyx_t_10 < __pyx_t_9; __pyx_t_10+=1) {
         __pyx_v_j = __pyx_t_10;
 
-        /* "bz3/backends/cython/_bz3.pyx":691
+        /* "bz3/backends/cython/_bz3.pyx":824
  *                     bz3_decode_blocks(self.states, self.buffers, self.sizes, self.old_sizes, <int32_t>thread_count)
  *                 for j in range(thread_count):
  *                     if bz3_last_error(self.states[j]) != BZ3_OK:             # <<<<<<<<<<<<<<
- *                         raise ValueError("Failed to decode data: %s" % bz3_strerror(self.states[j]))
- *                     ret.extend(<bytes>self.buffers[j][:self.old_sizes[j]])
+ *                         if self.ignore_error:
+ *                             fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(self.states[j]))
  */
         __pyx_t_2 = ((bz3_last_error((__pyx_v_self->states[__pyx_v_j])) != BZ3_OK) != 0);
-        if (unlikely(__pyx_t_2)) {
+        if (__pyx_t_2) {
 
-          /* "bz3/backends/cython/_bz3.pyx":692
+          /* "bz3/backends/cython/_bz3.pyx":825
  *                 for j in range(thread_count):
  *                     if bz3_last_error(self.states[j]) != BZ3_OK:
- *                         raise ValueError("Failed to decode data: %s" % bz3_strerror(self.states[j]))             # <<<<<<<<<<<<<<
+ *                         if self.ignore_error:             # <<<<<<<<<<<<<<
+ *                             fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(self.states[j]))
+ *                         else:
+ */
+          __pyx_t_2 = (__pyx_v_self->ignore_error != 0);
+          if (likely(__pyx_t_2)) {
+
+            /* "bz3/backends/cython/_bz3.pyx":826
+ *                     if bz3_last_error(self.states[j]) != BZ3_OK:
+ *                         if self.ignore_error:
+ *                             fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(self.states[j]))             # <<<<<<<<<<<<<<
+ *                         else:
+ *                             raise ValueError("Failed to decode data: %s" % bz3_strerror(self.states[j]))
+ */
+            (void)(fprintf(stderr, ((char const *)"Writing invalid block: %s\n"), bz3_strerror((__pyx_v_self->states[__pyx_v_j]))));
+
+            /* "bz3/backends/cython/_bz3.pyx":825
+ *                 for j in range(thread_count):
+ *                     if bz3_last_error(self.states[j]) != BZ3_OK:
+ *                         if self.ignore_error:             # <<<<<<<<<<<<<<
+ *                             fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(self.states[j]))
+ *                         else:
+ */
+            goto __pyx_L24;
+          }
+
+          /* "bz3/backends/cython/_bz3.pyx":828
+ *                             fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(self.states[j]))
+ *                         else:
+ *                             raise ValueError("Failed to decode data: %s" % bz3_strerror(self.states[j]))             # <<<<<<<<<<<<<<
  *                     ret.extend(<bytes>self.buffers[j][:self.old_sizes[j]])
  *             if should_delete:
  */
-          __pyx_t_1 = __Pyx_PyBytes_FromString(bz3_strerror((__pyx_v_self->states[__pyx_v_j]))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 692, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_1);
-          __pyx_t_3 = PyUnicode_Format(__pyx_kp_u_Failed_to_decode_data_s, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 692, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_3);
-          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-          __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 692, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_1);
-          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-          __Pyx_Raise(__pyx_t_1, 0, 0, 0);
-          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-          __PYX_ERR(0, 692, __pyx_L1_error)
+          /*else*/ {
+            __pyx_t_1 = __Pyx_PyBytes_FromString(bz3_strerror((__pyx_v_self->states[__pyx_v_j]))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 828, __pyx_L1_error)
+            __Pyx_GOTREF(__pyx_t_1);
+            __pyx_t_3 = PyUnicode_Format(__pyx_kp_u_Failed_to_decode_data_s, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 828, __pyx_L1_error)
+            __Pyx_GOTREF(__pyx_t_3);
+            __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+            __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 828, __pyx_L1_error)
+            __Pyx_GOTREF(__pyx_t_1);
+            __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+            __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+            __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+            __PYX_ERR(0, 828, __pyx_L1_error)
+          }
+          __pyx_L24:;
 
-          /* "bz3/backends/cython/_bz3.pyx":691
+          /* "bz3/backends/cython/_bz3.pyx":824
  *                     bz3_decode_blocks(self.states, self.buffers, self.sizes, self.old_sizes, <int32_t>thread_count)
  *                 for j in range(thread_count):
  *                     if bz3_last_error(self.states[j]) != BZ3_OK:             # <<<<<<<<<<<<<<
- *                         raise ValueError("Failed to decode data: %s" % bz3_strerror(self.states[j]))
- *                     ret.extend(<bytes>self.buffers[j][:self.old_sizes[j]])
+ *                         if self.ignore_error:
+ *                             fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(self.states[j]))
  */
         }
 
-        /* "bz3/backends/cython/_bz3.pyx":693
- *                     if bz3_last_error(self.states[j]) != BZ3_OK:
- *                         raise ValueError("Failed to decode data: %s" % bz3_strerror(self.states[j]))
+        /* "bz3/backends/cython/_bz3.pyx":829
+ *                         else:
+ *                             raise ValueError("Failed to decode data: %s" % bz3_strerror(self.states[j]))
  *                     ret.extend(<bytes>self.buffers[j][:self.old_sizes[j]])             # <<<<<<<<<<<<<<
  *             if should_delete:
  *                 del self.unused[:should_delete]
  */
-        __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(((const char*)(__pyx_v_self->buffers[__pyx_v_j])) + 0, (__pyx_v_self->old_sizes[__pyx_v_j]) - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 693, __pyx_L1_error)
+        __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(((const char*)(__pyx_v_self->buffers[__pyx_v_j])) + 0, (__pyx_v_self->old_sizes[__pyx_v_j]) - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 829, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_1);
-        __pyx_t_3 = __Pyx_CallUnboundCMethod1(&__pyx_umethod_PyByteArray_Type_extend, __pyx_v_ret, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 693, __pyx_L1_error)
+        __pyx_t_3 = __Pyx_CallUnboundCMethod1(&__pyx_umethod_PyByteArray_Type_extend, __pyx_v_ret, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 829, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       }
     }
 
-    /* "bz3/backends/cython/_bz3.pyx":694
- *                         raise ValueError("Failed to decode data: %s" % bz3_strerror(self.states[j]))
+    /* "bz3/backends/cython/_bz3.pyx":830
+ *                             raise ValueError("Failed to decode data: %s" % bz3_strerror(self.states[j]))
  *                     ret.extend(<bytes>self.buffers[j][:self.old_sizes[j]])
  *             if should_delete:             # <<<<<<<<<<<<<<
  *                 del self.unused[:should_delete]
  *         return bytes(ret)
  */
     __pyx_t_2 = (__pyx_v_should_delete != 0);
     if (__pyx_t_2) {
 
-      /* "bz3/backends/cython/_bz3.pyx":695
+      /* "bz3/backends/cython/_bz3.pyx":831
  *                     ret.extend(<bytes>self.buffers[j][:self.old_sizes[j]])
  *             if should_delete:
  *                 del self.unused[:should_delete]             # <<<<<<<<<<<<<<
  *         return bytes(ret)
  * 
  */
       if (unlikely(__pyx_v_self->unused == Py_None)) {
         PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
-        __PYX_ERR(0, 695, __pyx_L1_error)
+        __PYX_ERR(0, 831, __pyx_L1_error)
       }
-      if (__Pyx_PyObject_DelSlice(__pyx_v_self->unused, 0, __pyx_v_should_delete, NULL, NULL, NULL, 0, 1, 0) < 0) __PYX_ERR(0, 695, __pyx_L1_error)
+      if (__Pyx_PyObject_DelSlice(__pyx_v_self->unused, 0, __pyx_v_should_delete, NULL, NULL, NULL, 0, 1, 0) < 0) __PYX_ERR(0, 831, __pyx_L1_error)
 
-      /* "bz3/backends/cython/_bz3.pyx":694
- *                         raise ValueError("Failed to decode data: %s" % bz3_strerror(self.states[j]))
+      /* "bz3/backends/cython/_bz3.pyx":830
+ *                             raise ValueError("Failed to decode data: %s" % bz3_strerror(self.states[j]))
  *                     ret.extend(<bytes>self.buffers[j][:self.old_sizes[j]])
  *             if should_delete:             # <<<<<<<<<<<<<<
  *                 del self.unused[:should_delete]
  *         return bytes(ret)
  */
     }
 
-    /* "bz3/backends/cython/_bz3.pyx":658
+    /* "bz3/backends/cython/_bz3.pyx":789
  *         cdef uint32_t i, thread_count, j, should_delete=0
  *         cdef int should_break = 0
  *         if input_size > 0:             # <<<<<<<<<<<<<<
  *             # if PyByteArray_Resize(self.unused, input_size+PyByteArray_GET_SIZE(self.unused)) < 0:
  *             #     raise
  */
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":696
+  /* "bz3/backends/cython/_bz3.pyx":832
  *             if should_delete:
  *                 del self.unused[:should_delete]
  *         return bytes(ret)             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_ret); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 696, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_ret); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 832, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_r = ((PyObject*)__pyx_t_3);
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
-  /* "bz3/backends/cython/_bz3.pyx":651
- *             PyMem_Free(self.old_sizes)
+  /* "bz3/backends/cython/_bz3.pyx":782
+ *         MEMLOG("BZ3OmpDecompressor __dealloc__ %p\n", <void *> self)
  * 
  *     cpdef inline bytes decompress(self, const uint8_t[::1] data):             # <<<<<<<<<<<<<<
  *         cdef Py_ssize_t input_size = data.shape[0]
  *         cdef int32_t code
  */
 
   /* function exit code */
@@ -12748,15 +14791,15 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("decompress (wrapper)", 0);
   assert(__pyx_arg_data); {
-    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t__const__(__pyx_arg_data, 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 651, __pyx_L3_error)
+    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t__const__(__pyx_arg_data, 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 782, __pyx_L3_error)
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   __Pyx_AddTraceback("bz3.backends.cython._bz3.BZ3OmpDecompressor.decompress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
@@ -12772,16 +14815,16 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decompress", 0);
   __Pyx_XDECREF(__pyx_r);
-  if (unlikely(!__pyx_v_data.memview)) { __Pyx_RaiseUnboundLocalError("data"); __PYX_ERR(0, 651, __pyx_L1_error) }
-  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_decompress(__pyx_v_self, __pyx_v_data, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 651, __pyx_L1_error)
+  if (unlikely(!__pyx_v_data.memview)) { __Pyx_RaiseUnboundLocalError("data"); __PYX_ERR(0, 782, __pyx_L1_error) }
+  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_decompress(__pyx_v_self, __pyx_v_data, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 782, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -12791,15 +14834,15 @@
   __pyx_L0:;
   __PYX_XDEC_MEMVIEW(&__pyx_v_data, 1);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":699
+/* "bz3/backends/cython/_bz3.pyx":835
  * 
  *     @property
  *     def unused_data(self):             # <<<<<<<<<<<<<<
  *         """Data found after the end of the compressed stream."""
  *         return bytes(self.unused)
  */
 
@@ -12821,29 +14864,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":701
+  /* "bz3/backends/cython/_bz3.pyx":837
  *     def unused_data(self):
  *         """Data found after the end of the compressed stream."""
  *         return bytes(self.unused)             # <<<<<<<<<<<<<<
  * 
  *     cpdef inline list error(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_self->unused); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 701, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_self->unused); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 837, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "bz3/backends/cython/_bz3.pyx":699
+  /* "bz3/backends/cython/_bz3.pyx":835
  * 
  *     @property
  *     def unused_data(self):             # <<<<<<<<<<<<<<
  *         """Data found after the end of the compressed stream."""
  *         return bytes(self.unused)
  */
 
@@ -12854,15 +14897,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":703
+/* "bz3/backends/cython/_bz3.pyx":839
  *         return bytes(self.unused)
  * 
  *     cpdef inline list error(self):             # <<<<<<<<<<<<<<
  *         cdef uint32_t i
  *         cdef list ret = []
  */
 
@@ -12880,87 +14923,87 @@
   PyObject *__pyx_t_6 = NULL;
   int __pyx_t_7;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("error", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":705
+  /* "bz3/backends/cython/_bz3.pyx":841
  *     cpdef inline list error(self):
  *         cdef uint32_t i
  *         cdef list ret = []             # <<<<<<<<<<<<<<
  *         for i in range(self.numthreads):
  *             if bz3_last_error(self.states[i]) != BZ3_OK:
  */
-  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 705, __pyx_L1_error)
+  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 841, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_ret = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":706
+  /* "bz3/backends/cython/_bz3.pyx":842
  *         cdef uint32_t i
  *         cdef list ret = []
  *         for i in range(self.numthreads):             # <<<<<<<<<<<<<<
  *             if bz3_last_error(self.states[i]) != BZ3_OK:
  *                 ret.append((<bytes> bz3_strerror(self.states[i])).decode())
  */
   __pyx_t_2 = __pyx_v_self->numthreads;
   __pyx_t_3 = __pyx_t_2;
   for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
     __pyx_v_i = __pyx_t_4;
 
-    /* "bz3/backends/cython/_bz3.pyx":707
+    /* "bz3/backends/cython/_bz3.pyx":843
  *         cdef list ret = []
  *         for i in range(self.numthreads):
  *             if bz3_last_error(self.states[i]) != BZ3_OK:             # <<<<<<<<<<<<<<
  *                 ret.append((<bytes> bz3_strerror(self.states[i])).decode())
  *         return ret
  */
     __pyx_t_5 = ((bz3_last_error((__pyx_v_self->states[__pyx_v_i])) != BZ3_OK) != 0);
     if (__pyx_t_5) {
 
-      /* "bz3/backends/cython/_bz3.pyx":708
+      /* "bz3/backends/cython/_bz3.pyx":844
  *         for i in range(self.numthreads):
  *             if bz3_last_error(self.states[i]) != BZ3_OK:
  *                 ret.append((<bytes> bz3_strerror(self.states[i])).decode())             # <<<<<<<<<<<<<<
  *         return ret
  */
-      __pyx_t_1 = __Pyx_PyBytes_FromString(bz3_strerror((__pyx_v_self->states[__pyx_v_i]))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 708, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyBytes_FromString(bz3_strerror((__pyx_v_self->states[__pyx_v_i]))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 844, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
       if (unlikely(__pyx_t_1 == Py_None)) {
         PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "decode");
-        __PYX_ERR(0, 708, __pyx_L1_error)
+        __PYX_ERR(0, 844, __pyx_L1_error)
       }
-      __pyx_t_6 = __Pyx_decode_bytes(((PyObject*)__pyx_t_1), 0, PY_SSIZE_T_MAX, NULL, NULL, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 708, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_decode_bytes(((PyObject*)__pyx_t_1), 0, PY_SSIZE_T_MAX, NULL, NULL, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 844, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __pyx_t_7 = __Pyx_PyList_Append(__pyx_v_ret, __pyx_t_6); if (unlikely(__pyx_t_7 == ((int)-1))) __PYX_ERR(0, 708, __pyx_L1_error)
+      __pyx_t_7 = __Pyx_PyList_Append(__pyx_v_ret, __pyx_t_6); if (unlikely(__pyx_t_7 == ((int)-1))) __PYX_ERR(0, 844, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
 
-      /* "bz3/backends/cython/_bz3.pyx":707
+      /* "bz3/backends/cython/_bz3.pyx":843
  *         cdef list ret = []
  *         for i in range(self.numthreads):
  *             if bz3_last_error(self.states[i]) != BZ3_OK:             # <<<<<<<<<<<<<<
  *                 ret.append((<bytes> bz3_strerror(self.states[i])).decode())
  *         return ret
  */
     }
   }
 
-  /* "bz3/backends/cython/_bz3.pyx":709
+  /* "bz3/backends/cython/_bz3.pyx":845
  *             if bz3_last_error(self.states[i]) != BZ3_OK:
  *                 ret.append((<bytes> bz3_strerror(self.states[i])).decode())
  *         return ret             # <<<<<<<<<<<<<<
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_ret);
   __pyx_r = __pyx_v_ret;
   goto __pyx_L0;
 
-  /* "bz3/backends/cython/_bz3.pyx":703
+  /* "bz3/backends/cython/_bz3.pyx":839
  *         return bytes(self.unused)
  * 
  *     cpdef inline list error(self):             # <<<<<<<<<<<<<<
  *         cdef uint32_t i
  *         cdef list ret = []
  */
 
@@ -12996,15 +15039,15 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("error", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_error(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 703, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_error(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 839, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -13013,15 +15056,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":579
+/* "bz3/backends/cython/_bz3.pyx":688
  *         int32_t * sizes   # compressed
  *         int32_t * old_sizes  # origin
  *         readonly int32_t block_size             # <<<<<<<<<<<<<<
  *         bytearray unused  #
  *         bint have_magic_number
  */
 
@@ -13043,15 +15086,15 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_From_int32_t(__pyx_v_self->block_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 579, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int32_t(__pyx_v_self->block_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 688, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -13060,20 +15103,20 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "bz3/backends/cython/_bz3.pyx":582
+/* "bz3/backends/cython/_bz3.pyx":691
  *         bytearray unused  #
  *         bint have_magic_number
  *         readonly uint32_t numthreads  # how many threads to use             # <<<<<<<<<<<<<<
+ *         readonly bint ignore_error  # decode
  * 
- *     cdef inline int init_state(self, int32_t block_size) except -1:
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_10numthreads_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_10numthreads_1__get__(PyObject *__pyx_v_self) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -13090,15 +15133,15 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_From_uint32_t(__pyx_v_self->numthreads); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 582, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_uint32_t(__pyx_v_self->numthreads); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 691, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -13107,14 +15150,61 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
+/* "bz3/backends/cython/_bz3.pyx":692
+ *         bint have_magic_number
+ *         readonly uint32_t numthreads  # how many threads to use
+ *         readonly bint ignore_error  # decode             # <<<<<<<<<<<<<<
+ * 
+ *     cdef inline int init_state(self, int32_t block_size) except -1:
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_12ignore_error_1__get__(PyObject *__pyx_v_self); /*proto*/
+static PyObject *__pyx_pw_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_12ignore_error_1__get__(PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_12ignore_error___get__(((struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_12ignore_error___get__(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__get__", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->ignore_error); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 692, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("bz3.backends.cython._bz3.BZ3OmpDecompressor.ignore_error.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
 /* Python wrapper */
@@ -13142,15 +15232,15 @@
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__16, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
@@ -13199,15 +15289,15 @@
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
@@ -13425,15 +15515,15 @@
     /* "View.MemoryView":134
  * 
  *         if not self.ndim:
  *             raise ValueError("Empty shape tuple for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if itemsize <= 0:
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 134, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__19, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 134, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __PYX_ERR(1, 134, __pyx_L1_error)
 
     /* "View.MemoryView":133
  *         self.itemsize = itemsize
@@ -13457,15 +15547,15 @@
     /* "View.MemoryView":137
  * 
  *         if itemsize <= 0:
  *             raise ValueError("itemsize <= 0 for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if not isinstance(format, bytes):
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__19, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 137, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__20, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 137, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __PYX_ERR(1, 137, __pyx_L1_error)
 
     /* "View.MemoryView":136
  *             raise ValueError("Empty shape tuple for cython.array")
@@ -13584,15 +15674,15 @@
     /* "View.MemoryView":149
  * 
  *         if not self._shape:
  *             raise MemoryError("unable to allocate shape and strides.")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__20, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 149, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__21, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 149, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __PYX_ERR(1, 149, __pyx_L1_error)
 
     /* "View.MemoryView":148
  *         self._strides = self._shape + self.ndim
@@ -13858,15 +15948,15 @@
       /* "View.MemoryView":177
  *             self.data = <char *>malloc(self.len)
  *             if not self.data:
  *                 raise MemoryError("unable to allocate array data.")             # <<<<<<<<<<<<<<
  * 
  *             if self.dtype_is_object:
  */
-      __pyx_t_10 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__21, NULL); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 177, __pyx_L1_error)
+      __pyx_t_10 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__22, NULL); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 177, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_10);
       __Pyx_Raise(__pyx_t_10, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
       __PYX_ERR(1, 177, __pyx_L1_error)
 
       /* "View.MemoryView":176
  * 
@@ -14102,15 +16192,15 @@
     /* "View.MemoryView":193
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")             # <<<<<<<<<<<<<<
  *         info.buf = self.data
  *         info.len = self.len
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__22, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 193, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__23, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 193, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __PYX_ERR(1, 193, __pyx_L1_error)
 
     /* "View.MemoryView":192
  *         elif self.mode == u"fortran":
@@ -14836,15 +16926,15 @@
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__23, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__24, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
@@ -14892,15 +16982,15 @@
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__24, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
@@ -16621,15 +18711,15 @@
     /* "View.MemoryView":420
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:
  *             raise TypeError("Cannot assign to read-only memoryview")             # <<<<<<<<<<<<<<
  * 
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 420, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__26, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 420, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __PYX_ERR(1, 420, __pyx_L1_error)
 
     /* "View.MemoryView":419
  * 
@@ -17669,15 +19759,15 @@
       /* "View.MemoryView":497
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  *             raise ValueError("Unable to convert item to object")             # <<<<<<<<<<<<<<
  *         else:
  *             if len(self.view.format) == 1:
  */
-      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__26, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 497, __pyx_L5_except_error)
+      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__27, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 497, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_Raise(__pyx_t_6, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       __PYX_ERR(1, 497, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
@@ -18031,15 +20121,15 @@
     /* "View.MemoryView":522
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_ND:
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__27, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 522, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__28, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 522, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __PYX_ERR(1, 522, __pyx_L1_error)
 
     /* "View.MemoryView":521
  *     @cname('getbuffer')
@@ -18580,15 +20670,15 @@
     /* "View.MemoryView":572
  *         if self.view.strides == NULL:
  * 
  *             raise ValueError("Buffer view does not expose strides")             # <<<<<<<<<<<<<<
  * 
  *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__28, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 572, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__29, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 572, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __PYX_ERR(1, 572, __pyx_L1_error)
 
     /* "View.MemoryView":570
  *     @property
@@ -18697,15 +20787,15 @@
  *             return (-1,) * self.view.ndim             # <<<<<<<<<<<<<<
  * 
  *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
  */
     __Pyx_XDECREF(__pyx_r);
     __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 579, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = PyNumber_Multiply(__pyx_tuple__29, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 579, __pyx_L1_error)
+    __pyx_t_3 = PyNumber_Multiply(__pyx_tuple__30, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 579, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
     /* "View.MemoryView":578
@@ -19735,15 +21825,15 @@
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__30, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__31, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
@@ -19791,15 +21881,15 @@
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__31, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__32, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
@@ -20148,17 +22238,17 @@
  *             else:
  */
         __pyx_t_8 = PyObject_Length(__pyx_v_tup); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(1, 684, __pyx_L1_error)
         __pyx_t_7 = PyList_New(1 * ((((__pyx_v_ndim - __pyx_t_8) + 1)<0) ? 0:((__pyx_v_ndim - __pyx_t_8) + 1))); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 684, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
         { Py_ssize_t __pyx_temp;
           for (__pyx_temp=0; __pyx_temp < ((__pyx_v_ndim - __pyx_t_8) + 1); __pyx_temp++) {
-            __Pyx_INCREF(__pyx_slice__32);
-            __Pyx_GIVEREF(__pyx_slice__32);
-            PyList_SET_ITEM(__pyx_t_7, __pyx_temp, __pyx_slice__32);
+            __Pyx_INCREF(__pyx_slice__33);
+            __Pyx_GIVEREF(__pyx_slice__33);
+            PyList_SET_ITEM(__pyx_t_7, __pyx_temp, __pyx_slice__33);
           }
         }
         __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_7); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 684, __pyx_L1_error)
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
         /* "View.MemoryView":685
  *             if not seen_ellipsis:
@@ -20183,15 +22273,15 @@
  *                 seen_ellipsis = True
  *             else:
  *                 result.append(slice(None))             # <<<<<<<<<<<<<<
  *             have_slices = True
  *         else:
  */
       /*else*/ {
-        __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_slice__32); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 687, __pyx_L1_error)
+        __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_slice__33); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 687, __pyx_L1_error)
       }
       __pyx_L7:;
 
       /* "View.MemoryView":688
  *             else:
  *                 result.append(slice(None))
  *             have_slices = True             # <<<<<<<<<<<<<<
@@ -20323,17 +22413,17 @@
  * 
  *     return have_slices or nslices, tuple(result)
  */
     __pyx_t_3 = PyList_New(1 * ((__pyx_v_nslices<0) ? 0:__pyx_v_nslices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 698, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     { Py_ssize_t __pyx_temp;
       for (__pyx_temp=0; __pyx_temp < __pyx_v_nslices; __pyx_temp++) {
-        __Pyx_INCREF(__pyx_slice__32);
-        __Pyx_GIVEREF(__pyx_slice__32);
-        PyList_SET_ITEM(__pyx_t_3, __pyx_temp, __pyx_slice__32);
+        __Pyx_INCREF(__pyx_slice__33);
+        __Pyx_GIVEREF(__pyx_slice__33);
+        PyList_SET_ITEM(__pyx_t_3, __pyx_temp, __pyx_slice__33);
       }
     }
     __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_3); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 698, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
     /* "View.MemoryView":697
  * 
@@ -20452,15 +22542,15 @@
       /* "View.MemoryView":705
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  *             raise ValueError("Indirect dimensions not supported")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__33, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 705, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__34, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 705, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_Raise(__pyx_t_5, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __PYX_ERR(1, 705, __pyx_L1_error)
 
       /* "View.MemoryView":704
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
@@ -20560,15 +22650,15 @@
  *     cdef _memoryviewslice memviewsliceobj
  * 
  *     assert memview.view.ndim > 0             # <<<<<<<<<<<<<<
  * 
  *     if isinstance(memview, _memoryviewslice):
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
-  if (unlikely(!Py_OptimizeFlag)) {
+  if (unlikely(__pyx_assertions_enabled())) {
     if (unlikely(!((__pyx_v_memview->view.ndim > 0) != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
       __PYX_ERR(1, 724, __pyx_L1_error)
     }
   }
   #endif
 
@@ -22636,15 +24726,15 @@
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__34, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__35, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
@@ -22692,15 +24782,15 @@
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__35, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__36, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
@@ -25969,15 +28059,15 @@
  *     cdef object __pyx_result
  *     if __pyx_checksum not in (0xb068931, 0x82a3537, 0x6ae9995):             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
  *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)
  */
   __pyx_t_1 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_t_1, __pyx_tuple__36, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_t_1, __pyx_tuple__37, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_3 = (__pyx_t_2 != 0);
   if (__pyx_t_3) {
 
     /* "(tree fragment)":5
  *     cdef object __pyx_result
  *     if __pyx_checksum not in (0xb068931, 0x82a3537, 0x6ae9995):
@@ -26391,38 +28481,38 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 static struct __pyx_vtabstruct_3bz3_8backends_6cython_4_bz3_BZ3Decompressor __pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3Decompressor;
 
 static struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *__pyx_freelist_3bz3_8backends_6cython_4_bz3_BZ3Decompressor[8];
 static int __pyx_freecount_3bz3_8backends_6cython_4_bz3_BZ3Decompressor = 0;
 
-static PyObject *__pyx_tp_new_3bz3_8backends_6cython_4_bz3_BZ3Decompressor(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
+static PyObject *__pyx_tp_new_3bz3_8backends_6cython_4_bz3_BZ3Decompressor(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *p;
   PyObject *o;
   if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_3bz3_8backends_6cython_4_bz3_BZ3Decompressor > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor)))) {
     o = (PyObject*)__pyx_freelist_3bz3_8backends_6cython_4_bz3_BZ3Decompressor[--__pyx_freecount_3bz3_8backends_6cython_4_bz3_BZ3Decompressor];
     memset(o, 0, sizeof(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor));
     (void) PyObject_INIT(o, t);
   } else {
     o = (*t->tp_alloc)(t, 0);
     if (unlikely(!o)) return 0;
   }
   p = ((struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *)o);
   p->__pyx_vtab = __pyx_vtabptr_3bz3_8backends_6cython_4_bz3_BZ3Decompressor;
   p->unused = ((PyObject*)Py_None); Py_INCREF(Py_None);
-  if (unlikely(__pyx_pw_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_1__cinit__(o, __pyx_empty_tuple, NULL) < 0)) goto bad;
+  if (unlikely(__pyx_pw_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_1__cinit__(o, a, k) < 0)) goto bad;
   return o;
   bad:
   Py_DECREF(o); o = 0;
   return NULL;
 }
 
 static void __pyx_tp_dealloc_3bz3_8backends_6cython_4_bz3_BZ3Decompressor(PyObject *o) {
@@ -26447,25 +28537,30 @@
   return __pyx_pw_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_11unused_data_1__get__(o);
 }
 
 static PyObject *__pyx_getprop_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_block_size(PyObject *o, CYTHON_UNUSED void *x) {
   return __pyx_pw_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_10block_size_1__get__(o);
 }
 
+static PyObject *__pyx_getprop_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_ignore_error(PyObject *o, CYTHON_UNUSED void *x) {
+  return __pyx_pw_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_12ignore_error_1__get__(o);
+}
+
 static PyMethodDef __pyx_methods_3bz3_8backends_6cython_4_bz3_BZ3Decompressor[] = {
   {"decompress", (PyCFunction)__pyx_pw_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_5decompress, METH_O, __pyx_doc_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_4decompress},
   {"error", (PyCFunction)__pyx_pw_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_7error, METH_NOARGS, __pyx_doc_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_6error},
   {"__reduce_cython__", (PyCFunction)__pyx_pw_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_9__reduce_cython__, METH_NOARGS, __pyx_doc_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_8__reduce_cython__},
   {"__setstate_cython__", (PyCFunction)__pyx_pw_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_11__setstate_cython__, METH_O, __pyx_doc_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_10__setstate_cython__},
   {0, 0, 0, 0}
 };
 
 static struct PyGetSetDef __pyx_getsets_3bz3_8backends_6cython_4_bz3_BZ3Decompressor[] = {
   {(char *)"unused_data", __pyx_getprop_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_unused_data, 0, (char *)"Data found after the end of the compressed stream.", 0},
   {(char *)"block_size", __pyx_getprop_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_block_size, 0, (char *)0, 0},
+  {(char *)"ignore_error", __pyx_getprop_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_ignore_error, 0, (char *)0, 0},
   {0, 0, 0, 0, 0}
 };
 
 static PyTypeObject __pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Decompressor = {
   PyVarObject_HEAD_INIT(0, 0)
   "bz3.backends.cython._bz3.BZ3Decompressor", /*tp_name*/
   sizeof(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor), /*tp_basicsize*/
@@ -26528,15 +28623,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 static struct __pyx_vtabstruct_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor __pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor;
 
 static struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *__pyx_freelist_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor[8];
 static int __pyx_freecount_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor = 0;
@@ -26666,15 +28761,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 static struct __pyx_vtabstruct_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor __pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor;
 
 static struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *__pyx_freelist_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor[8];
 static int __pyx_freecount_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor = 0;
@@ -26726,26 +28821,31 @@
   return __pyx_pw_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_10block_size_1__get__(o);
 }
 
 static PyObject *__pyx_getprop_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_numthreads(PyObject *o, CYTHON_UNUSED void *x) {
   return __pyx_pw_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_10numthreads_1__get__(o);
 }
 
+static PyObject *__pyx_getprop_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_ignore_error(PyObject *o, CYTHON_UNUSED void *x) {
+  return __pyx_pw_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_12ignore_error_1__get__(o);
+}
+
 static PyMethodDef __pyx_methods_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor[] = {
   {"decompress", (PyCFunction)__pyx_pw_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_5decompress, METH_O, __pyx_doc_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_4decompress},
   {"error", (PyCFunction)__pyx_pw_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_7error, METH_NOARGS, __pyx_doc_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_6error},
   {"__reduce_cython__", (PyCFunction)__pyx_pw_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_9__reduce_cython__, METH_NOARGS, __pyx_doc_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_8__reduce_cython__},
   {"__setstate_cython__", (PyCFunction)__pyx_pw_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_11__setstate_cython__, METH_O, __pyx_doc_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_10__setstate_cython__},
   {0, 0, 0, 0}
 };
 
 static struct PyGetSetDef __pyx_getsets_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor[] = {
   {(char *)"unused_data", __pyx_getprop_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_unused_data, 0, (char *)"Data found after the end of the compressed stream.", 0},
   {(char *)"block_size", __pyx_getprop_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_block_size, 0, (char *)0, 0},
   {(char *)"numthreads", __pyx_getprop_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_numthreads, 0, (char *)0, 0},
+  {(char *)"ignore_error", __pyx_getprop_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_ignore_error, 0, (char *)0, 0},
   {0, 0, 0, 0, 0}
 };
 
 static PyTypeObject __pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor = {
   PyVarObject_HEAD_INIT(0, 0)
   "bz3.backends.cython._bz3.BZ3OmpDecompressor", /*tp_name*/
   sizeof(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor), /*tp_basicsize*/
@@ -26808,15 +28908,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 static struct __pyx_vtabstruct_array __pyx_vtable_array;
 
 static PyObject *__pyx_tp_new_array(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_array_obj *p;
@@ -26837,15 +28937,15 @@
   Py_DECREF(o); o = 0;
   return NULL;
 }
 
 static void __pyx_tp_dealloc_array(PyObject *o) {
   struct __pyx_array_obj *p = (struct __pyx_array_obj *)o;
   #if CYTHON_USE_TP_FINALIZE
-  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !__Pyx_PyObject_GC_IsFinalized(o))) {
     if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   {
     PyObject *etype, *eval, *etb;
     PyErr_Fetch(&etype, &eval, &etb);
     __Pyx_SET_REFCNT(o, Py_REFCNT(o) + 1);
@@ -27000,15 +29100,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyObject *__pyx_tp_new_Enum(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
   struct __pyx_MemviewEnum_obj *p;
   PyObject *o;
@@ -27022,15 +29122,15 @@
   p->name = Py_None; Py_INCREF(Py_None);
   return o;
 }
 
 static void __pyx_tp_dealloc_Enum(PyObject *o) {
   struct __pyx_MemviewEnum_obj *p = (struct __pyx_MemviewEnum_obj *)o;
   #if CYTHON_USE_TP_FINALIZE
-  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !__Pyx_PyObject_GC_IsFinalized(o)) {
     if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   PyObject_GC_UnTrack(o);
   Py_CLEAR(p->name);
   (*Py_TYPE(o)->tp_free)(o);
 }
@@ -27122,15 +29222,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 static struct __pyx_vtabstruct_memoryview __pyx_vtable_memoryview;
 
 static PyObject *__pyx_tp_new_memoryview(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_memoryview_obj *p;
@@ -27153,15 +29253,15 @@
   Py_DECREF(o); o = 0;
   return NULL;
 }
 
 static void __pyx_tp_dealloc_memoryview(PyObject *o) {
   struct __pyx_memoryview_obj *p = (struct __pyx_memoryview_obj *)o;
   #if CYTHON_USE_TP_FINALIZE
-  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !__Pyx_PyObject_GC_IsFinalized(o)) {
     if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   PyObject_GC_UnTrack(o);
   {
     PyObject *etype, *eval, *etb;
     PyErr_Fetch(&etype, &eval, &etb);
@@ -27386,15 +29486,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 static struct __pyx_vtabstruct__memoryviewslice __pyx_vtable__memoryviewslice;
 
 static PyObject *__pyx_tp_new__memoryviewslice(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_memoryviewslice_obj *p;
@@ -27406,15 +29506,15 @@
   p->from_slice.memview = NULL;
   return o;
 }
 
 static void __pyx_tp_dealloc__memoryviewslice(PyObject *o) {
   struct __pyx_memoryviewslice_obj *p = (struct __pyx_memoryviewslice_obj *)o;
   #if CYTHON_USE_TP_FINALIZE
-  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !__Pyx_PyObject_GC_IsFinalized(o)) {
     if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   PyObject_GC_UnTrack(o);
   {
     PyObject *etype, *eval, *etb;
     PyErr_Fetch(&etype, &eval, &etb);
@@ -27535,25 +29635,25 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyMethodDef __pyx_methods[] = {
-  {"test_file", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3bz3_8backends_6cython_4_bz3_5test_file, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3bz3_8backends_6cython_4_bz3_4test_file},
-  {"bound", (PyCFunction)__pyx_pw_3bz3_8backends_6cython_4_bz3_7bound, METH_O, __pyx_doc_3bz3_8backends_6cython_4_bz3_6bound},
-  {"compress_into", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3bz3_8backends_6cython_4_bz3_9compress_into, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3bz3_8backends_6cython_4_bz3_8compress_into},
-  {"decompress_into", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3bz3_8backends_6cython_4_bz3_11decompress_into, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3bz3_8backends_6cython_4_bz3_10decompress_into},
-  {"libversion", (PyCFunction)__pyx_pw_3bz3_8backends_6cython_4_bz3_13libversion, METH_NOARGS, __pyx_doc_3bz3_8backends_6cython_4_bz3_12libversion},
+  {"test_file", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3bz3_8backends_6cython_4_bz3_7test_file, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3bz3_8backends_6cython_4_bz3_6test_file},
+  {"bound", (PyCFunction)__pyx_pw_3bz3_8backends_6cython_4_bz3_9bound, METH_O, __pyx_doc_3bz3_8backends_6cython_4_bz3_8bound},
+  {"compress_into", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3bz3_8backends_6cython_4_bz3_11compress_into, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3bz3_8backends_6cython_4_bz3_10compress_into},
+  {"decompress_into", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3bz3_8backends_6cython_4_bz3_13decompress_into, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3bz3_8backends_6cython_4_bz3_12decompress_into},
+  {"libversion", (PyCFunction)__pyx_pw_3bz3_8backends_6cython_4_bz3_15libversion, METH_NOARGS, __pyx_doc_3bz3_8backends_6cython_4_bz3_14libversion},
   {0, 0, 0, 0}
 };
 
 #if PY_MAJOR_VERSION >= 3
 #if CYTHON_PEP489_MULTI_PHASE_INIT
 static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
 static int __pyx_pymod_exec__bz3(PyObject* module); /*proto*/
@@ -27607,14 +29707,15 @@
   {&__pyx_kp_s_Cannot_assign_to_read_only_memor, __pyx_k_Cannot_assign_to_read_only_memor, sizeof(__pyx_k_Cannot_assign_to_read_only_memor), 0, 0, 1, 0},
   {&__pyx_kp_s_Cannot_create_writable_memory_vi, __pyx_k_Cannot_create_writable_memory_vi, sizeof(__pyx_k_Cannot_create_writable_memory_vi), 0, 0, 1, 0},
   {&__pyx_kp_s_Cannot_index_with_type_s, __pyx_k_Cannot_index_with_type_s, sizeof(__pyx_k_Cannot_index_with_type_s), 0, 0, 1, 0},
   {&__pyx_n_s_Ellipsis, __pyx_k_Ellipsis, sizeof(__pyx_k_Ellipsis), 0, 0, 1, 1},
   {&__pyx_kp_s_Empty_shape_tuple_for_cython_arr, __pyx_k_Empty_shape_tuple_for_cython_arr, sizeof(__pyx_k_Empty_shape_tuple_for_cython_arr), 0, 0, 1, 0},
   {&__pyx_kp_u_Failed_to_allocate_memory, __pyx_k_Failed_to_allocate_memory, sizeof(__pyx_k_Failed_to_allocate_memory), 0, 1, 0, 0},
   {&__pyx_kp_u_Failed_to_create_a_block_encoder, __pyx_k_Failed_to_create_a_block_encoder, sizeof(__pyx_k_Failed_to_create_a_block_encoder), 0, 1, 0, 0},
+  {&__pyx_kp_u_Failed_to_decode_a_block_Inconsi, __pyx_k_Failed_to_decode_a_block_Inconsi, sizeof(__pyx_k_Failed_to_decode_a_block_Inconsi), 0, 1, 0, 0},
   {&__pyx_kp_u_Failed_to_decode_a_block_s, __pyx_k_Failed_to_decode_a_block_s, sizeof(__pyx_k_Failed_to_decode_a_block_s), 0, 1, 0, 0},
   {&__pyx_kp_u_Failed_to_decode_data_s, __pyx_k_Failed_to_decode_data_s, sizeof(__pyx_k_Failed_to_decode_data_s), 0, 1, 0, 0},
   {&__pyx_kp_u_Failed_to_encode_a_block_s, __pyx_k_Failed_to_encode_a_block_s, sizeof(__pyx_k_Failed_to_encode_a_block_s), 0, 1, 0, 0},
   {&__pyx_kp_s_Incompatible_checksums_0x_x_vs_0, __pyx_k_Incompatible_checksums_0x_x_vs_0, sizeof(__pyx_k_Incompatible_checksums_0x_x_vs_0), 0, 0, 1, 0},
   {&__pyx_n_s_IndexError, __pyx_k_IndexError, sizeof(__pyx_k_IndexError), 0, 0, 1, 1},
   {&__pyx_kp_s_Indirect_dimensions_not_supporte, __pyx_k_Indirect_dimensions_not_supporte, sizeof(__pyx_k_Indirect_dimensions_not_supporte), 0, 0, 1, 0},
   {&__pyx_kp_u_Invalid_file_Reason_Smaller_than, __pyx_k_Invalid_file_Reason_Smaller_than, sizeof(__pyx_k_Invalid_file_Reason_Smaller_than), 0, 1, 0, 0},
@@ -27665,14 +29766,15 @@
   {&__pyx_n_s_flush, __pyx_k_flush, sizeof(__pyx_k_flush), 0, 0, 1, 1},
   {&__pyx_n_s_format, __pyx_k_format, sizeof(__pyx_k_format), 0, 0, 1, 1},
   {&__pyx_n_s_fortran, __pyx_k_fortran, sizeof(__pyx_k_fortran), 0, 0, 1, 1},
   {&__pyx_n_u_fortran, __pyx_k_fortran, sizeof(__pyx_k_fortran), 0, 1, 0, 1},
   {&__pyx_n_s_getstate, __pyx_k_getstate, sizeof(__pyx_k_getstate), 0, 0, 1, 1},
   {&__pyx_kp_s_got_differing_extents_in_dimensi, __pyx_k_got_differing_extents_in_dimensi, sizeof(__pyx_k_got_differing_extents_in_dimensi), 0, 0, 1, 0},
   {&__pyx_n_s_id, __pyx_k_id, sizeof(__pyx_k_id), 0, 0, 1, 1},
+  {&__pyx_n_s_ignore_error, __pyx_k_ignore_error, sizeof(__pyx_k_ignore_error), 0, 0, 1, 1},
   {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
   {&__pyx_n_s_input, __pyx_k_input, sizeof(__pyx_k_input), 0, 0, 1, 1},
   {&__pyx_kp_u_input_except_a_file_like_object, __pyx_k_input_except_a_file_like_object, sizeof(__pyx_k_input_except_a_file_like_object), 0, 1, 0, 0},
   {&__pyx_n_s_itemsize, __pyx_k_itemsize, sizeof(__pyx_k_itemsize), 0, 0, 1, 1},
   {&__pyx_kp_s_itemsize_0_for_cython_array, __pyx_k_itemsize_0_for_cython_array, sizeof(__pyx_k_itemsize_0_for_cython_array), 0, 0, 1, 0},
   {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
   {&__pyx_n_s_memview, __pyx_k_memview, sizeof(__pyx_k_memview), 0, 0, 1, 1},
@@ -27697,14 +29799,15 @@
   {&__pyx_n_s_pyx_result, __pyx_k_pyx_result, sizeof(__pyx_k_pyx_result), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_state, __pyx_k_pyx_state, sizeof(__pyx_k_pyx_state), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_type, __pyx_k_pyx_type, sizeof(__pyx_k_pyx_type), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_unpickle_Enum, __pyx_k_pyx_unpickle_Enum, sizeof(__pyx_k_pyx_unpickle_Enum), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
   {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
   {&__pyx_n_s_read, __pyx_k_read, sizeof(__pyx_k_read), 0, 0, 1, 1},
+  {&__pyx_n_s_recover_file, __pyx_k_recover_file, sizeof(__pyx_k_recover_file), 0, 0, 1, 1},
   {&__pyx_n_s_reduce, __pyx_k_reduce, sizeof(__pyx_k_reduce), 0, 0, 1, 1},
   {&__pyx_n_s_reduce_cython, __pyx_k_reduce_cython, sizeof(__pyx_k_reduce_cython), 0, 0, 1, 1},
   {&__pyx_n_s_reduce_ex, __pyx_k_reduce_ex, sizeof(__pyx_k_reduce_ex), 0, 0, 1, 1},
   {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
   {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
   {&__pyx_n_s_shape, __pyx_k_shape, sizeof(__pyx_k_shape), 0, 0, 1, 1},
   {&__pyx_n_s_should_raise, __pyx_k_should_raise, sizeof(__pyx_k_should_raise), 0, 0, 1, 1},
@@ -27723,61 +29826,61 @@
   {&__pyx_kp_s_unable_to_allocate_shape_and_str, __pyx_k_unable_to_allocate_shape_and_str, sizeof(__pyx_k_unable_to_allocate_shape_and_str), 0, 0, 1, 0},
   {&__pyx_n_s_unpack, __pyx_k_unpack, sizeof(__pyx_k_unpack), 0, 0, 1, 1},
   {&__pyx_n_s_update, __pyx_k_update, sizeof(__pyx_k_update), 0, 0, 1, 1},
   {&__pyx_n_s_write, __pyx_k_write, sizeof(__pyx_k_write), 0, 0, 1, 1},
   {0, 0, 0, 0, 0, 0, 0}
 };
 static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
-  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 40, __pyx_L1_error)
-  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(0, 44, __pyx_L1_error)
+  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 44, __pyx_L1_error)
+  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(0, 48, __pyx_L1_error)
   __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(1, 2, __pyx_L1_error)
-  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 434, __pyx_L1_error)
+  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 521, __pyx_L1_error)
   __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(1, 152, __pyx_L1_error)
   __pyx_builtin_Ellipsis = __Pyx_GetBuiltinName(__pyx_n_s_Ellipsis); if (!__pyx_builtin_Ellipsis) __PYX_ERR(1, 406, __pyx_L1_error)
   __pyx_builtin_id = __Pyx_GetBuiltinName(__pyx_n_s_id); if (!__pyx_builtin_id) __PYX_ERR(1, 615, __pyx_L1_error)
   __pyx_builtin_IndexError = __Pyx_GetBuiltinName(__pyx_n_s_IndexError); if (!__pyx_builtin_IndexError) __PYX_ERR(1, 834, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
 
-  /* "bz3/backends/cython/_bz3.pyx":40
+  /* "bz3/backends/cython/_bz3.pyx":44
  *     def __cinit__(self, int32_t block_size):
  *         if block_size < KiB(65) or block_size > MiB(511):
  *             raise ValueError("Block size must be between 65 KiB and 511 MiB")             # <<<<<<<<<<<<<<
  *         self.block_size = block_size
  *         self.state = bz3_new(block_size)
  */
-  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_u_Block_size_must_be_between_65_Ki); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 40, __pyx_L1_error)
+  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_u_Block_size_must_be_between_65_Ki); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 44, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple_);
   __Pyx_GIVEREF(__pyx_tuple_);
 
-  /* "bz3/backends/cython/_bz3.pyx":44
+  /* "bz3/backends/cython/_bz3.pyx":48
  *         self.state = bz3_new(block_size)
  *         if self.state == NULL:
  *             raise MemoryError("Failed to create a block encoder state")             # <<<<<<<<<<<<<<
- *         self.buffer = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
+ *         self.buffer = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))
  *         if self.buffer == NULL:
  */
-  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_u_Failed_to_create_a_block_encoder); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 44, __pyx_L1_error)
+  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_u_Failed_to_create_a_block_encoder); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 48, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__2);
   __Pyx_GIVEREF(__pyx_tuple__2);
 
-  /* "bz3/backends/cython/_bz3.pyx":49
+  /* "bz3/backends/cython/_bz3.pyx":53
  *             bz3_free(self.state)
  *             self.state = NULL
  *             raise MemoryError("Failed to allocate memory")             # <<<<<<<<<<<<<<
  *         self.uncompressed = bytearray()
  *         self.have_magic_number = 0 # magic number
  */
-  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_u_Failed_to_allocate_memory); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 49, __pyx_L1_error)
+  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_u_Failed_to_allocate_memory); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 53, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__3);
   __Pyx_GIVEREF(__pyx_tuple__3);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
@@ -27792,395 +29895,423 @@
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
   __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__8);
   __Pyx_GIVEREF(__pyx_tuple__8);
 
-  /* "bz3/backends/cython/_bz3.pyx":166
+  /* "bz3/backends/cython/_bz3.pyx":172
  *             if PyByteArray_GET_SIZE(self.unused) > 9 and not self.have_magic_number: # 9 bytes magic number
  *                 if strncmp(PyByteArray_AS_STRING(self.unused), magic, 5) != 0:
  *                     raise ValueError("Invalid signature")             # <<<<<<<<<<<<<<
  *                 block_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[5]))
  *                 if block_size  < KiB(65) or block_size >MiB(511):
  */
-  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_u_Invalid_signature); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(0, 166, __pyx_L1_error)
+  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_u_Invalid_signature); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(0, 172, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__9);
   __Pyx_GIVEREF(__pyx_tuple__9);
 
-  /* "bz3/backends/cython/_bz3.pyx":169
+  /* "bz3/backends/cython/_bz3.pyx":175
  *                 block_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[5]))
  *                 if block_size  < KiB(65) or block_size >MiB(511):
  *                     raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")             # <<<<<<<<<<<<<<
  *                 self.init_state(block_size)
  *                 del self.unused[:9]
  */
-  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_u_The_input_file_is_corrupted_Reas); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(0, 169, __pyx_L1_error)
+  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_u_The_input_file_is_corrupted_Reas); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(0, 175, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__10);
   __Pyx_GIVEREF(__pyx_tuple__10);
 
+  /* "bz3/backends/cython/_bz3.pyx":186
+ *                 old_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[4]))
+ *                 if old_size > <int32_t>bz3_bound(self.block_size) or new_size > <int32_t>bz3_bound(self.block_size):
+ *                     raise ValueError("Failed to decode a block: Inconsistent headers.")             # <<<<<<<<<<<<<<
+ *                 if PyByteArray_GET_SIZE(self.unused) < new_size+8: #
+ *                     break
+ */
+  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_u_Failed_to_decode_a_block_Inconsi); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(0, 186, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__11);
+  __Pyx_GIVEREF(__pyx_tuple__11);
+
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(1, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__11);
-  __Pyx_GIVEREF(__pyx_tuple__11);
+  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__12);
+  __Pyx_GIVEREF(__pyx_tuple__12);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__12);
-  __Pyx_GIVEREF(__pyx_tuple__12);
+  __pyx_tuple__13 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__13);
+  __Pyx_GIVEREF(__pyx_tuple__13);
 
-  /* "bz3/backends/cython/_bz3.pyx":257
+  /* "bz3/backends/cython/_bz3.pyx":269
  *     data = input.read(9) # magic and block_size type: bytes len = 9
  *     if PyBytes_GET_SIZE(data) < 9:
  *         raise ValueError("Invalid file. Reason: Smaller than magic header")             # <<<<<<<<<<<<<<
  *     if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:
  *         raise ValueError("Invalid signature")
  */
-  __pyx_tuple__13 = PyTuple_Pack(1, __pyx_kp_u_Invalid_file_Reason_Smaller_than); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(0, 257, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__13);
-  __Pyx_GIVEREF(__pyx_tuple__13);
+  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_u_Invalid_file_Reason_Smaller_than); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(0, 269, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__14);
+  __Pyx_GIVEREF(__pyx_tuple__14);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(1, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__14);
-  __Pyx_GIVEREF(__pyx_tuple__14);
+  __pyx_tuple__15 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__15);
+  __Pyx_GIVEREF(__pyx_tuple__15);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_tuple__15 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__15);
-  __Pyx_GIVEREF(__pyx_tuple__15);
+  __pyx_tuple__16 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__16);
+  __Pyx_GIVEREF(__pyx_tuple__16);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_tuple__16 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(1, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__16);
-  __Pyx_GIVEREF(__pyx_tuple__16);
+  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__17);
+  __Pyx_GIVEREF(__pyx_tuple__17);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__17);
-  __Pyx_GIVEREF(__pyx_tuple__17);
+  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__18);
+  __Pyx_GIVEREF(__pyx_tuple__18);
 
   /* "View.MemoryView":134
  * 
  *         if not self.ndim:
  *             raise ValueError("Empty shape tuple for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if itemsize <= 0:
  */
-  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_s_Empty_shape_tuple_for_cython_arr); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(1, 134, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__18);
-  __Pyx_GIVEREF(__pyx_tuple__18);
+  __pyx_tuple__19 = PyTuple_Pack(1, __pyx_kp_s_Empty_shape_tuple_for_cython_arr); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(1, 134, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__19);
+  __Pyx_GIVEREF(__pyx_tuple__19);
 
   /* "View.MemoryView":137
  * 
  *         if itemsize <= 0:
  *             raise ValueError("itemsize <= 0 for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if not isinstance(format, bytes):
  */
-  __pyx_tuple__19 = PyTuple_Pack(1, __pyx_kp_s_itemsize_0_for_cython_array); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(1, 137, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__19);
-  __Pyx_GIVEREF(__pyx_tuple__19);
+  __pyx_tuple__20 = PyTuple_Pack(1, __pyx_kp_s_itemsize_0_for_cython_array); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(1, 137, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__20);
+  __Pyx_GIVEREF(__pyx_tuple__20);
 
   /* "View.MemoryView":149
  * 
  *         if not self._shape:
  *             raise MemoryError("unable to allocate shape and strides.")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__20 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_shape_and_str); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(1, 149, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__20);
-  __Pyx_GIVEREF(__pyx_tuple__20);
+  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_shape_and_str); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(1, 149, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__21);
+  __Pyx_GIVEREF(__pyx_tuple__21);
 
   /* "View.MemoryView":177
  *             self.data = <char *>malloc(self.len)
  *             if not self.data:
  *                 raise MemoryError("unable to allocate array data.")             # <<<<<<<<<<<<<<
  * 
  *             if self.dtype_is_object:
  */
-  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_array_data); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(1, 177, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__21);
-  __Pyx_GIVEREF(__pyx_tuple__21);
+  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_array_data); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(1, 177, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__22);
+  __Pyx_GIVEREF(__pyx_tuple__22);
 
   /* "View.MemoryView":193
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")             # <<<<<<<<<<<<<<
  *         info.buf = self.data
  *         info.len = self.len
  */
-  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_kp_s_Can_only_create_a_buffer_that_is); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(1, 193, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__22);
-  __Pyx_GIVEREF(__pyx_tuple__22);
+  __pyx_tuple__23 = PyTuple_Pack(1, __pyx_kp_s_Can_only_create_a_buffer_that_is); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(1, 193, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__23);
+  __Pyx_GIVEREF(__pyx_tuple__23);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_tuple__23 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(1, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__23);
-  __Pyx_GIVEREF(__pyx_tuple__23);
+  __pyx_tuple__24 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__24);
+  __Pyx_GIVEREF(__pyx_tuple__24);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_tuple__24 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__24);
-  __Pyx_GIVEREF(__pyx_tuple__24);
+  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__25);
+  __Pyx_GIVEREF(__pyx_tuple__25);
 
   /* "View.MemoryView":420
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:
  *             raise TypeError("Cannot assign to read-only memoryview")             # <<<<<<<<<<<<<<
  * 
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  */
-  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_kp_s_Cannot_assign_to_read_only_memor); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(1, 420, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__25);
-  __Pyx_GIVEREF(__pyx_tuple__25);
+  __pyx_tuple__26 = PyTuple_Pack(1, __pyx_kp_s_Cannot_assign_to_read_only_memor); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(1, 420, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__26);
+  __Pyx_GIVEREF(__pyx_tuple__26);
 
   /* "View.MemoryView":497
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  *             raise ValueError("Unable to convert item to object")             # <<<<<<<<<<<<<<
  *         else:
  *             if len(self.view.format) == 1:
  */
-  __pyx_tuple__26 = PyTuple_Pack(1, __pyx_kp_s_Unable_to_convert_item_to_object); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(1, 497, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__26);
-  __Pyx_GIVEREF(__pyx_tuple__26);
+  __pyx_tuple__27 = PyTuple_Pack(1, __pyx_kp_s_Unable_to_convert_item_to_object); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(1, 497, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__27);
+  __Pyx_GIVEREF(__pyx_tuple__27);
 
   /* "View.MemoryView":522
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_ND:
  */
-  __pyx_tuple__27 = PyTuple_Pack(1, __pyx_kp_s_Cannot_create_writable_memory_vi); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(1, 522, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__27);
-  __Pyx_GIVEREF(__pyx_tuple__27);
+  __pyx_tuple__28 = PyTuple_Pack(1, __pyx_kp_s_Cannot_create_writable_memory_vi); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(1, 522, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__28);
+  __Pyx_GIVEREF(__pyx_tuple__28);
 
   /* "View.MemoryView":572
  *         if self.view.strides == NULL:
  * 
  *             raise ValueError("Buffer view does not expose strides")             # <<<<<<<<<<<<<<
  * 
  *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])
  */
-  __pyx_tuple__28 = PyTuple_Pack(1, __pyx_kp_s_Buffer_view_does_not_expose_stri); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(1, 572, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__28);
-  __Pyx_GIVEREF(__pyx_tuple__28);
+  __pyx_tuple__29 = PyTuple_Pack(1, __pyx_kp_s_Buffer_view_does_not_expose_stri); if (unlikely(!__pyx_tuple__29)) __PYX_ERR(1, 572, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__29);
+  __Pyx_GIVEREF(__pyx_tuple__29);
 
   /* "View.MemoryView":579
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:
  *             return (-1,) * self.view.ndim             # <<<<<<<<<<<<<<
  * 
  *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
  */
-  __pyx_tuple__29 = PyTuple_New(1); if (unlikely(!__pyx_tuple__29)) __PYX_ERR(1, 579, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__29);
+  __pyx_tuple__30 = PyTuple_New(1); if (unlikely(!__pyx_tuple__30)) __PYX_ERR(1, 579, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__30);
   __Pyx_INCREF(__pyx_int_neg_1);
   __Pyx_GIVEREF(__pyx_int_neg_1);
-  PyTuple_SET_ITEM(__pyx_tuple__29, 0, __pyx_int_neg_1);
-  __Pyx_GIVEREF(__pyx_tuple__29);
+  PyTuple_SET_ITEM(__pyx_tuple__30, 0, __pyx_int_neg_1);
+  __Pyx_GIVEREF(__pyx_tuple__30);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_tuple__30 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__30)) __PYX_ERR(1, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__30);
-  __Pyx_GIVEREF(__pyx_tuple__30);
+  __pyx_tuple__31 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__31)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__31);
+  __Pyx_GIVEREF(__pyx_tuple__31);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_tuple__31 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__31)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__31);
-  __Pyx_GIVEREF(__pyx_tuple__31);
+  __pyx_tuple__32 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__32)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__32);
+  __Pyx_GIVEREF(__pyx_tuple__32);
 
   /* "View.MemoryView":684
  *         if item is Ellipsis:
  *             if not seen_ellipsis:
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))             # <<<<<<<<<<<<<<
  *                 seen_ellipsis = True
  *             else:
  */
-  __pyx_slice__32 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_slice__32)) __PYX_ERR(1, 684, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_slice__32);
-  __Pyx_GIVEREF(__pyx_slice__32);
+  __pyx_slice__33 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_slice__33)) __PYX_ERR(1, 684, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_slice__33);
+  __Pyx_GIVEREF(__pyx_slice__33);
 
   /* "View.MemoryView":705
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  *             raise ValueError("Indirect dimensions not supported")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__33 = PyTuple_Pack(1, __pyx_kp_s_Indirect_dimensions_not_supporte); if (unlikely(!__pyx_tuple__33)) __PYX_ERR(1, 705, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__33);
-  __Pyx_GIVEREF(__pyx_tuple__33);
+  __pyx_tuple__34 = PyTuple_Pack(1, __pyx_kp_s_Indirect_dimensions_not_supporte); if (unlikely(!__pyx_tuple__34)) __PYX_ERR(1, 705, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__34);
+  __Pyx_GIVEREF(__pyx_tuple__34);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_tuple__34 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__34)) __PYX_ERR(1, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__34);
-  __Pyx_GIVEREF(__pyx_tuple__34);
+  __pyx_tuple__35 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__35)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__35);
+  __Pyx_GIVEREF(__pyx_tuple__35);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_tuple__35 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__35)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__35);
-  __Pyx_GIVEREF(__pyx_tuple__35);
-  __pyx_tuple__36 = PyTuple_Pack(3, __pyx_int_184977713, __pyx_int_136983863, __pyx_int_112105877); if (unlikely(!__pyx_tuple__36)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __pyx_tuple__36 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__36)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__36);
   __Pyx_GIVEREF(__pyx_tuple__36);
+  __pyx_tuple__37 = PyTuple_Pack(3, __pyx_int_184977713, __pyx_int_136983863, __pyx_int_112105877); if (unlikely(!__pyx_tuple__37)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__37);
+  __Pyx_GIVEREF(__pyx_tuple__37);
 
-  /* "bz3/backends/cython/_bz3.pyx":204
+  /* "bz3/backends/cython/_bz3.pyx":215
  * 
  * 
  * def compress_file(object input, object output, int32_t block_size):             # <<<<<<<<<<<<<<
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  */
-  __pyx_tuple__37 = PyTuple_Pack(9, __pyx_n_s_input, __pyx_n_s_output, __pyx_n_s_block_size, __pyx_n_s_state, __pyx_n_s_buffer, __pyx_n_s_data, __pyx_n_s_new_size, __pyx_n_s_byteswap_buf, __pyx_n_s_old_size); if (unlikely(!__pyx_tuple__37)) __PYX_ERR(0, 204, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__37);
-  __Pyx_GIVEREF(__pyx_tuple__37);
-  __pyx_codeobj__38 = (PyObject*)__Pyx_PyCode_New(3, 0, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__37, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_bz3_backends_cython__bz3_pyx, __pyx_n_s_compress_file, 204, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__38)) __PYX_ERR(0, 204, __pyx_L1_error)
+  __pyx_tuple__38 = PyTuple_Pack(9, __pyx_n_s_input, __pyx_n_s_output, __pyx_n_s_block_size, __pyx_n_s_state, __pyx_n_s_buffer, __pyx_n_s_data, __pyx_n_s_new_size, __pyx_n_s_byteswap_buf, __pyx_n_s_old_size); if (unlikely(!__pyx_tuple__38)) __PYX_ERR(0, 215, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__38);
+  __Pyx_GIVEREF(__pyx_tuple__38);
+  __pyx_codeobj__39 = (PyObject*)__Pyx_PyCode_New(3, 0, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__38, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_bz3_backends_cython__bz3_pyx, __pyx_n_s_compress_file, 215, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__39)) __PYX_ERR(0, 215, __pyx_L1_error)
 
-  /* "bz3/backends/cython/_bz3.pyx":248
- *         PyMem_Free(buffer)
+  /* "bz3/backends/cython/_bz3.pyx":260
+ *         buffer = NULL
  * 
  * def decompress_file(object input, object output):             # <<<<<<<<<<<<<<
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  */
-  __pyx_tuple__39 = PyTuple_Pack(9, __pyx_n_s_input, __pyx_n_s_output, __pyx_n_s_data, __pyx_n_s_block_size, __pyx_n_s_state, __pyx_n_s_buffer, __pyx_n_s_new_size, __pyx_n_s_old_size, __pyx_n_s_code); if (unlikely(!__pyx_tuple__39)) __PYX_ERR(0, 248, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__39);
-  __Pyx_GIVEREF(__pyx_tuple__39);
-  __pyx_codeobj__40 = (PyObject*)__Pyx_PyCode_New(2, 0, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__39, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_bz3_backends_cython__bz3_pyx, __pyx_n_s_decompress_file, 248, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__40)) __PYX_ERR(0, 248, __pyx_L1_error)
+  __pyx_tuple__40 = PyTuple_Pack(9, __pyx_n_s_input, __pyx_n_s_output, __pyx_n_s_data, __pyx_n_s_block_size, __pyx_n_s_state, __pyx_n_s_buffer, __pyx_n_s_new_size, __pyx_n_s_old_size, __pyx_n_s_code); if (unlikely(!__pyx_tuple__40)) __PYX_ERR(0, 260, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__40);
+  __Pyx_GIVEREF(__pyx_tuple__40);
+  __pyx_codeobj__41 = (PyObject*)__Pyx_PyCode_New(2, 0, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__40, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_bz3_backends_cython__bz3_pyx, __pyx_n_s_decompress_file, 260, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__41)) __PYX_ERR(0, 260, __pyx_L1_error)
+
+  /* "bz3/backends/cython/_bz3.pyx":314
+ *         buffer = NULL
+ * 
+ * def recover_file(object input, object output):             # <<<<<<<<<<<<<<
+ *     if not PyFile_Check(input):
+ *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
+ */
+  __pyx_tuple__42 = PyTuple_Pack(9, __pyx_n_s_input, __pyx_n_s_output, __pyx_n_s_data, __pyx_n_s_block_size, __pyx_n_s_state, __pyx_n_s_buffer, __pyx_n_s_new_size, __pyx_n_s_old_size, __pyx_n_s_code); if (unlikely(!__pyx_tuple__42)) __PYX_ERR(0, 314, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__42);
+  __Pyx_GIVEREF(__pyx_tuple__42);
+  __pyx_codeobj__43 = (PyObject*)__Pyx_PyCode_New(2, 0, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__42, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_bz3_backends_cython__bz3_pyx, __pyx_n_s_recover_file, 314, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__43)) __PYX_ERR(0, 314, __pyx_L1_error)
 
   /* "View.MemoryView":287
  *         return self.name
  * 
  * cdef generic = Enum("<strided and direct or indirect>")             # <<<<<<<<<<<<<<
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")
  */
-  __pyx_tuple__41 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct_or_indirect); if (unlikely(!__pyx_tuple__41)) __PYX_ERR(1, 287, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__41);
-  __Pyx_GIVEREF(__pyx_tuple__41);
+  __pyx_tuple__44 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct_or_indirect); if (unlikely(!__pyx_tuple__44)) __PYX_ERR(1, 287, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__44);
+  __Pyx_GIVEREF(__pyx_tuple__44);
 
   /* "View.MemoryView":288
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default             # <<<<<<<<<<<<<<
  * cdef indirect = Enum("<strided and indirect>")
  * 
  */
-  __pyx_tuple__42 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct); if (unlikely(!__pyx_tuple__42)) __PYX_ERR(1, 288, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__42);
-  __Pyx_GIVEREF(__pyx_tuple__42);
+  __pyx_tuple__45 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct); if (unlikely(!__pyx_tuple__45)) __PYX_ERR(1, 288, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__45);
+  __Pyx_GIVEREF(__pyx_tuple__45);
 
   /* "View.MemoryView":289
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__43 = PyTuple_Pack(1, __pyx_kp_s_strided_and_indirect); if (unlikely(!__pyx_tuple__43)) __PYX_ERR(1, 289, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__43);
-  __Pyx_GIVEREF(__pyx_tuple__43);
+  __pyx_tuple__46 = PyTuple_Pack(1, __pyx_kp_s_strided_and_indirect); if (unlikely(!__pyx_tuple__46)) __PYX_ERR(1, 289, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__46);
+  __Pyx_GIVEREF(__pyx_tuple__46);
 
   /* "View.MemoryView":292
  * 
  * 
  * cdef contiguous = Enum("<contiguous and direct>")             # <<<<<<<<<<<<<<
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")
  * 
  */
-  __pyx_tuple__44 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_direct); if (unlikely(!__pyx_tuple__44)) __PYX_ERR(1, 292, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__44);
-  __Pyx_GIVEREF(__pyx_tuple__44);
+  __pyx_tuple__47 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_direct); if (unlikely(!__pyx_tuple__47)) __PYX_ERR(1, 292, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__47);
+  __Pyx_GIVEREF(__pyx_tuple__47);
 
   /* "View.MemoryView":293
  * 
  * cdef contiguous = Enum("<contiguous and direct>")
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__45 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_indirect); if (unlikely(!__pyx_tuple__45)) __PYX_ERR(1, 293, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__45);
-  __Pyx_GIVEREF(__pyx_tuple__45);
+  __pyx_tuple__48 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_indirect); if (unlikely(!__pyx_tuple__48)) __PYX_ERR(1, 293, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__48);
+  __Pyx_GIVEREF(__pyx_tuple__48);
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
-  __pyx_tuple__46 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__46)) __PYX_ERR(1, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__46);
-  __Pyx_GIVEREF(__pyx_tuple__46);
-  __pyx_codeobj__47 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__46, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Enum, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__47)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __pyx_tuple__49 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__49)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__49);
+  __Pyx_GIVEREF(__pyx_tuple__49);
+  __pyx_codeobj__50 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__49, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Enum, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__50)) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
+  /* AssertionsEnabled.init */
+  __Pyx_init_assertions_enabled();
+
+if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 1, __pyx_L1_error)
+
   /* InitThreads.init */
   #if defined(WITH_THREAD) && PY_VERSION_HEX < 0x030700F0
 PyEval_InitThreads();
 #endif
 
 if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 1, __pyx_L1_error)
 
@@ -28243,73 +30374,73 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
   /*--- Type init code ---*/
   __pyx_vtabptr_3bz3_8backends_6cython_4_bz3_BZ3Compressor = &__pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3Compressor;
   __pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3Compressor.compress = (PyObject *(*)(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Compressor *, __Pyx_memviewslice, int __pyx_skip_dispatch))__pyx_f_3bz3_8backends_6cython_4_bz3_13BZ3Compressor_compress;
   __pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3Compressor.flush = (PyObject *(*)(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Compressor *, int __pyx_skip_dispatch))__pyx_f_3bz3_8backends_6cython_4_bz3_13BZ3Compressor_flush;
   __pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3Compressor.error = (PyObject *(*)(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Compressor *, int __pyx_skip_dispatch))__pyx_f_3bz3_8backends_6cython_4_bz3_13BZ3Compressor_error;
-  if (PyType_Ready(&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Compressor) < 0) __PYX_ERR(0, 30, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Compressor) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Compressor.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Compressor.tp_dictoffset && __pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Compressor.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Compressor.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
   }
-  if (__Pyx_SetVtable(__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Compressor.tp_dict, __pyx_vtabptr_3bz3_8backends_6cython_4_bz3_BZ3Compressor) < 0) __PYX_ERR(0, 30, __pyx_L1_error)
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_BZ3Compressor, (PyObject *)&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Compressor) < 0) __PYX_ERR(0, 30, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Compressor) < 0) __PYX_ERR(0, 30, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Compressor.tp_dict, __pyx_vtabptr_3bz3_8backends_6cython_4_bz3_BZ3Compressor) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_BZ3Compressor, (PyObject *)&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Compressor) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Compressor) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
   __pyx_ptype_3bz3_8backends_6cython_4_bz3_BZ3Compressor = &__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Compressor;
   __pyx_vtabptr_3bz3_8backends_6cython_4_bz3_BZ3Decompressor = &__pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3Decompressor;
   __pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3Decompressor.init_state = (int (*)(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *, int32_t))__pyx_f_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_init_state;
   __pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3Decompressor.decompress = (PyObject *(*)(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *, __Pyx_memviewslice, int __pyx_skip_dispatch))__pyx_f_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_decompress;
   __pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3Decompressor.error = (PyObject *(*)(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3Decompressor *, int __pyx_skip_dispatch))__pyx_f_3bz3_8backends_6cython_4_bz3_15BZ3Decompressor_error;
-  if (PyType_Ready(&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Decompressor) < 0) __PYX_ERR(0, 122, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Decompressor) < 0) __PYX_ERR(0, 126, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Decompressor.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Decompressor.tp_dictoffset && __pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Decompressor.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Decompressor.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
   }
-  if (__Pyx_SetVtable(__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Decompressor.tp_dict, __pyx_vtabptr_3bz3_8backends_6cython_4_bz3_BZ3Decompressor) < 0) __PYX_ERR(0, 122, __pyx_L1_error)
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_BZ3Decompressor, (PyObject *)&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Decompressor) < 0) __PYX_ERR(0, 122, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Decompressor) < 0) __PYX_ERR(0, 122, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Decompressor.tp_dict, __pyx_vtabptr_3bz3_8backends_6cython_4_bz3_BZ3Decompressor) < 0) __PYX_ERR(0, 126, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_BZ3Decompressor, (PyObject *)&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Decompressor) < 0) __PYX_ERR(0, 126, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Decompressor) < 0) __PYX_ERR(0, 126, __pyx_L1_error)
   __pyx_ptype_3bz3_8backends_6cython_4_bz3_BZ3Decompressor = &__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3Decompressor;
   __pyx_vtabptr_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor = &__pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor;
   __pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor.free_states = (void (*)(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *))__pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_free_states;
   __pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor.free_buffers = (void (*)(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *))__pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_free_buffers;
   __pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor.compress = (PyObject *(*)(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *, __Pyx_memviewslice, int __pyx_skip_dispatch))__pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_compress;
   __pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor.flush = (PyObject *(*)(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *, int __pyx_skip_dispatch))__pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_flush;
   __pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor.error = (PyObject *(*)(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor *, int __pyx_skip_dispatch))__pyx_f_3bz3_8backends_6cython_4_bz3_16BZ3OmpCompressor_error;
-  if (PyType_Ready(&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor) < 0) __PYX_ERR(0, 396, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor) < 0) __PYX_ERR(0, 470, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor.tp_dictoffset && __pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
   }
-  if (__Pyx_SetVtable(__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor.tp_dict, __pyx_vtabptr_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor) < 0) __PYX_ERR(0, 396, __pyx_L1_error)
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_BZ3OmpCompressor, (PyObject *)&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor) < 0) __PYX_ERR(0, 396, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor) < 0) __PYX_ERR(0, 396, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor.tp_dict, __pyx_vtabptr_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor) < 0) __PYX_ERR(0, 470, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_BZ3OmpCompressor, (PyObject *)&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor) < 0) __PYX_ERR(0, 470, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor) < 0) __PYX_ERR(0, 470, __pyx_L1_error)
   __pyx_ptype_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor = &__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpCompressor;
   __pyx_vtabptr_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor = &__pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor;
   __pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor.init_state = (int (*)(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *, int32_t))__pyx_f_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_init_state;
   __pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor.free_states = (void (*)(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *))__pyx_f_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_free_states;
   __pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor.free_buffers = (void (*)(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *))__pyx_f_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_free_buffers;
   __pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor.decompress = (PyObject *(*)(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *, __Pyx_memviewslice, int __pyx_skip_dispatch))__pyx_f_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_decompress;
   __pyx_vtable_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor.error = (PyObject *(*)(struct __pyx_obj_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor *, int __pyx_skip_dispatch))__pyx_f_3bz3_8backends_6cython_4_bz3_18BZ3OmpDecompressor_error;
-  if (PyType_Ready(&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor) < 0) __PYX_ERR(0, 573, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor) < 0) __PYX_ERR(0, 682, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor.tp_dictoffset && __pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
   }
-  if (__Pyx_SetVtable(__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor.tp_dict, __pyx_vtabptr_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor) < 0) __PYX_ERR(0, 573, __pyx_L1_error)
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_BZ3OmpDecompressor, (PyObject *)&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor) < 0) __PYX_ERR(0, 573, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor) < 0) __PYX_ERR(0, 573, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor.tp_dict, __pyx_vtabptr_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor) < 0) __PYX_ERR(0, 682, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_BZ3OmpDecompressor, (PyObject *)&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor) < 0) __PYX_ERR(0, 682, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor) < 0) __PYX_ERR(0, 682, __pyx_L1_error)
   __pyx_ptype_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor = &__pyx_type_3bz3_8backends_6cython_4_bz3_BZ3OmpDecompressor;
   __pyx_vtabptr_array = &__pyx_vtable_array;
   __pyx_vtable_array.get_memview = (PyObject *(*)(struct __pyx_array_obj *))__pyx_array_get_memview;
   if (PyType_Ready(&__pyx_type___pyx_array) < 0) __PYX_ERR(1, 106, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type___pyx_array.tp_print = 0;
   #endif
@@ -28371,22 +30502,21 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
   /*--- Type import code ---*/
   __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 9, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
+  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType_0_29_36(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
   #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x050B0000
-  sizeof(PyTypeObject),
+  sizeof(PyTypeObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_36(PyTypeObject),
   #else
-  sizeof(PyHeapTypeObject),
+  sizeof(PyHeapTypeObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_36(PyHeapTypeObject),
   #endif
-  __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(2, 9, __pyx_L1_error)
+  __Pyx_ImportType_CheckSize_Warn_0_29_36); if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(2, 9, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_RefNannyFinishContext();
   return -1;
@@ -28605,45 +30735,57 @@
   (void)__Pyx_modinit_variable_import_code();
   (void)__Pyx_modinit_function_import_code();
   /*--- Execution code ---*/
   #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
   if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
 
-  /* "bz3/backends/cython/_bz3.pyx":20
- * 
+  /* "bz3/backends/cython/_bz3.pyx":24
+ *     void* PyMem_Calloc(size_t nelem, size_t elsize)
  * 
  * cdef const char* magic = "BZ3v1"             # <<<<<<<<<<<<<<
  * 
  * cdef inline uint8_t PyFile_Check(object file):
  */
   __pyx_v_3bz3_8backends_6cython_4_bz3_magic = ((char const *)"BZ3v1");
 
-  /* "bz3/backends/cython/_bz3.pyx":204
+  /* "bz3/backends/cython/_bz3.pyx":215
  * 
  * 
  * def compress_file(object input, object output, int32_t block_size):             # <<<<<<<<<<<<<<
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  */
-  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3bz3_8backends_6cython_4_bz3_1compress_file, NULL, __pyx_n_s_bz3_backends_cython__bz3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 204, __pyx_L1_error)
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3bz3_8backends_6cython_4_bz3_1compress_file, NULL, __pyx_n_s_bz3_backends_cython__bz3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 215, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_compress_file, __pyx_t_1) < 0) __PYX_ERR(0, 204, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_compress_file, __pyx_t_1) < 0) __PYX_ERR(0, 215, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "bz3/backends/cython/_bz3.pyx":248
- *         PyMem_Free(buffer)
+  /* "bz3/backends/cython/_bz3.pyx":260
+ *         buffer = NULL
  * 
  * def decompress_file(object input, object output):             # <<<<<<<<<<<<<<
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  */
-  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3bz3_8backends_6cython_4_bz3_3decompress_file, NULL, __pyx_n_s_bz3_backends_cython__bz3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 248, __pyx_L1_error)
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3bz3_8backends_6cython_4_bz3_3decompress_file, NULL, __pyx_n_s_bz3_backends_cython__bz3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 260, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_decompress_file, __pyx_t_1) < 0) __PYX_ERR(0, 260, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "bz3/backends/cython/_bz3.pyx":314
+ *         buffer = NULL
+ * 
+ * def recover_file(object input, object output):             # <<<<<<<<<<<<<<
+ *     if not PyFile_Check(input):
+ *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
+ */
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3bz3_8backends_6cython_4_bz3_5recover_file, NULL, __pyx_n_s_bz3_backends_cython__bz3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 314, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_decompress_file, __pyx_t_1) < 0) __PYX_ERR(0, 248, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_recover_file, __pyx_t_1) < 0) __PYX_ERR(0, 314, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "bz3/backends/cython/_bz3.pyx":1
  * # cython: language_level=3             # <<<<<<<<<<<<<<
  * # cython: cdivision=True
  * cimport cython
  */
@@ -28668,71 +30810,71 @@
   /* "View.MemoryView":287
  *         return self.name
  * 
  * cdef generic = Enum("<strided and direct or indirect>")             # <<<<<<<<<<<<<<
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__41, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 287, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__44, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 287, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(generic);
   __Pyx_DECREF_SET(generic, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":288
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default             # <<<<<<<<<<<<<<
  * cdef indirect = Enum("<strided and indirect>")
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__42, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 288, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__45, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 288, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(strided);
   __Pyx_DECREF_SET(strided, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":289
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__43, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 289, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__46, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 289, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(indirect);
   __Pyx_DECREF_SET(indirect, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":292
  * 
  * 
  * cdef contiguous = Enum("<contiguous and direct>")             # <<<<<<<<<<<<<<
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__44, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 292, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__47, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 292, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(contiguous);
   __Pyx_DECREF_SET(contiguous, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":293
  * 
  * cdef contiguous = Enum("<contiguous and direct>")
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__45, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 293, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__48, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 293, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(indirect_contiguous);
   __Pyx_DECREF_SET(indirect_contiguous, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":317
@@ -29194,28 +31336,28 @@
                             "BaseException");
             goto bad;
         }
         PyException_SetCause(value, fixed_cause);
     }
     PyErr_SetObject(type, value);
     if (tb) {
-#if CYTHON_COMPILING_IN_PYPY
-        PyObject *tmp_type, *tmp_value, *tmp_tb;
-        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
-        Py_INCREF(tb);
-        PyErr_Restore(tmp_type, tmp_value, tb);
-        Py_XDECREF(tmp_tb);
-#else
+#if CYTHON_FAST_THREAD_STATE
         PyThreadState *tstate = __Pyx_PyThreadState_Current;
         PyObject* tmp_tb = tstate->curexc_traceback;
         if (tb != tmp_tb) {
             Py_INCREF(tb);
             tstate->curexc_traceback = tb;
             Py_XDECREF(tmp_tb);
         }
+#else
+        PyObject *tmp_type, *tmp_value, *tmp_tb;
+        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
+        Py_INCREF(tb);
+        PyErr_Restore(tmp_type, tmp_value, tb);
+        Py_XDECREF(tmp_tb);
 #endif
     }
 bad:
     Py_XDECREF(owned_instance);
     return;
 }
 #endif
@@ -29854,54 +31996,14 @@
     if (decode_func) {
         return decode_func(cstring, length, errors);
     } else {
         return PyUnicode_Decode(cstring, length, encoding, errors);
     }
 }
 
-/* KeywordStringCheck */
-static int __Pyx_CheckKeywordStrings(
-    PyObject *kwdict,
-    const char* function_name,
-    int kw_allowed)
-{
-    PyObject* key = 0;
-    Py_ssize_t pos = 0;
-#if CYTHON_COMPILING_IN_PYPY
-    if (!kw_allowed && PyDict_Next(kwdict, &pos, &key, 0))
-        goto invalid_keyword;
-    return 1;
-#else
-    while (PyDict_Next(kwdict, &pos, &key, 0)) {
-        #if PY_MAJOR_VERSION < 3
-        if (unlikely(!PyString_Check(key)))
-        #endif
-            if (unlikely(!PyUnicode_Check(key)))
-                goto invalid_keyword_type;
-    }
-    if ((!kw_allowed) && unlikely(key))
-        goto invalid_keyword;
-    return 1;
-invalid_keyword_type:
-    PyErr_Format(PyExc_TypeError,
-        "%.200s() keywords must be strings", function_name);
-    return 0;
-#endif
-invalid_keyword:
-    PyErr_Format(PyExc_TypeError,
-    #if PY_MAJOR_VERSION < 3
-        "%.200s() got an unexpected keyword argument '%.200s'",
-        function_name, PyString_AsString(key));
-    #else
-        "%s() got an unexpected keyword argument '%U'",
-        function_name, key);
-    #endif
-    return 0;
-}
-
 /* GetException */
 #if CYTHON_FAST_THREAD_STATE
 static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb)
 #else
 static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb)
 #endif
 {
@@ -31201,61 +33303,79 @@
     Py_XDECREF(reduce_cython);
     Py_XDECREF(setstate);
     Py_XDECREF(setstate_cython);
     return ret;
 }
 
 /* TypeImport */
-#ifndef __PYX_HAVE_RT_ImportType
-#define __PYX_HAVE_RT_ImportType
-static PyTypeObject *__Pyx_ImportType(PyObject *module, const char *module_name, const char *class_name,
-    size_t size, enum __Pyx_ImportType_CheckSize check_size)
+#ifndef __PYX_HAVE_RT_ImportType_0_29_36
+#define __PYX_HAVE_RT_ImportType_0_29_36
+static PyTypeObject *__Pyx_ImportType_0_29_36(PyObject *module, const char *module_name, const char *class_name,
+    size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_0_29_36 check_size)
 {
     PyObject *result = 0;
     char warning[200];
     Py_ssize_t basicsize;
+    Py_ssize_t itemsize;
 #ifdef Py_LIMITED_API
     PyObject *py_basicsize;
+    PyObject *py_itemsize;
 #endif
     result = PyObject_GetAttrString(module, class_name);
     if (!result)
         goto bad;
     if (!PyType_Check(result)) {
         PyErr_Format(PyExc_TypeError,
             "%.200s.%.200s is not a type object",
             module_name, class_name);
         goto bad;
     }
 #ifndef Py_LIMITED_API
     basicsize = ((PyTypeObject *)result)->tp_basicsize;
+    itemsize = ((PyTypeObject *)result)->tp_itemsize;
 #else
     py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
     if (!py_basicsize)
         goto bad;
     basicsize = PyLong_AsSsize_t(py_basicsize);
     Py_DECREF(py_basicsize);
     py_basicsize = 0;
     if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
         goto bad;
+    py_itemsize = PyObject_GetAttrString(result, "__itemsize__");
+    if (!py_itemsize)
+        goto bad;
+    itemsize = PyLong_AsSsize_t(py_itemsize);
+    Py_DECREF(py_itemsize);
+    py_itemsize = 0;
+    if (itemsize == (Py_ssize_t)-1 && PyErr_Occurred())
+        goto bad;
 #endif
-    if ((size_t)basicsize < size) {
+    if (itemsize) {
+        if (size % alignment) {
+            alignment = size % alignment;
+        }
+        if (itemsize < (Py_ssize_t)alignment)
+            itemsize = (Py_ssize_t)alignment;
+    }
+    if ((size_t)(basicsize + itemsize) < size) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         goto bad;
     }
-    if (check_size == __Pyx_ImportType_CheckSize_Error && (size_t)basicsize != size) {
+    if (check_size == __Pyx_ImportType_CheckSize_Error_0_29_36 && (size_t)basicsize != size) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         goto bad;
     }
-    else if (check_size == __Pyx_ImportType_CheckSize_Warn && (size_t)basicsize > size) {
+    else if (check_size == __Pyx_ImportType_CheckSize_Warn_0_29_36 && (size_t)basicsize > size) {
         PyOS_snprintf(warning, sizeof(warning),
             "%s.%s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
     }
     return (PyTypeObject *)result;
@@ -32518,15 +34638,15 @@
                         } else if (8 * sizeof(int32_t) >= 4 * PyLong_SHIFT) {
                             return (int32_t) (((((((((int32_t)digits[3]) << PyLong_SHIFT) | (int32_t)digits[2]) << PyLong_SHIFT) | (int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -32714,15 +34834,15 @@
                         } else if (8 * sizeof(size_t) >= 4 * PyLong_SHIFT) {
                             return (size_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -32910,15 +35030,15 @@
                         } else if (8 * sizeof(uint32_t) >= 4 * PyLong_SHIFT) {
                             return (uint32_t) (((((((((uint32_t)digits[3]) << PyLong_SHIFT) | (uint32_t)digits[2]) << PyLong_SHIFT) | (uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -33296,15 +35416,15 @@
                         } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                             return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -33492,15 +35612,15 @@
                         } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                             return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -33688,15 +35808,15 @@
                         } else if (8 * sizeof(char) >= 4 * PyLong_SHIFT) {
                             return (char) (((((((((char)digits[3]) << PyLong_SHIFT) | (char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
```

### Comparing `bzip3-0.1.2rc1/bz3/backends/cython/_bz3.pyx` & `bzip3-0.1.3rc1/bz3/backends/cython/_bz3.pyx`

 * *Files 22% similar despite different names*

```diff
@@ -1,709 +1,845 @@
-# cython: language_level=3
-# cython: cdivision=True
-cimport cython
-from cpython.bytearray cimport PyByteArray_AS_STRING, PyByteArray_GET_SIZE
-from cpython.bytes cimport (PyBytes_AS_STRING, PyBytes_FromStringAndSize,
-                            PyBytes_GET_SIZE)
-from cpython.mem cimport PyMem_Free, PyMem_Malloc
-from cpython.object cimport PyObject_HasAttrString
-from libc.stdint cimport int32_t, uint8_t, uint32_t
-from libc.string cimport memcpy, memset, strncmp
-
-from bz3.backends.cython.bzip3 cimport (BZ3_OK, KiB, MiB, bz3_bound,
-                                        bz3_compress, bz3_decode_block,
-                                        bz3_decompress, bz3_encode_block,
-                                        bz3_free, bz3_last_error, bz3_new,
-                                        bz3_state, bz3_strerror, bz3_version,
-                                        read_neutral_s32, write_neutral_s32)
-
-
-cdef const char* magic = "BZ3v1"
-
-cdef inline uint8_t PyFile_Check(object file):
-    if PyObject_HasAttrString(file, "read") and PyObject_HasAttrString(file, "write"):  # should we check seek method?
-        return 1
-    return 0
-
-@cython.freelist(8)
-@cython.no_gc
-@cython.final
-cdef class BZ3Compressor:
-    cdef:
-        bz3_state * state
-        uint8_t * buffer
-        readonly int32_t block_size
-        bytearray uncompressed
-        bint have_magic_number
-
-    def __cinit__(self, int32_t block_size):
-        if block_size < KiB(65) or block_size > MiB(511):
-            raise ValueError("Block size must be between 65 KiB and 511 MiB")
-        self.block_size = block_size
-        self.state = bz3_new(block_size)
-        if self.state == NULL:
-            raise MemoryError("Failed to create a block encoder state")
-        self.buffer = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
-        if self.buffer == NULL:
-            bz3_free(self.state)
-            self.state = NULL
-            raise MemoryError("Failed to allocate memory")
-        self.uncompressed = bytearray()
-        self.have_magic_number = 0 # 还没有写入magic number
-
-    def __dealloc__(self):
-        if self.state != NULL:
-            bz3_free(self.state)
-            self.state = NULL
-        if self.buffer !=NULL:
-            PyMem_Free(self.buffer)
-            self.buffer = NULL
-
-    cpdef inline bytes compress(self, const uint8_t[::1] data):
-        cdef Py_ssize_t input_size = data.shape[0]
-        cdef int32_t new_size
-        cdef bytearray ret = bytearray()
-        if not self.have_magic_number:
-            # if PyByteArray_Resize(ret, 9) < 0:
-            #     raise
-            # memcpy(PyByteArray_AS_STRING(ret), magic, 5)
-            ret.extend(<bytes>magic[:5]+b"\x00\x00\x00\x00")  # 9 bytes
-            write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[5]), self.block_size)
-            self.have_magic_number = 1
-
-        if input_size > 0:
-            # if PyByteArray_Resize(self.uncompressed, input_size+PyByteArray_GET_SIZE(self.uncompressed)) < 0:
-            #     raise
-            # memcpy(&(PyByteArray_AS_STRING(self.uncompressed)[PyByteArray_GET_SIZE(self.uncompressed)-input_size]), &data[0], input_size) # todo? direct copy to bytearray
-            self.uncompressed.extend(data)
-            while PyByteArray_GET_SIZE(self.uncompressed)>=self.block_size:
-                memcpy(self.buffer, PyByteArray_AS_STRING(self.uncompressed), <size_t>self.block_size)
-                # make a copy
-                with nogil:
-                    new_size = bz3_encode_block(self.state, self.buffer, self.block_size)
-                if new_size == -1:
-                    raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.state))
-                # if PyByteArray_Resize(ret, PyByteArray_GET_SIZE(ret) + new_size + 8) < 0:
-                #     raise
-                ret.extend((new_size + 8)*b"\x00")
-                write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-new_size-8]), new_size)
-                write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-new_size-4]), self.block_size)
-                memcpy(&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-new_size]), self.buffer, <size_t>new_size)
-
-                del self.uncompressed[:self.block_size]
-        return bytes(ret)
-
-    cpdef inline bytes flush(self):
-        cdef bytes ret = b""
-        cdef int32_t new_size
-        cdef int32_t old_size = <int32_t>PyByteArray_GET_SIZE(self.uncompressed)
-        if self.uncompressed:
-            memcpy(self.buffer, PyByteArray_AS_STRING(self.uncompressed), <size_t>old_size)
-            with nogil:
-                new_size = bz3_encode_block(self.state, self.buffer, old_size)
-            if new_size == -1:
-                raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.state))
-            ret = PyBytes_FromStringAndSize(NULL, new_size + 8)
-            if not ret:
-                raise
-            write_neutral_s32(<uint8_t*>PyBytes_AS_STRING(ret), new_size)
-            write_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(ret)[4]), old_size)
-            memcpy(&(PyBytes_AS_STRING(ret)[8]), self.buffer, <size_t> new_size)
-            self.uncompressed.clear()
-        return ret
-
-    cpdef inline str error(self):
-        if bz3_last_error(self.state) != BZ3_OK:
-            return (<bytes>bz3_strerror(self.state)).decode()
-        return None
-
-@cython.freelist(8)
-@cython.no_gc
-@cython.final
-cdef class BZ3Decompressor:
-    cdef:
-        bz3_state * state
-        uint8_t * buffer
-        readonly int32_t block_size
-        bytearray unused  # 还没解压的数据
-        bint have_magic_number
-
-    cdef inline int init_state(self, int32_t block_size) except -1:
-        """should exec only once"""
-        self.block_size = block_size
-        self.state = bz3_new(block_size)
-        if self.state == NULL:
-            raise MemoryError("Failed to create a block encoder state")
-        self.buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
-        if self.buffer == NULL:
-            bz3_free(self.state)
-            self.state = NULL
-            raise MemoryError("Failed to allocate memory")
-
-    def __cinit__(self):
-        self.unused = bytearray()
-        self.have_magic_number = 0 # 还没有读到magic number
-
-    def __dealloc__(self):
-        if self.state != NULL:
-            bz3_free(self.state)
-            self.state = NULL
-        if self.buffer !=NULL:
-            PyMem_Free(self.buffer)
-            self.buffer = NULL
-
-    cpdef inline bytes decompress(self, const uint8_t[::1] data):
-        cdef Py_ssize_t input_size = data.shape[0]
-        cdef int32_t code
-        cdef bytearray ret = bytearray()
-        cdef int32_t new_size, old_size, block_size
-        if input_size > 0:
-            # if PyByteArray_Resize(self.unused, input_size+PyByteArray_GET_SIZE(self.unused)) < 0:
-            #     raise
-            # memcpy(&(PyByteArray_AS_STRING(self.unused)[PyByteArray_GET_SIZE(self.unused)-input_size]), &data[0], input_size) # self.unused.extend
-            self.unused.extend(data)
-            if PyByteArray_GET_SIZE(self.unused) > 9 and not self.have_magic_number: # 9 bytes magic number
-                if strncmp(PyByteArray_AS_STRING(self.unused), magic, 5) != 0:
-                    raise ValueError("Invalid signature")
-                block_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[5]))
-                if block_size  < KiB(65) or block_size >MiB(511):
-                    raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
-                self.init_state(block_size)
-                del self.unused[:9]
-                self.have_magic_number = 1
-
-            while True:
-                if PyByteArray_GET_SIZE(self.unused)<8: # 8 byte的 header都不够 直接返回
-                    break
-                new_size = read_neutral_s32(<uint8_t*>PyByteArray_AS_STRING(self.unused)) # todo gcc warning but bytes is contst
-                old_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[4]))
-                if PyByteArray_GET_SIZE(self.unused) < new_size+8: # 数据段不够
-                    break
-                memcpy(self.buffer, &(PyByteArray_AS_STRING(self.unused)[8]), <size_t>new_size)
-                with nogil:
-                    code = bz3_decode_block(self.state, self.buffer, new_size, old_size)
-                if code == -1:
-                    raise ValueError("Failed to decode a block: %s" % bz3_strerror(self.state))
-                # if PyByteArray_Resize(ret, PyByteArray_GET_SIZE(ret) + old_size) < 0:
-                #     raise
-                ret.extend(<bytes>self.buffer[:old_size])
-                # memcpy(&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-old_size]), self.buffer, <size_t>old_size)
-                del self.unused[:new_size+8]
-        return bytes(ret)
-
-    @property
-    def unused_data(self):
-        """Data found after the end of the compressed stream."""
-        return bytes(self.unused)
-
-    cpdef inline str error(self):
-        if bz3_last_error(self.state) != BZ3_OK:
-            return (<bytes> bz3_strerror(self.state)).decode()
-        return None
-
-
-def compress_file(object input, object output, int32_t block_size):
-    if not PyFile_Check(input):
-        raise TypeError("input except a file-like object, got %s" % type(input).__name__)
-    if not PyFile_Check(output):
-        raise TypeError("output except a file-like object, got %s" % type(output).__name__)
-    cdef bz3_state *state = bz3_new(block_size)
-    if state == NULL:
-        raise MemoryError("Failed to create a block encoder state")
-    cdef uint8_t * buffer = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
-    if buffer == NULL:
-        bz3_free(state)
-        state = NULL
-        raise MemoryError
-    cdef bytes data
-    cdef int32_t new_size
-    cdef uint8_t byteswap_buf[4]
-
-    output.write(b"BZ3v1")
-    write_neutral_s32(byteswap_buf, block_size)
-    output.write(PyBytes_FromStringAndSize(<char*>&byteswap_buf[0], 4))  # magic header
-    cdef int32_t old_size
-    try:
-        while True:
-            data = input.read(block_size)
-            if not data:
-                break
-            old_size = <int32_t>PyBytes_GET_SIZE(data)
-            memcpy(buffer, PyBytes_AS_STRING(data), <size_t>old_size)
-            with nogil:
-                new_size = bz3_encode_block(state, buffer, old_size)
-            if new_size == -1:
-                raise ValueError("Failed to encode a block: %s" % bz3_strerror(state))
-            write_neutral_s32(byteswap_buf, new_size)
-            output.write(PyBytes_FromStringAndSize(<char*>&byteswap_buf[0], 4))
-            write_neutral_s32(byteswap_buf, old_size)
-            output.write(PyBytes_FromStringAndSize(<char*>&byteswap_buf[0], 4))
-            output.write(PyBytes_FromStringAndSize(<char*>buffer, new_size))
-            output.flush()
-    finally:
-        output.flush()
-        bz3_free(state)
-        state = NULL
-        PyMem_Free(buffer)
-
-def decompress_file(object input, object output):
-    if not PyFile_Check(input):
-        raise TypeError("input except a file-like object, got %s" % type(input).__name__)
-    if not PyFile_Check(output):
-        raise TypeError("output except a file-like object, got %s" % type(output).__name__)
-    cdef bytes data
-    cdef int32_t block_size
-    data = input.read(9) # magic and block_size type: bytes len = 9
-    if PyBytes_GET_SIZE(data) < 9:
-        raise ValueError("Invalid file. Reason: Smaller than magic header")
-    if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:
-        raise ValueError("Invalid signature")
-    block_size = read_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(data)[5]))
-    if block_size < KiB(65) or block_size > MiB(511):
-        raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
-    cdef bz3_state *state = bz3_new(block_size)
-    if state == NULL:
-        raise MemoryError("Failed to create a block encoder state")
-    cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
-    if buffer == NULL:
-        bz3_free(state)
-        state = NULL
-        raise MemoryError("Failed to allocate memory")
-    cdef int32_t new_size, old_size, code
-
-    try:
-        while True:
-            data = input.read(4)
-            if PyBytes_GET_SIZE(data) < 4:
-                break
-            new_size = read_neutral_s32(<uint8_t*>PyBytes_AS_STRING(data))
-            data = input.read(4)
-            if PyBytes_GET_SIZE(data) < 4:
-                break
-            old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
-            data = input.read(new_size) # type: bytes
-            if PyBytes_GET_SIZE(data) < new_size:
-                break
-            memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
-            with nogil:
-                code = bz3_decode_block(state, buffer, new_size, old_size)
-            if code == -1:
-                raise ValueError("Failed to decode a block: %s" % bz3_strerror(state))
-            output.write(PyBytes_FromStringAndSize(<char*>buffer, old_size))
-            output.flush()
-    finally:
-        output.flush()
-        bz3_free(state)
-        state = NULL
-        PyMem_Free(buffer)
-
-cpdef inline bint test_file(object input, bint should_raise = False) except? 0:
-    if not PyFile_Check(input):
-        raise TypeError("input except a file-like object, got %s" % type(input).__name__)
-    cdef bytes data
-    cdef int32_t block_size
-    data = input.read(9)  # magic and block_size type: bytes len = 9
-    if PyBytes_GET_SIZE(data) < 9:
-        if should_raise:
-            raise ValueError("Invalid file. Reason: Smaller than magic header")
-        return 0
-    if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:
-        if should_raise:
-            raise ValueError("Invalid signature")
-        return 0
-    block_size = read_neutral_s32(<uint8_t *> &(PyBytes_AS_STRING(data)[5]))
-    if block_size < KiB(65) or block_size > MiB(511):
-        if should_raise:
-            raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
-        return 0
-    cdef bz3_state *state = bz3_new(block_size)
-    if state == NULL:
-        raise MemoryError("Failed to create a block encoder state")
-    cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
-    if buffer == NULL:
-        bz3_free(state)
-        state = NULL
-        raise MemoryError("Failed to allocate memory")
-    cdef int32_t new_size, old_size, code
-
-    try:
-        while True:
-            data = input.read(4)
-            if PyBytes_GET_SIZE(data) < 4:
-                break
-            new_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
-            data = input.read(4)
-            if PyBytes_GET_SIZE(data) < 4:
-                break
-            old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
-            data = input.read(new_size)  # type: bytes
-            if PyBytes_GET_SIZE(data) < new_size:
-                break
-            memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
-            with nogil:
-                code = bz3_decode_block(state, buffer, new_size, old_size)
-            # print(f"newsize {new_size} oldsize {old_size}") # todo
-            if code == -1:
-                if should_raise:
-                    raise ValueError("Failed to decode a block: %s" % bz3_strerror(state))
-                return 0
-        return 1
-    finally:
-        bz3_free(state)
-        state = NULL
-        PyMem_Free(buffer)
-
-cpdef inline size_t bound(size_t input_size) nogil:
-    return bz3_bound(input_size)
-
-
-cpdef inline size_t compress_into(const uint8_t[::1] data, uint8_t[::1] out, uint32_t block_size = 1000000) except? 0:
-    cdef:
-        size_t out_size = <size_t>out.shape[0]
-        int bzerr
-    with nogil:
-        bzerr = bz3_compress(block_size, &data[0], &out[0], <size_t>data.shape[0], &out_size)
-    if bzerr != BZ3_OK:
-        raise ValueError(f"bz3_compress() failed with error code {bzerr}")
-    return out_size
-
-cpdef inline size_t decompress_into(const uint8_t[::1] data, uint8_t[::1] out) except? 0:
-    cdef:
-        size_t out_size = <size_t>out.shape[0]
-        int bzerr
-    with nogil:
-        bzerr = bz3_decompress(&data[0], &out[0], <size_t>data.shape[0], &out_size)
-    if bzerr != BZ3_OK:
-        raise ValueError(f"bz3_decompress() failed with error code {bzerr}")
-    return out_size
-
-cpdef inline str libversion():
-    return (<bytes>bz3_version()).decode()
-
-# openmp
-from cython.parallel cimport prange
-
-
-cdef void bz3_encode_blocks(bz3_state ** states, uint8_t ** buffers, int32_t *sizes, int32_t numthreads):
-    # sizes: read and write
-    cdef int32_t i
-    for i in prange(numthreads, nogil=True, schedule="static", num_threads=numthreads):
-        sizes[i] = bz3_encode_block(states[i], buffers[i], sizes[i])
-
-
-@cython.freelist(8)
-@cython.no_gc
-@cython.final
-cdef class BZ3OmpCompressor:
-    cdef:
-        bz3_state ** states
-        uint8_t ** buffers
-        int32_t * sizes   # compressed
-        int32_t * old_sizes # origin size
-        readonly int32_t block_size
-        bytearray uncompressed
-        bint have_magic_number
-        readonly uint32_t numthreads  # how many threads to use
-
-    def __cinit__(self, int32_t block_size, uint32_t numthreads):
-        if block_size < KiB(65) or block_size > MiB(511):
-            raise ValueError("Block size must be between 65 KiB and 511 MiB")
-        self.block_size = block_size
-        self.states = <bz3_state **>PyMem_Malloc(sizeof(bz3_state *) * numthreads) # prepare the array
-        if not self.states:
-            raise MemoryError
-        self.buffers = <uint8_t **>PyMem_Malloc(sizeof(uint8_t *) * numthreads)
-        if not self.buffers:
-            PyMem_Free(self.states)
-            raise MemoryError
-        self.sizes = <int32_t *>PyMem_Malloc(sizeof(int32_t) * numthreads)
-        if not self.sizes:
-            PyMem_Free(self.states)
-            PyMem_Free(self.buffers)
-            raise MemoryError
-        self.old_sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
-        if not self.old_sizes:
-            PyMem_Free(self.states)
-            PyMem_Free(self.buffers)
-            PyMem_Free(self.sizes)
-            raise MemoryError
-        memset(self.states, 0, sizeof(bz3_state *) * numthreads)
-        memset(self.buffers, 0, sizeof(uint8_t *) * numthreads)
-
-        cdef uint32_t i
-        try:
-            for i in range(numthreads):
-                self.states[i] = bz3_new(block_size)
-                if self.states[i] == NULL:
-                    raise MemoryError("Failed to create a block encoder state")  # todo 如何善后
-                self.buffers[i] = <uint8_t *>PyMem_Malloc(block_size + block_size / 50 + 32)
-                if self.buffers[i] == NULL:
-                    raise MemoryError("Failed to allocate memory")
-        except:
-            self.free_states()
-            self.free_buffers()
-            PyMem_Free(self.states)
-            PyMem_Free(self.buffers)
-            PyMem_Free(self.sizes)
-            PyMem_Free(self.old_sizes)
-            raise
-        self.uncompressed = bytearray()
-        self.have_magic_number = 0 # 还没有写入magic number
-        self.numthreads = numthreads
-
-    cdef inline void free_states(self):
-        cdef uint32_t i
-        for i in range(self.numthreads):
-            if self.states[i]:
-                bz3_free(self.states[i])
-                self.states[i] = NULL
-
-    cdef inline void free_buffers(self):
-        cdef uint32_t i
-        for i in range(self.numthreads):
-            if self.buffers[i]:
-                PyMem_Free(self.buffers[i])
-                self.buffers[i] = NULL
-
-    def __dealloc__(self):
-        cdef uint32_t i
-        self.free_states()
-        self.free_buffers()
-        if self.states:
-            PyMem_Free(self.states)
-        if self.buffers:
-            PyMem_Free(self.buffers)
-        if self.sizes:
-            PyMem_Free(self.sizes)
-        if self.old_sizes:
-            PyMem_Free(self.old_sizes)
-
-    cpdef inline bytes compress(self, const uint8_t[::1] data):
-        cdef Py_ssize_t input_size = data.shape[0]
-        cdef int32_t new_size
-        cdef bytearray ret = bytearray()
-        cdef int32_t all_blocks_size = self.block_size * self.numthreads
-        if not self.have_magic_number:
-            # if PyByteArray_Resize(ret, 9) < 0:
-            #     raise
-            # memcpy(PyByteArray_AS_STRING(ret), magic, 5)
-            ret.extend(<bytes>magic[:5]+b"\x00\x00\x00\x00")  # 9 bytes
-            write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[5]), self.block_size)
-            self.have_magic_number = 1
-        cdef uint32_t i
-        if input_size > 0:
-            # if PyByteArray_Resize(self.uncompressed, input_size+PyByteArray_GET_SIZE(self.uncompressed)) < 0:
-            #     raise
-            # memcpy(&(PyByteArray_AS_STRING(self.uncompressed)[PyByteArray_GET_SIZE(self.uncompressed)-input_size]), &data[0], input_size) # todo? direct copy to bytearray
-            self.uncompressed.extend(data)
-            if PyByteArray_GET_SIZE(self.uncompressed) >= all_blocks_size:  # able to perform a compress
-                while PyByteArray_GET_SIZE(self.uncompressed) >= all_blocks_size:  # ensure fill all blocks
-                    for i in range(self.numthreads):
-                        self.sizes[i] = self.block_size  # fill the sizes array
-                        memcpy(self.buffers[i], &PyByteArray_AS_STRING(self.uncompressed)[i*self.block_size], <size_t>self.block_size)
-                        # make a copy
-                    bz3_encode_blocks(self.states, self.buffers, self.sizes, <int32_t>self.numthreads)
-                    for i in range(self.numthreads):
-                        if bz3_last_error(self.states[i]) != BZ3_OK:
-                            raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.states[i]))
-                        # if PyByteArray_Resize(ret, PyByteArray_GET_SIZE(ret) + new_size + 8) < 0:
-                        #     raise
-                        ret.extend((self.sizes[i] + 8)*b"\x00")
-                        write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-self.sizes[i]-8]), self.sizes[i])
-                        write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-self.sizes[i]-4]), self.block_size)
-                        memcpy(&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-self.sizes[i]]), self.buffers[i], <size_t>self.sizes[i])
-
-                    del self.uncompressed[:all_blocks_size]
-            return bytes(ret)
-
-    cpdef inline bytes flush(self):
-        cdef bytearray ret = bytearray()
-        cdef int32_t new_size
-        cdef int32_t remain_size = <int32_t>PyByteArray_GET_SIZE(self.uncompressed)
-        cdef:
-            int i = 0  # thread count
-            int j
-        if self.uncompressed:  # will perform a compress
-            while self.block_size * (i+1) < remain_size:
-                memcpy(self.buffers[i],
-                       &PyByteArray_AS_STRING(self.uncompressed)[i*self.block_size],
-                       <size_t>self.block_size)
-                self.sizes[i] = self.old_sizes[i] = self.block_size
-                # old_sizes[i] = self.block_size
-                i += 1
-            memcpy(self.buffers[i],
-                   &PyByteArray_AS_STRING(self.uncompressed)[i * self.block_size],
-                   <size_t> (remain_size-i*self.block_size))  # fill as many blocks as possible
-            self.sizes[i] = self.old_sizes[i] = remain_size-i*self.block_size
-            # old_sizes[i] = remain_size-i*self.block_size
-            i += 1
-            bz3_encode_blocks(self.states, self.buffers, self.sizes, i)
-            for j in range(i):  # state index
-                if bz3_last_error(self.states[j]) != BZ3_OK:
-                    raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.states[j]))
-
-                ret.extend((self.sizes[j] + 8) * b"\x00")
-                write_neutral_s32(<uint8_t *> &(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret) - self.sizes[j] - 8]),
-                                  self.sizes[j])
-                write_neutral_s32(<uint8_t *> &(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret) - self.sizes[j] - 4]),
-                                  self.old_sizes[j])
-                memcpy(&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret) - self.sizes[j]]), self.buffers[j],
-                       <size_t> self.sizes[j])
-
-            self.uncompressed.clear()
-        return bytes(ret)
-
-    cpdef inline list error(self):
-        cdef uint32_t i
-        cdef list ret = []
-        for i in range(self.numthreads):
-            if bz3_last_error(self.states[i]) != BZ3_OK:
-                ret.append((<bytes>bz3_strerror(self.states[i])).decode())
-        return ret
-
-
-cdef void bz3_decode_blocks(bz3_state ** states, uint8_t ** buffers, int32_t* sizes, int32_t* orig_size, int32_t numthreads):
-    cdef int32_t i
-    for i in prange(numthreads, nogil=True, schedule='static', num_threads=numthreads):
-        bz3_decode_block(states[i], buffers[i], sizes[i], orig_size[i])
-
-
-@cython.freelist(8)
-@cython.no_gc
-@cython.final
-cdef class BZ3OmpDecompressor:
-    cdef:
-        bz3_state ** states
-        uint8_t ** buffers
-        int32_t * sizes   # compressed
-        int32_t * old_sizes  # origin
-        readonly int32_t block_size
-        bytearray unused  # 还没解压的数据
-        bint have_magic_number
-        readonly uint32_t numthreads  # how many threads to use
-
-    cdef inline int init_state(self, int32_t block_size) except -1:
-        """should exec only once"""
-        if not self.states:
-            self.states = <bz3_state **> PyMem_Malloc(sizeof(bz3_state *) * self.numthreads)  # prepare the array
-            if not self.states:
-                raise MemoryError
-        if not self.buffers:
-            self.buffers = <uint8_t **> PyMem_Malloc(sizeof(uint8_t *) * self.numthreads)
-            if not self.buffers:
-                raise MemoryError
-
-        memset(self.states, 0, sizeof(bz3_state *) * self.numthreads)
-        memset(self.buffers, 0, sizeof(uint8_t *) * self.numthreads)
-        cdef uint32_t i
-        try:
-            for i in range(self.numthreads):
-                self.states[i] = bz3_new(block_size)
-                if self.states[i] == NULL:
-                    raise MemoryError("Failed to create a block encoder state")  # todo 如何善后
-                self.buffers[i] = <uint8_t *> PyMem_Malloc(block_size + block_size / 50 + 32)
-                if self.buffers[i] == NULL:
-                    raise MemoryError("Failed to allocate memory")
-        except:
-            self.free_states()
-            self.free_buffers()
-            raise
-        self.block_size = block_size
-
-    def __cinit__(self,  uint32_t numthreads):
-        self.unused = bytearray()
-        self.have_magic_number = 0 # 还没有读到magic number
-        self.numthreads = numthreads
-
-        self.sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
-        if not self.sizes:
-            raise MemoryError
-        self.old_sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
-        if not self.old_sizes:
-            PyMem_Free(self.sizes)
-            raise MemoryError
-
-    cdef inline void free_states(self):
-        cdef uint32_t i
-        for i in range(self.numthreads):
-            if self.states[i]:
-                bz3_free(self.states[i])
-                self.states[i] = NULL
-
-    cdef inline void free_buffers(self):
-        cdef uint32_t i
-        for i in range(self.numthreads):
-            if self.buffers[i]:
-                PyMem_Free(self.buffers[i])
-                self.buffers[i] = NULL
-
-    def __dealloc__(self):
-        self.free_states()
-        self.free_buffers()
-        if self.states:
-            PyMem_Free(self.states)
-        if self.buffers:
-            PyMem_Free(self.buffers)
-        if self.sizes:
-            PyMem_Free(self.sizes)
-        if self.old_sizes:
-            PyMem_Free(self.old_sizes)
-
-    cpdef inline bytes decompress(self, const uint8_t[::1] data):
-        cdef Py_ssize_t input_size = data.shape[0]
-        cdef int32_t code
-        cdef bytearray ret = bytearray()
-        cdef int32_t  block_size
-        cdef uint32_t i, thread_count, j, should_delete=0
-        cdef int should_break = 0
-        if input_size > 0:
-            # if PyByteArray_Resize(self.unused, input_size+PyByteArray_GET_SIZE(self.unused)) < 0:
-            #     raise
-            # memcpy(&(PyByteArray_AS_STRING(self.unused)[PyByteArray_GET_SIZE(self.unused)-input_size]), &data[0], input_size) # self.unused.extend
-            self.unused.extend(data) # read header
-            if PyByteArray_GET_SIZE(self.unused) > 9 and not self.have_magic_number: # 9 bytes magic number
-                if strncmp(PyByteArray_AS_STRING(self.unused), magic, 5) != 0:
-                    raise ValueError("Invalid signature")
-                block_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[5]))
-                if block_size  < KiB(65) or block_size >MiB(511):
-                    raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
-                self.init_state(block_size)
-                del self.unused[:9]
-                self.have_magic_number = 1
-            # 有几个block就用几个
-            while not should_break:
-                thread_count = 0  # 这一波能用上几个thread
-                # should_delete = 0 # 讀取完成后從self.unused刪多少
-                for i in range(self.numthreads):
-                    if (PyByteArray_GET_SIZE(self.unused)-should_delete)<8: # 8 byte的 header都不够 直接返回
-                        should_break = 1
-                        break
-                    self.sizes[i] = read_neutral_s32(<uint8_t*>&PyByteArray_AS_STRING(self.unused)[should_delete]) # todo gcc warning but bytes is const
-                    self.old_sizes[i] = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[should_delete+4]))
-                    if (PyByteArray_GET_SIZE(self.unused)-should_delete) < self.sizes[i]+8: # 数据段不够
-                        should_break = 1
-                        break
-                    memcpy(self.buffers[i], &(PyByteArray_AS_STRING(self.unused)[should_delete+8]), <size_t>self.sizes[i])
-                    should_delete += (self.sizes[i] + 8)
-                    thread_count += 1
-                if thread_count:  # 一个block都凑不齐decode个jb
-                    bz3_decode_blocks(self.states, self.buffers, self.sizes, self.old_sizes, <int32_t>thread_count)
-                for j in range(thread_count):
-                    if bz3_last_error(self.states[j]) != BZ3_OK:
-                        raise ValueError("Failed to decode data: %s" % bz3_strerror(self.states[j]))
-                    ret.extend(<bytes>self.buffers[j][:self.old_sizes[j]])
-            if should_delete:
-                del self.unused[:should_delete]
-        return bytes(ret)
-
-    @property
-    def unused_data(self):
-        """Data found after the end of the compressed stream."""
-        return bytes(self.unused)
-
-    cpdef inline list error(self):
-        cdef uint32_t i
-        cdef list ret = []
-        for i in range(self.numthreads):
-            if bz3_last_error(self.states[i]) != BZ3_OK:
-                ret.append((<bytes> bz3_strerror(self.states[i])).decode())
-        return ret
+# cython: language_level=3
+# cython: cdivision=True
+cimport cython
+from cpython.bytearray cimport PyByteArray_AS_STRING, PyByteArray_GET_SIZE
+from cpython.bytes cimport (PyBytes_AS_STRING, PyBytes_FromStringAndSize,
+                            PyBytes_GET_SIZE)
+from cpython.mem cimport PyMem_Free, PyMem_Malloc
+from cpython.object cimport PyObject_HasAttrString
+from libc.stdint cimport int32_t, uint8_t, uint32_t
+from libc.stdio cimport fprintf, stderr
+from libc.string cimport memcpy, strncmp
+
+from bz3.backends.cython.bzip3 cimport (BZ3_OK, KiB, MiB, bz3_bound,
+                                        bz3_compress, bz3_decode_block,
+                                        bz3_decompress, bz3_encode_block,
+                                        bz3_free, bz3_last_error, bz3_new,
+                                        bz3_state, bz3_strerror, bz3_version,
+                                        read_neutral_s32, write_neutral_s32, MEMLOG)
+
+
+cdef extern from "Python.h":
+    void* PyMem_Calloc(size_t nelem, size_t elsize)
+
+cdef const char* magic = "BZ3v1"
+
+cdef inline uint8_t PyFile_Check(object file):
+    if PyObject_HasAttrString(file, "read") and PyObject_HasAttrString(file, "write"):  # should we check seek method?
+        return 1
+    return 0
+
+@cython.freelist(8)
+@cython.no_gc
+@cython.final
+cdef class BZ3Compressor:
+    cdef:
+        bz3_state * state
+        uint8_t * buffer
+        readonly int32_t block_size
+        bytearray uncompressed
+        bint have_magic_number
+
+    def __cinit__(self, int32_t block_size):
+        if block_size < KiB(65) or block_size > MiB(511):
+            raise ValueError("Block size must be between 65 KiB and 511 MiB")
+        self.block_size = block_size
+        self.state = bz3_new(block_size)
+        if self.state == NULL:
+            raise MemoryError("Failed to create a block encoder state")
+        self.buffer = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))
+        if self.buffer == NULL:
+            bz3_free(self.state)
+            self.state = NULL
+            raise MemoryError("Failed to allocate memory")
+        self.uncompressed = bytearray()
+        self.have_magic_number = 0 # 还没有写入magic number
+
+    def __dealloc__(self):
+        if self.state != NULL:
+            bz3_free(self.state)
+            self.state = NULL
+        if self.buffer !=NULL:
+            PyMem_Free(self.buffer)
+            self.buffer = NULL
+
+    cpdef inline bytes compress(self, const uint8_t[::1] data):
+        cdef Py_ssize_t input_size = data.shape[0]
+        cdef int32_t new_size
+        cdef bytearray ret = bytearray()
+        if not self.have_magic_number:
+            # if PyByteArray_Resize(ret, 9) < 0:
+            #     raise
+            # memcpy(PyByteArray_AS_STRING(ret), magic, 5)
+            ret.extend(<bytes>magic[:5]+b"\x00\x00\x00\x00")  # 9 bytes
+            write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[5]), self.block_size)
+            self.have_magic_number = 1
+
+        if input_size > 0:
+            # if PyByteArray_Resize(self.uncompressed, input_size+PyByteArray_GET_SIZE(self.uncompressed)) < 0:
+            #     raise
+            # memcpy(&(PyByteArray_AS_STRING(self.uncompressed)[PyByteArray_GET_SIZE(self.uncompressed)-input_size]), &data[0], input_size) # todo? direct copy to bytearray
+            self.uncompressed.extend(data)
+            while PyByteArray_GET_SIZE(self.uncompressed)>=self.block_size:
+                memcpy(self.buffer, PyByteArray_AS_STRING(self.uncompressed), <size_t>self.block_size)
+                # make a copy
+                with nogil:
+                    new_size = bz3_encode_block(self.state, self.buffer, self.block_size)
+                if new_size == -1:
+                    raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.state))
+                # if PyByteArray_Resize(ret, PyByteArray_GET_SIZE(ret) + new_size + 8) < 0:
+                #     raise
+                ret.extend((new_size + 8)*b"\x00")
+                write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-new_size-8]), new_size)
+                write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-new_size-4]), self.block_size)
+                memcpy(&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-new_size]), self.buffer, <size_t>new_size)
+
+                del self.uncompressed[:self.block_size]
+        return bytes(ret)
+
+    cpdef inline bytes flush(self):
+        cdef bytes ret = b""
+        cdef int32_t new_size
+        cdef int32_t old_size = <int32_t>PyByteArray_GET_SIZE(self.uncompressed)
+        if self.uncompressed:
+            memcpy(self.buffer, PyByteArray_AS_STRING(self.uncompressed), <size_t>old_size)
+            with nogil:
+                new_size = bz3_encode_block(self.state, self.buffer, old_size)
+            if new_size == -1:
+                raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.state))
+            ret = PyBytes_FromStringAndSize(NULL, new_size + 8)
+            if not ret:
+                raise
+            write_neutral_s32(<uint8_t*>PyBytes_AS_STRING(ret), new_size)
+            write_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(ret)[4]), old_size)
+            memcpy(&(PyBytes_AS_STRING(ret)[8]), self.buffer, <size_t> new_size)
+            self.uncompressed.clear()
+        return ret
+
+    cpdef inline str error(self):
+        if bz3_last_error(self.state) != BZ3_OK:
+            return (<bytes>bz3_strerror(self.state)).decode()
+        return None
+
+@cython.freelist(8)
+@cython.no_gc
+@cython.final
+cdef class BZ3Decompressor:
+    cdef:
+        bz3_state * state
+        uint8_t * buffer
+        readonly int32_t block_size
+        bytearray unused  # 还没解压的数据
+        bint have_magic_number
+        readonly bint ignore_error # 是否忽略decode错误
+
+    cdef inline int init_state(self, int32_t block_size) except -1:
+        """should exec only once"""
+        self.block_size = block_size
+        self.state = bz3_new(block_size)
+        if self.state == NULL:
+            raise MemoryError("Failed to create a block encoder state")
+        self.buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
+        if self.buffer == NULL:
+            bz3_free(self.state)
+            self.state = NULL
+            raise MemoryError("Failed to allocate memory")
+
+    def __cinit__(self, bint ignore_error = False):
+        self.unused = bytearray()
+        self.have_magic_number = 0 # 还没有读到magic number
+        self.ignore_error = ignore_error
+
+    def __dealloc__(self):
+        if self.state != NULL:
+            bz3_free(self.state)
+            self.state = NULL
+        if self.buffer !=NULL:
+            PyMem_Free(self.buffer)
+            self.buffer = NULL
+
+    cpdef inline bytes decompress(self, const uint8_t[::1] data):
+        cdef Py_ssize_t input_size = data.shape[0]
+        cdef int32_t code
+        cdef bytearray ret = bytearray()
+        cdef int32_t new_size, old_size, block_size
+        if input_size > 0:
+            # if PyByteArray_Resize(self.unused, input_size+PyByteArray_GET_SIZE(self.unused)) < 0:
+            #     raise
+            # memcpy(&(PyByteArray_AS_STRING(self.unused)[PyByteArray_GET_SIZE(self.unused)-input_size]), &data[0], input_size) # self.unused.extend
+            self.unused.extend(data)
+            if PyByteArray_GET_SIZE(self.unused) > 9 and not self.have_magic_number: # 9 bytes magic number
+                if strncmp(PyByteArray_AS_STRING(self.unused), magic, 5) != 0:
+                    raise ValueError("Invalid signature")
+                block_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[5]))
+                if block_size  < KiB(65) or block_size >MiB(511):
+                    raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
+                self.init_state(block_size)
+                del self.unused[:9]
+                self.have_magic_number = 1
+
+            while True:
+                if PyByteArray_GET_SIZE(self.unused)<8: # 8 byte的 header都不够 直接返回
+                    break
+                new_size = read_neutral_s32(<uint8_t*>PyByteArray_AS_STRING(self.unused)) # todo gcc warning but bytes is contst
+                old_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[4]))
+                if old_size > <int32_t>bz3_bound(self.block_size) or new_size > <int32_t>bz3_bound(self.block_size):
+                    raise ValueError("Failed to decode a block: Inconsistent headers.")
+                if PyByteArray_GET_SIZE(self.unused) < new_size+8: # 数据段不够
+                    break
+                memcpy(self.buffer, &(PyByteArray_AS_STRING(self.unused)[8]), <size_t>new_size)
+                with nogil:
+                    code = bz3_decode_block(self.state, self.buffer, new_size, old_size)
+                if code == -1:
+                    if self.ignore_error:
+                        fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(self.state))
+                    else:
+                        raise ValueError("Failed to decode a block: %s" % bz3_strerror(self.state))
+                # if PyByteArray_Resize(ret, PyByteArray_GET_SIZE(ret) + old_size) < 0:
+                #     raise
+                ret.extend(<bytes>self.buffer[:old_size])
+                # memcpy(&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-old_size]), self.buffer, <size_t>old_size)
+                del self.unused[:new_size+8]
+        return bytes(ret)
+
+    @property
+    def unused_data(self):
+        """Data found after the end of the compressed stream."""
+        return bytes(self.unused)
+
+    cpdef inline str error(self):
+        if bz3_last_error(self.state) != BZ3_OK:
+            return (<bytes> bz3_strerror(self.state)).decode()
+        return None
+
+
+def compress_file(object input, object output, int32_t block_size):
+    if not PyFile_Check(input):
+        raise TypeError("input except a file-like object, got %s" % type(input).__name__)
+    if not PyFile_Check(output):
+        raise TypeError("output except a file-like object, got %s" % type(output).__name__)
+    cdef bz3_state *state = bz3_new(block_size)
+    if state == NULL:
+        raise MemoryError("Failed to create a block encoder state")
+    cdef uint8_t * buffer = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))
+    if buffer == NULL:
+        bz3_free(state)
+        state = NULL
+        raise MemoryError
+    cdef bytes data
+    cdef int32_t new_size
+    cdef uint8_t byteswap_buf[4]
+
+    output.write(b"BZ3v1")
+    write_neutral_s32(byteswap_buf, block_size)
+    output.write(PyBytes_FromStringAndSize(<char*>&byteswap_buf[0], 4))  # magic header
+    cdef int32_t old_size
+    try:
+        while True:
+            data = input.read(block_size)
+            if not data:
+                break
+            old_size = <int32_t>PyBytes_GET_SIZE(data)
+            memcpy(buffer, PyBytes_AS_STRING(data), <size_t>old_size)
+            with nogil:
+                new_size = bz3_encode_block(state, buffer, old_size)
+            if new_size == -1:
+                raise ValueError("Failed to encode a block: %s" % bz3_strerror(state))
+            write_neutral_s32(byteswap_buf, new_size)
+            output.write(PyBytes_FromStringAndSize(<char*>&byteswap_buf[0], 4))
+            write_neutral_s32(byteswap_buf, old_size)
+            output.write(PyBytes_FromStringAndSize(<char*>&byteswap_buf[0], 4))
+            output.write(PyBytes_FromStringAndSize(<char*>buffer, new_size))
+            output.flush()
+    finally:
+        output.flush()
+        bz3_free(state)
+        state = NULL
+        PyMem_Free(buffer)
+        buffer = NULL
+
+def decompress_file(object input, object output):
+    if not PyFile_Check(input):
+        raise TypeError("input except a file-like object, got %s" % type(input).__name__)
+    if not PyFile_Check(output):
+        raise TypeError("output except a file-like object, got %s" % type(output).__name__)
+    cdef bytes data
+    cdef int32_t block_size
+    data = input.read(9) # magic and block_size type: bytes len = 9
+    if PyBytes_GET_SIZE(data) < 9:
+        raise ValueError("Invalid file. Reason: Smaller than magic header")
+    if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:
+        raise ValueError("Invalid signature")
+    block_size = read_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(data)[5]))
+    if block_size < KiB(65) or block_size > MiB(511):
+        raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
+    cdef bz3_state *state = bz3_new(block_size)
+    if state == NULL:
+        raise MemoryError("Failed to create a block encoder state")
+    cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
+    if buffer == NULL:
+        bz3_free(state)
+        state = NULL
+        raise MemoryError("Failed to allocate memory")
+    cdef int32_t new_size, old_size, code
+
+    try:
+        while True:
+            data = input.read(4)
+            if PyBytes_GET_SIZE(data) < 4:
+                break
+            new_size = read_neutral_s32(<uint8_t*>PyBytes_AS_STRING(data))
+            data = input.read(4)
+            if PyBytes_GET_SIZE(data) < 4:
+                break
+            old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
+            if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):
+                raise ValueError("Failed to decode a block: Inconsistent headers.")
+            data = input.read(new_size) # type: bytes
+            if PyBytes_GET_SIZE(data) < new_size:
+                break
+            memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
+            with nogil:
+                code = bz3_decode_block(state, buffer, new_size, old_size)
+            if code == -1:
+                raise ValueError("Failed to decode a block: %s" % bz3_strerror(state))
+            output.write(PyBytes_FromStringAndSize(<char*>buffer, old_size))
+            output.flush()
+    finally:
+        output.flush()
+        bz3_free(state)
+        state = NULL
+        PyMem_Free(buffer)
+        buffer = NULL
+
+def recover_file(object input, object output):
+    if not PyFile_Check(input):
+        raise TypeError("input except a file-like object, got %s" % type(input).__name__)
+    if not PyFile_Check(output):
+        raise TypeError("output except a file-like object, got %s" % type(output).__name__)
+    cdef bytes data
+    cdef int32_t block_size
+    data = input.read(9) # magic and block_size type: bytes len = 9
+    if PyBytes_GET_SIZE(data) < 9:
+        raise ValueError("Invalid file. Reason: Smaller than magic header")
+    if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:
+        raise ValueError("Invalid signature")
+    block_size = read_neutral_s32(<uint8_t*>&(PyBytes_AS_STRING(data)[5]))
+    if block_size < KiB(65) or block_size > MiB(511):
+        raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
+    cdef bz3_state *state = bz3_new(block_size)
+    if state == NULL:
+        raise MemoryError("Failed to create a block encoder state")
+    cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
+    if buffer == NULL:
+        bz3_free(state)
+        state = NULL
+        raise MemoryError("Failed to allocate memory")
+    cdef int32_t new_size, old_size, code
+
+    try:
+        while True:
+            data = input.read(4)
+            if PyBytes_GET_SIZE(data) < 4:
+                break
+            new_size = read_neutral_s32(<uint8_t*>PyBytes_AS_STRING(data))
+            data = input.read(4)
+            if PyBytes_GET_SIZE(data) < 4:
+                break
+            old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
+            if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):
+                raise ValueError("Failed to decode a block: Inconsistent headers.")
+            data = input.read(new_size) # type: bytes
+            if PyBytes_GET_SIZE(data) < new_size:
+                break
+            memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
+            with nogil:
+                code = bz3_decode_block(state, buffer, new_size, old_size)
+            if code == -1:
+                fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(state))
+            output.write(PyBytes_FromStringAndSize(<char*>buffer, old_size))
+            output.flush()
+    finally:
+        output.flush()
+        bz3_free(state)
+        state = NULL
+        PyMem_Free(buffer)
+        buffer = NULL
+
+cpdef inline bint test_file(object input, bint should_raise = False) except? 0:
+    if not PyFile_Check(input):
+        raise TypeError("input except a file-like object, got %s" % type(input).__name__)
+    cdef bytes data
+    cdef int32_t block_size
+    data = input.read(9)  # magic and block_size type: bytes len = 9
+    if PyBytes_GET_SIZE(data) < 9:
+        if should_raise:
+            raise ValueError("Invalid file. Reason: Smaller than magic header")
+        return 0
+    if strncmp(PyBytes_AS_STRING(data), magic, 5) != 0:
+        if should_raise:
+            raise ValueError("Invalid signature")
+        return 0
+    block_size = read_neutral_s32(<uint8_t *> &(PyBytes_AS_STRING(data)[5]))
+    if block_size < KiB(65) or block_size > MiB(511):
+        if should_raise:
+            raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
+        return 0
+    cdef bz3_state *state = bz3_new(block_size)
+    if state == NULL:
+        raise MemoryError("Failed to create a block encoder state")
+    cdef uint8_t *buffer = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
+    if buffer == NULL:
+        bz3_free(state)
+        state = NULL
+        raise MemoryError("Failed to allocate memory")
+    cdef int32_t new_size, old_size, code
+
+    try:
+        while True:
+            data = input.read(4)
+            if PyBytes_GET_SIZE(data) < 4:
+                break
+            new_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
+            data = input.read(4)
+            if PyBytes_GET_SIZE(data) < 4:
+                break
+            old_size = read_neutral_s32(<uint8_t *> PyBytes_AS_STRING(data))
+            if old_size > <int32_t>bz3_bound(block_size) or new_size > <int32_t>bz3_bound(block_size):
+                if should_raise:
+                    raise ValueError("Failed to decode a block: Inconsistent headers.")
+                return 0
+            data = input.read(new_size)  # type: bytes
+            if PyBytes_GET_SIZE(data) < new_size:
+                break
+            memcpy(buffer, PyBytes_AS_STRING(data), <size_t> new_size)
+            with nogil:
+                code = bz3_decode_block(state, buffer, new_size, old_size)
+            # print(f"newsize {new_size} oldsize {old_size}") # todo
+            if code == -1:
+                if should_raise:
+                    raise ValueError("Failed to decode a block: %s" % bz3_strerror(state))
+                return 0
+        return 1
+    finally:
+        bz3_free(state)
+        state = NULL
+        PyMem_Free(buffer)
+        buffer = NULL
+
+cpdef inline size_t bound(size_t input_size) nogil:
+    return bz3_bound(input_size)
+
+
+cpdef inline size_t compress_into(const uint8_t[::1] data, uint8_t[::1] out, uint32_t block_size = 1000000) except? 0:
+    cdef:
+        size_t out_size = <size_t>out.shape[0]
+        int bzerr
+    with nogil:
+        bzerr = bz3_compress(block_size, &data[0], &out[0], <size_t>data.shape[0], &out_size)
+    if bzerr != BZ3_OK:
+        raise ValueError(f"bz3_compress() failed with error code {bzerr}")
+    return out_size
+
+cpdef inline size_t decompress_into(const uint8_t[::1] data, uint8_t[::1] out) except? 0:
+    cdef:
+        size_t out_size = <size_t>out.shape[0]
+        int bzerr
+    with nogil:
+        bzerr = bz3_decompress(&data[0], &out[0], <size_t>data.shape[0], &out_size)
+    if bzerr != BZ3_OK:
+        raise ValueError(f"bz3_decompress() failed with error code {bzerr}")
+    return out_size
+
+cpdef inline str libversion():
+    return (<bytes>bz3_version()).decode()
+
+# openmp
+from cython.parallel cimport prange
+
+
+cdef void bz3_encode_blocks(bz3_state ** states, uint8_t ** buffers, int32_t *sizes, int32_t numthreads):
+    # sizes: read and write
+    cdef int32_t i
+    for i in prange(numthreads, nogil=True, schedule="static", num_threads=numthreads):
+        sizes[i] = bz3_encode_block(states[i], buffers[i], sizes[i])
+
+
+@cython.freelist(8)
+@cython.no_gc
+@cython.final
+cdef class BZ3OmpCompressor:
+    cdef:
+        bz3_state ** states
+        uint8_t ** buffers
+        int32_t * sizes   # compressed
+        int32_t * old_sizes # origin size
+        readonly int32_t block_size
+        bytearray uncompressed
+        bint have_magic_number
+        readonly uint32_t numthreads  # how many threads to use
+
+    def __cinit__(self, int32_t block_size, uint32_t numthreads):
+        if block_size < KiB(65) or block_size > MiB(511):
+            raise ValueError("Block size must be between 65 KiB and 511 MiB")
+        self.block_size = block_size
+        self.states = <bz3_state **>PyMem_Calloc(<size_t>numthreads, sizeof(bz3_state *)) # prepare the array
+        if not self.states:
+            raise MemoryError
+        MEMLOG("PyMem_Malloc %p\n", self.states)
+        self.buffers = <uint8_t **>PyMem_Calloc(<size_t>numthreads, sizeof(uint8_t *))
+        if not self.buffers:
+            PyMem_Free(self.states)
+            self.states = NULL
+            raise MemoryError
+        MEMLOG("PyMem_Malloc %p\n", self.buffers)
+        self.sizes = <int32_t *>PyMem_Malloc(sizeof(int32_t) * numthreads)
+        if not self.sizes:
+            PyMem_Free(self.states)
+            MEMLOG("PyMem_Free %p\n", self.states)
+            self.states = NULL
+            PyMem_Free(self.buffers)
+            MEMLOG("PyMem_Free %p\n", self.buffers)
+            self.buffers = NULL
+            raise MemoryError
+        MEMLOG("PyMem_Malloc %p\n", self.sizes)
+        self.old_sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
+        if not self.old_sizes:
+            PyMem_Free(self.states)
+            MEMLOG("PyMem_Free %p\n", self.states)
+            self.states = NULL
+            PyMem_Free(self.buffers)
+            MEMLOG("PyMem_Free %p\n", self.buffers)
+            self.buffers = NULL
+            PyMem_Free(self.sizes)
+            MEMLOG("PyMem_Free %p\n", self.sizes)
+            self.sizes = NULL
+            raise MemoryError
+        MEMLOG("PyMem_Malloc %p\n", self.old_sizes)
+
+        cdef uint32_t i
+        try:
+            for i in range(numthreads):
+                self.states[i] = bz3_new(block_size)
+                if self.states[i] == NULL:
+                    raise MemoryError("Failed to create a block encoder state")  # todo 如何善后
+                MEMLOG("bz3_new %p\n", self.states[i])
+                self.buffers[i] = <uint8_t *>PyMem_Malloc(bz3_bound(block_size))
+                if self.buffers[i] == NULL:
+                    raise MemoryError("Failed to allocate memory")
+                MEMLOG("PyMem_Malloc %p\n", self.buffers[i])
+        except:
+            self.free_states()
+            self.free_buffers()
+            PyMem_Free(self.states)
+            MEMLOG("PyMem_Free %p\n", self.states)
+            self.states = NULL
+            PyMem_Free(self.buffers)
+            MEMLOG("PyMem_Free %p\n", self.buffers)
+            self.buffers = NULL
+            PyMem_Free(self.sizes)
+            MEMLOG("PyMem_Free %p\n", self.sizes)
+            self.sizes = NULL
+            PyMem_Free(self.old_sizes)
+            MEMLOG("PyMem_Free %p\n", self.old_sizes)
+            self.old_sizes = NULL
+            raise
+        self.uncompressed = bytearray()
+        self.have_magic_number = 0 # 还没有写入magic number
+        self.numthreads = numthreads
+
+    cdef inline void free_states(self):
+        cdef uint32_t i
+        if self.states:
+            for i in range(self.numthreads):
+                if self.states[i]:
+                    bz3_free(self.states[i])
+                    MEMLOG("bz3_free %p\n", self.states[i])
+                    self.states[i] = NULL
+
+    cdef inline void free_buffers(self):
+        cdef uint32_t i
+        if self.buffers:
+            for i in range(self.numthreads):
+                if self.buffers[i]:
+                    PyMem_Free(self.buffers[i])
+                    MEMLOG("PyMem_Free %p\n", self.buffers[i])
+                    self.buffers[i] = NULL
+
+    def __dealloc__(self):
+        cdef uint32_t i
+        self.free_states()
+        self.free_buffers()
+        if self.states:
+            PyMem_Free(self.states)
+            MEMLOG("PyMem_Free %p\n", self.states)
+            self.states = NULL
+        if self.buffers:
+            PyMem_Free(self.buffers)
+            MEMLOG("PyMem_Free %p\n", self.buffers)
+            self.buffers = NULL
+        if self.sizes:
+            PyMem_Free(self.sizes)
+            MEMLOG("PyMem_Free %p\n", self.sizes)
+            self.sizes = NULL
+        if self.old_sizes:
+            PyMem_Free(self.old_sizes)
+            MEMLOG("PyMem_Free %p\n", self.old_sizes)
+            self.old_sizes = NULL
+
+    cpdef inline bytes compress(self, const uint8_t[::1] data):
+        cdef Py_ssize_t input_size = data.shape[0]
+        cdef int32_t new_size
+        cdef bytearray ret = bytearray()
+        cdef int32_t all_blocks_size = self.block_size * self.numthreads
+        if not self.have_magic_number:
+            # if PyByteArray_Resize(ret, 9) < 0:
+            #     raise
+            # memcpy(PyByteArray_AS_STRING(ret), magic, 5)
+            ret.extend(<bytes>magic[:5]+b"\x00\x00\x00\x00")  # 9 bytes
+            write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[5]), self.block_size)
+            self.have_magic_number = 1
+        cdef uint32_t i
+        if input_size > 0:
+            # if PyByteArray_Resize(self.uncompressed, input_size+PyByteArray_GET_SIZE(self.uncompressed)) < 0:
+            #     raise
+            # memcpy(&(PyByteArray_AS_STRING(self.uncompressed)[PyByteArray_GET_SIZE(self.uncompressed)-input_size]), &data[0], input_size) # todo? direct copy to bytearray
+            self.uncompressed.extend(data)
+            if PyByteArray_GET_SIZE(self.uncompressed) >= all_blocks_size:  # able to perform a compress
+                while PyByteArray_GET_SIZE(self.uncompressed) >= all_blocks_size:  # ensure fill all blocks
+                    for i in range(self.numthreads):
+                        self.sizes[i] = self.block_size  # fill the sizes array
+                        memcpy(self.buffers[i], &PyByteArray_AS_STRING(self.uncompressed)[i*self.block_size], <size_t>self.block_size)
+                        # make a copy
+                    bz3_encode_blocks(self.states, self.buffers, self.sizes, <int32_t>self.numthreads)
+                    for i in range(self.numthreads):
+                        if bz3_last_error(self.states[i]) != BZ3_OK:
+                            raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.states[i]))
+                        # if PyByteArray_Resize(ret, PyByteArray_GET_SIZE(ret) + new_size + 8) < 0:
+                        #     raise
+                        ret.extend((self.sizes[i] + 8)*b"\x00")
+                        write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-self.sizes[i]-8]), self.sizes[i])
+                        write_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-self.sizes[i]-4]), self.block_size)
+                        memcpy(&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret)-self.sizes[i]]), self.buffers[i], <size_t>self.sizes[i])
+
+                    del self.uncompressed[:all_blocks_size]
+            return bytes(ret)
+
+    cpdef inline bytes flush(self):
+        cdef bytearray ret = bytearray()
+        cdef int32_t new_size
+        cdef int32_t remain_size = <int32_t>PyByteArray_GET_SIZE(self.uncompressed)
+        cdef:
+            int i = 0  # thread count
+            int j
+        if self.uncompressed:  # will perform a compress
+            while self.block_size * (i+1) < remain_size:
+                memcpy(self.buffers[i],
+                       &PyByteArray_AS_STRING(self.uncompressed)[i*self.block_size],
+                       <size_t>self.block_size)
+                self.sizes[i] = self.old_sizes[i] = self.block_size
+                # old_sizes[i] = self.block_size
+                i += 1
+            memcpy(self.buffers[i],
+                   &PyByteArray_AS_STRING(self.uncompressed)[i * self.block_size],
+                   <size_t> (remain_size-i*self.block_size))  # fill as many blocks as possible
+            self.sizes[i] = self.old_sizes[i] = remain_size-i*self.block_size
+            # old_sizes[i] = remain_size-i*self.block_size
+            i += 1
+            bz3_encode_blocks(self.states, self.buffers, self.sizes, i)
+            for j in range(i):  # state index
+                if bz3_last_error(self.states[j]) != BZ3_OK:
+                    raise ValueError("Failed to encode a block: %s" % bz3_strerror(self.states[j]))
+
+                ret.extend((self.sizes[j] + 8) * b"\x00")
+                write_neutral_s32(<uint8_t *> &(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret) - self.sizes[j] - 8]),
+                                  self.sizes[j])
+                write_neutral_s32(<uint8_t *> &(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret) - self.sizes[j] - 4]),
+                                  self.old_sizes[j])
+                memcpy(&(PyByteArray_AS_STRING(ret)[PyByteArray_GET_SIZE(ret) - self.sizes[j]]), self.buffers[j],
+                       <size_t> self.sizes[j])
+
+            self.uncompressed.clear()
+        return bytes(ret)
+
+    cpdef inline list error(self):
+        cdef uint32_t i
+        cdef list ret = []
+        for i in range(self.numthreads):
+            if bz3_last_error(self.states[i]) != BZ3_OK:
+                ret.append((<bytes>bz3_strerror(self.states[i])).decode())
+        return ret
+
+
+cdef void bz3_decode_blocks(bz3_state ** states, uint8_t ** buffers, int32_t* sizes, int32_t* orig_size, int32_t numthreads):
+    cdef int32_t i
+    for i in prange(numthreads, nogil=True, schedule='static', num_threads=numthreads):
+        bz3_decode_block(states[i], buffers[i], sizes[i], orig_size[i])
+
+
+@cython.freelist(8)
+@cython.no_gc
+@cython.final
+cdef class BZ3OmpDecompressor:
+    cdef:
+        bz3_state ** states
+        uint8_t ** buffers
+        int32_t * sizes   # compressed
+        int32_t * old_sizes  # origin
+        readonly int32_t block_size
+        bytearray unused  # 还没解压的数据
+        bint have_magic_number
+        readonly uint32_t numthreads  # how many threads to use
+        readonly bint ignore_error  # 是否忽略decode错误
+
+    cdef inline int init_state(self, int32_t block_size) except -1:
+        """should exec only once"""
+        if not self.states:
+            self.states = <bz3_state **> PyMem_Calloc(self.numthreads, sizeof(bz3_state *))  # prepare the array
+            if not self.states:
+                raise MemoryError
+            MEMLOG("PyMem_Malloc %p\n", self.states)
+        if not self.buffers:
+            self.buffers = <uint8_t **> PyMem_Calloc(self.numthreads, sizeof(uint8_t *))
+            if not self.buffers:
+                raise MemoryError
+            MEMLOG("PyMem_Malloc %p\n", self.buffers)
+        cdef uint32_t i
+        try:
+            for i in range(self.numthreads):
+                self.states[i] = bz3_new(block_size)
+                if self.states[i] == NULL:
+                    raise MemoryError("Failed to create a block encoder state")  # todo 如何善后
+                MEMLOG("bz3_new %p\n", self.states[i])
+                self.buffers[i] = <uint8_t *> PyMem_Malloc(bz3_bound(block_size))
+                if self.buffers[i] == NULL:
+                    raise MemoryError("Failed to allocate memory")
+                MEMLOG("PyMem_Malloc %p\n", self.buffers[i])
+        except:
+            self.free_states()
+            self.free_buffers()
+            raise
+        self.block_size = block_size
+
+    def __cinit__(self,  uint32_t numthreads, bint ignore_error = False):
+        self.states = NULL
+        self.buffers = NULL
+        self.unused = bytearray()
+        self.have_magic_number = 0 # 还没有读到magic number
+        self.numthreads = numthreads
+        self.ignore_error = ignore_error
+
+        self.sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
+        if not self.sizes:
+            raise MemoryError
+        MEMLOG("PyMem_Malloc %p\n", self.sizes)
+        self.old_sizes = <int32_t *> PyMem_Malloc(sizeof(int32_t) * numthreads)
+        if not self.old_sizes:
+            PyMem_Free(self.sizes)
+            self.sizes = NULL
+            raise MemoryError
+        MEMLOG("PyMem_Malloc %p\n", self.old_sizes)
+        MEMLOG("BZ3OmpDecompressor __cinit__ %p\n", <void*>self)
+
+    cdef inline void free_states(self):
+        cdef uint32_t i
+        if self.states: # states数组是否初始化，即是否调用过init_states
+            for i in range(self.numthreads):
+                if self.states[i]:
+                    bz3_free(self.states[i])
+                    MEMLOG("bz3_free %p\n", self.states[i])
+                    self.states[i] = NULL
+
+    cdef inline void free_buffers(self):
+        cdef uint32_t i # states数组是否初始化，即是否调用过init_states
+        if self.buffers: # states数组是否初始化，即是否调用过init_states
+            for i in range(self.numthreads):
+                if self.buffers[i]:
+                    PyMem_Free(self.buffers[i])
+                    MEMLOG("PyMem_Free %p\n", self.buffers[i])
+                    self.buffers[i] = NULL
+
+    def __dealloc__(self):
+        self.free_states()
+        self.free_buffers()
+        if self.states:
+            PyMem_Free(self.states)
+            MEMLOG("PyMem_Free %p\n", self.states)
+            self.states = NULL
+        if self.buffers:
+            PyMem_Free(self.buffers)
+            MEMLOG("PyMem_Free %p\n", self.buffers)
+            self.buffers = NULL
+        if self.sizes:
+            PyMem_Free(self.sizes)
+            MEMLOG("PyMem_Free %p\n", self.sizes)
+            self.sizes = NULL
+        if self.old_sizes:
+            PyMem_Free(self.old_sizes)
+            MEMLOG("PyMem_Free %p\n", self.old_sizes)
+            self.old_sizes = NULL
+        MEMLOG("BZ3OmpDecompressor __dealloc__ %p\n", <void *> self)
+
+    cpdef inline bytes decompress(self, const uint8_t[::1] data):
+        cdef Py_ssize_t input_size = data.shape[0]
+        cdef int32_t code
+        cdef bytearray ret = bytearray()
+        cdef int32_t  block_size
+        cdef uint32_t i, thread_count, j, should_delete=0
+        cdef int should_break = 0
+        if input_size > 0:
+            # if PyByteArray_Resize(self.unused, input_size+PyByteArray_GET_SIZE(self.unused)) < 0:
+            #     raise
+            # memcpy(&(PyByteArray_AS_STRING(self.unused)[PyByteArray_GET_SIZE(self.unused)-input_size]), &data[0], input_size) # self.unused.extend
+            self.unused.extend(data) # read header
+            if PyByteArray_GET_SIZE(self.unused) > 9 and not self.have_magic_number: # 9 bytes magic number
+                if strncmp(PyByteArray_AS_STRING(self.unused), magic, 5) != 0:
+                    raise ValueError("Invalid signature")
+                block_size = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[5]))
+                if block_size  < KiB(65) or block_size >MiB(511):
+                    raise ValueError("The input file is corrupted. Reason: Invalid block size in the header")
+                self.init_state(block_size)
+                del self.unused[:9]
+                self.have_magic_number = 1
+            # 有几个block就用几个
+            while not should_break:
+                thread_count = 0  # 这一波能用上几个thread
+                # should_delete = 0 # 讀取完成后從self.unused刪多少
+                for i in range(self.numthreads):
+                    if (PyByteArray_GET_SIZE(self.unused)-should_delete)<8: # 8 byte的 header都不够 直接返回
+                        should_break = 1
+                        break
+                    self.sizes[i] = read_neutral_s32(<uint8_t*>&PyByteArray_AS_STRING(self.unused)[should_delete]) # todo gcc warning but bytes is const
+                    self.old_sizes[i] = read_neutral_s32(<uint8_t*>&(PyByteArray_AS_STRING(self.unused)[should_delete+4]))
+                    if self.old_sizes[i] > <int32_t>bz3_bound(self.block_size) or self.sizes[i] > <int32_t>bz3_bound(self.block_size):
+                        raise ValueError("Failed to decode a block: Inconsistent headers.")
+                    if (PyByteArray_GET_SIZE(self.unused)-should_delete) < self.sizes[i]+8: # 数据段不够
+                        should_break = 1
+                        break
+                    memcpy(self.buffers[i], &(PyByteArray_AS_STRING(self.unused)[should_delete+8]), <size_t>self.sizes[i])
+                    should_delete += (self.sizes[i] + 8)
+                    thread_count += 1
+                if thread_count:  # 一个block都凑不齐decode个jb
+                    bz3_decode_blocks(self.states, self.buffers, self.sizes, self.old_sizes, <int32_t>thread_count)
+                for j in range(thread_count):
+                    if bz3_last_error(self.states[j]) != BZ3_OK:
+                        if self.ignore_error:
+                            fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(self.states[j]))
+                        else:
+                            raise ValueError("Failed to decode data: %s" % bz3_strerror(self.states[j]))
+                    ret.extend(<bytes>self.buffers[j][:self.old_sizes[j]])
+            if should_delete:
+                del self.unused[:should_delete]
+        return bytes(ret)
+
+    @property
+    def unused_data(self):
+        """Data found after the end of the compressed stream."""
+        return bytes(self.unused)
+
+    cpdef inline list error(self):
+        cdef uint32_t i
+        cdef list ret = []
+        for i in range(self.numthreads):
+            if bz3_last_error(self.states[i]) != BZ3_OK:
+                ret.append((<bytes> bz3_strerror(self.states[i])).decode())
+        return ret
```

### Comparing `bzip3-0.1.2rc1/bz3/bz3.py` & `bzip3-0.1.3rc1/bz3/bz3.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,351 +1,356 @@
-"""
-Copyright (c) 2008-2021 synodriver <synodriver@gmail.com>
-"""
-import io
-import os
-from builtins import open as _builtin_open
-from threading import RLock
-from typing import IO
-
-from bz3.backends import BZ3Compressor, BZ3Decompressor
-from bz3.compression import BaseStream, DecompressReader
-
-try:
-    from bz3.backends import BZ3OmpCompressor, BZ3OmpDecompressor
-except ImportError:
-    pass
-
-_MODE_CLOSED = 0
-_MODE_READ = 1
-# Value 2 no longer used
-_MODE_WRITE = 3
-
-
-class BZ3File(BaseStream):
-    """A file object providing transparent bzip2 (de)compression.
-
-    A BZ3File can act as a wrapper for an existing file object, or refer
-    directly to a named file on disk.
-
-    Note that BZ3File provides a *binary* file interface - data read is
-    returned as bytes, and data to be written should be given as bytes.
-    """
-
-    def __init__(
-        self,
-        filename,
-        mode: str = "r",
-        block_size: int = 1024 * 1024,
-        num_threads: int = 1,
-    ):
-        self._lock = RLock()
-        self._fp = None  # type: IO
-        self._closefp = False
-        self._mode = _MODE_CLOSED
-        if mode in ("", "r", "rb"):
-            mode = "rb"
-            mode_code = _MODE_READ
-        elif mode in ("w", "wb"):
-            mode = "wb"
-            mode_code = _MODE_WRITE
-            self._compressor = (
-                BZ3Compressor(block_size)
-                if num_threads == 1
-                else BZ3OmpCompressor(block_size, num_threads)
-            )
-        elif mode in ("x", "xb"):
-            mode = "xb"
-            mode_code = _MODE_WRITE
-            self._compressor = (
-                BZ3Compressor(block_size)
-                if num_threads == 1
-                else BZ3OmpCompressor(block_size, num_threads)
-            )
-        elif mode in ("a", "ab"):
-            mode = "ab"
-            mode_code = _MODE_WRITE
-            self._compressor = (
-                BZ3Compressor(block_size)
-                if num_threads == 1
-                else BZ3OmpCompressor(block_size, num_threads)
-            )
-        else:
-            raise ValueError("Invalid mode: %r" % (mode,))
-
-        if isinstance(filename, (str, bytes, os.PathLike)):
-            self._fp = _builtin_open(filename, mode)
-            self._closefp = True
-            self._mode = mode_code
-        elif hasattr(filename, "read") or hasattr(filename, "write"):
-            self._fp = filename
-            self._mode = mode_code
-        else:
-            raise TypeError("filename must be a str, bytes, file or PathLike object")
-
-        if self._mode == _MODE_READ:
-            raw = (
-                DecompressReader(self._fp, BZ3Decompressor)
-                if num_threads == 1
-                else DecompressReader(
-                    self._fp, BZ3OmpDecompressor, numthreads=num_threads
-                )
-            )
-            self._buffer = io.BufferedReader(raw)
-        else:
-            self._pos = 0
-
-    def close(self):
-        """Flush and close the file.
-
-        May be called more than once without error. Once the file is
-        closed, any other operation on it will raise a ValueError.
-        """
-        with self._lock:
-            if self._mode == _MODE_CLOSED:
-                return
-            try:
-                if self._mode == _MODE_READ:
-                    self._buffer.close()
-                elif self._mode == _MODE_WRITE:
-                    self._fp.write(self._compressor.flush())
-                    self._compressor = None
-            finally:
-                try:
-                    if self._closefp:
-                        self._fp.close()
-                finally:
-                    self._fp = None
-                    self._closefp = False
-                    self._mode = _MODE_CLOSED
-                    self._buffer = None
-
-    @property
-    def closed(self):
-        """True if this file is closed."""
-        return self._mode == _MODE_CLOSED
-
-    def fileno(self):
-        """Return the file descriptor for the underlying file."""
-        self._check_not_closed()
-        return self._fp.fileno()
-
-    def seekable(self):
-        """Return whether the file supports seeking."""
-        return self.readable() and self._buffer.seekable()
-
-    def readable(self):
-        """Return whether the file was opened for reading."""
-        self._check_not_closed()
-        return self._mode == _MODE_READ
-
-    def writable(self):
-        """Return whether the file was opened for writing."""
-        self._check_not_closed()
-        return self._mode == _MODE_WRITE
-
-    def peek(self, n=0):
-        """Return buffered data without advancing the file position.
-
-        Always returns at least one byte of data, unless at EOF.
-        The exact number of bytes returned is unspecified.
-        """
-        with self._lock:
-            self._check_can_read()
-            # Relies on the undocumented fact that BufferedReader.peek()
-            # always returns at least one byte (except at EOF), independent
-            # of the value of n
-            return self._buffer.peek(n)
-
-    def read(self, size=-1):
-        """Read up to size uncompressed bytes from the file.
-
-        If size is negative or omitted, read until EOF is reached.
-        Returns b'' if the file is already at EOF.
-        """
-        with self._lock:
-            self._check_can_read()
-            return self._buffer.read(size)
-
-    def read1(self, size=-1):
-        """Read up to size uncompressed bytes, while trying to avoid
-        making multiple reads from the underlying stream. Reads up to a
-        buffer's worth of data if size is negative.
-
-        Returns b'' if the file is at EOF.
-        """
-        with self._lock:
-            self._check_can_read()
-            if size < 0:
-                size = io.DEFAULT_BUFFER_SIZE
-            return self._buffer.read1(size)
-
-    def readinto(self, b):
-        """Read bytes into b.
-
-        Returns the number of bytes read (0 for EOF).
-        """
-        with self._lock:
-            self._check_can_read()
-            return self._buffer.readinto(b)
-
-    def readline(self, size=-1):
-        """Read a line of uncompressed bytes from the file.
-
-        The terminating newline (if present) is retained. If size is
-        non-negative, no more than size bytes will be read (in which
-        case the line may be incomplete). Returns b'' if already at EOF.
-        """
-        if not isinstance(size, int):
-            if not hasattr(size, "__index__"):
-                raise TypeError("Integer argument expected")
-            size = size.__index__()
-        with self._lock:
-            self._check_can_read()
-            return self._buffer.readline(size)
-
-    def readlines(self, size=-1):
-        """Read a list of lines of uncompressed bytes from the file.
-
-        size can be specified to control the number of lines read: no
-        further lines will be read once the total size of the lines read
-        so far equals or exceeds size.
-        """
-        if not isinstance(size, int):
-            if not hasattr(size, "__index__"):
-                raise TypeError("Integer argument expected")
-            size = size.__index__()
-        with self._lock:
-            self._check_can_read()
-            return self._buffer.readlines(size)
-
-    def write(self, data):
-        """Write a byte string to the file.
-
-        Returns the number of uncompressed bytes written, which is
-        always len(data). Note that due to buffering, the file on disk
-        may not reflect the data written until close() is called.
-        """
-        with self._lock:
-            self._check_can_write()
-            compressed = self._compressor.compress(data)
-            self._fp.write(compressed)
-            self._pos += len(data)
-            return len(data)
-
-    def writelines(self, seq):
-        """Write a sequence of byte strings to the file.
-
-        Returns the number of uncompressed bytes written.
-        seq can be any iterable yielding byte strings.
-
-        Line separators are not added between the written byte strings.
-        """
-        with self._lock:
-            return BaseStream.writelines(self, seq)
-
-    def seek(self, offset, whence=io.SEEK_SET):
-        """Change the file position.
-
-        The new position is specified by offset, relative to the
-        position indicated by whence. Values for whence are:
-
-            0: start of stream (default); offset must not be negative
-            1: current stream position
-            2: end of stream; offset must not be positive
-
-        Returns the new file position.
-
-        Note that seeking is emulated, so depending on the parameters,
-        this operation may be extremely slow.
-        """
-        with self._lock:
-            self._check_can_seek()
-            return self._buffer.seek(offset, whence)
-
-    def tell(self):
-        """Return the current file position."""
-        with self._lock:
-            self._check_not_closed()
-            if self._mode == _MODE_READ:
-                return self._buffer.tell()
-            return self._pos
-
-
-def open(
-    filename,
-    mode: str = "rb",
-    block_size: int = 1024 * 1024,
-    encoding: str = None,
-    errors: str = None,
-    newline: str = None,
-    num_threads: int = 1,
-) -> BZ3File:
-    """Open a bzip3-compressed file in binary or text mode.
-
-    The filename argument can be an actual filename (a str, bytes, or
-    PathLike object), or an existing file object to read from or write
-    to.
-
-    The mode argument can be "r", "rb", "w", "wb", "x", "xb", "a" or
-    "ab" for binary mode, or "rt", "wt", "xt" or "at" for text mode.
-    The default mode is "rb", and the default compresslevel is 9.
-
-    For binary mode, this function is equivalent to the BZ2File
-    constructor: BZ2File(filename, mode, compresslevel). In this case,
-    the encoding, errors and newline arguments must not be provided.
-
-    For text mode, a BZ2File object is created, and wrapped in an
-    io.TextIOWrapper instance with the specified encoding, error
-    handling behavior, and line ending(s).
-
-    """
-    if "t" in mode:
-        if "b" in mode:
-            raise ValueError("Invalid mode: %r" % (mode,))
-    else:
-        if encoding is not None:
-            raise ValueError("Argument 'encoding' not supported in binary mode")
-        if errors is not None:
-            raise ValueError("Argument 'errors' not supported in binary mode")
-        if newline is not None:
-            raise ValueError("Argument 'newline' not supported in binary mode")
-
-    bz_mode = mode.replace("t", "")
-    binary_file = BZ3File(filename, bz_mode, block_size, num_threads)
-
-    if "t" in mode:
-        return io.TextIOWrapper(binary_file, encoding, errors, newline)
-    else:
-        return binary_file
-
-
-def compress(data: bytes, block_size: int = 1024 * 1024, num_threads: int = 1) -> bytes:
-    """Compress a block of data.
-
-    block_size, if given, must be a number between 65 KiB and 511 MiB as bytes.
-    num_threads, which control how many threads to use. if given, must >= 1.
-
-    For incremental compression, use a BZ3Compressor object instead.
-    """
-    if num_threads == 1:
-        compressor = BZ3Compressor(block_size)
-    elif num_threads > 1:
-        compressor = BZ3OmpCompressor(block_size, num_threads)
-    else:
-        raise ValueError("num_threads must greater or equal to 1")
-    return compressor.compress(data) + compressor.flush()
-
-
-def decompress(data: bytes, num_threads: int = 1) -> bytes:
-    """Decompress a block of data.
-    num_threads, which control how many threads to use. if given, must >= 1.
-
-    For incremental decompression, use a BZ2Decompressor object instead.
-    """
-    if num_threads == 1:
-        decomp = BZ3Decompressor()
-    elif num_threads > 1:
-        decomp = BZ3OmpDecompressor(num_threads)
-    else:
-        raise ValueError("num_threads must greater or equal to 1")
-    return decomp.decompress(data)
+"""
+Copyright (c) 2008-2023 synodriver <diguohuangjiajinweijun@gmail.com>
+"""
+import io
+import os
+from builtins import open as _builtin_open
+from threading import RLock
+from typing import IO
+
+from bz3.backends import BZ3Compressor, BZ3Decompressor
+from bz3.compression import BaseStream, DecompressReader
+
+try:
+    from bz3.backends import BZ3OmpCompressor, BZ3OmpDecompressor
+except ImportError:
+    pass
+
+_MODE_CLOSED = 0
+_MODE_READ = 1
+# Value 2 no longer used
+_MODE_WRITE = 3
+
+
+class BZ3File(BaseStream):
+    """A file object providing transparent bzip2 (de)compression.
+
+    A BZ3File can act as a wrapper for an existing file object, or refer
+    directly to a named file on disk.
+
+    Note that BZ3File provides a *binary* file interface - data read is
+    returned as bytes, and data to be written should be given as bytes.
+    """
+
+    def __init__(
+        self,
+        filename,
+        mode: str = "r",
+        block_size: int = 1024 * 1024,
+        num_threads: int = 1,
+        ignore_error: bool = False,
+    ):
+        self._lock = RLock()
+        self._fp = None  # type: IO
+        self._closefp = False
+        self._mode = _MODE_CLOSED
+        if mode in ("", "r", "rb"):
+            mode = "rb"
+            mode_code = _MODE_READ
+        elif mode in ("w", "wb"):
+            mode = "wb"
+            mode_code = _MODE_WRITE
+            self._compressor = (
+                BZ3Compressor(block_size)
+                if num_threads == 1
+                else BZ3OmpCompressor(block_size, num_threads)
+            )
+        elif mode in ("x", "xb"):
+            mode = "xb"
+            mode_code = _MODE_WRITE
+            self._compressor = (
+                BZ3Compressor(block_size)
+                if num_threads == 1
+                else BZ3OmpCompressor(block_size, num_threads)
+            )
+        elif mode in ("a", "ab"):
+            mode = "ab"
+            mode_code = _MODE_WRITE
+            self._compressor = (
+                BZ3Compressor(block_size)
+                if num_threads == 1
+                else BZ3OmpCompressor(block_size, num_threads)
+            )
+        else:
+            raise ValueError("Invalid mode: %r" % (mode,))
+
+        if isinstance(filename, (str, bytes, os.PathLike)):
+            self._fp = _builtin_open(filename, mode)
+            self._closefp = True
+            self._mode = mode_code
+        elif hasattr(filename, "read") or hasattr(filename, "write"):
+            self._fp = filename
+            self._mode = mode_code
+        else:
+            raise TypeError("filename must be a str, bytes, file or PathLike object")
+
+        if self._mode == _MODE_READ:
+            raw = (
+                DecompressReader(self._fp, BZ3Decompressor, ignore_error=ignore_error)
+                if num_threads == 1
+                else DecompressReader(
+                    self._fp,
+                    BZ3OmpDecompressor,
+                    numthreads=num_threads,
+                    ignore_error=ignore_error,
+                )
+            )
+            self._buffer = io.BufferedReader(raw)
+        else:
+            self._pos = 0
+
+    def close(self):
+        """Flush and close the file.
+
+        May be called more than once without error. Once the file is
+        closed, any other operation on it will raise a ValueError.
+        """
+        with self._lock:
+            if self._mode == _MODE_CLOSED:
+                return
+            try:
+                if self._mode == _MODE_READ:
+                    self._buffer.close()
+                elif self._mode == _MODE_WRITE:
+                    self._fp.write(self._compressor.flush())
+                    self._compressor = None
+            finally:
+                try:
+                    if self._closefp:
+                        self._fp.close()
+                finally:
+                    self._fp = None
+                    self._closefp = False
+                    self._mode = _MODE_CLOSED
+                    self._buffer = None
+
+    @property
+    def closed(self):
+        """True if this file is closed."""
+        return self._mode == _MODE_CLOSED
+
+    def fileno(self):
+        """Return the file descriptor for the underlying file."""
+        self._check_not_closed()
+        return self._fp.fileno()
+
+    def seekable(self):
+        """Return whether the file supports seeking."""
+        return self.readable() and self._buffer.seekable()
+
+    def readable(self):
+        """Return whether the file was opened for reading."""
+        self._check_not_closed()
+        return self._mode == _MODE_READ
+
+    def writable(self):
+        """Return whether the file was opened for writing."""
+        self._check_not_closed()
+        return self._mode == _MODE_WRITE
+
+    def peek(self, n=0):
+        """Return buffered data without advancing the file position.
+
+        Always returns at least one byte of data, unless at EOF.
+        The exact number of bytes returned is unspecified.
+        """
+        with self._lock:
+            self._check_can_read()
+            # Relies on the undocumented fact that BufferedReader.peek()
+            # always returns at least one byte (except at EOF), independent
+            # of the value of n
+            return self._buffer.peek(n)
+
+    def read(self, size=-1):
+        """Read up to size uncompressed bytes from the file.
+
+        If size is negative or omitted, read until EOF is reached.
+        Returns b'' if the file is already at EOF.
+        """
+        with self._lock:
+            self._check_can_read()
+            return self._buffer.read(size)
+
+    def read1(self, size=-1):
+        """Read up to size uncompressed bytes, while trying to avoid
+        making multiple reads from the underlying stream. Reads up to a
+        buffer's worth of data if size is negative.
+
+        Returns b'' if the file is at EOF.
+        """
+        with self._lock:
+            self._check_can_read()
+            if size < 0:
+                size = io.DEFAULT_BUFFER_SIZE
+            return self._buffer.read1(size)
+
+    def readinto(self, b):
+        """Read bytes into b.
+
+        Returns the number of bytes read (0 for EOF).
+        """
+        with self._lock:
+            self._check_can_read()
+            return self._buffer.readinto(b)
+
+    def readline(self, size=-1):
+        """Read a line of uncompressed bytes from the file.
+
+        The terminating newline (if present) is retained. If size is
+        non-negative, no more than size bytes will be read (in which
+        case the line may be incomplete). Returns b'' if already at EOF.
+        """
+        if not isinstance(size, int):
+            if not hasattr(size, "__index__"):
+                raise TypeError("Integer argument expected")
+            size = size.__index__()
+        with self._lock:
+            self._check_can_read()
+            return self._buffer.readline(size)
+
+    def readlines(self, size=-1):
+        """Read a list of lines of uncompressed bytes from the file.
+
+        size can be specified to control the number of lines read: no
+        further lines will be read once the total size of the lines read
+        so far equals or exceeds size.
+        """
+        if not isinstance(size, int):
+            if not hasattr(size, "__index__"):
+                raise TypeError("Integer argument expected")
+            size = size.__index__()
+        with self._lock:
+            self._check_can_read()
+            return self._buffer.readlines(size)
+
+    def write(self, data):
+        """Write a byte string to the file.
+
+        Returns the number of uncompressed bytes written, which is
+        always len(data). Note that due to buffering, the file on disk
+        may not reflect the data written until close() is called.
+        """
+        with self._lock:
+            self._check_can_write()
+            compressed = self._compressor.compress(data)
+            self._fp.write(compressed)
+            self._pos += len(data)
+            return len(data)
+
+    def writelines(self, seq):
+        """Write a sequence of byte strings to the file.
+
+        Returns the number of uncompressed bytes written.
+        seq can be any iterable yielding byte strings.
+
+        Line separators are not added between the written byte strings.
+        """
+        with self._lock:
+            return BaseStream.writelines(self, seq)
+
+    def seek(self, offset, whence=io.SEEK_SET):
+        """Change the file position.
+
+        The new position is specified by offset, relative to the
+        position indicated by whence. Values for whence are:
+
+            0: start of stream (default); offset must not be negative
+            1: current stream position
+            2: end of stream; offset must not be positive
+
+        Returns the new file position.
+
+        Note that seeking is emulated, so depending on the parameters,
+        this operation may be extremely slow.
+        """
+        with self._lock:
+            self._check_can_seek()
+            return self._buffer.seek(offset, whence)
+
+    def tell(self):
+        """Return the current file position."""
+        with self._lock:
+            self._check_not_closed()
+            if self._mode == _MODE_READ:
+                return self._buffer.tell()
+            return self._pos
+
+
+def open(
+    filename,
+    mode: str = "rb",
+    block_size: int = 1024 * 1024,
+    encoding: str = None,
+    errors: str = None,
+    newline: str = None,
+    num_threads: int = 1,
+    ignore_error: bool = False,
+) -> BZ3File:
+    """Open a bzip3-compressed file in binary or text mode.
+
+    The filename argument can be an actual filename (a str, bytes, or
+    PathLike object), or an existing file object to read from or write
+    to.
+
+    The mode argument can be "r", "rb", "w", "wb", "x", "xb", "a" or
+    "ab" for binary mode, or "rt", "wt", "xt" or "at" for text mode.
+    The default mode is "rb", and the default compresslevel is 9.
+
+    For binary mode, this function is equivalent to the BZ3File
+    constructor: BZ3File(filename, mode, ...). In this case,
+    the encoding, errors and newline arguments must not be provided.
+
+    For text mode, a BZ3File object is created, and wrapped in an
+    io.TextIOWrapper instance with the specified encoding, error
+    handling behavior, and line ending(s).
+
+    """
+    if "t" in mode:
+        if "b" in mode:
+            raise ValueError("Invalid mode: %r" % (mode,))
+    else:
+        if encoding is not None:
+            raise ValueError("Argument 'encoding' not supported in binary mode")
+        if errors is not None:
+            raise ValueError("Argument 'errors' not supported in binary mode")
+        if newline is not None:
+            raise ValueError("Argument 'newline' not supported in binary mode")
+
+    bz_mode = mode.replace("t", "")
+    binary_file = BZ3File(filename, bz_mode, block_size, num_threads, ignore_error)
+
+    if "t" in mode:
+        return io.TextIOWrapper(binary_file, encoding, errors, newline)
+    else:
+        return binary_file
+
+
+def compress(data: bytes, block_size: int = 1024 * 1024, num_threads: int = 1) -> bytes:
+    """Compress a block of data.
+
+    block_size, if given, must be a number between 65 KiB and 511 MiB as bytes.
+    num_threads, which control how many threads to use. if given, must >= 1.
+
+    For incremental compression, use a BZ3Compressor object instead.
+    """
+    if num_threads == 1:
+        compressor = BZ3Compressor(block_size)
+    elif num_threads > 1:
+        compressor = BZ3OmpCompressor(block_size, num_threads)
+    else:
+        raise ValueError("num_threads must greater or equal to 1")
+    return compressor.compress(data) + compressor.flush()
+
+
+def decompress(data: bytes, num_threads: int = 1) -> bytes:
+    """Decompress a block of data.
+    num_threads, which control how many threads to use. if given, must >= 1.
+
+    For incremental decompression, use a BZ2Decompressor object instead.
+    """
+    if num_threads == 1:
+        decomp = BZ3Decompressor()
+    elif num_threads > 1:
+        decomp = BZ3OmpDecompressor(num_threads)
+    else:
+        raise ValueError("num_threads must greater or equal to 1")
+    return decomp.decompress(data)
```

### Comparing `bzip3-0.1.2rc1/bz3/compression.py` & `bzip3-0.1.3rc1/bz3/compression.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,161 +1,162 @@
-"""Copied from cpython to ensure compatibility"""
-import io
-from typing import Any, Callable, Dict
-
-BUFFER_SIZE = io.DEFAULT_BUFFER_SIZE  # Compressed data read chunk size
-
-
-class BaseStream(io.BufferedIOBase):
-    """Mode-checking helper functions."""
-
-    def _check_not_closed(self):
-        if self.closed:
-            raise ValueError("I/O operation on closed file")
-
-    def _check_can_read(self):
-        if not self.readable():
-            raise io.UnsupportedOperation("File not open for reading")
-
-    def _check_can_write(self):
-        if not self.writable():
-            raise io.UnsupportedOperation("File not open for writing")
-
-    def _check_can_seek(self):
-        if not self.readable():
-            raise io.UnsupportedOperation(
-                "Seeking is only supported " "on files open for reading"
-            )
-        if not self.seekable():
-            raise io.UnsupportedOperation(
-                "The underlying file object " "does not support seeking"
-            )
-
-
-class DecompressReader(io.RawIOBase):
-    """Adapts the decompressor API to a RawIOBase reader API"""
-
-    def readable(self):
-        return True
-
-    def __init__(
-        self,
-        fp: io.IOBase,
-        decomp_factory: Callable,
-        **decomp_args: Dict[str, Any],
-    ):
-        self._fp = fp
-        self._eof = False
-        self._pos = 0  # Current offset in decompressed stream
-
-        # Set to size of decompressed stream once it is known, for SEEK_END
-        self._size = -1
-
-        # Save the decompressor factory and arguments.
-        # If the file contains multiple compressed streams, each
-        # stream will need a separate decompressor object. A new decompressor
-        # object is also needed when implementing a backwards seek().
-        self._decomp_factory = decomp_factory
-        self._decomp_args = decomp_args
-        self._decompressor = self._decomp_factory(**self._decomp_args)
-
-        # Exception class to catch from decompressor signifying invalid
-        # trailing data to ignore
-        self._buffer = bytearray()  # type: bytearray
-
-    def close(self) -> None:
-        self._decompressor = None
-        return super().close()
-
-    def seekable(self) -> bool:
-        return self._fp.seekable()
-
-    def readinto(self, b) -> int:
-        with memoryview(b) as view, view.cast("B") as byte_view:
-            data = self.read(len(byte_view))
-            byte_view[: len(data)] = data
-        return len(data)
-
-    def read(self, size=-1) -> bytes:  # todo 这个是重点
-        if size < 0:
-            return self.readall()
-        if size <= len(self._buffer):
-            self._pos += size
-            ret = bytes(self._buffer[:size])
-            del self._buffer[:size]
-            return ret
-        if not size or self._eof:
-            return b""
-        # data = None  # Default if EOF is encountered
-        # Depending on the input data, our call to the decompressor may not
-        # return any data. In this case, try again after reading another block.
-        # try:
-        while True:
-            rawblock = self._fp.read(BUFFER_SIZE)
-            if not rawblock:
-                break
-            self._buffer.extend(self._decompressor.decompress(rawblock))
-            if len(self._buffer) >= size:
-                break
-        if len(self._buffer) >= size:
-            self._pos += size
-            ret = bytes(self._buffer[:size])
-            del self._buffer[:size]
-        else:  # 不够长了
-            self._pos += len(self._buffer)
-            self._eof = True
-            self._size = self._pos
-            ret = bytes(self._buffer)
-            self._buffer.clear()
-        return ret
-
-    def readall(self) -> bytes:
-        while True:
-            rawblock = self._fp.read(BUFFER_SIZE)
-            if not rawblock:
-                break
-            self._buffer.extend(self._decompressor.decompress(rawblock))
-        self._pos += len(self._buffer)
-        ret = bytes(self._buffer)
-        self._buffer.clear()
-        return ret
-
-    # Rewind the file to the beginning of the data stream.
-    def _rewind(self):
-        self._fp.seek(0)
-        self._eof = False
-        self._pos = 0
-        self._decompressor = self._decomp_factory(**self._decomp_args)
-
-    def seek(self, offset, whence=io.SEEK_SET):
-        # Recalculate offset as an absolute file position.
-        if whence == io.SEEK_SET:
-            pass
-        elif whence == io.SEEK_CUR:
-            offset = self._pos + offset
-        elif whence == io.SEEK_END:
-            # Seeking relative to EOF - we need to know the file's size.
-            if self._size < 0:
-                while self.read(io.DEFAULT_BUFFER_SIZE):
-                    pass
-            offset = self._size + offset
-        else:
-            raise ValueError("Invalid value for whence: {}".format(whence))
-
-        # Make it so that offset is the number of bytes to skip forward.
-        if offset < self._pos:
-            self._rewind()
-        else:
-            offset -= self._pos
-
-        # Read and discard data until we reach the desired position.
-        while offset > 0:
-            data = self.read(min(io.DEFAULT_BUFFER_SIZE, offset))
-            if not data:
-                break
-            offset -= len(data)
-
-        return self._pos
-
-    def tell(self) -> int:
-        """Return the current file position."""
-        return self._pos
+"""Copied from cpython to ensure compatibility"""
+import io
+from typing import Any, Callable, Dict
+
+BUFFER_SIZE = io.DEFAULT_BUFFER_SIZE  # Compressed data read chunk size
+
+
+class BaseStream(io.BufferedIOBase):
+    """Mode-checking helper functions."""
+
+    def _check_not_closed(self):
+        if self.closed:
+            raise ValueError("I/O operation on closed file")
+
+    def _check_can_read(self):
+        if not self.readable():
+            raise io.UnsupportedOperation("File not open for reading")
+
+    def _check_can_write(self):
+        if not self.writable():
+            raise io.UnsupportedOperation("File not open for writing")
+
+    def _check_can_seek(self):
+        if not self.readable():
+            raise io.UnsupportedOperation(
+                "Seeking is only supported " "on files open for reading"
+            )
+        if not self.seekable():
+            raise io.UnsupportedOperation(
+                "The underlying file object " "does not support seeking"
+            )
+
+
+class DecompressReader(io.RawIOBase):
+    """Adapts the decompressor API to a RawIOBase reader API"""
+
+    def readable(self):
+        return True
+
+    def __init__(
+        self,
+        fp: io.IOBase,
+        decomp_factory: Callable,
+        **decomp_args: Dict[str, Any],
+    ):
+        self._fp = fp
+        self._eof = False
+        self._pos = 0  # Current offset in decompressed stream
+
+        # Set to size of decompressed stream once it is known, for SEEK_END
+        self._size = -1
+
+        # Save the decompressor factory and arguments.
+        # If the file contains multiple compressed streams, each
+        # stream will need a separate decompressor object. A new decompressor
+        # object is also needed when implementing a backwards seek().
+        self._decomp_factory = decomp_factory
+        self._decomp_args = decomp_args
+        self._decompressor = self._decomp_factory(**self._decomp_args)
+
+        # Exception class to catch from decompressor signifying invalid
+        # trailing data to ignore
+        self._buffer = bytearray()  # type: bytearray
+
+    def close(self) -> None:
+        self._decompressor = None
+        return super().close()
+
+    def seekable(self) -> bool:
+        return self._fp.seekable()
+
+    def readinto(self, b) -> int:
+        with memoryview(b) as view, view.cast("B") as byte_view:
+            data = self.read(len(byte_view))
+            byte_view[: len(data)] = data
+        return len(data)
+
+    def read(self, size=-1) -> bytes:  # todo 这个是重点
+        if size < 0:
+            return self.readall()
+        if size <= len(self._buffer):
+            self._pos += size
+            ret = bytes(self._buffer[:size])
+            del self._buffer[:size]
+            return ret
+        if not size or self._eof:
+            return b""
+        # data = None  # Default if EOF is encountered
+        # Depending on the input data, our call to the decompressor may not
+        # return any data. In this case, try again after reading another block.
+        # try:
+        while True:
+            rawblock = self._fp.read(BUFFER_SIZE)
+            if not rawblock:
+                break
+            self._buffer.extend(self._decompressor.decompress(rawblock))
+            if len(self._buffer) >= size:
+                break
+        if len(self._buffer) >= size:
+            self._pos += size
+            ret = bytes(self._buffer[:size])
+            del self._buffer[:size]
+        else:  # 不够长了
+            self._pos += len(self._buffer)
+            self._eof = True
+            self._size = self._pos
+            ret = bytes(self._buffer)
+            self._buffer.clear()
+        return ret
+
+    def readall(self) -> bytes:
+        while True:
+            rawblock = self._fp.read(BUFFER_SIZE)
+            if not rawblock:
+                break
+            self._buffer.extend(self._decompressor.decompress(rawblock))
+        self._pos += len(self._buffer)
+        ret = bytes(self._buffer)
+        self._buffer.clear()
+        return ret
+
+    # Rewind the file to the beginning of the data stream.
+    def _rewind(self):
+        self._fp.seek(0)
+        self._eof = False
+        self._pos = 0
+        self._buffer.clear()
+        self._decompressor = self._decomp_factory(**self._decomp_args)
+
+    def seek(self, offset, whence=io.SEEK_SET):
+        # Recalculate offset as an absolute file position.
+        if whence == io.SEEK_SET:
+            pass
+        elif whence == io.SEEK_CUR:
+            offset = self._pos + offset
+        elif whence == io.SEEK_END:
+            # Seeking relative to EOF - we need to know the file's size.
+            if self._size < 0:
+                while self.read(io.DEFAULT_BUFFER_SIZE):
+                    pass
+            offset = self._size + offset
+        else:
+            raise ValueError("Invalid value for whence: {}".format(whence))
+
+        # Make it so that offset is the number of bytes to skip forward.
+        if offset < self._pos:
+            self._rewind()
+        else:
+            offset -= self._pos
+
+        # Read and discard data until we reach the desired position.
+        while offset > 0:
+            data = self.read(min(io.DEFAULT_BUFFER_SIZE, offset))
+            if not data:
+                break
+            offset -= len(data)
+
+        return self._pos
+
+    def tell(self) -> int:
+        """Return the current file position."""
+        return self._pos
```

### Comparing `bzip3-0.1.2rc1/bzip3.egg-info/PKG-INFO` & `bzip3-0.1.3rc1/bzip3.egg-info/PKG-INFO`

 * *Files 15% similar despite different names*

```diff
@@ -1,113 +1,114 @@
-Metadata-Version: 2.1
-Name: bzip3
-Version: 0.1.2rc1
-Summary: bz3 compress and decompress
-Home-page: https://github.com/synodriver/python-bz3
-Author: synodriver
-Author-email: diguohuangjiajinweijun@gmail.com
-License: BSD
-Keywords: bz3,compress,decompress
-Classifier: Development Status :: 3 - Alpha
-Classifier: Operating System :: OS Independent
-Classifier: License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)
-Classifier: Programming Language :: C
-Classifier: Programming Language :: Cython
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3.6
-Classifier: Programming Language :: Python :: 3.7
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-Classifier: Programming Language :: Python :: Implementation :: CPython
-Classifier: Programming Language :: Python :: Implementation :: PyPy
-Requires-Python: >=3.6
-Description-Content-Type: text/markdown
-
-<h1 align="center"><i>✨ python-bz3 ✨ </i></h1>
-
-<h3 align="center">The python binding for <a href="https://github.com/kspalaiologos/bzip3/tree/master">bzip3</a> with parallel support</h3>
-
-[![pypi](https://img.shields.io/pypi/v/bzip3.svg)](https://pypi.org/project/bzip3/)
-![python](https://img.shields.io/pypi/pyversions/bzip3)
-![implementation](https://img.shields.io/pypi/implementation/bzip3)
-![wheel](https://img.shields.io/pypi/wheel/bzip3)
-![license](https://img.shields.io/github/license/synodriver/python-bz3.svg)
-![action](https://img.shields.io/github/workflow/status/synodriver/python-bz3/build%20wheel)
-
-### install
-```bash
-pip install bzip3
-```
-
-
-### Usage
-```python
-from bz3 import compress_file, decompress_file, test_file, compress, decompress
-import bz3
-
-with open("test_inp.txt", "rb") as inp, open("compressed.bz3", "wb") as out:
-    compress_file(inp, out, 1000 * 1000)
-
-with open("compressed.bz3", "rb") as inp:
-    test_file(inp, True)    
-
-with open("compressed.bz3", "rb") as inp, open("output.txt", "wb") as out:
-    decompress_file(inp, out)
-
-print(decompress(compress(b"12121")))
-
-with bz3.open("test.bz3", "wt", encoding="utf-8", num_threads=4) as f:
-    f.write("test data")
-
-with bz3.open("test.bz3", "rt", encoding="utf-8", num_threads=4) as f:
-    print(f.read())
-```
-- use ```BZ3_USE_CFFI``` env var to specify a backend
-- ```num_threads``` is only available on cython backend which have openmp support
-
-### Public functions
-```python
-from typing import IO, Optional
-
-def compress_file(input: IO, output: IO, block_size: int) -> None: ...
-def decompress_file(input: IO, output: IO) -> None: ...
-def test_file(input: IO, should_raise: bool = ...) -> bool: ...
-
-
-class BZ3File:
-    def __init__(self, filename, mode: str = ..., block_size: int = ..., num_threads: int = ...) -> None: ...
-    def close(self) -> None: ...
-    @property
-    def closed(self): ...
-    def fileno(self): ...
-    def seekable(self): ...
-    def readable(self): ...
-    def writable(self): ...
-    def peek(self, n: int = ...): ...
-    def read(self, size: int = ...): ...
-    def read1(self, size: int = ...): ...
-    def readinto(self, b): ...
-    def readline(self, size: int = ...): ...
-    def readlines(self, size: int = ...): ...
-    def write(self, data): ...
-    def writelines(self, seq): ...
-    def seek(self, offset, whence=...): ...
-    def tell(self): ...
-
-def open(filename, mode: str = ..., block_size: int = ..., encoding: str = ..., errors: str = ..., newline: str = ..., num_threads: int = 1) -> BZ3File: ...
-def compress(data: bytes, block_size: int = ..., num_threads: int = 1) -> bytes: ...
-def decompress(data: bytes, num_threads: int = 1) -> bytes: ...
-
-def libversion() -> str: ... # Get bzip3 version
-def bound(inp: int) -> int: ... # Return the recommended size of the output buffer for the compression functions.
-
-# High-level api
-# Compress a block of data into out buffer, zerocopy, both parameters accept objects which implements buffer-protocol.
-# out must be writabel, size of out must be at least equal to bound(len(inp))
-def compress_into(inp: Union[bytes, bytearray], out: bytearray) -> int: ...
-# Decompress a block of data into out buffer, zerocopy
-def decompress_into(inp: Union[bytes, bytearray], out: bytearray) -> int: ...
-```
-
-- Note, high-level api won't work with low-level api, see [this](https://github.com/kspalaiologos/bzip3/issues/70)
+Metadata-Version: 2.1
+Name: bzip3
+Version: 0.1.3rc1
+Summary: bz3 compress and decompress
+Home-page: https://github.com/synodriver/python-bz3
+Author: synodriver
+Author-email: diguohuangjiajinweijun@gmail.com
+License: BSD
+Keywords: bz3,compress,decompress
+Classifier: Development Status :: 3 - Alpha
+Classifier: Operating System :: OS Independent
+Classifier: License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)
+Classifier: Programming Language :: C
+Classifier: Programming Language :: Cython
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3.6
+Classifier: Programming Language :: Python :: 3.7
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: Implementation :: CPython
+Classifier: Programming Language :: Python :: Implementation :: PyPy
+Requires-Python: >=3.6
+Description-Content-Type: text/markdown
+
+<h1 align="center"><i>✨ python-bz3 ✨ </i></h1>
+
+<h3 align="center">The python binding for <a href="https://github.com/kspalaiologos/bzip3/tree/master">bzip3</a> with parallel support</h3>
+
+[![pypi](https://img.shields.io/pypi/v/bzip3.svg)](https://pypi.org/project/bzip3/)
+![python](https://img.shields.io/pypi/pyversions/bzip3)
+![implementation](https://img.shields.io/pypi/implementation/bzip3)
+![wheel](https://img.shields.io/pypi/wheel/bzip3)
+![license](https://img.shields.io/github/license/synodriver/python-bz3.svg)
+![action](https://img.shields.io/github/workflow/status/synodriver/python-bz3/build%20wheel)
+
+### install
+```bash
+pip install bzip3
+```
+
+
+### Usage
+```python
+from bz3 import compress_file, decompress_file, test_file, compress, decompress
+import bz3
+
+with open("test_inp.txt", "rb") as inp, open("compressed.bz3", "wb") as out:
+    compress_file(inp, out, 1000 * 1000)
+
+with open("compressed.bz3", "rb") as inp:
+    test_file(inp, True)    
+
+with open("compressed.bz3", "rb") as inp, open("output.txt", "wb") as out:
+    decompress_file(inp, out)
+
+print(decompress(compress(b"12121")))
+
+with bz3.open("test.bz3", "wt", encoding="utf-8", num_threads=4) as f:
+    f.write("test data")
+
+with bz3.open("test.bz3", "rt", encoding="utf-8", num_threads=4) as f:
+    print(f.read())
+```
+- use ```BZ3_USE_CFFI``` env var to specify a backend
+- ```num_threads``` is only available on cython backend which have openmp support
+
+### Public functions
+```python
+from typing import IO, Optional, Union
+
+def compress_file(input: IO, output: IO, block_size: int) -> None: ...
+def decompress_file(input: IO, output: IO) -> None: ...
+def recover_file(input: IO, output: IO) -> None: ...
+def test_file(input: IO, should_raise: bool = ...) -> bool: ...
+
+
+class BZ3File:
+    def __init__(self, filename, mode: str = ..., block_size: int = ..., num_threads: int = ..., ignore_error: bool = False) -> None: ...
+    def close(self) -> None: ...
+    @property
+    def closed(self): ...
+    def fileno(self): ...
+    def seekable(self): ...
+    def readable(self): ...
+    def writable(self): ...
+    def peek(self, n: int = ...): ...
+    def read(self, size: int = ...): ...
+    def read1(self, size: int = ...): ...
+    def readinto(self, b): ...
+    def readline(self, size: int = ...): ...
+    def readlines(self, size: int = ...): ...
+    def write(self, data): ...
+    def writelines(self, seq): ...
+    def seek(self, offset, whence=...): ...
+    def tell(self): ...
+
+def open(filename, mode: str = ..., block_size: int = ..., encoding: str = ..., errors: str = ..., newline: str = ..., num_threads: int = 1, ignore_error: bool = False) -> BZ3File: ...
+def compress(data: bytes, block_size: int = ..., num_threads: int = 1) -> bytes: ...
+def decompress(data: bytes, num_threads: int = 1) -> bytes: ...
+
+def libversion() -> str: ... # Get bzip3 version
+def bound(inp: int) -> int: ... # Return the recommended size of the output buffer for the compression functions.
+
+# High-level api
+# Compress a block of data into out buffer, zerocopy, both parameters accept objects which implements buffer-protocol.
+# out must be writabel, size of out must be at least equal to bound(len(inp))
+def compress_into(inp: Union[bytes, bytearray], out: bytearray) -> int: ...
+# Decompress a block of data into out buffer, zerocopy
+def decompress_into(inp: Union[bytes, bytearray], out: bytearray) -> int: ...
+```
+
+- Note, high-level api won't work with low-level api, see [this](https://github.com/kspalaiologos/bzip3/issues/70)
```

### Comparing `bzip3-0.1.2rc1/bzip3.egg-info/SOURCES.txt` & `bzip3-0.1.3rc1/bzip3.egg-info/SOURCES.txt`

 * *Files 26% similar despite different names*

```diff
@@ -1,36 +1,31 @@
 MANIFEST.in
 README.markdown
 setup.py
 ./dep/src/libbz3.c
 bz3/__init__.py
 bz3/bz3.py
 bz3/compression.py
-bz3/backends/cython/_bz3.c
-bz3/__pycache__/__init__.cpython-310.pyc
-bz3/__pycache__/bz3.cpython-310.pyc
-bz3/__pycache__/compression.cpython-310.pyc
 bz3/backends/__init__.py
-bz3/backends/__pycache__/__init__.cpython-310.pyc
 bz3/backends/cffi/__init__.py
-bz3/backends/cffi/_bz3.pyd
 bz3/backends/cffi/build.py
 bz3/backends/cython/__init__.py
 bz3/backends/cython/_bz3.c
 bz3/backends/cython/_bz3.pyx
 bz3/backends/cython/bzip3.pxd
-bz3/backends/cython/__pycache__/__init__.cpython-310.pyc
 bzip3.egg-info/PKG-INFO
 bzip3.egg-info/SOURCES.txt
 bzip3.egg-info/dependency_links.txt
 bzip3.egg-info/not-zip-safe
 bzip3.egg-info/requires.txt
 bzip3.egg-info/top_level.txt
 dep/include/common.h
 dep/include/getopt-shim.h
 dep/include/libbz3.h
 dep/include/libsais.h
 dep/src/libbz3.c
 dep/src/main.c
 test/test_compress.py
+test/test_mem.py
 test/test_omp.py
+test/test_seek.py
 test/test_thread.py
```

### Comparing `bzip3-0.1.2rc1/dep/include/common.h` & `bzip3-0.1.3rc1/dep/include/common.h`

 * *Files 10% similar despite different names*

```diff
@@ -1,125 +1,126 @@
-
-/*
- * BZip3 - A spiritual successor to BZip2.
- * Copyright (C) 2022 Kamila Szewczyk
- *
- * This program is free software: you can redistribute it and/or modify it
- * under the terms of the GNU Lesser General Public License as published by the Free
- * Software Foundation, either version 3 of the License, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU Lesser General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef _COMMON_H
-#define _COMMON_H
-
-#define KiB(x) ((x)*1024)
-#define MiB(x) ((x)*1024 * 1024)
-
-#include <inttypes.h>
-#include <stdint.h>
-
-typedef uint8_t u8;
-typedef uint16_t u16;
-typedef uint32_t u32;
-typedef uint64_t u64;
-
-typedef int8_t s8;
-typedef int16_t s16;
-typedef int32_t s32;
-
-static s32 read_neutral_s32(const u8 * data) {
-    return ((u32)data[0]) | (((u32)data[1]) << 8) | (((u32)data[2]) << 16) | (((u32)data[3]) << 24);
-}
-
-static void write_neutral_s32(u8 * data, s32 value) {
-    data[0] = value & 0xFF;
-    data[1] = (value >> 8) & 0xFF;
-    data[2] = (value >> 16) & 0xFF;
-    data[3] = (value >> 24) & 0xFF;
-}
-
-#if defined(__GNUC__) || defined(__clang__)
-    #define RESTRICT __restrict__
-#elif defined(_MSC_VER) || defined(__INTEL_COMPILER)
-    #define RESTRICT __restrict
-#else
-    #define RESTRICT restrict
-    #warning Your compiler, configuration or platform might not be supported.
-#endif
-
-#if defined(__has_builtin)
-    #if __has_builtin(__builtin_prefetch)
-        #define HAS_BUILTIN_PREFETCH
-    #endif
-#elif defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 2)) || (__GNUC__ >= 4))
-    #define HAS_BUILTIN_PREFETCH
-#endif
-
-#if defined(__has_builtin)
-    #if __has_builtin(__builtin_bswap16)
-        #define HAS_BUILTIN_BSWAP16
-    #endif
-#elif defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ >= 5))
-    #define HAS_BUILTIN_BSWAP16
-#endif
-
-#if defined(HAS_BUILTIN_PREFETCH)
-    #define prefetch(address) __builtin_prefetch((const void *)(address), 0, 0)
-    #define prefetchw(address) __builtin_prefetch((const void *)(address), 1, 0)
-#elif defined(_M_IX86) || defined(_M_AMD64) || defined(__x86_64__) || defined(i386) || defined(__i386__) || \
-    defined(__i386)
-    #include <intrin.h>
-    #define prefetch(address) _mm_prefetch((const void *)(address), _MM_HINT_NTA)
-    #define prefetchw(address) _m_prefetchw((const void *)(address))
-#elif defined(_M_ARM) || defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__) || defined(__ARM_ARCH_7R__) || \
-    defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7S__)
-    #include <intrin.h>
-    #define prefetch(address) __prefetch((const void *)(address))
-    #define prefetchw(address) __prefetchw((const void *)(address))
-#elif defined(_M_ARM64) || defined(__aarch64__)
-    #include <intrin.h>
-    #define prefetch(address) __prefetch2((const void *)(address), 1)
-    #define prefetchw(address) __prefetch2((const void *)(address), 17)
-#else
-    #error Your compiler, configuration or platform is not supported.
-#endif
-
-#if !defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)
-    #if defined(_LITTLE_ENDIAN) || (defined(BYTE_ORDER) && defined(LITTLE_ENDIAN) && BYTE_ORDER == LITTLE_ENDIAN) || \
-        (defined(_BYTE_ORDER) && defined(_LITTLE_ENDIAN) && _BYTE_ORDER == _LITTLE_ENDIAN) ||                        \
-        (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && __BYTE_ORDER == __LITTLE_ENDIAN) ||                    \
-        (defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
-        #define __LITTLE_ENDIAN__
-    #elif defined(_BIG_ENDIAN) || (defined(BYTE_ORDER) && defined(BIG_ENDIAN) && BYTE_ORDER == BIG_ENDIAN) || \
-        (defined(_BYTE_ORDER) && defined(_BIG_ENDIAN) && _BYTE_ORDER == _BIG_ENDIAN) ||                       \
-        (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && __BYTE_ORDER == __BIG_ENDIAN) ||                   \
-        (defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
-        #define __BIG_ENDIAN__
-    #elif defined(_WIN32)
-        #define __LITTLE_ENDIAN__
-    #endif
-#endif
-
-#if defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)
-    #if defined(HAS_BUILTIN_BSWAP16)
-        #define bswap16(x) (__builtin_bswap16(x))
-    #elif defined(_MSC_VER) && !defined(__INTEL_COMPILER)
-        #define bswap16(x) (_byteswap_ushort(x))
-    #else
-        #define bswap16(x) ((u16)(x >> 8) | (u16)(x << 8))
-    #endif
-#elif !defined(__LITTLE_ENDIAN__) && defined(__BIG_ENDIAN__)
-    #define bswap16(x) (x)
-#else
-    #error Your compiler, configuration or platform is not supported.
-#endif
-
-#endif
+
+/*
+ * BZip3 - A spiritual successor to BZip2.
+ * Copyright (C) 2022-2023 Kamila Szewczyk
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by the Free
+ * Software Foundation, either version 3 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _COMMON_H
+#define _COMMON_H
+
+#define KiB(x) ((x)*1024)
+#define MiB(x) ((x)*1024 * 1024)
+#define BWT_BOUND(x) ((x) + 128)
+
+#include <inttypes.h>
+#include <stdint.h>
+
+typedef uint8_t u8;
+typedef uint16_t u16;
+typedef uint32_t u32;
+typedef uint64_t u64;
+
+typedef int8_t s8;
+typedef int16_t s16;
+typedef int32_t s32;
+
+static s32 read_neutral_s32(const u8 * data) {
+    return ((u32)data[0]) | (((u32)data[1]) << 8) | (((u32)data[2]) << 16) | (((u32)data[3]) << 24);
+}
+
+static void write_neutral_s32(u8 * data, s32 value) {
+    data[0] = value & 0xFF;
+    data[1] = (value >> 8) & 0xFF;
+    data[2] = (value >> 16) & 0xFF;
+    data[3] = (value >> 24) & 0xFF;
+}
+
+#if defined(__GNUC__) || defined(__clang__)
+    #define RESTRICT __restrict__
+#elif defined(_MSC_VER) || defined(__INTEL_COMPILER)
+    #define RESTRICT __restrict
+#else
+    #define RESTRICT restrict
+    #warning Your compiler, configuration or platform might not be supported.
+#endif
+
+#if defined(__has_builtin)
+    #if __has_builtin(__builtin_prefetch)
+        #define HAS_BUILTIN_PREFETCH
+    #endif
+#elif defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 2)) || (__GNUC__ >= 4))
+    #define HAS_BUILTIN_PREFETCH
+#endif
+
+#if defined(__has_builtin)
+    #if __has_builtin(__builtin_bswap16)
+        #define HAS_BUILTIN_BSWAP16
+    #endif
+#elif defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ >= 5))
+    #define HAS_BUILTIN_BSWAP16
+#endif
+
+#if defined(HAS_BUILTIN_PREFETCH)
+    #define prefetch(address) __builtin_prefetch((const void *)(address), 0, 0)
+    #define prefetchw(address) __builtin_prefetch((const void *)(address), 1, 0)
+#elif defined(_M_IX86) || defined(_M_AMD64) || defined(__x86_64__) || defined(i386) || defined(__i386__) || \
+    defined(__i386)
+    #include <intrin.h>
+    #define prefetch(address) _mm_prefetch((const void *)(address), _MM_HINT_NTA)
+    #define prefetchw(address) _m_prefetchw((const void *)(address))
+#elif defined(_M_ARM) || defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__) || defined(__ARM_ARCH_7R__) || \
+    defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7S__)
+    #include <intrin.h>
+    #define prefetch(address) __prefetch((const void *)(address))
+    #define prefetchw(address) __prefetchw((const void *)(address))
+#elif defined(_M_ARM64) || defined(__aarch64__)
+    #include <intrin.h>
+    #define prefetch(address) __prefetch2((const void *)(address), 1)
+    #define prefetchw(address) __prefetch2((const void *)(address), 17)
+#else
+    #error Your compiler, configuration or platform is not supported.
+#endif
+
+#if !defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)
+    #if defined(_LITTLE_ENDIAN) || (defined(BYTE_ORDER) && defined(LITTLE_ENDIAN) && BYTE_ORDER == LITTLE_ENDIAN) || \
+        (defined(_BYTE_ORDER) && defined(_LITTLE_ENDIAN) && _BYTE_ORDER == _LITTLE_ENDIAN) ||                        \
+        (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && __BYTE_ORDER == __LITTLE_ENDIAN) ||                    \
+        (defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
+        #define __LITTLE_ENDIAN__
+    #elif defined(_BIG_ENDIAN) || (defined(BYTE_ORDER) && defined(BIG_ENDIAN) && BYTE_ORDER == BIG_ENDIAN) || \
+        (defined(_BYTE_ORDER) && defined(_BIG_ENDIAN) && _BYTE_ORDER == _BIG_ENDIAN) ||                       \
+        (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && __BYTE_ORDER == __BIG_ENDIAN) ||                   \
+        (defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
+        #define __BIG_ENDIAN__
+    #elif defined(_WIN32)
+        #define __LITTLE_ENDIAN__
+    #endif
+#endif
+
+#if defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)
+    #if defined(HAS_BUILTIN_BSWAP16)
+        #define bswap16(x) (__builtin_bswap16(x))
+    #elif defined(_MSC_VER) && !defined(__INTEL_COMPILER)
+        #define bswap16(x) (_byteswap_ushort(x))
+    #else
+        #define bswap16(x) ((u16)(x >> 8) | (u16)(x << 8))
+    #endif
+#elif !defined(__LITTLE_ENDIAN__) && defined(__BIG_ENDIAN__)
+    #define bswap16(x) (x)
+#else
+    #error Your compiler, configuration or platform is not supported.
+#endif
+
+#endif
```

### Comparing `bzip3-0.1.2rc1/dep/include/getopt-shim.h` & `bzip3-0.1.3rc1/dep/include/getopt-shim.h`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,236 +1,236 @@
-/*
-  Copyright 2005-2014 Rich Felker, et al.
-
-  Permission is hereby granted, free of charge, to any person obtaining
-  a copy of this software and associated documentation files (the
-  "Software"), to deal in the Software without restriction, including
-  without limitation the rights to use, copy, modify, merge, publish,
-  distribute, sublicense, and/or sell copies of the Software, and to
-  permit persons to whom the Software is furnished to do so, subject to
-  the following conditions:
-
-  The above copyright notice and this permission notice shall be
-  included in all copies or substantial portions of the Software.
-
-  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#ifndef _GETOPT_H
-#define _GETOPT_H
-
-#ifdef WIN32
-static void flockfile(FILE * f) { _lock_file(f); }
-static void funlockfile(FILE * f) { _unlock_file(f); }
-#endif
-
-int getopt(int, char * const[], const char *);
-extern char * optarg;
-extern int optind, opterr, optopt, optreset;
-
-struct option {
-    const char * name;
-    int has_arg;
-    int * flag;
-    int val;
-};
-
-int getopt_long(int, char * const *, const char *, const struct option *, int *);
-int getopt_long_only(int, char * const *, const char *, const struct option *, int *);
-
-#define no_argument 0
-#define required_argument 1
-#define optional_argument 2
-
-char * optarg;
-int optind = 1, opterr = 1, optopt, __optpos, optreset = 0;
-
-#define optpos __optpos
-
-static void __getopt_msg(const char * a, const char * b, const char * c, size_t l) {
-    FILE * f = stderr;
-    flockfile(f);
-    fputs(a, f) >= 0 && fwrite(b, strlen(b), 1, f) && fwrite(c, 1, l, f) == l && putc('\n', f);
-    funlockfile(f);
-}
-
-int getopt(int argc, char * const argv[], const char * optstring) {
-    int i, c, d;
-    int k, l;
-    char * optchar;
-
-    if (!optind || optreset) {
-        optreset = 0;
-        __optpos = 0;
-        optind = 1;
-    }
-
-    if (optind >= argc || !argv[optind]) return -1;
-
-    if (argv[optind][0] != '-') {
-        if (optstring[0] == '-') {
-            optarg = argv[optind++];
-            return 1;
-        }
-        return -1;
-    }
-
-    if (!argv[optind][1]) return -1;
-
-    if (argv[optind][1] == '-' && !argv[optind][2]) return optind++, -1;
-
-    if (!optpos) optpos++;
-    c = argv[optind][optpos], k = 1;
-    optchar = argv[optind] + optpos;
-    optopt = c;
-    optpos += k;
-
-    if (!argv[optind][optpos]) {
-        optind++;
-        optpos = 0;
-    }
-
-    if (optstring[0] == '-' || optstring[0] == '+') optstring++;
-
-    i = 0;
-    d = 0;
-    do {
-        d = optstring[i], l = 1;
-        if (l > 0)
-            i += l;
-        else
-            i++;
-    } while (l && d != c);
-
-    if (d != c) {
-        if (optstring[0] != ':' && opterr) __getopt_msg(argv[0], ": unrecognized option: ", optchar, k);
-        return '?';
-    }
-    if (optstring[i] == ':') {
-        if (optstring[i + 1] == ':')
-            optarg = 0;
-        else if (optind >= argc) {
-            if (optstring[0] == ':') return ':';
-            if (opterr) __getopt_msg(argv[0], ": option requires an argument: ", optchar, k);
-            return '?';
-        }
-        if (optstring[i + 1] != ':' || optpos) {
-            optarg = argv[optind++] + optpos;
-            optpos = 0;
-        }
-    }
-    return c;
-}
-
-static void permute(char * const * argv, int dest, int src) {
-    char ** av = (char **)argv;
-    char * tmp = av[src];
-    int i;
-    for (i = src; i > dest; i--) av[i] = av[i - 1];
-    av[dest] = tmp;
-}
-
-static int __getopt_long_core(int argc, char * const * argv, const char * optstring, const struct option * longopts,
-                              int * idx, int longonly) {
-    optarg = 0;
-    if (longopts && argv[optind][0] == '-' &&
-        ((longonly && argv[optind][1] && argv[optind][1] != '-') || (argv[optind][1] == '-' && argv[optind][2]))) {
-        int colon = optstring[optstring[0] == '+' || optstring[0] == '-'] == ':';
-        int i, cnt, match;
-        char * opt;
-        for (cnt = i = 0; longopts[i].name; i++) {
-            const char * name = longopts[i].name;
-            opt = argv[optind] + 1;
-            if (*opt == '-') opt++;
-            for (; *name && *name == *opt; name++, opt++)
-                ;
-            if (*opt && *opt != '=') continue;
-            match = i;
-            if (!*name) {
-                cnt = 1;
-                break;
-            }
-            cnt++;
-        }
-        if (cnt == 1) {
-            i = match;
-            optind++;
-            optopt = longopts[i].val;
-            if (*opt == '=') {
-                if (!longopts[i].has_arg) {
-                    if (colon || !opterr) return '?';
-                    __getopt_msg(argv[0], ": option does not take an argument: ", longopts[i].name,
-                                 strlen(longopts[i].name));
-                    return '?';
-                }
-                optarg = opt + 1;
-            } else if (longopts[i].has_arg == required_argument) {
-                if (!(optarg = argv[optind])) {
-                    if (colon) return ':';
-                    if (!opterr) return '?';
-                    __getopt_msg(argv[0], ": option requires an argument: ", longopts[i].name,
-                                 strlen(longopts[i].name));
-                    return '?';
-                }
-                optind++;
-            }
-            if (idx) *idx = i;
-            if (longopts[i].flag) {
-                *longopts[i].flag = longopts[i].val;
-                return 0;
-            }
-            return longopts[i].val;
-        }
-        if (argv[optind][1] == '-') {
-            if (!colon && opterr)
-                __getopt_msg(argv[0], cnt ? ": option is ambiguous: " : ": unrecognized option: ", argv[optind] + 2,
-                             strlen(argv[optind] + 2));
-            optind++;
-            return '?';
-        }
-    }
-    return getopt(argc, argv, optstring);
-}
-
-static int __getopt_long(int argc, char * const * argv, const char * optstring, const struct option * longopts,
-                         int * idx, int longonly) {
-    int ret, skipped, resumed;
-    if (!optind || optreset) {
-        optreset = 0;
-        __optpos = 0;
-        optind = 1;
-    }
-    if (optind >= argc || !argv[optind]) return -1;
-    skipped = optind;
-    if (optstring[0] != '+' && optstring[0] != '-') {
-        int i;
-        for (i = optind;; i++) {
-            if (i >= argc || !argv[i]) return -1;
-            if (argv[i][0] == '-' && argv[i][1]) break;
-        }
-        optind = i;
-    }
-    resumed = optind;
-    ret = __getopt_long_core(argc, argv, optstring, longopts, idx, longonly);
-    if (resumed > skipped) {
-        int i, cnt = optind - resumed;
-        for (i = 0; i < cnt; i++) permute(argv, skipped, optind - 1);
-        optind = skipped + cnt;
-    }
-    return ret;
-}
-
-int getopt_long(int argc, char * const * argv, const char * optstring, const struct option * longopts, int * idx) {
-    return __getopt_long(argc, argv, optstring, longopts, idx, 0);
-}
-
-int getopt_long_only(int argc, char * const * argv, const char * optstring, const struct option * longopts, int * idx) {
-    return __getopt_long(argc, argv, optstring, longopts, idx, 1);
-}
-
-#endif
+/*
+  Copyright 2005-2014 Rich Felker, et al.
+
+  Permission is hereby granted, free of charge, to any person obtaining
+  a copy of this software and associated documentation files (the
+  "Software"), to deal in the Software without restriction, including
+  without limitation the rights to use, copy, modify, merge, publish,
+  distribute, sublicense, and/or sell copies of the Software, and to
+  permit persons to whom the Software is furnished to do so, subject to
+  the following conditions:
+
+  The above copyright notice and this permission notice shall be
+  included in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/
+
+#ifndef _GETOPT_H
+#define _GETOPT_H
+
+#ifdef WIN32
+static void flockfile(FILE * f) { _lock_file(f); }
+static void funlockfile(FILE * f) { _unlock_file(f); }
+#endif
+
+int getopt(int, char * const[], const char *);
+extern char * optarg;
+extern int optind, opterr, optopt, optreset;
+
+struct option {
+    const char * name;
+    int has_arg;
+    int * flag;
+    int val;
+};
+
+int getopt_long(int, char * const *, const char *, const struct option *, int *);
+int getopt_long_only(int, char * const *, const char *, const struct option *, int *);
+
+#define no_argument 0
+#define required_argument 1
+#define optional_argument 2
+
+char * optarg;
+int optind = 1, opterr = 1, optopt, __optpos, optreset = 0;
+
+#define optpos __optpos
+
+static void __getopt_msg(const char * a, const char * b, const char * c, size_t l) {
+    FILE * f = stderr;
+    flockfile(f);
+    fputs(a, f) >= 0 && fwrite(b, strlen(b), 1, f) && fwrite(c, 1, l, f) == l && putc('\n', f);
+    funlockfile(f);
+}
+
+int getopt(int argc, char * const argv[], const char * optstring) {
+    int i, c, d;
+    int k, l;
+    char * optchar;
+
+    if (!optind || optreset) {
+        optreset = 0;
+        __optpos = 0;
+        optind = 1;
+    }
+
+    if (optind >= argc || !argv[optind]) return -1;
+
+    if (argv[optind][0] != '-') {
+        if (optstring[0] == '-') {
+            optarg = argv[optind++];
+            return 1;
+        }
+        return -1;
+    }
+
+    if (!argv[optind][1]) return -1;
+
+    if (argv[optind][1] == '-' && !argv[optind][2]) return optind++, -1;
+
+    if (!optpos) optpos++;
+    c = argv[optind][optpos], k = 1;
+    optchar = argv[optind] + optpos;
+    optopt = c;
+    optpos += k;
+
+    if (!argv[optind][optpos]) {
+        optind++;
+        optpos = 0;
+    }
+
+    if (optstring[0] == '-' || optstring[0] == '+') optstring++;
+
+    i = 0;
+    d = 0;
+    do {
+        d = optstring[i], l = 1;
+        if (l > 0)
+            i += l;
+        else
+            i++;
+    } while (l && d != c);
+
+    if (d != c) {
+        if (optstring[0] != ':' && opterr) __getopt_msg(argv[0], ": unrecognized option: ", optchar, k);
+        return '?';
+    }
+    if (optstring[i] == ':') {
+        if (optstring[i + 1] == ':')
+            optarg = 0;
+        else if (optind >= argc) {
+            if (optstring[0] == ':') return ':';
+            if (opterr) __getopt_msg(argv[0], ": option requires an argument: ", optchar, k);
+            return '?';
+        }
+        if (optstring[i + 1] != ':' || optpos) {
+            optarg = argv[optind++] + optpos;
+            optpos = 0;
+        }
+    }
+    return c;
+}
+
+static void permute(char * const * argv, int dest, int src) {
+    char ** av = (char **)argv;
+    char * tmp = av[src];
+    int i;
+    for (i = src; i > dest; i--) av[i] = av[i - 1];
+    av[dest] = tmp;
+}
+
+static int __getopt_long_core(int argc, char * const * argv, const char * optstring, const struct option * longopts,
+                              int * idx, int longonly) {
+    optarg = 0;
+    if (longopts && argv[optind][0] == '-' &&
+        ((longonly && argv[optind][1] && argv[optind][1] != '-') || (argv[optind][1] == '-' && argv[optind][2]))) {
+        int colon = optstring[optstring[0] == '+' || optstring[0] == '-'] == ':';
+        int i, cnt, match;
+        char * opt;
+        for (cnt = i = 0; longopts[i].name; i++) {
+            const char * name = longopts[i].name;
+            opt = argv[optind] + 1;
+            if (*opt == '-') opt++;
+            for (; *name && *name == *opt; name++, opt++)
+                ;
+            if (*opt && *opt != '=') continue;
+            match = i;
+            if (!*name) {
+                cnt = 1;
+                break;
+            }
+            cnt++;
+        }
+        if (cnt == 1) {
+            i = match;
+            optind++;
+            optopt = longopts[i].val;
+            if (*opt == '=') {
+                if (!longopts[i].has_arg) {
+                    if (colon || !opterr) return '?';
+                    __getopt_msg(argv[0], ": option does not take an argument: ", longopts[i].name,
+                                 strlen(longopts[i].name));
+                    return '?';
+                }
+                optarg = opt + 1;
+            } else if (longopts[i].has_arg == required_argument) {
+                if (!(optarg = argv[optind])) {
+                    if (colon) return ':';
+                    if (!opterr) return '?';
+                    __getopt_msg(argv[0], ": option requires an argument: ", longopts[i].name,
+                                 strlen(longopts[i].name));
+                    return '?';
+                }
+                optind++;
+            }
+            if (idx) *idx = i;
+            if (longopts[i].flag) {
+                *longopts[i].flag = longopts[i].val;
+                return 0;
+            }
+            return longopts[i].val;
+        }
+        if (argv[optind][1] == '-') {
+            if (!colon && opterr)
+                __getopt_msg(argv[0], cnt ? ": option is ambiguous: " : ": unrecognized option: ", argv[optind] + 2,
+                             strlen(argv[optind] + 2));
+            optind++;
+            return '?';
+        }
+    }
+    return getopt(argc, argv, optstring);
+}
+
+static int __getopt_long(int argc, char * const * argv, const char * optstring, const struct option * longopts,
+                         int * idx, int longonly) {
+    int ret, skipped, resumed;
+    if (!optind || optreset) {
+        optreset = 0;
+        __optpos = 0;
+        optind = 1;
+    }
+    if (optind >= argc || !argv[optind]) return -1;
+    skipped = optind;
+    if (optstring[0] != '+' && optstring[0] != '-') {
+        int i;
+        for (i = optind;; i++) {
+            if (i >= argc || !argv[i]) return -1;
+            if (argv[i][0] == '-' && argv[i][1]) break;
+        }
+        optind = i;
+    }
+    resumed = optind;
+    ret = __getopt_long_core(argc, argv, optstring, longopts, idx, longonly);
+    if (resumed > skipped) {
+        int i, cnt = optind - resumed;
+        for (i = 0; i < cnt; i++) permute(argv, skipped, optind - 1);
+        optind = skipped + cnt;
+    }
+    return ret;
+}
+
+int getopt_long(int argc, char * const * argv, const char * optstring, const struct option * longopts, int * idx) {
+    return __getopt_long(argc, argv, optstring, longopts, idx, 0);
+}
+
+int getopt_long_only(int argc, char * const * argv, const char * optstring, const struct option * longopts, int * idx) {
+    return __getopt_long(argc, argv, optstring, longopts, idx, 1);
+}
+
+#endif
```

### Comparing `bzip3-0.1.2rc1/dep/include/libbz3.h` & `bzip3-0.1.3rc1/dep/include/libbz3.h`

 * *Files 14% similar despite different names*

```diff
@@ -1,144 +1,144 @@
-
-/*
- * BZip3 - A spiritual successor to BZip2.
- * Copyright (C) 2022 Kamila Szewczyk
- *
- * This program is free software: you can redistribute it and/or modify it
- * under the terms of the GNU Lesser General Public License as published by the Free
- * Software Foundation, either version 3 of the License, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU Lesser General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef _LIBBZ3_H
-#define _LIBBZ3_H
-
-#include <stddef.h>
-#include <stdint.h>
-
-/* Symbol visibility control. */
-#ifndef BZIP3_VISIBLE
-    #if defined(__GNUC__) && (__GNUC__ >= 4) && !defined(__MINGW32__)
-        #define BZIP3_VISIBLE __attribute__((visibility("default")))
-    #else
-        #define BZIP3_VISIBLE
-    #endif
-#endif
-
-#if defined(BZIP3_DLL_EXPORT) && (BZIP3_DLL_EXPORT == 1)
-    #define BZIP3_API __declspec(dllexport) BZIP3_VISIBLE
-#elif defined(BZIP3_DLL_IMPORT) && (BZIP3_DLL_IMPORT == 1)
-    #define BZIP3_API __declspec(dllimport) BZIP3_VISIBLE
-#else
-    #define BZIP3_API BZIP3_VISIBLE
-#endif
-
-#define BZ3_OK 0
-#define BZ3_ERR_OUT_OF_BOUNDS -1
-#define BZ3_ERR_BWT -2
-#define BZ3_ERR_CRC -3
-#define BZ3_ERR_MALFORMED_HEADER -4
-#define BZ3_ERR_TRUNCATED_DATA -5
-#define BZ3_ERR_DATA_TOO_BIG -6
-#define BZ3_ERR_INIT -7
-
-struct bz3_state;
-
-/**
- * @brief Get bzip3 version.
- */
-BZIP3_API const char * bz3_version(void);
-
-/**
- * @brief Get the last error number associated with a given state.
- */
-BZIP3_API int8_t bz3_last_error(struct bz3_state * state);
-
-/**
- * @brief Return a user-readable message explaining the cause of the last error.
- */
-BZIP3_API const char * bz3_strerror(struct bz3_state * state);
-
-/**
- * @brief Construct a new block encoder state, which will encode blocks as big as the given block size.
- * The decoder will be able to decode blocks at most as big as the given block size.
- * Returns NULL in case allocation fails or the block size is not between 65K and 511M
- */
-BZIP3_API struct bz3_state * bz3_new(int32_t block_size);
-
-/**
- * @brief Free the memory occupied by a block encoder state.
- */
-BZIP3_API void bz3_free(struct bz3_state * state);
-
-/**
- * @brief Return the recommended size of the output buffer for the compression functions.
- */
-BZIP3_API size_t bz3_bound(size_t input_size);
-
-/* ** HIGH LEVEL APIs ** */
-
-/**
- * @brief Compress a block of data. This function does not support parallelism
- * by itself, consider using the low level `bz3_encode_blocks()` function instead.
- * Using the low level API might provide better performance.
- * Returns a bzip3 error code; BZ3_OK when the operation is successful.
- * Make sure to set out_size to the size of the output buffer before the operation;
- * out_size must be at least equal to `bz3_bound(in_size)'.
- */
-BZIP3_API int bz3_compress(uint32_t block_size, const uint8_t * in, uint8_t * out, size_t in_size, size_t * out_size);
-
-/**
- * @brief Decompress a block of data. This function does not support parallelism
- * by itself, consider using the low level `bz3_decode_blocks()` function instead.
- * Using the low level API might provide better performance.
- * Returns a bzip3 error code; BZ3_OK when the operation is successful.
- * Make sure to set out_size to the size of the output buffer before the operation.
- */
-BZIP3_API int bz3_decompress(const uint8_t * in, uint8_t * out, size_t in_size, size_t * out_size);
-
-/* ** LOW LEVEL APIs ** */
-
-/**
- * @brief Encode a single block. Returns the amount of bytes written to `buffer'.
- * `buffer' must be able to hold at least `bz3_bound(size)' bytes. The size must not
- * exceed the block size associated with the state.
- */
-BZIP3_API int32_t bz3_encode_block(struct bz3_state * state, uint8_t * buffer, int32_t size);
-
-/**
- * @brief Decode a single block.
- * `buffer' must be able to hold at least `orig_size' bytes. The size must not exceed the block size
- * associated with the state.
- * @param size The size of the compressed data in `buffer'
- * @param orig_size The original size of the data before compression.
- */
-BZIP3_API int32_t bz3_decode_block(struct bz3_state * state, uint8_t * buffer, int32_t size, int32_t orig_size);
-
-/**
- * @brief Encode `n' blocks, all in parallel.
- * All specifics of the `bz3_encode_block' still hold. The function will launch a thread for each block.
- * The compressed sizes are written to the `sizes' array. Every buffer is overwritten and none of them can overlap.
- * Precisely `n' states, buffers and sizes must be supplied.
- *
- * Expects `n' between 2 and 16.
- *
- * Present in the shared library only if -lpthread was present during building.
- */
-BZIP3_API void bz3_encode_blocks(struct bz3_state * states[], uint8_t * buffers[], int32_t sizes[], int32_t n);
-
-/**
- * @brief Decode `n' blocks, all in parallel.
- * Same specifics as `bz3_encode_blocks', but doesn't overwrite `sizes'.
- */
-BZIP3_API void bz3_decode_blocks(struct bz3_state * states[], uint8_t * buffers[], int32_t sizes[],
-                                 int32_t orig_sizes[], int32_t n);
-
-#endif
+
+/*
+ * BZip3 - A spiritual successor to BZip2.
+ * Copyright (C) 2022-2023 Kamila Szewczyk
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by the Free
+ * Software Foundation, either version 3 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef LIBBZ3_H
+#define LIBBZ3_H
+
+#include <stddef.h>
+#include <stdint.h>
+
+/* Symbol visibility control. */
+#ifndef BZIP3_VISIBLE
+    #if defined(__GNUC__) && (__GNUC__ >= 4) && !defined(__MINGW32__)
+        #define BZIP3_VISIBLE __attribute__((visibility("default")))
+    #else
+        #define BZIP3_VISIBLE
+    #endif
+#endif
+
+#if defined(BZIP3_DLL_EXPORT) && (BZIP3_DLL_EXPORT == 1)
+    #define BZIP3_API __declspec(dllexport) BZIP3_VISIBLE
+#elif defined(BZIP3_DLL_IMPORT) && (BZIP3_DLL_IMPORT == 1)
+    #define BZIP3_API __declspec(dllimport) BZIP3_VISIBLE
+#else
+    #define BZIP3_API BZIP3_VISIBLE
+#endif
+
+#define BZ3_OK 0
+#define BZ3_ERR_OUT_OF_BOUNDS -1
+#define BZ3_ERR_BWT -2
+#define BZ3_ERR_CRC -3
+#define BZ3_ERR_MALFORMED_HEADER -4
+#define BZ3_ERR_TRUNCATED_DATA -5
+#define BZ3_ERR_DATA_TOO_BIG -6
+#define BZ3_ERR_INIT -7
+
+struct bz3_state;
+
+/**
+ * @brief Get bzip3 version.
+ */
+BZIP3_API const char * bz3_version(void);
+
+/**
+ * @brief Get the last error number associated with a given state.
+ */
+BZIP3_API int8_t bz3_last_error(struct bz3_state * state);
+
+/**
+ * @brief Return a user-readable message explaining the cause of the last error.
+ */
+BZIP3_API const char * bz3_strerror(struct bz3_state * state);
+
+/**
+ * @brief Construct a new block encoder state, which will encode blocks as big as the given block size.
+ * The decoder will be able to decode blocks at most as big as the given block size.
+ * Returns NULL in case allocation fails or the block size is not between 65K and 511M
+ */
+BZIP3_API struct bz3_state * bz3_new(int32_t block_size);
+
+/**
+ * @brief Free the memory occupied by a block encoder state.
+ */
+BZIP3_API void bz3_free(struct bz3_state * state);
+
+/**
+ * @brief Return the recommended size of the output buffer for the compression functions.
+ */
+BZIP3_API size_t bz3_bound(size_t input_size);
+
+/* ** HIGH LEVEL APIs ** */
+
+/**
+ * @brief Compress a block of data. This function does not support parallelism
+ * by itself, consider using the low level `bz3_encode_blocks()` function instead.
+ * Using the low level API might provide better performance.
+ * Returns a bzip3 error code; BZ3_OK when the operation is successful.
+ * Make sure to set out_size to the size of the output buffer before the operation;
+ * out_size must be at least equal to `bz3_bound(in_size)'.
+ */
+BZIP3_API int bz3_compress(uint32_t block_size, const uint8_t * in, uint8_t * out, size_t in_size, size_t * out_size);
+
+/**
+ * @brief Decompress a block of data. This function does not support parallelism
+ * by itself, consider using the low level `bz3_decode_blocks()` function instead.
+ * Using the low level API might provide better performance.
+ * Returns a bzip3 error code; BZ3_OK when the operation is successful.
+ * Make sure to set out_size to the size of the output buffer before the operation.
+ */
+BZIP3_API int bz3_decompress(const uint8_t * in, uint8_t * out, size_t in_size, size_t * out_size);
+
+/* ** LOW LEVEL APIs ** */
+
+/**
+ * @brief Encode a single block. Returns the amount of bytes written to `buffer'.
+ * `buffer' must be able to hold at least `bz3_bound(size)' bytes. The size must not
+ * exceed the block size associated with the state.
+ */
+BZIP3_API int32_t bz3_encode_block(struct bz3_state * state, uint8_t * buffer, int32_t size);
+
+/**
+ * @brief Decode a single block.
+ * `buffer' must be able to hold at least `orig_size' bytes. The size must not exceed the block size
+ * associated with the state.
+ * @param size The size of the compressed data in `buffer'
+ * @param orig_size The original size of the data before compression.
+ */
+BZIP3_API int32_t bz3_decode_block(struct bz3_state * state, uint8_t * buffer, int32_t size, int32_t orig_size);
+
+/**
+ * @brief Encode `n' blocks, all in parallel.
+ * All specifics of the `bz3_encode_block' still hold. The function will launch a thread for each block.
+ * The compressed sizes are written to the `sizes' array. Every buffer is overwritten and none of them can overlap.
+ * Precisely `n' states, buffers and sizes must be supplied.
+ *
+ * Expects `n' between 2 and 16.
+ *
+ * Present in the shared library only if -lpthread was present during building.
+ */
+BZIP3_API void bz3_encode_blocks(struct bz3_state * states[], uint8_t * buffers[], int32_t sizes[], int32_t n);
+
+/**
+ * @brief Decode `n' blocks, all in parallel.
+ * Same specifics as `bz3_encode_blocks', but doesn't overwrite `sizes'.
+ */
+BZIP3_API void bz3_decode_blocks(struct bz3_state * states[], uint8_t * buffers[], int32_t sizes[],
+                                 int32_t orig_sizes[], int32_t n);
+
+#endif
```

### Comparing `bzip3-0.1.2rc1/dep/include/libsais.h` & `bzip3-0.1.3rc1/dep/include/libsais.h`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,5428 +1,5428 @@
-/*--
-
-This file is a part of libsais, a library for linear time suffix array,
-longest common prefix array and burrows wheeler transform construction.
-
-   Copyright (c) 2021-2022 Ilya Grebnov <ilya.grebnov@gmail.com>
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
-Please see the file LICENSE for full copyright information.
-
-The stability patches that fix undefined behaviour in unbwt routines:
-
-   Copyright (c) 2022 Kamila Szewczyk <kspalaiologos@gmail.com>
-
-   Licensed under the same license as the original software.
-
---*/
-
-#ifndef LIBSAIS_H
-#define LIBSAIS_H
-
-#include "common.h"
-
-/* libsais source code amalgamate. */
-
-#include <limits.h>
-#include <stddef.h>
-#include <stdint.h>
-#include <stdlib.h>
-#include <string.h>
-
-#define UNUSED(_x) (void)(_x)
-
-typedef s32 sa_sint_t;
-typedef u32 sa_uint_t;
-typedef ptrdiff_t fast_sint_t;
-typedef size_t fast_uint_t;
-
-#define SAINT_BIT (32)
-#define SAINT_MAX INT32_MAX
-#define SAINT_MIN INT32_MIN
-
-#define ALPHABET_SIZE (1 << CHAR_BIT)
-#define UNBWT_FASTBITS (17)
-
-#define SUFFIX_GROUP_BIT (SAINT_BIT - 1)
-#define SUFFIX_GROUP_MARKER (((sa_sint_t)1) << (SUFFIX_GROUP_BIT - 1))
-
-#define BUCKETS_INDEX2(_c, _s) (((_c) << 1) + (_s))
-#define BUCKETS_INDEX4(_c, _s) (((_c) << 2) + (_s))
-
-#define LIBSAIS_PER_THREAD_CACHE_SIZE (24576)
-
-typedef struct LIBSAIS_THREAD_CACHE {
-    sa_sint_t symbol;
-    sa_sint_t index;
-} LIBSAIS_THREAD_CACHE;
-
-typedef union LIBSAIS_THREAD_STATE {
-    struct {
-        fast_sint_t position;
-        fast_sint_t count;
-
-        fast_sint_t m;
-        fast_sint_t last_lms_suffix;
-
-        sa_sint_t * buckets;
-        LIBSAIS_THREAD_CACHE * cache;
-    } state;
-
-    u8 padding[64];
-} LIBSAIS_THREAD_STATE;
-
-typedef struct LIBSAIS_CONTEXT {
-    sa_sint_t * buckets;
-    LIBSAIS_THREAD_STATE * thread_state;
-    fast_sint_t threads;
-} LIBSAIS_CONTEXT;
-
-typedef struct LIBSAIS_UNBWT_CONTEXT {
-    sa_uint_t * bucket2;
-    u16 * fastbits;
-    sa_uint_t * buckets;
-    fast_sint_t threads;
-} LIBSAIS_UNBWT_CONTEXT;
-
-static void * libsais_align_up(const void * address, size_t alignment) {
-    return (void *)((((ptrdiff_t)address) + ((ptrdiff_t)alignment) - 1) & (-((ptrdiff_t)alignment)));
-}
-
-static void * libsais_alloc_aligned(size_t size, size_t alignment) {
-    void * address = malloc(size + sizeof(short) + alignment - 1);
-    if (address != NULL) {
-        void * aligned_address = libsais_align_up((void *)((ptrdiff_t)address + (ptrdiff_t)(sizeof(short))), alignment);
-        ((short *)aligned_address)[-1] = (short)((ptrdiff_t)aligned_address - (ptrdiff_t)address);
-
-        return aligned_address;
-    }
-
-    return NULL;
-}
-
-static void libsais_free_aligned(void * aligned_address) {
-    if (aligned_address != NULL) {
-        free((void *)((ptrdiff_t)aligned_address - ((short *)aligned_address)[-1]));
-    }
-}
-
-static LIBSAIS_THREAD_STATE * libsais_alloc_thread_state(sa_sint_t threads) {
-    LIBSAIS_THREAD_STATE * RESTRICT thread_state =
-        (LIBSAIS_THREAD_STATE *)libsais_alloc_aligned((size_t)threads * sizeof(LIBSAIS_THREAD_STATE), 4096);
-    sa_sint_t * RESTRICT thread_buckets =
-        (sa_sint_t *)libsais_alloc_aligned((size_t)threads * 4 * ALPHABET_SIZE * sizeof(sa_sint_t), 4096);
-    LIBSAIS_THREAD_CACHE * RESTRICT thread_cache = (LIBSAIS_THREAD_CACHE *)libsais_alloc_aligned(
-        (size_t)threads * LIBSAIS_PER_THREAD_CACHE_SIZE * sizeof(LIBSAIS_THREAD_CACHE), 4096);
-
-    if (thread_state != NULL && thread_buckets != NULL && thread_cache != NULL) {
-        fast_sint_t t;
-        for (t = 0; t < threads; ++t) {
-            thread_state[t].state.buckets = thread_buckets;
-            thread_buckets += 4 * ALPHABET_SIZE;
-            thread_state[t].state.cache = thread_cache;
-            thread_cache += LIBSAIS_PER_THREAD_CACHE_SIZE;
-        }
-
-        return thread_state;
-    }
-
-    libsais_free_aligned(thread_cache);
-    libsais_free_aligned(thread_buckets);
-    libsais_free_aligned(thread_state);
-    return NULL;
-}
-
-static void libsais_free_thread_state(LIBSAIS_THREAD_STATE * thread_state) {
-    if (thread_state != NULL) {
-        libsais_free_aligned(thread_state[0].state.cache);
-        libsais_free_aligned(thread_state[0].state.buckets);
-        libsais_free_aligned(thread_state);
-    }
-}
-
-static LIBSAIS_CONTEXT * libsais_create_ctx_main(sa_sint_t threads) {
-    LIBSAIS_CONTEXT * RESTRICT ctx = (LIBSAIS_CONTEXT *)libsais_alloc_aligned(sizeof(LIBSAIS_CONTEXT), 64);
-    sa_sint_t * RESTRICT buckets = (sa_sint_t *)libsais_alloc_aligned(8 * ALPHABET_SIZE * sizeof(sa_sint_t), 4096);
-    LIBSAIS_THREAD_STATE * RESTRICT thread_state = threads > 1 ? libsais_alloc_thread_state(threads) : NULL;
-
-    if (ctx != NULL && buckets != NULL && (thread_state != NULL || threads == 1)) {
-        ctx->buckets = buckets;
-        ctx->threads = threads;
-        ctx->thread_state = thread_state;
-
-        return ctx;
-    }
-
-    libsais_free_thread_state(thread_state);
-    libsais_free_aligned(buckets);
-    libsais_free_aligned(ctx);
-    return NULL;
-}
-
-static void libsais_free_ctx_main(LIBSAIS_CONTEXT * ctx) {
-    if (ctx != NULL) {
-        libsais_free_thread_state(ctx->thread_state);
-        libsais_free_aligned(ctx->buckets);
-        libsais_free_aligned(ctx);
-    }
-}
-static void libsais_gather_lms_suffixes_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n, fast_sint_t m,
-                                           fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
-    if (omp_block_size > 0) {
-        const fast_sint_t prefetch_distance = 128;
-
-        fast_sint_t i, j = omp_block_start + omp_block_size, c0 = T[omp_block_start + omp_block_size - 1], c1 = -1;
-
-        while (j < n && (c1 = T[j]) == c0) {
-            ++j;
-        }
-
-        fast_uint_t s = c0 >= c1;
-
-        for (i = omp_block_start + omp_block_size - 2, j = omp_block_start + 3; i >= j; i -= 4) {
-            prefetch(&T[i - prefetch_distance]);
-
-            c1 = T[i - 0];
-            s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i + 1);
-            m -= ((s & 3) == 1);
-            c0 = T[i - 1];
-            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i - 0);
-            m -= ((s & 3) == 1);
-            c1 = T[i - 2];
-            s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i - 1);
-            m -= ((s & 3) == 1);
-            c0 = T[i - 3];
-            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i - 2);
-            m -= ((s & 3) == 1);
-        }
-
-        for (j -= 3; i >= j; i -= 1) {
-            c1 = c0;
-            c0 = T[i];
-            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i + 1);
-            m -= ((s & 3) == 1);
-        }
-
-        SA[m] = (sa_sint_t)(i + 1);
-    }
-}
-
-static void libsais_gather_lms_suffixes_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                               sa_sint_t threads, LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    {
-        (void)(threads);
-        (void)(thread_state);
-
-        fast_sint_t omp_thread_num = 0;
-        fast_sint_t omp_num_threads = 1;
-
-        fast_sint_t omp_block_stride = (n / omp_num_threads) & (-16);
-        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
-        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : n - omp_block_start;
-
-        if (omp_num_threads == 1) {
-            libsais_gather_lms_suffixes_8u(T, SA, n, (fast_sint_t)n - 1, omp_block_start, omp_block_size);
-        }
-    }
-}
-
-static sa_sint_t libsais_gather_lms_suffixes_32s(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n) {
-    const fast_sint_t prefetch_distance = 32;
-
-    sa_sint_t i = n - 2;
-    sa_sint_t m = n - 1;
-    fast_uint_t s = 1;
-    fast_sint_t c0 = T[n - 1];
-    fast_sint_t c1 = 0;
-
-    for (; i >= 3; i -= 4) {
-        prefetch(&T[i - prefetch_distance]);
-
-        c1 = T[i - 0];
-        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-        SA[m] = i + 1;
-        m -= ((s & 3) == 1);
-        c0 = T[i - 1];
-        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-        SA[m] = i - 0;
-        m -= ((s & 3) == 1);
-        c1 = T[i - 2];
-        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-        SA[m] = i - 1;
-        m -= ((s & 3) == 1);
-        c0 = T[i - 3];
-        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-        SA[m] = i - 2;
-        m -= ((s & 3) == 1);
-    }
-
-    for (; i >= 0; i -= 1) {
-        c1 = c0;
-        c0 = T[i];
-        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-        SA[m] = i + 1;
-        m -= ((s & 3) == 1);
-    }
-
-    return n - 1 - m;
-}
-
-static sa_sint_t libsais_gather_compacted_lms_suffixes_32s(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                           sa_sint_t n) {
-    const fast_sint_t prefetch_distance = 32;
-
-    sa_sint_t i = n - 2;
-    sa_sint_t m = n - 1;
-    fast_uint_t s = 1;
-    fast_sint_t c0 = T[n - 1];
-    fast_sint_t c1 = 0;
-
-    for (; i >= 3; i -= 4) {
-        prefetch(&T[i - prefetch_distance]);
-
-        c1 = T[i - 0];
-        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-        SA[m] = i + 1;
-        m -= ((fast_sint_t)(s & 3) == (c0 >= 0));
-        c0 = T[i - 1];
-        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-        SA[m] = i - 0;
-        m -= ((fast_sint_t)(s & 3) == (c1 >= 0));
-        c1 = T[i - 2];
-        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-        SA[m] = i - 1;
-        m -= ((fast_sint_t)(s & 3) == (c0 >= 0));
-        c0 = T[i - 3];
-        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-        SA[m] = i - 2;
-        m -= ((fast_sint_t)(s & 3) == (c1 >= 0));
-    }
-
-    for (; i >= 0; i -= 1) {
-        c1 = c0;
-        c0 = T[i];
-        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-        SA[m] = i + 1;
-        m -= ((fast_sint_t)(s & 3) == (c1 >= 0));
-    }
-
-    return n - 1 - m;
-}
-static void libsais_count_lms_suffixes_32s_2k(const sa_sint_t * RESTRICT T, sa_sint_t n, sa_sint_t k,
-                                              sa_sint_t * RESTRICT buckets) {
-    const fast_sint_t prefetch_distance = 32;
-
-    memset(buckets, 0, 2 * (size_t)k * sizeof(sa_sint_t));
-
-    sa_sint_t i = n - 2;
-    fast_uint_t s = 1;
-    fast_sint_t c0 = T[n - 1];
-    fast_sint_t c1 = 0;
-
-    for (; i >= prefetch_distance + 3; i -= 4) {
-        prefetch(&T[i - 2 * prefetch_distance]);
-
-        prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 0], 0)]);
-        prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 1], 0)]);
-        prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 2], 0)]);
-        prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 3], 0)]);
-
-        c1 = T[i - 0];
-        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-        buckets[BUCKETS_INDEX2((fast_uint_t)c0, (s & 3) == 1)]++;
-
-        c0 = T[i - 1];
-        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-        buckets[BUCKETS_INDEX2((fast_uint_t)c1, (s & 3) == 1)]++;
-
-        c1 = T[i - 2];
-        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-        buckets[BUCKETS_INDEX2((fast_uint_t)c0, (s & 3) == 1)]++;
-
-        c0 = T[i - 3];
-        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-        buckets[BUCKETS_INDEX2((fast_uint_t)c1, (s & 3) == 1)]++;
-    }
-
-    for (; i >= 0; i -= 1) {
-        c1 = c0;
-        c0 = T[i];
-        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-        buckets[BUCKETS_INDEX2((fast_uint_t)c1, (s & 3) == 1)]++;
-    }
-
-    buckets[BUCKETS_INDEX2((fast_uint_t)c0, 0)]++;
-}
-static sa_sint_t libsais_count_and_gather_lms_suffixes_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                          sa_sint_t * RESTRICT buckets, fast_sint_t omp_block_start,
-                                                          fast_sint_t omp_block_size) {
-    memset(buckets, 0, 4 * ALPHABET_SIZE * sizeof(sa_sint_t));
-
-    fast_sint_t m = omp_block_start + omp_block_size - 1;
-
-    if (omp_block_size > 0) {
-        const fast_sint_t prefetch_distance = 128;
-
-        fast_sint_t i, j = m + 1, c0 = T[m], c1 = -1;
-
-        while (j < n && (c1 = T[j]) == c0) {
-            ++j;
-        }
-
-        fast_uint_t s = c0 >= c1;
-
-        for (i = m - 1, j = omp_block_start + 3; i >= j; i -= 4) {
-            prefetch(&T[i - prefetch_distance]);
-
-            c1 = T[i - 0];
-            s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i + 1);
-            m -= ((s & 3) == 1);
-            buckets[BUCKETS_INDEX4((fast_uint_t)c0, s & 3)]++;
-
-            c0 = T[i - 1];
-            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i - 0);
-            m -= ((s & 3) == 1);
-            buckets[BUCKETS_INDEX4((fast_uint_t)c1, s & 3)]++;
-
-            c1 = T[i - 2];
-            s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i - 1);
-            m -= ((s & 3) == 1);
-            buckets[BUCKETS_INDEX4((fast_uint_t)c0, s & 3)]++;
-
-            c0 = T[i - 3];
-            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i - 2);
-            m -= ((s & 3) == 1);
-            buckets[BUCKETS_INDEX4((fast_uint_t)c1, s & 3)]++;
-        }
-
-        for (j -= 3; i >= j; i -= 1) {
-            c1 = c0;
-            c0 = T[i];
-            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i + 1);
-            m -= ((s & 3) == 1);
-            buckets[BUCKETS_INDEX4((fast_uint_t)c1, s & 3)]++;
-        }
-
-        c1 = (i >= 0) ? T[i] : -1;
-        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-        SA[m] = (sa_sint_t)(i + 1);
-        m -= ((s & 3) == 1);
-        buckets[BUCKETS_INDEX4((fast_uint_t)c0, s & 3)]++;
-    }
-
-    return (sa_sint_t)(omp_block_start + omp_block_size - 1 - m);
-}
-
-static sa_sint_t libsais_count_and_gather_lms_suffixes_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                              sa_sint_t n, sa_sint_t * RESTRICT buckets,
-                                                              sa_sint_t threads,
-                                                              LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    sa_sint_t m = 0;
-
-    {
-        (void)(threads);
-        (void)(thread_state);
-
-        fast_sint_t omp_thread_num = 0;
-        fast_sint_t omp_num_threads = 1;
-
-        fast_sint_t omp_block_stride = (n / omp_num_threads) & (-16);
-        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
-        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : n - omp_block_start;
-
-        if (omp_num_threads == 1) {
-            m = libsais_count_and_gather_lms_suffixes_8u(T, SA, n, buckets, omp_block_start, omp_block_size);
-        }
-    }
-
-    return m;
-}
-
-static sa_sint_t libsais_count_and_gather_lms_suffixes_32s_4k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                              sa_sint_t n, sa_sint_t k, sa_sint_t * RESTRICT buckets,
-                                                              fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
-    memset(buckets, 0, 4 * (size_t)k * sizeof(sa_sint_t));
-
-    fast_sint_t m = omp_block_start + omp_block_size - 1;
-
-    if (omp_block_size > 0) {
-        const fast_sint_t prefetch_distance = 32;
-
-        fast_sint_t i, j = m + 1, c0 = T[m], c1 = -1;
-
-        while (j < n && (c1 = T[j]) == c0) {
-            ++j;
-        }
-
-        fast_uint_t s = c0 >= c1;
-
-        for (i = m - 1, j = omp_block_start + prefetch_distance + 3; i >= j; i -= 4) {
-            prefetch(&T[i - 2 * prefetch_distance]);
-
-            prefetchw(&buckets[BUCKETS_INDEX4(T[i - prefetch_distance - 0], 0)]);
-            prefetchw(&buckets[BUCKETS_INDEX4(T[i - prefetch_distance - 1], 0)]);
-            prefetchw(&buckets[BUCKETS_INDEX4(T[i - prefetch_distance - 2], 0)]);
-            prefetchw(&buckets[BUCKETS_INDEX4(T[i - prefetch_distance - 3], 0)]);
-
-            c1 = T[i - 0];
-            s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i + 1);
-            m -= ((s & 3) == 1);
-            buckets[BUCKETS_INDEX4((fast_uint_t)c0, s & 3)]++;
-
-            c0 = T[i - 1];
-            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i - 0);
-            m -= ((s & 3) == 1);
-            buckets[BUCKETS_INDEX4((fast_uint_t)c1, s & 3)]++;
-
-            c1 = T[i - 2];
-            s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i - 1);
-            m -= ((s & 3) == 1);
-            buckets[BUCKETS_INDEX4((fast_uint_t)c0, s & 3)]++;
-
-            c0 = T[i - 3];
-            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i - 2);
-            m -= ((s & 3) == 1);
-            buckets[BUCKETS_INDEX4((fast_uint_t)c1, s & 3)]++;
-        }
-
-        for (j -= prefetch_distance + 3; i >= j; i -= 1) {
-            c1 = c0;
-            c0 = T[i];
-            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i + 1);
-            m -= ((s & 3) == 1);
-            buckets[BUCKETS_INDEX4((fast_uint_t)c1, s & 3)]++;
-        }
-
-        c1 = (i >= 0) ? T[i] : -1;
-        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-        SA[m] = (sa_sint_t)(i + 1);
-        m -= ((s & 3) == 1);
-        buckets[BUCKETS_INDEX4((fast_uint_t)c0, s & 3)]++;
-    }
-
-    return (sa_sint_t)(omp_block_start + omp_block_size - 1 - m);
-}
-
-static sa_sint_t libsais_count_and_gather_lms_suffixes_32s_2k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                              sa_sint_t n, sa_sint_t k, sa_sint_t * RESTRICT buckets,
-                                                              fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
-    memset(buckets, 0, 2 * (size_t)k * sizeof(sa_sint_t));
-
-    fast_sint_t m = omp_block_start + omp_block_size - 1;
-
-    if (omp_block_size > 0) {
-        const fast_sint_t prefetch_distance = 32;
-
-        fast_sint_t i, j = m + 1, c0 = T[m], c1 = -1;
-
-        while (j < n && (c1 = T[j]) == c0) {
-            ++j;
-        }
-
-        fast_uint_t s = c0 >= c1;
-
-        for (i = m - 1, j = omp_block_start + prefetch_distance + 3; i >= j; i -= 4) {
-            prefetch(&T[i - 2 * prefetch_distance]);
-
-            prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 0], 0)]);
-            prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 1], 0)]);
-            prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 2], 0)]);
-            prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 3], 0)]);
-
-            c1 = T[i - 0];
-            s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i + 1);
-            m -= ((s & 3) == 1);
-            buckets[BUCKETS_INDEX2((fast_uint_t)c0, (s & 3) == 1)]++;
-
-            c0 = T[i - 1];
-            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i - 0);
-            m -= ((s & 3) == 1);
-            buckets[BUCKETS_INDEX2((fast_uint_t)c1, (s & 3) == 1)]++;
-
-            c1 = T[i - 2];
-            s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i - 1);
-            m -= ((s & 3) == 1);
-            buckets[BUCKETS_INDEX2((fast_uint_t)c0, (s & 3) == 1)]++;
-
-            c0 = T[i - 3];
-            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i - 2);
-            m -= ((s & 3) == 1);
-            buckets[BUCKETS_INDEX2((fast_uint_t)c1, (s & 3) == 1)]++;
-        }
-
-        for (j -= prefetch_distance + 3; i >= j; i -= 1) {
-            c1 = c0;
-            c0 = T[i];
-            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i + 1);
-            m -= ((s & 3) == 1);
-            buckets[BUCKETS_INDEX2((fast_uint_t)c1, (s & 3) == 1)]++;
-        }
-
-        c1 = (i >= 0) ? T[i] : -1;
-        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-        SA[m] = (sa_sint_t)(i + 1);
-        m -= ((s & 3) == 1);
-        buckets[BUCKETS_INDEX2((fast_uint_t)c0, (s & 3) == 1)]++;
-    }
-
-    return (sa_sint_t)(omp_block_start + omp_block_size - 1 - m);
-}
-
-static sa_sint_t libsais_count_and_gather_compacted_lms_suffixes_32s_2k(const sa_sint_t * RESTRICT T,
-                                                                        sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                                        sa_sint_t k, sa_sint_t * RESTRICT buckets,
-                                                                        fast_sint_t omp_block_start,
-                                                                        fast_sint_t omp_block_size) {
-    memset(buckets, 0, 2 * (size_t)k * sizeof(sa_sint_t));
-
-    fast_sint_t m = omp_block_start + omp_block_size - 1;
-
-    if (omp_block_size > 0) {
-        const fast_sint_t prefetch_distance = 32;
-
-        fast_sint_t i, j = m + 1, c0 = T[m], c1 = -1;
-
-        while (j < n && (c1 = T[j]) == c0) {
-            ++j;
-        }
-
-        fast_uint_t s = c0 >= c1;
-
-        for (i = m - 1, j = omp_block_start + prefetch_distance + 3; i >= j; i -= 4) {
-            prefetch(&T[i - 2 * prefetch_distance]);
-
-            prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 0] & SAINT_MAX, 0)]);
-            prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 1] & SAINT_MAX, 0)]);
-            prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 2] & SAINT_MAX, 0)]);
-            prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 3] & SAINT_MAX, 0)]);
-
-            c1 = T[i - 0];
-            s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i + 1);
-            m -= ((fast_sint_t)(s & 3) == (c0 >= 0));
-            c0 &= SAINT_MAX;
-            buckets[BUCKETS_INDEX2((fast_uint_t)c0, (s & 3) == 1)]++;
-
-            c0 = T[i - 1];
-            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i - 0);
-            m -= ((fast_sint_t)(s & 3) == (c1 >= 0));
-            c1 &= SAINT_MAX;
-            buckets[BUCKETS_INDEX2((fast_uint_t)c1, (s & 3) == 1)]++;
-
-            c1 = T[i - 2];
-            s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i - 1);
-            m -= ((fast_sint_t)(s & 3) == (c0 >= 0));
-            c0 &= SAINT_MAX;
-            buckets[BUCKETS_INDEX2((fast_uint_t)c0, (s & 3) == 1)]++;
-
-            c0 = T[i - 3];
-            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i - 2);
-            m -= ((fast_sint_t)(s & 3) == (c1 >= 0));
-            c1 &= SAINT_MAX;
-            buckets[BUCKETS_INDEX2((fast_uint_t)c1, (s & 3) == 1)]++;
-        }
-
-        for (j -= prefetch_distance + 3; i >= j; i -= 1) {
-            c1 = c0;
-            c0 = T[i];
-            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-            SA[m] = (sa_sint_t)(i + 1);
-            m -= ((fast_sint_t)(s & 3) == (c1 >= 0));
-            c1 &= SAINT_MAX;
-            buckets[BUCKETS_INDEX2((fast_uint_t)c1, (s & 3) == 1)]++;
-        }
-
-        c1 = (i >= 0) ? T[i] : -1;
-        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-        SA[m] = (sa_sint_t)(i + 1);
-        m -= ((fast_sint_t)(s & 3) == (c0 >= 0));
-        c0 &= SAINT_MAX;
-        buckets[BUCKETS_INDEX2((fast_uint_t)c0, (s & 3) == 1)]++;
-    }
-
-    return (sa_sint_t)(omp_block_start + omp_block_size - 1 - m);
-}
-static sa_sint_t libsais_count_and_gather_lms_suffixes_32s_4k_nofs_omp(const sa_sint_t * RESTRICT T,
-                                                                       sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                                       sa_sint_t k, sa_sint_t * RESTRICT buckets,
-                                                                       sa_sint_t threads) {
-    sa_sint_t m = 0;
-    {
-        (void)(threads);
-
-        fast_sint_t omp_num_threads = 1;
-
-        if (omp_num_threads == 1) {
-            m = libsais_count_and_gather_lms_suffixes_32s_4k(T, SA, n, k, buckets, 0, n);
-        }
-    }
-
-    return m;
-}
-
-static sa_sint_t libsais_count_and_gather_lms_suffixes_32s_2k_nofs_omp(const sa_sint_t * RESTRICT T,
-                                                                       sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                                       sa_sint_t k, sa_sint_t * RESTRICT buckets,
-                                                                       sa_sint_t threads) {
-    sa_sint_t m = 0;
-    {
-        (void)(threads);
-
-        fast_sint_t omp_num_threads = 1;
-
-        if (omp_num_threads == 1) {
-            m = libsais_count_and_gather_lms_suffixes_32s_2k(T, SA, n, k, buckets, 0, n);
-        }
-    }
-
-    return m;
-}
-
-static sa_sint_t libsais_count_and_gather_compacted_lms_suffixes_32s_2k_nofs_omp(const sa_sint_t * RESTRICT T,
-                                                                                 sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                                                 sa_sint_t k,
-                                                                                 sa_sint_t * RESTRICT buckets,
-                                                                                 sa_sint_t threads) {
-    sa_sint_t m = 0;
-    {
-        (void)(threads);
-
-        fast_sint_t omp_num_threads = 1;
-
-        if (omp_num_threads == 1) {
-            m = libsais_count_and_gather_compacted_lms_suffixes_32s_2k(T, SA, n, k, buckets, 0, n);
-        }
-    }
-
-    return m;
-}
-
-static sa_sint_t libsais_count_and_gather_lms_suffixes_32s_4k_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                                  sa_sint_t n, sa_sint_t k,
-                                                                  sa_sint_t * RESTRICT buckets, sa_sint_t threads,
-                                                                  LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    sa_sint_t m;
-    (void)(thread_state);
-
-    { m = libsais_count_and_gather_lms_suffixes_32s_4k_nofs_omp(T, SA, n, k, buckets, threads); }
-
-    return m;
-}
-
-static sa_sint_t libsais_count_and_gather_lms_suffixes_32s_2k_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                                  sa_sint_t n, sa_sint_t k,
-                                                                  sa_sint_t * RESTRICT buckets, sa_sint_t threads,
-                                                                  LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    sa_sint_t m;
-    (void)(thread_state);
-
-    { m = libsais_count_and_gather_lms_suffixes_32s_2k_nofs_omp(T, SA, n, k, buckets, threads); }
-
-    return m;
-}
-
-static void libsais_count_and_gather_compacted_lms_suffixes_32s_2k_omp(const sa_sint_t * RESTRICT T,
-                                                                       sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                                       sa_sint_t k, sa_sint_t * RESTRICT buckets,
-                                                                       sa_sint_t threads,
-                                                                       LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    (void)(thread_state);
-
-    { libsais_count_and_gather_compacted_lms_suffixes_32s_2k_nofs_omp(T, SA, n, k, buckets, threads); }
-}
-
-static void libsais_count_suffixes_32s(const sa_sint_t * RESTRICT T, sa_sint_t n, sa_sint_t k,
-                                       sa_sint_t * RESTRICT buckets) {
-    const fast_sint_t prefetch_distance = 32;
-
-    memset(buckets, 0, (size_t)k * sizeof(sa_sint_t));
-
-    fast_sint_t i, j;
-    for (i = 0, j = (fast_sint_t)n - 7; i < j; i += 8) {
-        prefetch(&T[i + prefetch_distance]);
-
-        buckets[T[i + 0]]++;
-        buckets[T[i + 1]]++;
-        buckets[T[i + 2]]++;
-        buckets[T[i + 3]]++;
-        buckets[T[i + 4]]++;
-        buckets[T[i + 5]]++;
-        buckets[T[i + 6]]++;
-        buckets[T[i + 7]]++;
-    }
-
-    for (j += 7; i < j; i += 1) {
-        buckets[T[i]]++;
-    }
-}
-
-static void libsais_initialize_buckets_start_and_end_8u(sa_sint_t * RESTRICT buckets, sa_sint_t * RESTRICT freq) {
-    sa_sint_t * RESTRICT bucket_start = &buckets[6 * ALPHABET_SIZE];
-    sa_sint_t * RESTRICT bucket_end = &buckets[7 * ALPHABET_SIZE];
-
-    if (freq != NULL) {
-        fast_sint_t i, j;
-        sa_sint_t sum = 0;
-        for (i = BUCKETS_INDEX4(0, 0), j = 0; i <= BUCKETS_INDEX4(ALPHABET_SIZE - 1, 0);
-             i += BUCKETS_INDEX4(1, 0), j += 1) {
-            bucket_start[j] = sum;
-            sum += (freq[j] = buckets[i + BUCKETS_INDEX4(0, 0)] + buckets[i + BUCKETS_INDEX4(0, 1)] +
-                              buckets[i + BUCKETS_INDEX4(0, 2)] + buckets[i + BUCKETS_INDEX4(0, 3)]);
-            bucket_end[j] = sum;
-        }
-    } else {
-        fast_sint_t i, j;
-        sa_sint_t sum = 0;
-        for (i = BUCKETS_INDEX4(0, 0), j = 0; i <= BUCKETS_INDEX4(ALPHABET_SIZE - 1, 0);
-             i += BUCKETS_INDEX4(1, 0), j += 1) {
-            bucket_start[j] = sum;
-            sum += buckets[i + BUCKETS_INDEX4(0, 0)] + buckets[i + BUCKETS_INDEX4(0, 1)] +
-                   buckets[i + BUCKETS_INDEX4(0, 2)] + buckets[i + BUCKETS_INDEX4(0, 3)];
-            bucket_end[j] = sum;
-        }
-    }
-}
-
-static void libsais_initialize_buckets_start_and_end_32s_6k(sa_sint_t k, sa_sint_t * RESTRICT buckets) {
-    sa_sint_t * RESTRICT bucket_start = &buckets[4 * k];
-    sa_sint_t * RESTRICT bucket_end = &buckets[5 * k];
-
-    fast_sint_t i, j;
-    sa_sint_t sum = 0;
-    for (i = BUCKETS_INDEX4(0, 0), j = 0; i <= BUCKETS_INDEX4((fast_sint_t)k - 1, 0);
-         i += BUCKETS_INDEX4(1, 0), j += 1) {
-        bucket_start[j] = sum;
-        sum += buckets[i + BUCKETS_INDEX4(0, 0)] + buckets[i + BUCKETS_INDEX4(0, 1)] +
-               buckets[i + BUCKETS_INDEX4(0, 2)] + buckets[i + BUCKETS_INDEX4(0, 3)];
-        bucket_end[j] = sum;
-    }
-}
-
-static void libsais_initialize_buckets_start_and_end_32s_4k(sa_sint_t k, sa_sint_t * RESTRICT buckets) {
-    sa_sint_t * RESTRICT bucket_start = &buckets[2 * k];
-    sa_sint_t * RESTRICT bucket_end = &buckets[3 * k];
-
-    fast_sint_t i, j;
-    sa_sint_t sum = 0;
-    for (i = BUCKETS_INDEX2(0, 0), j = 0; i <= BUCKETS_INDEX2((fast_sint_t)k - 1, 0);
-         i += BUCKETS_INDEX2(1, 0), j += 1) {
-        bucket_start[j] = sum;
-        sum += buckets[i + BUCKETS_INDEX2(0, 0)] + buckets[i + BUCKETS_INDEX2(0, 1)];
-        bucket_end[j] = sum;
-    }
-}
-
-static void libsais_initialize_buckets_end_32s_2k(sa_sint_t k, sa_sint_t * RESTRICT buckets) {
-    fast_sint_t i;
-    sa_sint_t sum0 = 0;
-    for (i = BUCKETS_INDEX2(0, 0); i <= BUCKETS_INDEX2((fast_sint_t)k - 1, 0); i += BUCKETS_INDEX2(1, 0)) {
-        sum0 += buckets[i + BUCKETS_INDEX2(0, 0)] + buckets[i + BUCKETS_INDEX2(0, 1)];
-        buckets[i + BUCKETS_INDEX2(0, 0)] = sum0;
-    }
-}
-
-static void libsais_initialize_buckets_start_and_end_32s_2k(sa_sint_t k, sa_sint_t * RESTRICT buckets) {
-    fast_sint_t i, j;
-    for (i = BUCKETS_INDEX2(0, 0), j = 0; i <= BUCKETS_INDEX2((fast_sint_t)k - 1, 0);
-         i += BUCKETS_INDEX2(1, 0), j += 1) {
-        buckets[j] = buckets[i];
-    }
-
-    buckets[k] = 0;
-    memcpy(&buckets[k + 1], buckets, ((size_t)k - 1) * sizeof(sa_sint_t));
-}
-
-static void libsais_initialize_buckets_start_32s_1k(sa_sint_t k, sa_sint_t * RESTRICT buckets) {
-    fast_sint_t i;
-    sa_sint_t sum = 0;
-    for (i = 0; i <= (fast_sint_t)k - 1; i += 1) {
-        sa_sint_t tmp = buckets[i];
-        buckets[i] = sum;
-        sum += tmp;
-    }
-}
-
-static void libsais_initialize_buckets_end_32s_1k(sa_sint_t k, sa_sint_t * RESTRICT buckets) {
-    fast_sint_t i;
-    sa_sint_t sum = 0;
-    for (i = 0; i <= (fast_sint_t)k - 1; i += 1) {
-        sum += buckets[i];
-        buckets[i] = sum;
-    }
-}
-
-static sa_sint_t libsais_initialize_buckets_for_lms_suffixes_radix_sort_8u(const u8 * RESTRICT T,
-                                                                           sa_sint_t * RESTRICT buckets,
-                                                                           sa_sint_t first_lms_suffix) {
-    {
-        fast_uint_t s = 0;
-        fast_sint_t c0 = T[first_lms_suffix];
-        fast_sint_t c1 = 0;
-
-        for (; --first_lms_suffix >= 0;) {
-            c1 = c0;
-            c0 = T[first_lms_suffix];
-            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-            buckets[BUCKETS_INDEX4((fast_uint_t)c1, s & 3)]--;
-        }
-
-        buckets[BUCKETS_INDEX4((fast_uint_t)c0, (s << 1) & 3)]--;
-    }
-
-    {
-        sa_sint_t * RESTRICT temp_bucket = &buckets[4 * ALPHABET_SIZE];
-
-        fast_sint_t i, j;
-        sa_sint_t sum = 0;
-        for (i = BUCKETS_INDEX4(0, 0), j = BUCKETS_INDEX2(0, 0); i <= BUCKETS_INDEX4(ALPHABET_SIZE - 1, 0);
-             i += BUCKETS_INDEX4(1, 0), j += BUCKETS_INDEX2(1, 0)) {
-            temp_bucket[j + BUCKETS_INDEX2(0, 1)] = sum;
-            sum += buckets[i + BUCKETS_INDEX4(0, 1)] + buckets[i + BUCKETS_INDEX4(0, 3)];
-            temp_bucket[j] = sum;
-        }
-
-        return sum;
-    }
-}
-
-static void libsais_initialize_buckets_for_lms_suffixes_radix_sort_32s_2k(const sa_sint_t * RESTRICT T, sa_sint_t k,
-                                                                          sa_sint_t * RESTRICT buckets,
-                                                                          sa_sint_t first_lms_suffix) {
-    buckets[BUCKETS_INDEX2(T[first_lms_suffix], 0)]++;
-    buckets[BUCKETS_INDEX2(T[first_lms_suffix], 1)]--;
-
-    fast_sint_t i;
-    sa_sint_t sum0 = 0, sum1 = 0;
-    for (i = BUCKETS_INDEX2(0, 0); i <= BUCKETS_INDEX2((fast_sint_t)k - 1, 0); i += BUCKETS_INDEX2(1, 0)) {
-        sum0 += buckets[i + BUCKETS_INDEX2(0, 0)] + buckets[i + BUCKETS_INDEX2(0, 1)];
-        sum1 += buckets[i + BUCKETS_INDEX2(0, 1)];
-
-        buckets[i + BUCKETS_INDEX2(0, 0)] = sum0;
-        buckets[i + BUCKETS_INDEX2(0, 1)] = sum1;
-    }
-}
-
-static sa_sint_t libsais_initialize_buckets_for_lms_suffixes_radix_sort_32s_6k(const sa_sint_t * RESTRICT T,
-                                                                               sa_sint_t k,
-                                                                               sa_sint_t * RESTRICT buckets,
-                                                                               sa_sint_t first_lms_suffix) {
-    {
-        fast_uint_t s = 0;
-        fast_sint_t c0 = T[first_lms_suffix];
-        fast_sint_t c1 = 0;
-
-        for (; --first_lms_suffix >= 0;) {
-            c1 = c0;
-            c0 = T[first_lms_suffix];
-            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-            buckets[BUCKETS_INDEX4((fast_uint_t)c1, s & 3)]--;
-        }
-
-        buckets[BUCKETS_INDEX4((fast_uint_t)c0, (s << 1) & 3)]--;
-    }
-
-    {
-        sa_sint_t * RESTRICT temp_bucket = &buckets[4 * k];
-
-        fast_sint_t i, j;
-        sa_sint_t sum = 0;
-        for (i = BUCKETS_INDEX4(0, 0), j = 0; i <= BUCKETS_INDEX4((fast_sint_t)k - 1, 0);
-             i += BUCKETS_INDEX4(1, 0), j += 1) {
-            sum += buckets[i + BUCKETS_INDEX4(0, 1)] + buckets[i + BUCKETS_INDEX4(0, 3)];
-            temp_bucket[j] = sum;
-        }
-
-        return sum;
-    }
-}
-
-static void libsais_initialize_buckets_for_radix_and_partial_sorting_32s_4k(const sa_sint_t * RESTRICT T, sa_sint_t k,
-                                                                            sa_sint_t * RESTRICT buckets,
-                                                                            sa_sint_t first_lms_suffix) {
-    sa_sint_t * RESTRICT bucket_start = &buckets[2 * k];
-    sa_sint_t * RESTRICT bucket_end = &buckets[3 * k];
-
-    buckets[BUCKETS_INDEX2(T[first_lms_suffix], 0)]++;
-    buckets[BUCKETS_INDEX2(T[first_lms_suffix], 1)]--;
-
-    fast_sint_t i, j;
-    sa_sint_t sum0 = 0, sum1 = 0;
-    for (i = BUCKETS_INDEX2(0, 0), j = 0; i <= BUCKETS_INDEX2((fast_sint_t)k - 1, 0);
-         i += BUCKETS_INDEX2(1, 0), j += 1) {
-        bucket_start[j] = sum1;
-
-        sum0 += buckets[i + BUCKETS_INDEX2(0, 1)];
-        sum1 += buckets[i + BUCKETS_INDEX2(0, 0)] + buckets[i + BUCKETS_INDEX2(0, 1)];
-        buckets[i + BUCKETS_INDEX2(0, 1)] = sum0;
-
-        bucket_end[j] = sum1;
-    }
-}
-
-static void libsais_radix_sort_lms_suffixes_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                               sa_sint_t * RESTRICT induction_bucket, fast_sint_t omp_block_start,
-                                               fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j;
-    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + prefetch_distance + 3; i >= j; i -= 4) {
-        prefetch(&SA[i - 2 * prefetch_distance]);
-
-        prefetch(&T[SA[i - prefetch_distance - 0]]);
-        prefetch(&T[SA[i - prefetch_distance - 1]]);
-        prefetch(&T[SA[i - prefetch_distance - 2]]);
-        prefetch(&T[SA[i - prefetch_distance - 3]]);
-
-        sa_sint_t p0 = SA[i - 0];
-        SA[--induction_bucket[BUCKETS_INDEX2(T[p0], 0)]] = p0;
-        sa_sint_t p1 = SA[i - 1];
-        SA[--induction_bucket[BUCKETS_INDEX2(T[p1], 0)]] = p1;
-        sa_sint_t p2 = SA[i - 2];
-        SA[--induction_bucket[BUCKETS_INDEX2(T[p2], 0)]] = p2;
-        sa_sint_t p3 = SA[i - 3];
-        SA[--induction_bucket[BUCKETS_INDEX2(T[p3], 0)]] = p3;
-    }
-
-    for (j -= prefetch_distance + 3; i >= j; i -= 1) {
-        sa_sint_t p = SA[i];
-        SA[--induction_bucket[BUCKETS_INDEX2(T[p], 0)]] = p;
-    }
-}
-
-static void libsais_radix_sort_lms_suffixes_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                   sa_sint_t m, sa_sint_t * RESTRICT buckets, sa_sint_t threads,
-                                                   LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    {
-        (void)(threads);
-        (void)(thread_state);
-
-        fast_sint_t omp_num_threads = 1;
-
-        if (omp_num_threads == 1) {
-            libsais_radix_sort_lms_suffixes_8u(T, SA, &buckets[4 * ALPHABET_SIZE], (fast_sint_t)n - (fast_sint_t)m + 1,
-                                               (fast_sint_t)m - 1);
-        }
-    }
-}
-
-static void libsais_radix_sort_lms_suffixes_32s_6k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                   sa_sint_t * RESTRICT induction_bucket, fast_sint_t omp_block_start,
-                                                   fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j;
-    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + 2 * prefetch_distance + 3; i >= j; i -= 4) {
-        prefetch(&SA[i - 3 * prefetch_distance]);
-
-        prefetch(&T[SA[i - 2 * prefetch_distance - 0]]);
-        prefetch(&T[SA[i - 2 * prefetch_distance - 1]]);
-        prefetch(&T[SA[i - 2 * prefetch_distance - 2]]);
-        prefetch(&T[SA[i - 2 * prefetch_distance - 3]]);
-
-        prefetchw(&induction_bucket[T[SA[i - prefetch_distance - 0]]]);
-        prefetchw(&induction_bucket[T[SA[i - prefetch_distance - 1]]]);
-        prefetchw(&induction_bucket[T[SA[i - prefetch_distance - 2]]]);
-        prefetchw(&induction_bucket[T[SA[i - prefetch_distance - 3]]]);
-
-        sa_sint_t p0 = SA[i - 0];
-        SA[--induction_bucket[T[p0]]] = p0;
-        sa_sint_t p1 = SA[i - 1];
-        SA[--induction_bucket[T[p1]]] = p1;
-        sa_sint_t p2 = SA[i - 2];
-        SA[--induction_bucket[T[p2]]] = p2;
-        sa_sint_t p3 = SA[i - 3];
-        SA[--induction_bucket[T[p3]]] = p3;
-    }
-
-    for (j -= 2 * prefetch_distance + 3; i >= j; i -= 1) {
-        sa_sint_t p = SA[i];
-        SA[--induction_bucket[T[p]]] = p;
-    }
-}
-
-static void libsais_radix_sort_lms_suffixes_32s_2k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                   sa_sint_t * RESTRICT induction_bucket, fast_sint_t omp_block_start,
-                                                   fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j;
-    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + 2 * prefetch_distance + 3; i >= j; i -= 4) {
-        prefetch(&SA[i - 3 * prefetch_distance]);
-
-        prefetch(&T[SA[i - 2 * prefetch_distance - 0]]);
-        prefetch(&T[SA[i - 2 * prefetch_distance - 1]]);
-        prefetch(&T[SA[i - 2 * prefetch_distance - 2]]);
-        prefetch(&T[SA[i - 2 * prefetch_distance - 3]]);
-
-        prefetchw(&induction_bucket[BUCKETS_INDEX2(T[SA[i - prefetch_distance - 0]], 0)]);
-        prefetchw(&induction_bucket[BUCKETS_INDEX2(T[SA[i - prefetch_distance - 1]], 0)]);
-        prefetchw(&induction_bucket[BUCKETS_INDEX2(T[SA[i - prefetch_distance - 2]], 0)]);
-        prefetchw(&induction_bucket[BUCKETS_INDEX2(T[SA[i - prefetch_distance - 3]], 0)]);
-
-        sa_sint_t p0 = SA[i - 0];
-        SA[--induction_bucket[BUCKETS_INDEX2(T[p0], 0)]] = p0;
-        sa_sint_t p1 = SA[i - 1];
-        SA[--induction_bucket[BUCKETS_INDEX2(T[p1], 0)]] = p1;
-        sa_sint_t p2 = SA[i - 2];
-        SA[--induction_bucket[BUCKETS_INDEX2(T[p2], 0)]] = p2;
-        sa_sint_t p3 = SA[i - 3];
-        SA[--induction_bucket[BUCKETS_INDEX2(T[p3], 0)]] = p3;
-    }
-
-    for (j -= 2 * prefetch_distance + 3; i >= j; i -= 1) {
-        sa_sint_t p = SA[i];
-        SA[--induction_bucket[BUCKETS_INDEX2(T[p], 0)]] = p;
-    }
-}
-static void libsais_radix_sort_lms_suffixes_32s_6k_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                       sa_sint_t n, sa_sint_t m, sa_sint_t * RESTRICT induction_bucket,
-                                                       sa_sint_t threads,
-                                                       LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    if (threads == 1 || m < 65536) {
-        libsais_radix_sort_lms_suffixes_32s_6k(T, SA, induction_bucket, (fast_sint_t)n - (fast_sint_t)m + 1,
-                                               (fast_sint_t)m - 1);
-    }
-    (void)(thread_state);
-}
-
-static void libsais_radix_sort_lms_suffixes_32s_2k_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                       sa_sint_t n, sa_sint_t m, sa_sint_t * RESTRICT induction_bucket,
-                                                       sa_sint_t threads,
-                                                       LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    if (threads == 1 || m < 65536) {
-        libsais_radix_sort_lms_suffixes_32s_2k(T, SA, induction_bucket, (fast_sint_t)n - (fast_sint_t)m + 1,
-                                               (fast_sint_t)m - 1);
-    }
-    (void)(thread_state);
-}
-
-static sa_sint_t libsais_radix_sort_lms_suffixes_32s_1k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                        sa_sint_t n, sa_sint_t * RESTRICT buckets) {
-    const fast_sint_t prefetch_distance = 32;
-
-    sa_sint_t i = n - 2;
-    sa_sint_t m = 0;
-    fast_uint_t s = 1;
-    fast_sint_t c0 = T[n - 1];
-    fast_sint_t c1 = 0;
-    fast_sint_t c2 = 0;
-
-    for (; i >= prefetch_distance + 3; i -= 4) {
-        prefetch(&T[i - 2 * prefetch_distance]);
-
-        prefetchw(&buckets[T[i - prefetch_distance - 0]]);
-        prefetchw(&buckets[T[i - prefetch_distance - 1]]);
-        prefetchw(&buckets[T[i - prefetch_distance - 2]]);
-        prefetchw(&buckets[T[i - prefetch_distance - 3]]);
-
-        c1 = T[i - 0];
-        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-        if ((s & 3) == 1) {
-            SA[--buckets[c2 = c0]] = i + 1;
-            m++;
-        }
-
-        c0 = T[i - 1];
-        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-        if ((s & 3) == 1) {
-            SA[--buckets[c2 = c1]] = i - 0;
-            m++;
-        }
-
-        c1 = T[i - 2];
-        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
-        if ((s & 3) == 1) {
-            SA[--buckets[c2 = c0]] = i - 1;
-            m++;
-        }
-
-        c0 = T[i - 3];
-        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-        if ((s & 3) == 1) {
-            SA[--buckets[c2 = c1]] = i - 2;
-            m++;
-        }
-    }
-
-    for (; i >= 0; i -= 1) {
-        c1 = c0;
-        c0 = T[i];
-        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
-        if ((s & 3) == 1) {
-            SA[--buckets[c2 = c1]] = i + 1;
-            m++;
-        }
-    }
-
-    if (m > 1) {
-        SA[buckets[c2]] = 0;
-    }
-
-    return m;
-}
-
-static void libsais_radix_sort_set_markers_32s_6k(sa_sint_t * RESTRICT SA, sa_sint_t * RESTRICT induction_bucket,
-                                                  fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j;
-    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 3; i < j; i += 4) {
-        prefetch(&induction_bucket[i + 2 * prefetch_distance]);
-
-        prefetchw(&SA[induction_bucket[i + prefetch_distance + 0]]);
-        prefetchw(&SA[induction_bucket[i + prefetch_distance + 1]]);
-        prefetchw(&SA[induction_bucket[i + prefetch_distance + 2]]);
-        prefetchw(&SA[induction_bucket[i + prefetch_distance + 3]]);
-
-        SA[induction_bucket[i + 0]] |= SAINT_MIN;
-        SA[induction_bucket[i + 1]] |= SAINT_MIN;
-        SA[induction_bucket[i + 2]] |= SAINT_MIN;
-        SA[induction_bucket[i + 3]] |= SAINT_MIN;
-    }
-
-    for (j += prefetch_distance + 3; i < j; i += 1) {
-        SA[induction_bucket[i]] |= SAINT_MIN;
-    }
-}
-
-static void libsais_radix_sort_set_markers_32s_4k(sa_sint_t * RESTRICT SA, sa_sint_t * RESTRICT induction_bucket,
-                                                  fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j;
-    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 3; i < j; i += 4) {
-        prefetch(&induction_bucket[BUCKETS_INDEX2(i + 2 * prefetch_distance, 0)]);
-
-        prefetchw(&SA[induction_bucket[BUCKETS_INDEX2(i + prefetch_distance + 0, 0)]]);
-        prefetchw(&SA[induction_bucket[BUCKETS_INDEX2(i + prefetch_distance + 1, 0)]]);
-        prefetchw(&SA[induction_bucket[BUCKETS_INDEX2(i + prefetch_distance + 2, 0)]]);
-        prefetchw(&SA[induction_bucket[BUCKETS_INDEX2(i + prefetch_distance + 3, 0)]]);
-
-        SA[induction_bucket[BUCKETS_INDEX2(i + 0, 0)]] |= SUFFIX_GROUP_MARKER;
-        SA[induction_bucket[BUCKETS_INDEX2(i + 1, 0)]] |= SUFFIX_GROUP_MARKER;
-        SA[induction_bucket[BUCKETS_INDEX2(i + 2, 0)]] |= SUFFIX_GROUP_MARKER;
-        SA[induction_bucket[BUCKETS_INDEX2(i + 3, 0)]] |= SUFFIX_GROUP_MARKER;
-    }
-
-    for (j += prefetch_distance + 3; i < j; i += 1) {
-        SA[induction_bucket[BUCKETS_INDEX2(i, 0)]] |= SUFFIX_GROUP_MARKER;
-    }
-}
-
-static void libsais_radix_sort_set_markers_32s_6k_omp(sa_sint_t * RESTRICT SA, sa_sint_t k,
-                                                      sa_sint_t * RESTRICT induction_bucket, sa_sint_t threads) {
-    {
-        (void)(threads);
-
-        fast_sint_t omp_block_start = 0;
-        fast_sint_t omp_block_size = (fast_sint_t)k - 1;
-        libsais_radix_sort_set_markers_32s_6k(SA, induction_bucket, omp_block_start, omp_block_size);
-    }
-}
-
-static void libsais_radix_sort_set_markers_32s_4k_omp(sa_sint_t * RESTRICT SA, sa_sint_t k,
-                                                      sa_sint_t * RESTRICT induction_bucket, sa_sint_t threads) {
-    {
-        (void)(threads);
-
-        fast_sint_t omp_block_start = 0;
-        fast_sint_t omp_block_size = (fast_sint_t)k - 1;
-        libsais_radix_sort_set_markers_32s_4k(SA, induction_bucket, omp_block_start, omp_block_size);
-    }
-}
-
-static void libsais_initialize_buckets_for_partial_sorting_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT buckets,
-                                                              sa_sint_t first_lms_suffix,
-                                                              sa_sint_t left_suffixes_count) {
-    sa_sint_t * RESTRICT temp_bucket = &buckets[4 * ALPHABET_SIZE];
-
-    buckets[BUCKETS_INDEX4((fast_uint_t)T[first_lms_suffix], 1)]++;
-
-    fast_sint_t i, j;
-    sa_sint_t sum0 = left_suffixes_count + 1, sum1 = 0;
-    for (i = BUCKETS_INDEX4(0, 0), j = BUCKETS_INDEX2(0, 0); i <= BUCKETS_INDEX4(ALPHABET_SIZE - 1, 0);
-         i += BUCKETS_INDEX4(1, 0), j += BUCKETS_INDEX2(1, 0)) {
-        temp_bucket[j + BUCKETS_INDEX2(0, 0)] = sum0;
-
-        sum0 += buckets[i + BUCKETS_INDEX4(0, 0)] + buckets[i + BUCKETS_INDEX4(0, 2)];
-        sum1 += buckets[i + BUCKETS_INDEX4(0, 1)];
-
-        buckets[j + BUCKETS_INDEX2(0, 0)] = sum0;
-        buckets[j + BUCKETS_INDEX2(0, 1)] = sum1;
-    }
-}
-
-static void libsais_initialize_buckets_for_partial_sorting_32s_6k(const sa_sint_t * RESTRICT T, sa_sint_t k,
-                                                                  sa_sint_t * RESTRICT buckets,
-                                                                  sa_sint_t first_lms_suffix,
-                                                                  sa_sint_t left_suffixes_count) {
-    sa_sint_t * RESTRICT temp_bucket = &buckets[4 * k];
-
-    fast_sint_t i, j;
-    sa_sint_t sum0 = left_suffixes_count + 1, sum1 = 0, sum2 = 0;
-    for (first_lms_suffix = T[first_lms_suffix], i = BUCKETS_INDEX4(0, 0), j = BUCKETS_INDEX2(0, 0);
-         i <= BUCKETS_INDEX4((fast_sint_t)first_lms_suffix - 1, 0);
-         i += BUCKETS_INDEX4(1, 0), j += BUCKETS_INDEX2(1, 0)) {
-        sa_sint_t SS = buckets[i + BUCKETS_INDEX4(0, 0)];
-        sa_sint_t LS = buckets[i + BUCKETS_INDEX4(0, 1)];
-        sa_sint_t SL = buckets[i + BUCKETS_INDEX4(0, 2)];
-        sa_sint_t LL = buckets[i + BUCKETS_INDEX4(0, 3)];
-
-        buckets[i + BUCKETS_INDEX4(0, 0)] = sum0;
-        buckets[i + BUCKETS_INDEX4(0, 1)] = sum2;
-        buckets[i + BUCKETS_INDEX4(0, 2)] = 0;
-        buckets[i + BUCKETS_INDEX4(0, 3)] = 0;
-
-        sum0 += SS + SL;
-        sum1 += LS;
-        sum2 += LS + LL;
-
-        temp_bucket[j + BUCKETS_INDEX2(0, 0)] = sum0;
-        temp_bucket[j + BUCKETS_INDEX2(0, 1)] = sum1;
-    }
-
-    for (sum1 += 1; i <= BUCKETS_INDEX4((fast_sint_t)k - 1, 0); i += BUCKETS_INDEX4(1, 0), j += BUCKETS_INDEX2(1, 0)) {
-        sa_sint_t SS = buckets[i + BUCKETS_INDEX4(0, 0)];
-        sa_sint_t LS = buckets[i + BUCKETS_INDEX4(0, 1)];
-        sa_sint_t SL = buckets[i + BUCKETS_INDEX4(0, 2)];
-        sa_sint_t LL = buckets[i + BUCKETS_INDEX4(0, 3)];
-
-        buckets[i + BUCKETS_INDEX4(0, 0)] = sum0;
-        buckets[i + BUCKETS_INDEX4(0, 1)] = sum2;
-        buckets[i + BUCKETS_INDEX4(0, 2)] = 0;
-        buckets[i + BUCKETS_INDEX4(0, 3)] = 0;
-
-        sum0 += SS + SL;
-        sum1 += LS;
-        sum2 += LS + LL;
-
-        temp_bucket[j + BUCKETS_INDEX2(0, 0)] = sum0;
-        temp_bucket[j + BUCKETS_INDEX2(0, 1)] = sum1;
-    }
-}
-
-static sa_sint_t libsais_partial_sorting_scan_left_to_right_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                               sa_sint_t * RESTRICT buckets, sa_sint_t d,
-                                                               fast_sint_t omp_block_start,
-                                                               fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    sa_sint_t * RESTRICT induction_bucket = &buckets[4 * ALPHABET_SIZE];
-    sa_sint_t * RESTRICT distinct_names = &buckets[2 * ALPHABET_SIZE];
-
-    fast_sint_t i, j;
-    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 1; i < j; i += 2) {
-        prefetch(&SA[i + 2 * prefetch_distance]);
-
-        prefetch(&T[SA[i + prefetch_distance + 0] & SAINT_MAX] - 1);
-        prefetch(&T[SA[i + prefetch_distance + 0] & SAINT_MAX] - 2);
-        prefetch(&T[SA[i + prefetch_distance + 1] & SAINT_MAX] - 1);
-        prefetch(&T[SA[i + prefetch_distance + 1] & SAINT_MAX] - 2);
-
-        sa_sint_t p0 = SA[i + 0];
-        d += (p0 < 0);
-        p0 &= SAINT_MAX;
-        sa_sint_t v0 = BUCKETS_INDEX2(T[p0 - 1], T[p0 - 2] >= T[p0 - 1]);
-        SA[induction_bucket[v0]++] = (p0 - 1) | ((sa_sint_t)(distinct_names[v0] != d) << (SAINT_BIT - 1));
-        distinct_names[v0] = d;
-
-        sa_sint_t p1 = SA[i + 1];
-        d += (p1 < 0);
-        p1 &= SAINT_MAX;
-        sa_sint_t v1 = BUCKETS_INDEX2(T[p1 - 1], T[p1 - 2] >= T[p1 - 1]);
-        SA[induction_bucket[v1]++] = (p1 - 1) | ((sa_sint_t)(distinct_names[v1] != d) << (SAINT_BIT - 1));
-        distinct_names[v1] = d;
-    }
-
-    for (j += prefetch_distance + 1; i < j; i += 1) {
-        sa_sint_t p = SA[i];
-        d += (p < 0);
-        p &= SAINT_MAX;
-        sa_sint_t v = BUCKETS_INDEX2(T[p - 1], T[p - 2] >= T[p - 1]);
-        SA[induction_bucket[v]++] = (p - 1) | ((sa_sint_t)(distinct_names[v] != d) << (SAINT_BIT - 1));
-        distinct_names[v] = d;
-    }
-
-    return d;
-}
-static sa_sint_t libsais_partial_sorting_scan_left_to_right_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                                   sa_sint_t n, sa_sint_t * RESTRICT buckets,
-                                                                   sa_sint_t left_suffixes_count, sa_sint_t d,
-                                                                   sa_sint_t threads,
-                                                                   LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    sa_sint_t * RESTRICT induction_bucket = &buckets[4 * ALPHABET_SIZE];
-    sa_sint_t * RESTRICT distinct_names = &buckets[2 * ALPHABET_SIZE];
-
-    SA[induction_bucket[BUCKETS_INDEX2(T[n - 1], T[n - 2] >= T[n - 1])]++] = (n - 1) | SAINT_MIN;
-    distinct_names[BUCKETS_INDEX2(T[n - 1], T[n - 2] >= T[n - 1])] = ++d;
-
-    if (threads == 1 || left_suffixes_count < 65536) {
-        d = libsais_partial_sorting_scan_left_to_right_8u(T, SA, buckets, d, 0, left_suffixes_count);
-    }
-    (void)(thread_state);
-    return d;
-}
-
-static sa_sint_t libsais_partial_sorting_scan_left_to_right_32s_6k(const sa_sint_t * RESTRICT T,
-                                                                   sa_sint_t * RESTRICT SA,
-                                                                   sa_sint_t * RESTRICT buckets, sa_sint_t d,
-                                                                   fast_sint_t omp_block_start,
-                                                                   fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j;
-    for (i = omp_block_start, j = omp_block_start + omp_block_size - 2 * prefetch_distance - 1; i < j; i += 2) {
-        prefetch(&SA[i + 3 * prefetch_distance]);
-
-        prefetch(&T[SA[i + 2 * prefetch_distance + 0] & SAINT_MAX] - 1);
-        prefetch(&T[SA[i + 2 * prefetch_distance + 0] & SAINT_MAX] - 2);
-        prefetch(&T[SA[i + 2 * prefetch_distance + 1] & SAINT_MAX] - 1);
-        prefetch(&T[SA[i + 2 * prefetch_distance + 1] & SAINT_MAX] - 2);
-
-        sa_sint_t p0 = SA[i + prefetch_distance + 0] & SAINT_MAX;
-        sa_sint_t v0 = BUCKETS_INDEX4(T[p0 - (p0 > 0)], 0);
-        prefetchw(&buckets[v0]);
-        sa_sint_t p1 = SA[i + prefetch_distance + 1] & SAINT_MAX;
-        sa_sint_t v1 = BUCKETS_INDEX4(T[p1 - (p1 > 0)], 0);
-        prefetchw(&buckets[v1]);
-
-        sa_sint_t p2 = SA[i + 0];
-        d += (p2 < 0);
-        p2 &= SAINT_MAX;
-        sa_sint_t v2 = BUCKETS_INDEX4(T[p2 - 1], T[p2 - 2] >= T[p2 - 1]);
-        SA[buckets[v2]++] = (p2 - 1) | ((sa_sint_t)(buckets[2 + v2] != d) << (SAINT_BIT - 1));
-        buckets[2 + v2] = d;
-
-        sa_sint_t p3 = SA[i + 1];
-        d += (p3 < 0);
-        p3 &= SAINT_MAX;
-        sa_sint_t v3 = BUCKETS_INDEX4(T[p3 - 1], T[p3 - 2] >= T[p3 - 1]);
-        SA[buckets[v3]++] = (p3 - 1) | ((sa_sint_t)(buckets[2 + v3] != d) << (SAINT_BIT - 1));
-        buckets[2 + v3] = d;
-    }
-
-    for (j += 2 * prefetch_distance + 1; i < j; i += 1) {
-        sa_sint_t p = SA[i];
-        d += (p < 0);
-        p &= SAINT_MAX;
-        sa_sint_t v = BUCKETS_INDEX4(T[p - 1], T[p - 2] >= T[p - 1]);
-        SA[buckets[v]++] = (p - 1) | ((sa_sint_t)(buckets[2 + v] != d) << (SAINT_BIT - 1));
-        buckets[2 + v] = d;
-    }
-
-    return d;
-}
-
-static sa_sint_t libsais_partial_sorting_scan_left_to_right_32s_4k(const sa_sint_t * RESTRICT T,
-                                                                   sa_sint_t * RESTRICT SA, sa_sint_t k,
-                                                                   sa_sint_t * RESTRICT buckets, sa_sint_t d,
-                                                                   fast_sint_t omp_block_start,
-                                                                   fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    sa_sint_t * RESTRICT induction_bucket = &buckets[2 * k];
-    sa_sint_t * RESTRICT distinct_names = &buckets[0 * k];
-
-    fast_sint_t i, j;
-    for (i = omp_block_start, j = omp_block_start + omp_block_size - 2 * prefetch_distance - 1; i < j; i += 2) {
-        prefetchw(&SA[i + 3 * prefetch_distance]);
-
-        sa_sint_t s0 = SA[i + 2 * prefetch_distance + 0];
-        const sa_sint_t * Ts0 = &T[s0 & ~SUFFIX_GROUP_MARKER] - 1;
-        prefetch(s0 > 0 ? Ts0 : NULL);
-        Ts0--;
-        prefetch(s0 > 0 ? Ts0 : NULL);
-        sa_sint_t s1 = SA[i + 2 * prefetch_distance + 1];
-        const sa_sint_t * Ts1 = &T[s1 & ~SUFFIX_GROUP_MARKER] - 1;
-        prefetch(s1 > 0 ? Ts1 : NULL);
-        Ts1--;
-        prefetch(s1 > 0 ? Ts1 : NULL);
-        sa_sint_t s2 = SA[i + 1 * prefetch_distance + 0];
-        if (s2 > 0) {
-            const fast_sint_t Ts2 = T[(s2 & ~SUFFIX_GROUP_MARKER) - 1];
-            prefetchw(&induction_bucket[Ts2]);
-            prefetchw(&distinct_names[BUCKETS_INDEX2(Ts2, 0)]);
-        }
-        sa_sint_t s3 = SA[i + 1 * prefetch_distance + 1];
-        if (s3 > 0) {
-            const fast_sint_t Ts3 = T[(s3 & ~SUFFIX_GROUP_MARKER) - 1];
-            prefetchw(&induction_bucket[Ts3]);
-            prefetchw(&distinct_names[BUCKETS_INDEX2(Ts3, 0)]);
-        }
-
-        sa_sint_t p0 = SA[i + 0];
-        SA[i + 0] = p0 & SAINT_MAX;
-        if (p0 > 0) {
-            SA[i + 0] = 0;
-            d += (p0 >> (SUFFIX_GROUP_BIT - 1));
-            p0 &= ~SUFFIX_GROUP_MARKER;
-            sa_sint_t v0 = BUCKETS_INDEX2(T[p0 - 1], T[p0 - 2] < T[p0 - 1]);
-            SA[induction_bucket[T[p0 - 1]]++] = (p0 - 1) | ((sa_sint_t)(T[p0 - 2] < T[p0 - 1]) << (SAINT_BIT - 1)) |
-                                                ((sa_sint_t)(distinct_names[v0] != d) << (SUFFIX_GROUP_BIT - 1));
-            distinct_names[v0] = d;
-        }
-
-        sa_sint_t p1 = SA[i + 1];
-        SA[i + 1] = p1 & SAINT_MAX;
-        if (p1 > 0) {
-            SA[i + 1] = 0;
-            d += (p1 >> (SUFFIX_GROUP_BIT - 1));
-            p1 &= ~SUFFIX_GROUP_MARKER;
-            sa_sint_t v1 = BUCKETS_INDEX2(T[p1 - 1], T[p1 - 2] < T[p1 - 1]);
-            SA[induction_bucket[T[p1 - 1]]++] = (p1 - 1) | ((sa_sint_t)(T[p1 - 2] < T[p1 - 1]) << (SAINT_BIT - 1)) |
-                                                ((sa_sint_t)(distinct_names[v1] != d) << (SUFFIX_GROUP_BIT - 1));
-            distinct_names[v1] = d;
-        }
-    }
-
-    for (j += 2 * prefetch_distance + 1; i < j; i += 1) {
-        sa_sint_t p = SA[i];
-        SA[i] = p & SAINT_MAX;
-        if (p > 0) {
-            SA[i] = 0;
-            d += (p >> (SUFFIX_GROUP_BIT - 1));
-            p &= ~SUFFIX_GROUP_MARKER;
-            sa_sint_t v = BUCKETS_INDEX2(T[p - 1], T[p - 2] < T[p - 1]);
-            SA[induction_bucket[T[p - 1]]++] = (p - 1) | ((sa_sint_t)(T[p - 2] < T[p - 1]) << (SAINT_BIT - 1)) |
-                                               ((sa_sint_t)(distinct_names[v] != d) << (SUFFIX_GROUP_BIT - 1));
-            distinct_names[v] = d;
-        }
-    }
-
-    return d;
-}
-
-static void libsais_partial_sorting_scan_left_to_right_32s_1k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                              sa_sint_t * RESTRICT induction_bucket,
-                                                              fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j;
-    for (i = omp_block_start, j = omp_block_start + omp_block_size - 2 * prefetch_distance - 1; i < j; i += 2) {
-        prefetchw(&SA[i + 3 * prefetch_distance]);
-
-        sa_sint_t s0 = SA[i + 2 * prefetch_distance + 0];
-        const sa_sint_t * Ts0 = &T[s0] - 1;
-        prefetch(s0 > 0 ? Ts0 : NULL);
-        sa_sint_t s1 = SA[i + 2 * prefetch_distance + 1];
-        const sa_sint_t * Ts1 = &T[s1] - 1;
-        prefetch(s1 > 0 ? Ts1 : NULL);
-        sa_sint_t s2 = SA[i + 1 * prefetch_distance + 0];
-        if (s2 > 0) {
-            prefetchw(&induction_bucket[T[s2 - 1]]);
-            prefetch(&T[s2] - 2);
-        }
-        sa_sint_t s3 = SA[i + 1 * prefetch_distance + 1];
-        if (s3 > 0) {
-            prefetchw(&induction_bucket[T[s3 - 1]]);
-            prefetch(&T[s3] - 2);
-        }
-
-        sa_sint_t p0 = SA[i + 0];
-        SA[i + 0] = p0 & SAINT_MAX;
-        if (p0 > 0) {
-            SA[i + 0] = 0;
-            SA[induction_bucket[T[p0 - 1]]++] = (p0 - 1) | ((sa_sint_t)(T[p0 - 2] < T[p0 - 1]) << (SAINT_BIT - 1));
-        }
-        sa_sint_t p1 = SA[i + 1];
-        SA[i + 1] = p1 & SAINT_MAX;
-        if (p1 > 0) {
-            SA[i + 1] = 0;
-            SA[induction_bucket[T[p1 - 1]]++] = (p1 - 1) | ((sa_sint_t)(T[p1 - 2] < T[p1 - 1]) << (SAINT_BIT - 1));
-        }
-    }
-
-    for (j += 2 * prefetch_distance + 1; i < j; i += 1) {
-        sa_sint_t p = SA[i];
-        SA[i] = p & SAINT_MAX;
-        if (p > 0) {
-            SA[i] = 0;
-            SA[induction_bucket[T[p - 1]]++] = (p - 1) | ((sa_sint_t)(T[p - 2] < T[p - 1]) << (SAINT_BIT - 1));
-        }
-    }
-}
-static sa_sint_t libsais_partial_sorting_scan_left_to_right_32s_6k_omp(
-    const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t * RESTRICT buckets,
-    sa_sint_t left_suffixes_count, sa_sint_t d, sa_sint_t threads, LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    SA[buckets[BUCKETS_INDEX4(T[n - 1], T[n - 2] >= T[n - 1])]++] = (n - 1) | SAINT_MIN;
-    buckets[2 + BUCKETS_INDEX4(T[n - 1], T[n - 2] >= T[n - 1])] = ++d;
-
-    if (threads == 1 || left_suffixes_count < 65536) {
-        d = libsais_partial_sorting_scan_left_to_right_32s_6k(T, SA, buckets, d, 0, left_suffixes_count);
-    }
-    (void)(thread_state);
-    return d;
-}
-
-static sa_sint_t libsais_partial_sorting_scan_left_to_right_32s_4k_omp(const sa_sint_t * RESTRICT T,
-                                                                       sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                                       sa_sint_t k, sa_sint_t * RESTRICT buckets,
-                                                                       sa_sint_t d, sa_sint_t threads,
-                                                                       LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    sa_sint_t * RESTRICT induction_bucket = &buckets[2 * k];
-    sa_sint_t * RESTRICT distinct_names = &buckets[0 * k];
-
-    SA[induction_bucket[T[n - 1]]++] =
-        (n - 1) | ((sa_sint_t)(T[n - 2] < T[n - 1]) << (SAINT_BIT - 1)) | SUFFIX_GROUP_MARKER;
-    distinct_names[BUCKETS_INDEX2(T[n - 1], T[n - 2] < T[n - 1])] = ++d;
-
-    if (threads == 1 || n < 65536) {
-        d = libsais_partial_sorting_scan_left_to_right_32s_4k(T, SA, k, buckets, d, 0, n);
-    }
-    (void)(thread_state);
-    return d;
-}
-
-static void libsais_partial_sorting_scan_left_to_right_32s_1k_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                                  sa_sint_t n, sa_sint_t * RESTRICT buckets,
-                                                                  sa_sint_t threads,
-                                                                  LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    SA[buckets[T[n - 1]]++] = (n - 1) | ((sa_sint_t)(T[n - 2] < T[n - 1]) << (SAINT_BIT - 1));
-
-    if (threads == 1 || n < 65536) {
-        libsais_partial_sorting_scan_left_to_right_32s_1k(T, SA, buckets, 0, n);
-    }
-    (void)(thread_state);
-}
-
-static void libsais_partial_sorting_shift_markers_8u_omp(sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                         const sa_sint_t * RESTRICT buckets, sa_sint_t threads) {
-    const fast_sint_t prefetch_distance = 32;
-
-    const sa_sint_t * RESTRICT temp_bucket = &buckets[4 * ALPHABET_SIZE];
-
-    fast_sint_t c;
-    (void)(threads);
-    (void)(n);
-
-    for (c = BUCKETS_INDEX2(ALPHABET_SIZE - 1, 0); c >= BUCKETS_INDEX2(1, 0); c -= BUCKETS_INDEX2(1, 0)) {
-        fast_sint_t i, j;
-        sa_sint_t s = SAINT_MIN;
-        for (i = (fast_sint_t)temp_bucket[c] - 1, j = (fast_sint_t)buckets[c - BUCKETS_INDEX2(1, 0)] + 3; i >= j;
-             i -= 4) {
-            prefetchw(&SA[i - prefetch_distance]);
-
-            sa_sint_t p0 = SA[i - 0], q0 = (p0 & SAINT_MIN) ^ s;
-            s = s ^ q0;
-            SA[i - 0] = p0 ^ q0;
-            sa_sint_t p1 = SA[i - 1], q1 = (p1 & SAINT_MIN) ^ s;
-            s = s ^ q1;
-            SA[i - 1] = p1 ^ q1;
-            sa_sint_t p2 = SA[i - 2], q2 = (p2 & SAINT_MIN) ^ s;
-            s = s ^ q2;
-            SA[i - 2] = p2 ^ q2;
-            sa_sint_t p3 = SA[i - 3], q3 = (p3 & SAINT_MIN) ^ s;
-            s = s ^ q3;
-            SA[i - 3] = p3 ^ q3;
-        }
-
-        for (j -= 3; i >= j; i -= 1) {
-            sa_sint_t p = SA[i], q = (p & SAINT_MIN) ^ s;
-            s = s ^ q;
-            SA[i] = p ^ q;
-        }
-    }
-}
-
-static void libsais_partial_sorting_shift_markers_32s_6k_omp(sa_sint_t * RESTRICT SA, sa_sint_t k,
-                                                             const sa_sint_t * RESTRICT buckets, sa_sint_t threads) {
-    const fast_sint_t prefetch_distance = 32;
-
-    const sa_sint_t * RESTRICT temp_bucket = &buckets[4 * k];
-
-    fast_sint_t c;
-    (void)(threads);
-
-    for (c = (fast_sint_t)k - 1; c >= 1; c -= 1) {
-        fast_sint_t i, j;
-        sa_sint_t s = SAINT_MIN;
-        for (i = (fast_sint_t)buckets[BUCKETS_INDEX4(c, 0)] - 1,
-            j = (fast_sint_t)temp_bucket[BUCKETS_INDEX2(c - 1, 0)] + 3;
-             i >= j; i -= 4) {
-            prefetchw(&SA[i - prefetch_distance]);
-
-            sa_sint_t p0 = SA[i - 0], q0 = (p0 & SAINT_MIN) ^ s;
-            s = s ^ q0;
-            SA[i - 0] = p0 ^ q0;
-            sa_sint_t p1 = SA[i - 1], q1 = (p1 & SAINT_MIN) ^ s;
-            s = s ^ q1;
-            SA[i - 1] = p1 ^ q1;
-            sa_sint_t p2 = SA[i - 2], q2 = (p2 & SAINT_MIN) ^ s;
-            s = s ^ q2;
-            SA[i - 2] = p2 ^ q2;
-            sa_sint_t p3 = SA[i - 3], q3 = (p3 & SAINT_MIN) ^ s;
-            s = s ^ q3;
-            SA[i - 3] = p3 ^ q3;
-        }
-
-        for (j -= 3; i >= j; i -= 1) {
-            sa_sint_t p = SA[i], q = (p & SAINT_MIN) ^ s;
-            s = s ^ q;
-            SA[i] = p ^ q;
-        }
-    }
-}
-
-static void libsais_partial_sorting_shift_markers_32s_4k(sa_sint_t * RESTRICT SA, sa_sint_t n) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i;
-    sa_sint_t s = SUFFIX_GROUP_MARKER;
-    for (i = (fast_sint_t)n - 1; i >= 3; i -= 4) {
-        prefetchw(&SA[i - prefetch_distance]);
-
-        sa_sint_t p0 = SA[i - 0],
-                  q0 = ((p0 & SUFFIX_GROUP_MARKER) ^ s) & ((sa_sint_t)(p0 > 0) << ((SUFFIX_GROUP_BIT - 1)));
-        s = s ^ q0;
-        SA[i - 0] = p0 ^ q0;
-        sa_sint_t p1 = SA[i - 1],
-                  q1 = ((p1 & SUFFIX_GROUP_MARKER) ^ s) & ((sa_sint_t)(p1 > 0) << ((SUFFIX_GROUP_BIT - 1)));
-        s = s ^ q1;
-        SA[i - 1] = p1 ^ q1;
-        sa_sint_t p2 = SA[i - 2],
-                  q2 = ((p2 & SUFFIX_GROUP_MARKER) ^ s) & ((sa_sint_t)(p2 > 0) << ((SUFFIX_GROUP_BIT - 1)));
-        s = s ^ q2;
-        SA[i - 2] = p2 ^ q2;
-        sa_sint_t p3 = SA[i - 3],
-                  q3 = ((p3 & SUFFIX_GROUP_MARKER) ^ s) & ((sa_sint_t)(p3 > 0) << ((SUFFIX_GROUP_BIT - 1)));
-        s = s ^ q3;
-        SA[i - 3] = p3 ^ q3;
-    }
-
-    for (; i >= 0; i -= 1) {
-        sa_sint_t p = SA[i], q = ((p & SUFFIX_GROUP_MARKER) ^ s) & ((sa_sint_t)(p > 0) << ((SUFFIX_GROUP_BIT - 1)));
-        s = s ^ q;
-        SA[i] = p ^ q;
-    }
-}
-
-static void libsais_partial_sorting_shift_buckets_32s_6k(sa_sint_t k, sa_sint_t * RESTRICT buckets) {
-    sa_sint_t * RESTRICT temp_bucket = &buckets[4 * k];
-
-    fast_sint_t i;
-    for (i = BUCKETS_INDEX2(0, 0); i <= BUCKETS_INDEX2((fast_sint_t)k - 1, 0); i += BUCKETS_INDEX2(1, 0)) {
-        buckets[2 * i + BUCKETS_INDEX4(0, 0)] = temp_bucket[i + BUCKETS_INDEX2(0, 0)];
-        buckets[2 * i + BUCKETS_INDEX4(0, 1)] = temp_bucket[i + BUCKETS_INDEX2(0, 1)];
-    }
-}
-
-static sa_sint_t libsais_partial_sorting_scan_right_to_left_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                               sa_sint_t * RESTRICT buckets, sa_sint_t d,
-                                                               fast_sint_t omp_block_start,
-                                                               fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    sa_sint_t * RESTRICT induction_bucket = &buckets[0 * ALPHABET_SIZE];
-    sa_sint_t * RESTRICT distinct_names = &buckets[2 * ALPHABET_SIZE];
-
-    fast_sint_t i, j;
-    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + prefetch_distance + 1; i >= j; i -= 2) {
-        prefetch(&SA[i - 2 * prefetch_distance]);
-
-        prefetch(&T[SA[i - prefetch_distance - 0] & SAINT_MAX] - 1);
-        prefetch(&T[SA[i - prefetch_distance - 0] & SAINT_MAX] - 2);
-        prefetch(&T[SA[i - prefetch_distance - 1] & SAINT_MAX] - 1);
-        prefetch(&T[SA[i - prefetch_distance - 1] & SAINT_MAX] - 2);
-
-        sa_sint_t p0 = SA[i - 0];
-        d += (p0 < 0);
-        p0 &= SAINT_MAX;
-        sa_sint_t v0 = BUCKETS_INDEX2(T[p0 - 1], T[p0 - 2] > T[p0 - 1]);
-        SA[--induction_bucket[v0]] = (p0 - 1) | ((sa_sint_t)(distinct_names[v0] != d) << (SAINT_BIT - 1));
-        distinct_names[v0] = d;
-
-        sa_sint_t p1 = SA[i - 1];
-        d += (p1 < 0);
-        p1 &= SAINT_MAX;
-        sa_sint_t v1 = BUCKETS_INDEX2(T[p1 - 1], T[p1 - 2] > T[p1 - 1]);
-        SA[--induction_bucket[v1]] = (p1 - 1) | ((sa_sint_t)(distinct_names[v1] != d) << (SAINT_BIT - 1));
-        distinct_names[v1] = d;
-    }
-
-    for (j -= prefetch_distance + 1; i >= j; i -= 1) {
-        sa_sint_t p = SA[i];
-        d += (p < 0);
-        p &= SAINT_MAX;
-        sa_sint_t v = BUCKETS_INDEX2(T[p - 1], T[p - 2] > T[p - 1]);
-        SA[--induction_bucket[v]] = (p - 1) | ((sa_sint_t)(distinct_names[v] != d) << (SAINT_BIT - 1));
-        distinct_names[v] = d;
-    }
-
-    return d;
-}
-static void libsais_partial_sorting_scan_right_to_left_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                              sa_sint_t n, sa_sint_t * RESTRICT buckets,
-                                                              sa_sint_t first_lms_suffix, sa_sint_t left_suffixes_count,
-                                                              sa_sint_t d, sa_sint_t threads,
-                                                              LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    fast_sint_t scan_start = (fast_sint_t)left_suffixes_count + 1;
-    fast_sint_t scan_end = (fast_sint_t)n - (fast_sint_t)first_lms_suffix;
-
-    if (threads == 1 || (scan_end - scan_start) < 65536) {
-        libsais_partial_sorting_scan_right_to_left_8u(T, SA, buckets, d, scan_start, scan_end - scan_start);
-    }
-    (void)(thread_state);
-}
-
-static sa_sint_t libsais_partial_sorting_scan_right_to_left_32s_6k(const sa_sint_t * RESTRICT T,
-                                                                   sa_sint_t * RESTRICT SA,
-                                                                   sa_sint_t * RESTRICT buckets, sa_sint_t d,
-                                                                   fast_sint_t omp_block_start,
-                                                                   fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j;
-    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + 2 * prefetch_distance + 1; i >= j; i -= 2) {
-        prefetch(&SA[i - 3 * prefetch_distance]);
-
-        prefetch(&T[SA[i - 2 * prefetch_distance - 0] & SAINT_MAX] - 1);
-        prefetch(&T[SA[i - 2 * prefetch_distance - 0] & SAINT_MAX] - 2);
-        prefetch(&T[SA[i - 2 * prefetch_distance - 1] & SAINT_MAX] - 1);
-        prefetch(&T[SA[i - 2 * prefetch_distance - 1] & SAINT_MAX] - 2);
-
-        sa_sint_t p0 = SA[i - prefetch_distance - 0] & SAINT_MAX;
-        sa_sint_t v0 = BUCKETS_INDEX4(T[p0 - (p0 > 0)], 0);
-        prefetchw(&buckets[v0]);
-        sa_sint_t p1 = SA[i - prefetch_distance - 1] & SAINT_MAX;
-        sa_sint_t v1 = BUCKETS_INDEX4(T[p1 - (p1 > 0)], 0);
-        prefetchw(&buckets[v1]);
-
-        sa_sint_t p2 = SA[i - 0];
-        d += (p2 < 0);
-        p2 &= SAINT_MAX;
-        sa_sint_t v2 = BUCKETS_INDEX4(T[p2 - 1], T[p2 - 2] > T[p2 - 1]);
-        SA[--buckets[v2]] = (p2 - 1) | ((sa_sint_t)(buckets[2 + v2] != d) << (SAINT_BIT - 1));
-        buckets[2 + v2] = d;
-
-        sa_sint_t p3 = SA[i - 1];
-        d += (p3 < 0);
-        p3 &= SAINT_MAX;
-        sa_sint_t v3 = BUCKETS_INDEX4(T[p3 - 1], T[p3 - 2] > T[p3 - 1]);
-        SA[--buckets[v3]] = (p3 - 1) | ((sa_sint_t)(buckets[2 + v3] != d) << (SAINT_BIT - 1));
-        buckets[2 + v3] = d;
-    }
-
-    for (j -= 2 * prefetch_distance + 1; i >= j; i -= 1) {
-        sa_sint_t p = SA[i];
-        d += (p < 0);
-        p &= SAINT_MAX;
-        sa_sint_t v = BUCKETS_INDEX4(T[p - 1], T[p - 2] > T[p - 1]);
-        SA[--buckets[v]] = (p - 1) | ((sa_sint_t)(buckets[2 + v] != d) << (SAINT_BIT - 1));
-        buckets[2 + v] = d;
-    }
-
-    return d;
-}
-
-static sa_sint_t libsais_partial_sorting_scan_right_to_left_32s_4k(const sa_sint_t * RESTRICT T,
-                                                                   sa_sint_t * RESTRICT SA, sa_sint_t k,
-                                                                   sa_sint_t * RESTRICT buckets, sa_sint_t d,
-                                                                   fast_sint_t omp_block_start,
-                                                                   fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    sa_sint_t * RESTRICT induction_bucket = &buckets[3 * k];
-    sa_sint_t * RESTRICT distinct_names = &buckets[0 * k];
-
-    fast_sint_t i, j;
-    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + 2 * prefetch_distance + 1; i >= j; i -= 2) {
-        prefetchw(&SA[i - 3 * prefetch_distance]);
-
-        sa_sint_t s0 = SA[i - 2 * prefetch_distance - 0];
-        const sa_sint_t * Ts0 = &T[s0 & ~SUFFIX_GROUP_MARKER] - 1;
-        prefetch(s0 > 0 ? Ts0 : NULL);
-        Ts0--;
-        prefetch(s0 > 0 ? Ts0 : NULL);
-        sa_sint_t s1 = SA[i - 2 * prefetch_distance - 1];
-        const sa_sint_t * Ts1 = &T[s1 & ~SUFFIX_GROUP_MARKER] - 1;
-        prefetch(s1 > 0 ? Ts1 : NULL);
-        Ts1--;
-        prefetch(s1 > 0 ? Ts1 : NULL);
-        sa_sint_t s2 = SA[i - 1 * prefetch_distance - 0];
-        if (s2 > 0) {
-            const fast_sint_t Ts2 = T[(s2 & ~SUFFIX_GROUP_MARKER) - 1];
-            prefetchw(&induction_bucket[Ts2]);
-            prefetchw(&distinct_names[BUCKETS_INDEX2(Ts2, 0)]);
-        }
-        sa_sint_t s3 = SA[i - 1 * prefetch_distance - 1];
-        if (s3 > 0) {
-            const fast_sint_t Ts3 = T[(s3 & ~SUFFIX_GROUP_MARKER) - 1];
-            prefetchw(&induction_bucket[Ts3]);
-            prefetchw(&distinct_names[BUCKETS_INDEX2(Ts3, 0)]);
-        }
-
-        sa_sint_t p0 = SA[i - 0];
-        if (p0 > 0) {
-            SA[i - 0] = 0;
-            d += (p0 >> (SUFFIX_GROUP_BIT - 1));
-            p0 &= ~SUFFIX_GROUP_MARKER;
-            sa_sint_t v0 = BUCKETS_INDEX2(T[p0 - 1], T[p0 - 2] > T[p0 - 1]);
-            SA[--induction_bucket[T[p0 - 1]]] = (p0 - 1) | ((sa_sint_t)(T[p0 - 2] > T[p0 - 1]) << (SAINT_BIT - 1)) |
-                                                ((sa_sint_t)(distinct_names[v0] != d) << (SUFFIX_GROUP_BIT - 1));
-            distinct_names[v0] = d;
-        }
-
-        sa_sint_t p1 = SA[i - 1];
-        if (p1 > 0) {
-            SA[i - 1] = 0;
-            d += (p1 >> (SUFFIX_GROUP_BIT - 1));
-            p1 &= ~SUFFIX_GROUP_MARKER;
-            sa_sint_t v1 = BUCKETS_INDEX2(T[p1 - 1], T[p1 - 2] > T[p1 - 1]);
-            SA[--induction_bucket[T[p1 - 1]]] = (p1 - 1) | ((sa_sint_t)(T[p1 - 2] > T[p1 - 1]) << (SAINT_BIT - 1)) |
-                                                ((sa_sint_t)(distinct_names[v1] != d) << (SUFFIX_GROUP_BIT - 1));
-            distinct_names[v1] = d;
-        }
-    }
-
-    for (j -= 2 * prefetch_distance + 1; i >= j; i -= 1) {
-        sa_sint_t p = SA[i];
-        if (p > 0) {
-            SA[i] = 0;
-            d += (p >> (SUFFIX_GROUP_BIT - 1));
-            p &= ~SUFFIX_GROUP_MARKER;
-            sa_sint_t v = BUCKETS_INDEX2(T[p - 1], T[p - 2] > T[p - 1]);
-            SA[--induction_bucket[T[p - 1]]] = (p - 1) | ((sa_sint_t)(T[p - 2] > T[p - 1]) << (SAINT_BIT - 1)) |
-                                               ((sa_sint_t)(distinct_names[v] != d) << (SUFFIX_GROUP_BIT - 1));
-            distinct_names[v] = d;
-        }
-    }
-
-    return d;
-}
-
-static void libsais_partial_sorting_scan_right_to_left_32s_1k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                              sa_sint_t * RESTRICT induction_bucket,
-                                                              fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j;
-    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + 2 * prefetch_distance + 1; i >= j; i -= 2) {
-        prefetchw(&SA[i - 3 * prefetch_distance]);
-
-        sa_sint_t s0 = SA[i - 2 * prefetch_distance - 0];
-        const sa_sint_t * Ts0 = &T[s0] - 1;
-        prefetch(s0 > 0 ? Ts0 : NULL);
-        sa_sint_t s1 = SA[i - 2 * prefetch_distance - 1];
-        const sa_sint_t * Ts1 = &T[s1] - 1;
-        prefetch(s1 > 0 ? Ts1 : NULL);
-        sa_sint_t s2 = SA[i - 1 * prefetch_distance - 0];
-        if (s2 > 0) {
-            prefetchw(&induction_bucket[T[s2 - 1]]);
-            prefetch(&T[s2] - 2);
-        }
-        sa_sint_t s3 = SA[i - 1 * prefetch_distance - 1];
-        if (s3 > 0) {
-            prefetchw(&induction_bucket[T[s3 - 1]]);
-            prefetch(&T[s3] - 2);
-        }
-
-        sa_sint_t p0 = SA[i - 0];
-        if (p0 > 0) {
-            SA[i - 0] = 0;
-            SA[--induction_bucket[T[p0 - 1]]] = (p0 - 1) | ((sa_sint_t)(T[p0 - 2] > T[p0 - 1]) << (SAINT_BIT - 1));
-        }
-        sa_sint_t p1 = SA[i - 1];
-        if (p1 > 0) {
-            SA[i - 1] = 0;
-            SA[--induction_bucket[T[p1 - 1]]] = (p1 - 1) | ((sa_sint_t)(T[p1 - 2] > T[p1 - 1]) << (SAINT_BIT - 1));
-        }
-    }
-
-    for (j -= 2 * prefetch_distance + 1; i >= j; i -= 1) {
-        sa_sint_t p = SA[i];
-        if (p > 0) {
-            SA[i] = 0;
-            SA[--induction_bucket[T[p - 1]]] = (p - 1) | ((sa_sint_t)(T[p - 2] > T[p - 1]) << (SAINT_BIT - 1));
-        }
-    }
-}
-static sa_sint_t libsais_partial_sorting_scan_right_to_left_32s_6k_omp(
-    const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t * RESTRICT buckets,
-    sa_sint_t first_lms_suffix, sa_sint_t left_suffixes_count, sa_sint_t d, sa_sint_t threads,
-    LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    fast_sint_t scan_start = (fast_sint_t)left_suffixes_count + 1;
-    fast_sint_t scan_end = (fast_sint_t)n - (fast_sint_t)first_lms_suffix;
-
-    if (threads == 1 || (scan_end - scan_start) < 65536) {
-        d = libsais_partial_sorting_scan_right_to_left_32s_6k(T, SA, buckets, d, scan_start, scan_end - scan_start);
-    }
-    (void)(thread_state);
-    return d;
-}
-
-static sa_sint_t libsais_partial_sorting_scan_right_to_left_32s_4k_omp(const sa_sint_t * RESTRICT T,
-                                                                       sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                                       sa_sint_t k, sa_sint_t * RESTRICT buckets,
-                                                                       sa_sint_t d, sa_sint_t threads,
-                                                                       LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    if (threads == 1 || n < 65536) {
-        d = libsais_partial_sorting_scan_right_to_left_32s_4k(T, SA, k, buckets, d, 0, n);
-    }
-    (void)(thread_state);
-    return d;
-}
-
-static void libsais_partial_sorting_scan_right_to_left_32s_1k_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                                  sa_sint_t n, sa_sint_t * RESTRICT buckets,
-                                                                  sa_sint_t threads,
-                                                                  LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    if (threads == 1 || n < 65536) {
-        libsais_partial_sorting_scan_right_to_left_32s_1k(T, SA, buckets, 0, n);
-    }
-    (void)(thread_state);
-}
-
-static fast_sint_t libsais_partial_sorting_gather_lms_suffixes_32s_4k(sa_sint_t * RESTRICT SA,
-                                                                      fast_sint_t omp_block_start,
-                                                                      fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j, l;
-    for (i = omp_block_start, j = omp_block_start + omp_block_size - 3, l = omp_block_start; i < j; i += 4) {
-        prefetch(&SA[i + prefetch_distance]);
-
-        sa_sint_t s0 = SA[i + 0];
-        SA[l] = (s0 - SUFFIX_GROUP_MARKER) & (~SUFFIX_GROUP_MARKER);
-        l += (s0 < 0);
-        sa_sint_t s1 = SA[i + 1];
-        SA[l] = (s1 - SUFFIX_GROUP_MARKER) & (~SUFFIX_GROUP_MARKER);
-        l += (s1 < 0);
-        sa_sint_t s2 = SA[i + 2];
-        SA[l] = (s2 - SUFFIX_GROUP_MARKER) & (~SUFFIX_GROUP_MARKER);
-        l += (s2 < 0);
-        sa_sint_t s3 = SA[i + 3];
-        SA[l] = (s3 - SUFFIX_GROUP_MARKER) & (~SUFFIX_GROUP_MARKER);
-        l += (s3 < 0);
-    }
-
-    for (j += 3; i < j; i += 1) {
-        sa_sint_t s = SA[i];
-        SA[l] = (s - SUFFIX_GROUP_MARKER) & (~SUFFIX_GROUP_MARKER);
-        l += (s < 0);
-    }
-
-    return l;
-}
-
-static fast_sint_t libsais_partial_sorting_gather_lms_suffixes_32s_1k(sa_sint_t * RESTRICT SA,
-                                                                      fast_sint_t omp_block_start,
-                                                                      fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j, l;
-    for (i = omp_block_start, j = omp_block_start + omp_block_size - 3, l = omp_block_start; i < j; i += 4) {
-        prefetch(&SA[i + prefetch_distance]);
-
-        sa_sint_t s0 = SA[i + 0];
-        SA[l] = s0 & SAINT_MAX;
-        l += (s0 < 0);
-        sa_sint_t s1 = SA[i + 1];
-        SA[l] = s1 & SAINT_MAX;
-        l += (s1 < 0);
-        sa_sint_t s2 = SA[i + 2];
-        SA[l] = s2 & SAINT_MAX;
-        l += (s2 < 0);
-        sa_sint_t s3 = SA[i + 3];
-        SA[l] = s3 & SAINT_MAX;
-        l += (s3 < 0);
-    }
-
-    for (j += 3; i < j; i += 1) {
-        sa_sint_t s = SA[i];
-        SA[l] = s & SAINT_MAX;
-        l += (s < 0);
-    }
-
-    return l;
-}
-
-static void libsais_partial_sorting_gather_lms_suffixes_32s_4k_omp(sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                                   sa_sint_t threads,
-                                                                   LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    {
-        (void)(threads);
-        (void)(thread_state);
-
-        fast_sint_t omp_thread_num = 0;
-        fast_sint_t omp_num_threads = 1;
-
-        fast_sint_t omp_block_stride = (n / omp_num_threads) & (-16);
-        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
-        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : n - omp_block_start;
-
-        if (omp_num_threads == 1) {
-            libsais_partial_sorting_gather_lms_suffixes_32s_4k(SA, omp_block_start, omp_block_size);
-        }
-    }
-}
-
-static void libsais_partial_sorting_gather_lms_suffixes_32s_1k_omp(sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                                   sa_sint_t threads,
-                                                                   LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    {
-        (void)(threads);
-        (void)(thread_state);
-
-        fast_sint_t omp_thread_num = 0;
-        fast_sint_t omp_num_threads = 1;
-
-        fast_sint_t omp_block_stride = (n / omp_num_threads) & (-16);
-        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
-        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : n - omp_block_start;
-
-        if (omp_num_threads == 1) {
-            libsais_partial_sorting_gather_lms_suffixes_32s_1k(SA, omp_block_start, omp_block_size);
-        }
-    }
-}
-
-static void libsais_induce_partial_order_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                sa_sint_t * RESTRICT buckets, sa_sint_t first_lms_suffix,
-                                                sa_sint_t left_suffixes_count, sa_sint_t threads,
-                                                LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    memset(&buckets[2 * ALPHABET_SIZE], 0, 2 * ALPHABET_SIZE * sizeof(sa_sint_t));
-
-    sa_sint_t d = libsais_partial_sorting_scan_left_to_right_8u_omp(T, SA, n, buckets, left_suffixes_count, 0, threads,
-                                                                    thread_state);
-    libsais_partial_sorting_shift_markers_8u_omp(SA, n, buckets, threads);
-    libsais_partial_sorting_scan_right_to_left_8u_omp(T, SA, n, buckets, first_lms_suffix, left_suffixes_count, d,
-                                                      threads, thread_state);
-}
-
-static void libsais_induce_partial_order_32s_6k_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                    sa_sint_t k, sa_sint_t * RESTRICT buckets,
-                                                    sa_sint_t first_lms_suffix, sa_sint_t left_suffixes_count,
-                                                    sa_sint_t threads, LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    sa_sint_t d = libsais_partial_sorting_scan_left_to_right_32s_6k_omp(T, SA, n, buckets, left_suffixes_count, 0,
-                                                                        threads, thread_state);
-    libsais_partial_sorting_shift_markers_32s_6k_omp(SA, k, buckets, threads);
-    libsais_partial_sorting_shift_buckets_32s_6k(k, buckets);
-    libsais_partial_sorting_scan_right_to_left_32s_6k_omp(T, SA, n, buckets, first_lms_suffix, left_suffixes_count, d,
-                                                          threads, thread_state);
-}
-
-static void libsais_induce_partial_order_32s_4k_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                    sa_sint_t k, sa_sint_t * RESTRICT buckets, sa_sint_t threads,
-                                                    LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    memset(buckets, 0, 2 * (size_t)k * sizeof(sa_sint_t));
-
-    sa_sint_t d = libsais_partial_sorting_scan_left_to_right_32s_4k_omp(T, SA, n, k, buckets, 0, threads, thread_state);
-    libsais_partial_sorting_shift_markers_32s_4k(SA, n);
-    libsais_partial_sorting_scan_right_to_left_32s_4k_omp(T, SA, n, k, buckets, d, threads, thread_state);
-    libsais_partial_sorting_gather_lms_suffixes_32s_4k_omp(SA, n, threads, thread_state);
-}
-
-static void libsais_induce_partial_order_32s_2k_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                    sa_sint_t k, sa_sint_t * RESTRICT buckets, sa_sint_t threads,
-                                                    LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    libsais_partial_sorting_scan_left_to_right_32s_1k_omp(T, SA, n, &buckets[1 * k], threads, thread_state);
-    libsais_partial_sorting_scan_right_to_left_32s_1k_omp(T, SA, n, &buckets[0 * k], threads, thread_state);
-    libsais_partial_sorting_gather_lms_suffixes_32s_1k_omp(SA, n, threads, thread_state);
-}
-
-static void libsais_induce_partial_order_32s_1k_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                    sa_sint_t k, sa_sint_t * RESTRICT buckets, sa_sint_t threads,
-                                                    LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    libsais_count_suffixes_32s(T, n, k, buckets);
-    libsais_initialize_buckets_start_32s_1k(k, buckets);
-    libsais_partial_sorting_scan_left_to_right_32s_1k_omp(T, SA, n, buckets, threads, thread_state);
-
-    libsais_count_suffixes_32s(T, n, k, buckets);
-    libsais_initialize_buckets_end_32s_1k(k, buckets);
-    libsais_partial_sorting_scan_right_to_left_32s_1k_omp(T, SA, n, buckets, threads, thread_state);
-
-    libsais_partial_sorting_gather_lms_suffixes_32s_1k_omp(SA, n, threads, thread_state);
-}
-
-static sa_sint_t libsais_renumber_lms_suffixes_8u(sa_sint_t * RESTRICT SA, sa_sint_t m, sa_sint_t name,
-                                                  fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    sa_sint_t * RESTRICT SAm = &SA[m];
-
-    fast_sint_t i, j;
-    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 3; i < j; i += 4) {
-        prefetch(&SA[i + 2 * prefetch_distance]);
-
-        prefetchw(&SAm[(SA[i + prefetch_distance + 0] & SAINT_MAX) >> 1]);
-        prefetchw(&SAm[(SA[i + prefetch_distance + 1] & SAINT_MAX) >> 1]);
-        prefetchw(&SAm[(SA[i + prefetch_distance + 2] & SAINT_MAX) >> 1]);
-        prefetchw(&SAm[(SA[i + prefetch_distance + 3] & SAINT_MAX) >> 1]);
-
-        sa_sint_t p0 = SA[i + 0];
-        SAm[(p0 & SAINT_MAX) >> 1] = name | SAINT_MIN;
-        name += p0 < 0;
-        sa_sint_t p1 = SA[i + 1];
-        SAm[(p1 & SAINT_MAX) >> 1] = name | SAINT_MIN;
-        name += p1 < 0;
-        sa_sint_t p2 = SA[i + 2];
-        SAm[(p2 & SAINT_MAX) >> 1] = name | SAINT_MIN;
-        name += p2 < 0;
-        sa_sint_t p3 = SA[i + 3];
-        SAm[(p3 & SAINT_MAX) >> 1] = name | SAINT_MIN;
-        name += p3 < 0;
-    }
-
-    for (j += prefetch_distance + 3; i < j; i += 1) {
-        sa_sint_t p = SA[i];
-        SAm[(p & SAINT_MAX) >> 1] = name | SAINT_MIN;
-        name += p < 0;
-    }
-
-    return name;
-}
-
-static fast_sint_t libsais_gather_marked_suffixes_8u(sa_sint_t * RESTRICT SA, sa_sint_t m, fast_sint_t l,
-                                                     fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    l -= 1;
-
-    fast_sint_t i, j;
-    for (i = (fast_sint_t)m + omp_block_start + omp_block_size - 1, j = (fast_sint_t)m + omp_block_start + 3; i >= j;
-         i -= 4) {
-        prefetch(&SA[i - prefetch_distance]);
-
-        sa_sint_t s0 = SA[i - 0];
-        SA[l] = s0 & SAINT_MAX;
-        l -= s0 < 0;
-        sa_sint_t s1 = SA[i - 1];
-        SA[l] = s1 & SAINT_MAX;
-        l -= s1 < 0;
-        sa_sint_t s2 = SA[i - 2];
-        SA[l] = s2 & SAINT_MAX;
-        l -= s2 < 0;
-        sa_sint_t s3 = SA[i - 3];
-        SA[l] = s3 & SAINT_MAX;
-        l -= s3 < 0;
-    }
-
-    for (j -= 3; i >= j; i -= 1) {
-        sa_sint_t s = SA[i];
-        SA[l] = s & SAINT_MAX;
-        l -= s < 0;
-    }
-
-    l += 1;
-
-    return l;
-}
-
-static sa_sint_t libsais_renumber_lms_suffixes_8u_omp(sa_sint_t * RESTRICT SA, sa_sint_t m, sa_sint_t threads,
-                                                      LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    sa_sint_t name = 0;
-    {
-        (void)(threads);
-        (void)(thread_state);
-
-        fast_sint_t omp_thread_num = 0;
-        fast_sint_t omp_num_threads = 1;
-
-        fast_sint_t omp_block_stride = (m / omp_num_threads) & (-16);
-        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
-        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : m - omp_block_start;
-
-        if (omp_num_threads == 1) {
-            name = libsais_renumber_lms_suffixes_8u(SA, m, 0, omp_block_start, omp_block_size);
-        }
-    }
-
-    return name;
-}
-
-static void libsais_gather_marked_lms_suffixes_8u_omp(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m, sa_sint_t fs,
-                                                      sa_sint_t threads, LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    {
-        (void)(threads);
-        (void)(thread_state);
-
-        fast_sint_t omp_thread_num = 0;
-        fast_sint_t omp_num_threads = 1;
-
-        fast_sint_t omp_block_stride = (((fast_sint_t)n >> 1) / omp_num_threads) & (-16);
-        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
-        fast_sint_t omp_block_size =
-            omp_thread_num < omp_num_threads - 1 ? omp_block_stride : ((fast_sint_t)n >> 1) - omp_block_start;
-
-        if (omp_num_threads == 1) {
-            libsais_gather_marked_suffixes_8u(SA, m, (fast_sint_t)n + (fast_sint_t)fs, omp_block_start, omp_block_size);
-        }
-    }
-}
-
-static sa_sint_t libsais_renumber_and_gather_lms_suffixes_8u_omp(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m,
-                                                                 sa_sint_t fs, sa_sint_t threads,
-                                                                 LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    memset(&SA[m], 0, ((size_t)n >> 1) * sizeof(sa_sint_t));
-
-    sa_sint_t name = libsais_renumber_lms_suffixes_8u_omp(SA, m, threads, thread_state);
-    if (name < m) {
-        libsais_gather_marked_lms_suffixes_8u_omp(SA, n, m, fs, threads, thread_state);
-    } else {
-        fast_sint_t i;
-        for (i = 0; i < m; i += 1) {
-            SA[i] &= SAINT_MAX;
-        }
-    }
-
-    return name;
-}
-
-static sa_sint_t libsais_renumber_distinct_lms_suffixes_32s_4k(sa_sint_t * RESTRICT SA, sa_sint_t m, sa_sint_t name,
-                                                               fast_sint_t omp_block_start,
-                                                               fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    sa_sint_t * RESTRICT SAm = &SA[m];
-
-    fast_sint_t i, j;
-    sa_sint_t p0, p1, p2, p3 = 0;
-    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 3; i < j; i += 4) {
-        prefetchw(&SA[i + 2 * prefetch_distance]);
-
-        prefetchw(&SAm[(SA[i + prefetch_distance + 0] & SAINT_MAX) >> 1]);
-        prefetchw(&SAm[(SA[i + prefetch_distance + 1] & SAINT_MAX) >> 1]);
-        prefetchw(&SAm[(SA[i + prefetch_distance + 2] & SAINT_MAX) >> 1]);
-        prefetchw(&SAm[(SA[i + prefetch_distance + 3] & SAINT_MAX) >> 1]);
-
-        p0 = SA[i + 0];
-        SAm[(SA[i + 0] = p0 & SAINT_MAX) >> 1] = name | (p0 & p3 & SAINT_MIN);
-        name += p0 < 0;
-        p1 = SA[i + 1];
-        SAm[(SA[i + 1] = p1 & SAINT_MAX) >> 1] = name | (p1 & p0 & SAINT_MIN);
-        name += p1 < 0;
-        p2 = SA[i + 2];
-        SAm[(SA[i + 2] = p2 & SAINT_MAX) >> 1] = name | (p2 & p1 & SAINT_MIN);
-        name += p2 < 0;
-        p3 = SA[i + 3];
-        SAm[(SA[i + 3] = p3 & SAINT_MAX) >> 1] = name | (p3 & p2 & SAINT_MIN);
-        name += p3 < 0;
-    }
-
-    for (j += prefetch_distance + 3; i < j; i += 1) {
-        p2 = p3;
-        p3 = SA[i];
-        SAm[(SA[i] = p3 & SAINT_MAX) >> 1] = name | (p3 & p2 & SAINT_MIN);
-        name += p3 < 0;
-    }
-
-    return name;
-}
-
-static void libsais_mark_distinct_lms_suffixes_32s(sa_sint_t * RESTRICT SA, sa_sint_t m, fast_sint_t omp_block_start,
-                                                   fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j;
-    sa_sint_t p0, p1, p2, p3 = 0;
-    for (i = (fast_sint_t)m + omp_block_start, j = (fast_sint_t)m + omp_block_start + omp_block_size - 3; i < j;
-         i += 4) {
-        prefetchw(&SA[i + prefetch_distance]);
-
-        p0 = SA[i + 0];
-        SA[i + 0] = p0 & (p3 | SAINT_MAX);
-        p0 = (p0 == 0) ? p3 : p0;
-        p1 = SA[i + 1];
-        SA[i + 1] = p1 & (p0 | SAINT_MAX);
-        p1 = (p1 == 0) ? p0 : p1;
-        p2 = SA[i + 2];
-        SA[i + 2] = p2 & (p1 | SAINT_MAX);
-        p2 = (p2 == 0) ? p1 : p2;
-        p3 = SA[i + 3];
-        SA[i + 3] = p3 & (p2 | SAINT_MAX);
-        p3 = (p3 == 0) ? p2 : p3;
-    }
-
-    for (j += 3; i < j; i += 1) {
-        p2 = p3;
-        p3 = SA[i];
-        SA[i] = p3 & (p2 | SAINT_MAX);
-        p3 = (p3 == 0) ? p2 : p3;
-    }
-}
-
-static void libsais_clamp_lms_suffixes_length_32s(sa_sint_t * RESTRICT SA, sa_sint_t m, fast_sint_t omp_block_start,
-                                                  fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    sa_sint_t * RESTRICT SAm = &SA[m];
-
-    fast_sint_t i, j;
-    for (i = omp_block_start, j = omp_block_start + omp_block_size - 3; i < j; i += 4) {
-        prefetchw(&SAm[i + prefetch_distance]);
-
-        SAm[i + 0] = (SAm[i + 0] < 0 ? SAm[i + 0] : 0) & SAINT_MAX;
-        SAm[i + 1] = (SAm[i + 1] < 0 ? SAm[i + 1] : 0) & SAINT_MAX;
-        SAm[i + 2] = (SAm[i + 2] < 0 ? SAm[i + 2] : 0) & SAINT_MAX;
-        SAm[i + 3] = (SAm[i + 3] < 0 ? SAm[i + 3] : 0) & SAINT_MAX;
-    }
-
-    for (j += 3; i < j; i += 1) {
-        SAm[i] = (SAm[i] < 0 ? SAm[i] : 0) & SAINT_MAX;
-    }
-}
-
-static sa_sint_t libsais_renumber_distinct_lms_suffixes_32s_4k_omp(sa_sint_t * RESTRICT SA, sa_sint_t m,
-                                                                   sa_sint_t threads,
-                                                                   LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    sa_sint_t name = 0;
-    {
-        (void)(threads);
-        (void)(thread_state);
-
-        fast_sint_t omp_thread_num = 0;
-        fast_sint_t omp_num_threads = 1;
-
-        fast_sint_t omp_block_stride = (m / omp_num_threads) & (-16);
-        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
-        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : m - omp_block_start;
-
-        if (omp_num_threads == 1) {
-            name = libsais_renumber_distinct_lms_suffixes_32s_4k(SA, m, 1, omp_block_start, omp_block_size);
-        }
-    }
-
-    return name - 1;
-}
-
-static void libsais_mark_distinct_lms_suffixes_32s_omp(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m,
-                                                       sa_sint_t threads) {
-    {
-        (void)(threads);
-
-        fast_sint_t omp_block_start = 0;
-        fast_sint_t omp_block_size = (fast_sint_t)n >> 1;
-
-        libsais_mark_distinct_lms_suffixes_32s(SA, m, omp_block_start, omp_block_size);
-    }
-}
-
-static void libsais_clamp_lms_suffixes_length_32s_omp(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m,
-                                                      sa_sint_t threads) {
-    {
-        (void)(threads);
-
-        fast_sint_t omp_block_start = 0;
-        fast_sint_t omp_block_size = (fast_sint_t)n >> 1;
-
-        libsais_clamp_lms_suffixes_length_32s(SA, m, omp_block_start, omp_block_size);
-    }
-}
-
-static sa_sint_t libsais_renumber_and_mark_distinct_lms_suffixes_32s_4k_omp(
-    sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m, sa_sint_t threads,
-    LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    memset(&SA[m], 0, ((size_t)n >> 1) * sizeof(sa_sint_t));
-
-    sa_sint_t name = libsais_renumber_distinct_lms_suffixes_32s_4k_omp(SA, m, threads, thread_state);
-    if (name < m) {
-        libsais_mark_distinct_lms_suffixes_32s_omp(SA, n, m, threads);
-    }
-
-    return name;
-}
-
-static sa_sint_t libsais_renumber_and_mark_distinct_lms_suffixes_32s_1k_omp(sa_sint_t * RESTRICT T,
-                                                                            sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                                            sa_sint_t m, sa_sint_t threads) {
-    const fast_sint_t prefetch_distance = 32;
-
-    sa_sint_t * RESTRICT SAm = &SA[m];
-
-    {
-        libsais_gather_lms_suffixes_32s(T, SA, n);
-
-        memset(&SA[m], 0, ((size_t)n - (size_t)m - (size_t)m) * sizeof(sa_sint_t));
-
-        fast_sint_t i, j;
-        for (i = (fast_sint_t)n - (fast_sint_t)m, j = (fast_sint_t)n - 1 - prefetch_distance - 3; i < j; i += 4) {
-            prefetch(&SA[i + 2 * prefetch_distance]);
-
-            prefetchw(&SAm[((sa_uint_t)SA[i + prefetch_distance + 0]) >> 1]);
-            prefetchw(&SAm[((sa_uint_t)SA[i + prefetch_distance + 1]) >> 1]);
-            prefetchw(&SAm[((sa_uint_t)SA[i + prefetch_distance + 2]) >> 1]);
-            prefetchw(&SAm[((sa_uint_t)SA[i + prefetch_distance + 3]) >> 1]);
-
-            SAm[((sa_uint_t)SA[i + 0]) >> 1] = SA[i + 1] - SA[i + 0] + 1 + SAINT_MIN;
-            SAm[((sa_uint_t)SA[i + 1]) >> 1] = SA[i + 2] - SA[i + 1] + 1 + SAINT_MIN;
-            SAm[((sa_uint_t)SA[i + 2]) >> 1] = SA[i + 3] - SA[i + 2] + 1 + SAINT_MIN;
-            SAm[((sa_uint_t)SA[i + 3]) >> 1] = SA[i + 4] - SA[i + 3] + 1 + SAINT_MIN;
-        }
-
-        for (j += prefetch_distance + 3; i < j; i += 1) {
-            SAm[((sa_uint_t)SA[i]) >> 1] = SA[i + 1] - SA[i] + 1 + SAINT_MIN;
-        }
-
-        SAm[((sa_uint_t)SA[n - 1]) >> 1] = 1 + SAINT_MIN;
-    }
-
-    { libsais_clamp_lms_suffixes_length_32s_omp(SA, n, m, threads); }
-
-    sa_sint_t name = 1;
-
-    {
-        fast_sint_t i, j, p = SA[0], plen = SAm[p >> 1];
-        sa_sint_t pdiff = SAINT_MIN;
-        for (i = 1, j = m - prefetch_distance - 1; i < j; i += 2) {
-            prefetch(&SA[i + 2 * prefetch_distance]);
-
-            prefetchw(&SAm[((sa_uint_t)SA[i + prefetch_distance + 0]) >> 1]);
-            prefetch(&T[((sa_uint_t)SA[i + prefetch_distance + 0])]);
-            prefetchw(&SAm[((sa_uint_t)SA[i + prefetch_distance + 1]) >> 1]);
-            prefetch(&T[((sa_uint_t)SA[i + prefetch_distance + 1])]);
-
-            fast_sint_t q = SA[i + 0], qlen = SAm[q >> 1];
-            sa_sint_t qdiff = SAINT_MIN;
-            if (plen == qlen) {
-                fast_sint_t l = 0;
-                do {
-                    if (T[p + l] != T[q + l]) {
-                        break;
-                    }
-                } while (++l < qlen);
-                qdiff = (sa_sint_t)(l - qlen) & SAINT_MIN;
-            }
-            SAm[p >> 1] = name | (pdiff & qdiff);
-            name += (qdiff < 0);
-
-            p = SA[i + 1];
-            plen = SAm[p >> 1];
-            pdiff = SAINT_MIN;
-            if (qlen == plen) {
-                fast_sint_t l = 0;
-                do {
-                    if (T[q + l] != T[p + l]) {
-                        break;
-                    }
-                } while (++l < plen);
-                pdiff = (sa_sint_t)(l - plen) & SAINT_MIN;
-            }
-            SAm[q >> 1] = name | (qdiff & pdiff);
-            name += (pdiff < 0);
-        }
-
-        for (j += prefetch_distance + 1; i < j; i += 1) {
-            fast_sint_t q = SA[i], qlen = SAm[q >> 1];
-            sa_sint_t qdiff = SAINT_MIN;
-            if (plen == qlen) {
-                fast_sint_t l = 0;
-                do {
-                    if (T[p + l] != T[q + l]) {
-                        break;
-                    }
-                } while (++l < plen);
-                qdiff = (sa_sint_t)(l - plen) & SAINT_MIN;
-            }
-            SAm[p >> 1] = name | (pdiff & qdiff);
-            name += (qdiff < 0);
-
-            p = q;
-            plen = qlen;
-            pdiff = qdiff;
-        }
-
-        SAm[p >> 1] = name | pdiff;
-        name++;
-    }
-
-    if (name <= m) {
-        libsais_mark_distinct_lms_suffixes_32s_omp(SA, n, m, threads);
-    }
-
-    return name - 1;
-}
-
-static void libsais_reconstruct_lms_suffixes(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m,
-                                             fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    const sa_sint_t * RESTRICT SAnm = &SA[n - m];
-
-    fast_sint_t i, j;
-    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 3; i < j; i += 4) {
-        prefetchw(&SA[i + 2 * prefetch_distance]);
-
-        prefetch(&SAnm[SA[i + prefetch_distance + 0]]);
-        prefetch(&SAnm[SA[i + prefetch_distance + 1]]);
-        prefetch(&SAnm[SA[i + prefetch_distance + 2]]);
-        prefetch(&SAnm[SA[i + prefetch_distance + 3]]);
-
-        SA[i + 0] = SAnm[SA[i + 0]];
-        SA[i + 1] = SAnm[SA[i + 1]];
-        SA[i + 2] = SAnm[SA[i + 2]];
-        SA[i + 3] = SAnm[SA[i + 3]];
-    }
-
-    for (j += prefetch_distance + 3; i < j; i += 1) {
-        SA[i] = SAnm[SA[i]];
-    }
-}
-
-static void libsais_reconstruct_lms_suffixes_omp(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m, sa_sint_t threads) {
-    {
-        (void)(threads);
-
-        fast_sint_t omp_block_start = 0;
-        fast_sint_t omp_block_size = m;
-        libsais_reconstruct_lms_suffixes(SA, n, m, omp_block_start, omp_block_size);
-    }
-}
-
-static void libsais_place_lms_suffixes_interval_8u(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m,
-                                                   const sa_sint_t * RESTRICT buckets) {
-    const sa_sint_t * RESTRICT bucket_end = &buckets[7 * ALPHABET_SIZE];
-
-    fast_sint_t c, j = n;
-    for (c = ALPHABET_SIZE - 2; c >= 0; --c) {
-        fast_sint_t l = (fast_sint_t)buckets[BUCKETS_INDEX2(c, 1) + BUCKETS_INDEX2(1, 0)] -
-                        (fast_sint_t)buckets[BUCKETS_INDEX2(c, 1)];
-        if (l > 0) {
-            fast_sint_t i = bucket_end[c];
-            if (j - i > 0) {
-                memset(&SA[i], 0, (size_t)(j - i) * sizeof(sa_sint_t));
-            }
-
-            memmove(&SA[j = (i - l)], &SA[m -= (sa_sint_t)l], (size_t)l * sizeof(sa_sint_t));
-        }
-    }
-
-    memset(&SA[0], 0, (size_t)j * sizeof(sa_sint_t));
-}
-
-static void libsais_place_lms_suffixes_interval_32s_4k(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t k, sa_sint_t m,
-                                                       const sa_sint_t * RESTRICT buckets) {
-    const sa_sint_t * RESTRICT bucket_end = &buckets[3 * k];
-
-    fast_sint_t c, j = n;
-    for (c = (fast_sint_t)k - 2; c >= 0; --c) {
-        fast_sint_t l = (fast_sint_t)buckets[BUCKETS_INDEX2(c, 1) + BUCKETS_INDEX2(1, 0)] -
-                        (fast_sint_t)buckets[BUCKETS_INDEX2(c, 1)];
-        if (l > 0) {
-            fast_sint_t i = bucket_end[c];
-            if (j - i > 0) {
-                memset(&SA[i], 0, (size_t)(j - i) * sizeof(sa_sint_t));
-            }
-
-            memmove(&SA[j = (i - l)], &SA[m -= (sa_sint_t)l], (size_t)l * sizeof(sa_sint_t));
-        }
-    }
-
-    memset(&SA[0], 0, (size_t)j * sizeof(sa_sint_t));
-}
-
-static void libsais_place_lms_suffixes_interval_32s_2k(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t k, sa_sint_t m,
-                                                       const sa_sint_t * RESTRICT buckets) {
-    fast_sint_t j = n;
-
-    if (k > 1) {
-        fast_sint_t c;
-        for (c = BUCKETS_INDEX2((fast_sint_t)k - 2, 0); c >= BUCKETS_INDEX2(0, 0); c -= BUCKETS_INDEX2(1, 0)) {
-            fast_sint_t l =
-                (fast_sint_t)buckets[c + BUCKETS_INDEX2(1, 1)] - (fast_sint_t)buckets[c + BUCKETS_INDEX2(0, 1)];
-            if (l > 0) {
-                fast_sint_t i = buckets[c];
-                if (j - i > 0) {
-                    memset(&SA[i], 0, (size_t)(j - i) * sizeof(sa_sint_t));
-                }
-
-                memmove(&SA[j = (i - l)], &SA[m -= (sa_sint_t)l], (size_t)l * sizeof(sa_sint_t));
-            }
-        }
-    }
-
-    memset(&SA[0], 0, (size_t)j * sizeof(sa_sint_t));
-}
-
-static void libsais_place_lms_suffixes_interval_32s_1k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                       sa_sint_t k, sa_sint_t m, sa_sint_t * RESTRICT buckets) {
-    const fast_sint_t prefetch_distance = 32;
-
-    sa_sint_t c = k - 1;
-    fast_sint_t i, l = buckets[c];
-    for (i = (fast_sint_t)m - 1; i >= prefetch_distance + 3; i -= 4) {
-        prefetch(&SA[i - 2 * prefetch_distance]);
-
-        prefetch(&T[SA[i - prefetch_distance - 0]]);
-        prefetch(&T[SA[i - prefetch_distance - 1]]);
-        prefetch(&T[SA[i - prefetch_distance - 2]]);
-        prefetch(&T[SA[i - prefetch_distance - 3]]);
-
-        sa_sint_t p0 = SA[i - 0];
-        if (T[p0] != c) {
-            c = T[p0];
-            memset(&SA[buckets[c]], 0, (size_t)(l - buckets[c]) * sizeof(sa_sint_t));
-            l = buckets[c];
-        }
-        SA[--l] = p0;
-        sa_sint_t p1 = SA[i - 1];
-        if (T[p1] != c) {
-            c = T[p1];
-            memset(&SA[buckets[c]], 0, (size_t)(l - buckets[c]) * sizeof(sa_sint_t));
-            l = buckets[c];
-        }
-        SA[--l] = p1;
-        sa_sint_t p2 = SA[i - 2];
-        if (T[p2] != c) {
-            c = T[p2];
-            memset(&SA[buckets[c]], 0, (size_t)(l - buckets[c]) * sizeof(sa_sint_t));
-            l = buckets[c];
-        }
-        SA[--l] = p2;
-        sa_sint_t p3 = SA[i - 3];
-        if (T[p3] != c) {
-            c = T[p3];
-            memset(&SA[buckets[c]], 0, (size_t)(l - buckets[c]) * sizeof(sa_sint_t));
-            l = buckets[c];
-        }
-        SA[--l] = p3;
-    }
-
-    for (; i >= 0; i -= 1) {
-        sa_sint_t p = SA[i];
-        if (T[p] != c) {
-            c = T[p];
-            memset(&SA[buckets[c]], 0, (size_t)(l - buckets[c]) * sizeof(sa_sint_t));
-            l = buckets[c];
-        }
-        SA[--l] = p;
-    }
-
-    memset(&SA[0], 0, (size_t)l * sizeof(sa_sint_t));
-}
-
-static void libsais_place_lms_suffixes_histogram_32s_6k(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t k, sa_sint_t m,
-                                                        const sa_sint_t * RESTRICT buckets) {
-    const sa_sint_t * RESTRICT bucket_end = &buckets[5 * k];
-
-    fast_sint_t c, j = n;
-    for (c = (fast_sint_t)k - 2; c >= 0; --c) {
-        fast_sint_t l = (fast_sint_t)buckets[BUCKETS_INDEX4(c, 1)];
-        if (l > 0) {
-            fast_sint_t i = bucket_end[c];
-            if (j - i > 0) {
-                memset(&SA[i], 0, (size_t)(j - i) * sizeof(sa_sint_t));
-            }
-
-            memmove(&SA[j = (i - l)], &SA[m -= (sa_sint_t)l], (size_t)l * sizeof(sa_sint_t));
-        }
-    }
-
-    memset(&SA[0], 0, (size_t)j * sizeof(sa_sint_t));
-}
-
-static void libsais_place_lms_suffixes_histogram_32s_4k(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t k, sa_sint_t m,
-                                                        const sa_sint_t * RESTRICT buckets) {
-    const sa_sint_t * RESTRICT bucket_end = &buckets[3 * k];
-
-    fast_sint_t c, j = n;
-    for (c = (fast_sint_t)k - 2; c >= 0; --c) {
-        fast_sint_t l = (fast_sint_t)buckets[BUCKETS_INDEX2(c, 1)];
-        if (l > 0) {
-            fast_sint_t i = bucket_end[c];
-            if (j - i > 0) {
-                memset(&SA[i], 0, (size_t)(j - i) * sizeof(sa_sint_t));
-            }
-
-            memmove(&SA[j = (i - l)], &SA[m -= (sa_sint_t)l], (size_t)l * sizeof(sa_sint_t));
-        }
-    }
-
-    memset(&SA[0], 0, (size_t)j * sizeof(sa_sint_t));
-}
-
-static void libsais_place_lms_suffixes_histogram_32s_2k(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t k, sa_sint_t m,
-                                                        const sa_sint_t * RESTRICT buckets) {
-    fast_sint_t j = n;
-
-    if (k > 1) {
-        fast_sint_t c;
-        for (c = BUCKETS_INDEX2((fast_sint_t)k - 2, 0); c >= BUCKETS_INDEX2(0, 0); c -= BUCKETS_INDEX2(1, 0)) {
-            fast_sint_t l = (fast_sint_t)buckets[c + BUCKETS_INDEX2(0, 1)];
-            if (l > 0) {
-                fast_sint_t i = buckets[c];
-                if (j - i > 0) {
-                    memset(&SA[i], 0, (size_t)(j - i) * sizeof(sa_sint_t));
-                }
-
-                memmove(&SA[j = (i - l)], &SA[m -= (sa_sint_t)l], (size_t)l * sizeof(sa_sint_t));
-            }
-        }
-    }
-
-    memset(&SA[0], 0, (size_t)j * sizeof(sa_sint_t));
-}
-
-static void libsais_final_bwt_scan_left_to_right_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                    sa_sint_t * RESTRICT induction_bucket, fast_sint_t omp_block_start,
-                                                    fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j;
-    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 1; i < j; i += 2) {
-        prefetchw(&SA[i + 2 * prefetch_distance]);
-
-        sa_sint_t s0 = SA[i + prefetch_distance + 0];
-        const u8 * Ts0 = &T[s0] - 1;
-        prefetch(s0 > 0 ? Ts0 : NULL);
-        Ts0--;
-        prefetch(s0 > 0 ? Ts0 : NULL);
-        sa_sint_t s1 = SA[i + prefetch_distance + 1];
-        const u8 * Ts1 = &T[s1] - 1;
-        prefetch(s1 > 0 ? Ts1 : NULL);
-        Ts1--;
-        prefetch(s1 > 0 ? Ts1 : NULL);
-
-        sa_sint_t p0 = SA[i + 0];
-        SA[i + 0] = p0 & SAINT_MAX;
-        if (p0 > 0) {
-            p0--;
-            SA[i + 0] = T[p0] | SAINT_MIN;
-            SA[induction_bucket[T[p0]]++] = p0 | ((sa_sint_t)(T[p0 - (p0 > 0)] < T[p0]) << (SAINT_BIT - 1));
-        }
-        sa_sint_t p1 = SA[i + 1];
-        SA[i + 1] = p1 & SAINT_MAX;
-        if (p1 > 0) {
-            p1--;
-            SA[i + 1] = T[p1] | SAINT_MIN;
-            SA[induction_bucket[T[p1]]++] = p1 | ((sa_sint_t)(T[p1 - (p1 > 0)] < T[p1]) << (SAINT_BIT - 1));
-        }
-    }
-
-    for (j += prefetch_distance + 1; i < j; i += 1) {
-        sa_sint_t p = SA[i];
-        SA[i] = p & SAINT_MAX;
-        if (p > 0) {
-            p--;
-            SA[i] = T[p] | SAINT_MIN;
-            SA[induction_bucket[T[p]]++] = p | ((sa_sint_t)(T[p - (p > 0)] < T[p]) << (SAINT_BIT - 1));
-        }
-    }
-}
-
-static void libsais_final_bwt_aux_scan_left_to_right_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t rm,
-                                                        sa_sint_t * RESTRICT I, sa_sint_t * RESTRICT induction_bucket,
-                                                        fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j;
-    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 1; i < j; i += 2) {
-        prefetchw(&SA[i + 2 * prefetch_distance]);
-
-        sa_sint_t s0 = SA[i + prefetch_distance + 0];
-        const u8 * Ts0 = &T[s0] - 1;
-        prefetch(s0 > 0 ? Ts0 : NULL);
-        Ts0--;
-        prefetch(s0 > 0 ? Ts0 : NULL);
-        sa_sint_t s1 = SA[i + prefetch_distance + 1];
-        const u8 * Ts1 = &T[s1] - 1;
-        prefetch(s1 > 0 ? Ts1 : NULL);
-        Ts1--;
-        prefetch(s1 > 0 ? Ts1 : NULL);
-
-        sa_sint_t p0 = SA[i + 0];
-        SA[i + 0] = p0 & SAINT_MAX;
-        if (p0 > 0) {
-            p0--;
-            SA[i + 0] = T[p0] | SAINT_MIN;
-            SA[induction_bucket[T[p0]]++] = p0 | ((sa_sint_t)(T[p0 - (p0 > 0)] < T[p0]) << (SAINT_BIT - 1));
-            if ((p0 & rm) == 0) {
-                I[p0 / (rm + 1)] = induction_bucket[T[p0]];
-            }
-        }
-        sa_sint_t p1 = SA[i + 1];
-        SA[i + 1] = p1 & SAINT_MAX;
-        if (p1 > 0) {
-            p1--;
-            SA[i + 1] = T[p1] | SAINT_MIN;
-            SA[induction_bucket[T[p1]]++] = p1 | ((sa_sint_t)(T[p1 - (p1 > 0)] < T[p1]) << (SAINT_BIT - 1));
-            if ((p1 & rm) == 0) {
-                I[p1 / (rm + 1)] = induction_bucket[T[p1]];
-            }
-        }
-    }
-
-    for (j += prefetch_distance + 1; i < j; i += 1) {
-        sa_sint_t p = SA[i];
-        SA[i] = p & SAINT_MAX;
-        if (p > 0) {
-            p--;
-            SA[i] = T[p] | SAINT_MIN;
-            SA[induction_bucket[T[p]]++] = p | ((sa_sint_t)(T[p - (p > 0)] < T[p]) << (SAINT_BIT - 1));
-            if ((p & rm) == 0) {
-                I[p / (rm + 1)] = induction_bucket[T[p]];
-            }
-        }
-    }
-}
-
-static void libsais_final_sorting_scan_left_to_right_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                        sa_sint_t * RESTRICT induction_bucket,
-                                                        fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j;
-    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 1; i < j; i += 2) {
-        prefetchw(&SA[i + 2 * prefetch_distance]);
-
-        sa_sint_t s0 = SA[i + prefetch_distance + 0];
-        const u8 * Ts0 = &T[s0] - 1;
-        prefetch(s0 > 0 ? Ts0 : NULL);
-        Ts0--;
-        prefetch(s0 > 0 ? Ts0 : NULL);
-        sa_sint_t s1 = SA[i + prefetch_distance + 1];
-        const u8 * Ts1 = &T[s1] - 1;
-        prefetch(s1 > 0 ? Ts1 : NULL);
-        Ts1--;
-        prefetch(s1 > 0 ? Ts1 : NULL);
-
-        sa_sint_t p0 = SA[i + 0];
-        SA[i + 0] = p0 ^ SAINT_MIN;
-        if (p0 > 0) {
-            p0--;
-            SA[induction_bucket[T[p0]]++] = p0 | ((sa_sint_t)(T[p0 - (p0 > 0)] < T[p0]) << (SAINT_BIT - 1));
-        }
-        sa_sint_t p1 = SA[i + 1];
-        SA[i + 1] = p1 ^ SAINT_MIN;
-        if (p1 > 0) {
-            p1--;
-            SA[induction_bucket[T[p1]]++] = p1 | ((sa_sint_t)(T[p1 - (p1 > 0)] < T[p1]) << (SAINT_BIT - 1));
-        }
-    }
-
-    for (j += prefetch_distance + 1; i < j; i += 1) {
-        sa_sint_t p = SA[i];
-        SA[i] = p ^ SAINT_MIN;
-        if (p > 0) {
-            p--;
-            SA[induction_bucket[T[p]]++] = p | ((sa_sint_t)(T[p - (p > 0)] < T[p]) << (SAINT_BIT - 1));
-        }
-    }
-}
-
-static void libsais_final_sorting_scan_left_to_right_32s(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                         sa_sint_t * RESTRICT induction_bucket,
-                                                         fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j;
-    for (i = omp_block_start, j = omp_block_start + omp_block_size - 2 * prefetch_distance - 1; i < j; i += 2) {
-        prefetchw(&SA[i + 3 * prefetch_distance]);
-
-        sa_sint_t s0 = SA[i + 2 * prefetch_distance + 0];
-        const sa_sint_t * Ts0 = &T[s0] - 1;
-        prefetch(s0 > 0 ? Ts0 : NULL);
-        sa_sint_t s1 = SA[i + 2 * prefetch_distance + 1];
-        const sa_sint_t * Ts1 = &T[s1] - 1;
-        prefetch(s1 > 0 ? Ts1 : NULL);
-        sa_sint_t s2 = SA[i + 1 * prefetch_distance + 0];
-        if (s2 > 0) {
-            prefetchw(&induction_bucket[T[s2 - 1]]);
-            prefetch(&T[s2] - 2);
-        }
-        sa_sint_t s3 = SA[i + 1 * prefetch_distance + 1];
-        if (s3 > 0) {
-            prefetchw(&induction_bucket[T[s3 - 1]]);
-            prefetch(&T[s3] - 2);
-        }
-
-        sa_sint_t p0 = SA[i + 0];
-        SA[i + 0] = p0 ^ SAINT_MIN;
-        if (p0 > 0) {
-            p0--;
-            SA[induction_bucket[T[p0]]++] = p0 | ((sa_sint_t)(T[p0 - (p0 > 0)] < T[p0]) << (SAINT_BIT - 1));
-        }
-        sa_sint_t p1 = SA[i + 1];
-        SA[i + 1] = p1 ^ SAINT_MIN;
-        if (p1 > 0) {
-            p1--;
-            SA[induction_bucket[T[p1]]++] = p1 | ((sa_sint_t)(T[p1 - (p1 > 0)] < T[p1]) << (SAINT_BIT - 1));
-        }
-    }
-
-    for (j += 2 * prefetch_distance + 1; i < j; i += 1) {
-        sa_sint_t p = SA[i];
-        SA[i] = p ^ SAINT_MIN;
-        if (p > 0) {
-            p--;
-            SA[induction_bucket[T[p]]++] = p | ((sa_sint_t)(T[p - (p > 0)] < T[p]) << (SAINT_BIT - 1));
-        }
-    }
-}
-static void libsais_final_bwt_scan_left_to_right_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, fast_sint_t n,
-                                                        sa_sint_t * RESTRICT induction_bucket, sa_sint_t threads,
-                                                        LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    SA[induction_bucket[T[(sa_sint_t)n - 1]]++] =
-        ((sa_sint_t)n - 1) | ((sa_sint_t)(T[(sa_sint_t)n - 2] < T[(sa_sint_t)n - 1]) << (SAINT_BIT - 1));
-
-    if (threads == 1 || n < 65536) {
-        libsais_final_bwt_scan_left_to_right_8u(T, SA, induction_bucket, 0, n);
-    }
-    (void)(thread_state);
-}
-
-static void libsais_final_bwt_aux_scan_left_to_right_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                            fast_sint_t n, sa_sint_t rm, sa_sint_t * RESTRICT I,
-                                                            sa_sint_t * RESTRICT induction_bucket, sa_sint_t threads,
-                                                            LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    SA[induction_bucket[T[(sa_sint_t)n - 1]]++] =
-        ((sa_sint_t)n - 1) | ((sa_sint_t)(T[(sa_sint_t)n - 2] < T[(sa_sint_t)n - 1]) << (SAINT_BIT - 1));
-
-    if ((((sa_sint_t)n - 1) & rm) == 0) {
-        I[((sa_sint_t)n - 1) / (rm + 1)] = induction_bucket[T[(sa_sint_t)n - 1]];
-    }
-
-    if (threads == 1 || n < 65536) {
-        libsais_final_bwt_aux_scan_left_to_right_8u(T, SA, rm, I, induction_bucket, 0, n);
-    }
-    (void)(thread_state);
-}
-
-static void libsais_final_sorting_scan_left_to_right_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                            fast_sint_t n, sa_sint_t * RESTRICT induction_bucket,
-                                                            sa_sint_t threads,
-                                                            LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    SA[induction_bucket[T[(sa_sint_t)n - 1]]++] =
-        ((sa_sint_t)n - 1) | ((sa_sint_t)(T[(sa_sint_t)n - 2] < T[(sa_sint_t)n - 1]) << (SAINT_BIT - 1));
-
-    if (threads == 1 || n < 65536) {
-        libsais_final_sorting_scan_left_to_right_8u(T, SA, induction_bucket, 0, n);
-    }
-    (void)(thread_state);
-}
-
-static void libsais_final_sorting_scan_left_to_right_32s_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                             sa_sint_t n, sa_sint_t * RESTRICT induction_bucket,
-                                                             sa_sint_t threads,
-                                                             LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    SA[induction_bucket[T[n - 1]]++] = (n - 1) | ((sa_sint_t)(T[n - 2] < T[n - 1]) << (SAINT_BIT - 1));
-
-    if (threads == 1 || n < 65536) {
-        libsais_final_sorting_scan_left_to_right_32s(T, SA, induction_bucket, 0, n);
-    }
-    (void)(thread_state);
-}
-
-static sa_sint_t libsais_final_bwt_scan_right_to_left_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                         sa_sint_t * RESTRICT induction_bucket,
-                                                         fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j;
-    sa_sint_t index = -1;
-    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + prefetch_distance + 1; i >= j; i -= 2) {
-        prefetchw(&SA[i - 2 * prefetch_distance]);
-
-        sa_sint_t s0 = SA[i - prefetch_distance - 0];
-        const u8 * Ts0 = &T[s0] - 1;
-        prefetch(s0 > 0 ? Ts0 : NULL);
-        Ts0--;
-        prefetch(s0 > 0 ? Ts0 : NULL);
-        sa_sint_t s1 = SA[i - prefetch_distance - 1];
-        const u8 * Ts1 = &T[s1] - 1;
-        prefetch(s1 > 0 ? Ts1 : NULL);
-        Ts1--;
-        prefetch(s1 > 0 ? Ts1 : NULL);
-
-        sa_sint_t p0 = SA[i - 0];
-        index = (p0 == 0) ? (sa_sint_t)(i - 0) : index;
-        SA[i - 0] = p0 & SAINT_MAX;
-        if (p0 > 0) {
-            p0--;
-            u8 c0 = T[p0 - (p0 > 0)], c1 = T[p0];
-            SA[i - 0] = c1;
-            sa_sint_t t = c0 | SAINT_MIN;
-            SA[--induction_bucket[c1]] = (c0 <= c1) ? p0 : t;
-        }
-
-        sa_sint_t p1 = SA[i - 1];
-        index = (p1 == 0) ? (sa_sint_t)(i - 1) : index;
-        SA[i - 1] = p1 & SAINT_MAX;
-        if (p1 > 0) {
-            p1--;
-            u8 c0 = T[p1 - (p1 > 0)], c1 = T[p1];
-            SA[i - 1] = c1;
-            sa_sint_t t = c0 | SAINT_MIN;
-            SA[--induction_bucket[c1]] = (c0 <= c1) ? p1 : t;
-        }
-    }
-
-    for (j -= prefetch_distance + 1; i >= j; i -= 1) {
-        sa_sint_t p = SA[i];
-        index = (p == 0) ? (sa_sint_t)i : index;
-        SA[i] = p & SAINT_MAX;
-        if (p > 0) {
-            p--;
-            u8 c0 = T[p - (p > 0)], c1 = T[p];
-            SA[i] = c1;
-            sa_sint_t t = c0 | SAINT_MIN;
-            SA[--induction_bucket[c1]] = (c0 <= c1) ? p : t;
-        }
-    }
-
-    return index;
-}
-
-static void libsais_final_bwt_aux_scan_right_to_left_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t rm,
-                                                        sa_sint_t * RESTRICT I, sa_sint_t * RESTRICT induction_bucket,
-                                                        fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j;
-    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + prefetch_distance + 1; i >= j; i -= 2) {
-        prefetchw(&SA[i - 2 * prefetch_distance]);
-
-        sa_sint_t s0 = SA[i - prefetch_distance - 0];
-        const u8 * Ts0 = &T[s0] - 1;
-        prefetch(s0 > 0 ? Ts0 : NULL);
-        Ts0--;
-        prefetch(s0 > 0 ? Ts0 : NULL);
-        sa_sint_t s1 = SA[i - prefetch_distance - 1];
-        const u8 * Ts1 = &T[s1] - 1;
-        prefetch(s1 > 0 ? Ts1 : NULL);
-        Ts1--;
-        prefetch(s1 > 0 ? Ts1 : NULL);
-
-        sa_sint_t p0 = SA[i - 0];
-        SA[i - 0] = p0 & SAINT_MAX;
-        if (p0 > 0) {
-            p0--;
-            u8 c0 = T[p0 - (p0 > 0)], c1 = T[p0];
-            SA[i - 0] = c1;
-            sa_sint_t t = c0 | SAINT_MIN;
-            SA[--induction_bucket[c1]] = (c0 <= c1) ? p0 : t;
-            if ((p0 & rm) == 0) {
-                I[p0 / (rm + 1)] = induction_bucket[T[p0]] + 1;
-            }
-        }
-
-        sa_sint_t p1 = SA[i - 1];
-        SA[i - 1] = p1 & SAINT_MAX;
-        if (p1 > 0) {
-            p1--;
-            u8 c0 = T[p1 - (p1 > 0)], c1 = T[p1];
-            SA[i - 1] = c1;
-            sa_sint_t t = c0 | SAINT_MIN;
-            SA[--induction_bucket[c1]] = (c0 <= c1) ? p1 : t;
-            if ((p1 & rm) == 0) {
-                I[p1 / (rm + 1)] = induction_bucket[T[p1]] + 1;
-            }
-        }
-    }
-
-    for (j -= prefetch_distance + 1; i >= j; i -= 1) {
-        sa_sint_t p = SA[i];
-        SA[i] = p & SAINT_MAX;
-        if (p > 0) {
-            p--;
-            u8 c0 = T[p - (p > 0)], c1 = T[p];
-            SA[i] = c1;
-            sa_sint_t t = c0 | SAINT_MIN;
-            SA[--induction_bucket[c1]] = (c0 <= c1) ? p : t;
-            if ((p & rm) == 0) {
-                I[p / (rm + 1)] = induction_bucket[T[p]] + 1;
-            }
-        }
-    }
-}
-
-static void libsais_final_sorting_scan_right_to_left_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                        sa_sint_t * RESTRICT induction_bucket,
-                                                        fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j;
-    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + prefetch_distance + 1; i >= j; i -= 2) {
-        prefetchw(&SA[i - 2 * prefetch_distance]);
-
-        sa_sint_t s0 = SA[i - prefetch_distance - 0];
-        const u8 * Ts0 = &T[s0] - 1;
-        prefetch(s0 > 0 ? Ts0 : NULL);
-        Ts0--;
-        prefetch(s0 > 0 ? Ts0 : NULL);
-        sa_sint_t s1 = SA[i - prefetch_distance - 1];
-        const u8 * Ts1 = &T[s1] - 1;
-        prefetch(s1 > 0 ? Ts1 : NULL);
-        Ts1--;
-        prefetch(s1 > 0 ? Ts1 : NULL);
-
-        sa_sint_t p0 = SA[i - 0];
-        SA[i - 0] = p0 & SAINT_MAX;
-        if (p0 > 0) {
-            p0--;
-            SA[--induction_bucket[T[p0]]] = p0 | ((sa_sint_t)(T[p0 - (p0 > 0)] > T[p0]) << (SAINT_BIT - 1));
-        }
-        sa_sint_t p1 = SA[i - 1];
-        SA[i - 1] = p1 & SAINT_MAX;
-        if (p1 > 0) {
-            p1--;
-            SA[--induction_bucket[T[p1]]] = p1 | ((sa_sint_t)(T[p1 - (p1 > 0)] > T[p1]) << (SAINT_BIT - 1));
-        }
-    }
-
-    for (j -= prefetch_distance + 1; i >= j; i -= 1) {
-        sa_sint_t p = SA[i];
-        SA[i] = p & SAINT_MAX;
-        if (p > 0) {
-            p--;
-            SA[--induction_bucket[T[p]]] = p | ((sa_sint_t)(T[p - (p > 0)] > T[p]) << (SAINT_BIT - 1));
-        }
-    }
-}
-
-static void libsais_final_sorting_scan_right_to_left_32s(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                         sa_sint_t * RESTRICT induction_bucket,
-                                                         fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j;
-    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + 2 * prefetch_distance + 1; i >= j; i -= 2) {
-        prefetchw(&SA[i - 3 * prefetch_distance]);
-
-        sa_sint_t s0 = SA[i - 2 * prefetch_distance - 0];
-        const sa_sint_t * Ts0 = &T[s0] - 1;
-        prefetch(s0 > 0 ? Ts0 : NULL);
-        sa_sint_t s1 = SA[i - 2 * prefetch_distance - 1];
-        const sa_sint_t * Ts1 = &T[s1] - 1;
-        prefetch(s1 > 0 ? Ts1 : NULL);
-        sa_sint_t s2 = SA[i - 1 * prefetch_distance - 0];
-        if (s2 > 0) {
-            prefetchw(&induction_bucket[T[s2 - 1]]);
-            prefetch(&T[s2] - 2);
-        }
-        sa_sint_t s3 = SA[i - 1 * prefetch_distance - 1];
-        if (s3 > 0) {
-            prefetchw(&induction_bucket[T[s3 - 1]]);
-            prefetch(&T[s3] - 2);
-        }
-
-        sa_sint_t p0 = SA[i - 0];
-        SA[i - 0] = p0 & SAINT_MAX;
-        if (p0 > 0) {
-            p0--;
-            SA[--induction_bucket[T[p0]]] = p0 | ((sa_sint_t)(T[p0 - (p0 > 0)] > T[p0]) << (SAINT_BIT - 1));
-        }
-        sa_sint_t p1 = SA[i - 1];
-        SA[i - 1] = p1 & SAINT_MAX;
-        if (p1 > 0) {
-            p1--;
-            SA[--induction_bucket[T[p1]]] = p1 | ((sa_sint_t)(T[p1 - (p1 > 0)] > T[p1]) << (SAINT_BIT - 1));
-        }
-    }
-
-    for (j -= 2 * prefetch_distance + 1; i >= j; i -= 1) {
-        sa_sint_t p = SA[i];
-        SA[i] = p & SAINT_MAX;
-        if (p > 0) {
-            p--;
-            SA[--induction_bucket[T[p]]] = p | ((sa_sint_t)(T[p - (p > 0)] > T[p]) << (SAINT_BIT - 1));
-        }
-    }
-}
-static sa_sint_t libsais_final_bwt_scan_right_to_left_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                             sa_sint_t n, sa_sint_t * RESTRICT induction_bucket,
-                                                             sa_sint_t threads,
-                                                             LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    sa_sint_t index = -1;
-
-    if (threads == 1 || n < 65536) {
-        index = libsais_final_bwt_scan_right_to_left_8u(T, SA, induction_bucket, 0, n);
-    }
-    (void)(thread_state);
-    return index;
-}
-
-static void libsais_final_bwt_aux_scan_right_to_left_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                            sa_sint_t rm, sa_sint_t * RESTRICT I,
-                                                            sa_sint_t * RESTRICT induction_bucket, sa_sint_t threads,
-                                                            LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    if (threads == 1 || n < 65536) {
-        libsais_final_bwt_aux_scan_right_to_left_8u(T, SA, rm, I, induction_bucket, 0, n);
-    }
-    (void)(thread_state);
-}
-
-static void libsais_final_sorting_scan_right_to_left_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                            sa_sint_t * RESTRICT induction_bucket, sa_sint_t threads,
-                                                            LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    if (threads == 1 || n < 65536) {
-        libsais_final_sorting_scan_right_to_left_8u(T, SA, induction_bucket, 0, n);
-    }
-    (void)(thread_state);
-}
-
-static void libsais_final_sorting_scan_right_to_left_32s_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                             sa_sint_t n, sa_sint_t * RESTRICT induction_bucket,
-                                                             sa_sint_t threads,
-                                                             LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    if (threads == 1 || n < 65536) {
-        libsais_final_sorting_scan_right_to_left_32s(T, SA, induction_bucket, 0, n);
-    }
-    (void)(thread_state);
-}
-
-static void libsais_clear_lms_suffixes_omp(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t k,
-                                           sa_sint_t * RESTRICT bucket_start, sa_sint_t * RESTRICT bucket_end,
-                                           sa_sint_t threads) {
-    fast_sint_t c;
-    (void)(threads);
-    (void)(n);
-
-    for (c = 0; c < k; ++c) {
-        if (bucket_end[c] > bucket_start[c]) {
-            memset(&SA[bucket_start[c]], 0, ((size_t)bucket_end[c] - (size_t)bucket_start[c]) * sizeof(sa_sint_t));
-        }
-    }
-}
-
-static sa_sint_t libsais_induce_final_order_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                   sa_sint_t bwt, sa_sint_t r, sa_sint_t * RESTRICT I,
-                                                   sa_sint_t * RESTRICT buckets, sa_sint_t threads,
-                                                   LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    if (!bwt) {
-        libsais_final_sorting_scan_left_to_right_8u_omp(T, SA, n, &buckets[6 * ALPHABET_SIZE], threads, thread_state);
-        if (threads > 1 && n >= 65536) {
-            libsais_clear_lms_suffixes_omp(SA, n, ALPHABET_SIZE, &buckets[6 * ALPHABET_SIZE],
-                                           &buckets[7 * ALPHABET_SIZE], threads);
-        }
-        libsais_final_sorting_scan_right_to_left_8u_omp(T, SA, n, &buckets[7 * ALPHABET_SIZE], threads, thread_state);
-        return 0;
-    } else if (I != NULL) {
-        libsais_final_bwt_aux_scan_left_to_right_8u_omp(T, SA, n, r - 1, I, &buckets[6 * ALPHABET_SIZE], threads,
-                                                        thread_state);
-        if (threads > 1 && n >= 65536) {
-            libsais_clear_lms_suffixes_omp(SA, n, ALPHABET_SIZE, &buckets[6 * ALPHABET_SIZE],
-                                           &buckets[7 * ALPHABET_SIZE], threads);
-        }
-        libsais_final_bwt_aux_scan_right_to_left_8u_omp(T, SA, n, r - 1, I, &buckets[7 * ALPHABET_SIZE], threads,
-                                                        thread_state);
-        return 0;
-    } else {
-        libsais_final_bwt_scan_left_to_right_8u_omp(T, SA, n, &buckets[6 * ALPHABET_SIZE], threads, thread_state);
-        if (threads > 1 && n >= 65536) {
-            libsais_clear_lms_suffixes_omp(SA, n, ALPHABET_SIZE, &buckets[6 * ALPHABET_SIZE],
-                                           &buckets[7 * ALPHABET_SIZE], threads);
-        }
-        return libsais_final_bwt_scan_right_to_left_8u_omp(T, SA, n, &buckets[7 * ALPHABET_SIZE], threads,
-                                                           thread_state);
-    }
-}
-
-static void libsais_induce_final_order_32s_6k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                              sa_sint_t k, sa_sint_t * RESTRICT buckets, sa_sint_t threads,
-                                              LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    libsais_final_sorting_scan_left_to_right_32s_omp(T, SA, n, &buckets[4 * k], threads, thread_state);
-    libsais_final_sorting_scan_right_to_left_32s_omp(T, SA, n, &buckets[5 * k], threads, thread_state);
-}
-
-static void libsais_induce_final_order_32s_4k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                              sa_sint_t k, sa_sint_t * RESTRICT buckets, sa_sint_t threads,
-                                              LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    libsais_final_sorting_scan_left_to_right_32s_omp(T, SA, n, &buckets[2 * k], threads, thread_state);
-    libsais_final_sorting_scan_right_to_left_32s_omp(T, SA, n, &buckets[3 * k], threads, thread_state);
-}
-
-static void libsais_induce_final_order_32s_2k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                              sa_sint_t k, sa_sint_t * RESTRICT buckets, sa_sint_t threads,
-                                              LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    libsais_final_sorting_scan_left_to_right_32s_omp(T, SA, n, &buckets[1 * k], threads, thread_state);
-    libsais_final_sorting_scan_right_to_left_32s_omp(T, SA, n, &buckets[0 * k], threads, thread_state);
-}
-
-static void libsais_induce_final_order_32s_1k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                              sa_sint_t k, sa_sint_t * RESTRICT buckets, sa_sint_t threads,
-                                              LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    libsais_count_suffixes_32s(T, n, k, buckets);
-    libsais_initialize_buckets_start_32s_1k(k, buckets);
-    libsais_final_sorting_scan_left_to_right_32s_omp(T, SA, n, buckets, threads, thread_state);
-
-    libsais_count_suffixes_32s(T, n, k, buckets);
-    libsais_initialize_buckets_end_32s_1k(k, buckets);
-    libsais_final_sorting_scan_right_to_left_32s_omp(T, SA, n, buckets, threads, thread_state);
-}
-
-static sa_sint_t libsais_renumber_unique_and_nonunique_lms_suffixes_32s(sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                                        sa_sint_t m, sa_sint_t f,
-                                                                        fast_sint_t omp_block_start,
-                                                                        fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    sa_sint_t * RESTRICT SAm = &SA[m];
-
-    sa_sint_t i, j;
-    for (i = (sa_sint_t)omp_block_start,
-        j = (sa_sint_t)omp_block_start + (sa_sint_t)omp_block_size - 2 * (sa_sint_t)prefetch_distance - 3;
-         i < j; i += 4) {
-        prefetch(&SA[i + 3 * prefetch_distance]);
-
-        prefetchw(&SAm[((sa_uint_t)SA[i + 2 * prefetch_distance + 0]) >> 1]);
-        prefetchw(&SAm[((sa_uint_t)SA[i + 2 * prefetch_distance + 1]) >> 1]);
-        prefetchw(&SAm[((sa_uint_t)SA[i + 2 * prefetch_distance + 2]) >> 1]);
-        prefetchw(&SAm[((sa_uint_t)SA[i + 2 * prefetch_distance + 3]) >> 1]);
-
-        sa_uint_t q0 = (sa_uint_t)SA[i + prefetch_distance + 0];
-        const sa_sint_t * Tq0 = &T[q0];
-        prefetchw(SAm[q0 >> 1] < 0 ? Tq0 : NULL);
-        sa_uint_t q1 = (sa_uint_t)SA[i + prefetch_distance + 1];
-        const sa_sint_t * Tq1 = &T[q1];
-        prefetchw(SAm[q1 >> 1] < 0 ? Tq1 : NULL);
-        sa_uint_t q2 = (sa_uint_t)SA[i + prefetch_distance + 2];
-        const sa_sint_t * Tq2 = &T[q2];
-        prefetchw(SAm[q2 >> 1] < 0 ? Tq2 : NULL);
-        sa_uint_t q3 = (sa_uint_t)SA[i + prefetch_distance + 3];
-        const sa_sint_t * Tq3 = &T[q3];
-        prefetchw(SAm[q3 >> 1] < 0 ? Tq3 : NULL);
-
-        sa_uint_t p0 = (sa_uint_t)SA[i + 0];
-        sa_sint_t s0 = SAm[p0 >> 1];
-        if (s0 < 0) {
-            T[p0] |= SAINT_MIN;
-            f++;
-            s0 = i + 0 + SAINT_MIN + f;
-        }
-        SAm[p0 >> 1] = s0 - f;
-        sa_uint_t p1 = (sa_uint_t)SA[i + 1];
-        sa_sint_t s1 = SAm[p1 >> 1];
-        if (s1 < 0) {
-            T[p1] |= SAINT_MIN;
-            f++;
-            s1 = i + 1 + SAINT_MIN + f;
-        }
-        SAm[p1 >> 1] = s1 - f;
-        sa_uint_t p2 = (sa_uint_t)SA[i + 2];
-        sa_sint_t s2 = SAm[p2 >> 1];
-        if (s2 < 0) {
-            T[p2] |= SAINT_MIN;
-            f++;
-            s2 = i + 2 + SAINT_MIN + f;
-        }
-        SAm[p2 >> 1] = s2 - f;
-        sa_uint_t p3 = (sa_uint_t)SA[i + 3];
-        sa_sint_t s3 = SAm[p3 >> 1];
-        if (s3 < 0) {
-            T[p3] |= SAINT_MIN;
-            f++;
-            s3 = i + 3 + SAINT_MIN + f;
-        }
-        SAm[p3 >> 1] = s3 - f;
-    }
-
-    for (j += 2 * (sa_sint_t)prefetch_distance + 3; i < j; i += 1) {
-        sa_uint_t p = (sa_uint_t)SA[i];
-        sa_sint_t s = SAm[p >> 1];
-        if (s < 0) {
-            T[p] |= SAINT_MIN;
-            f++;
-            s = i + SAINT_MIN + f;
-        }
-        SAm[p >> 1] = s - f;
-    }
-
-    return f;
-}
-
-static void libsais_compact_unique_and_nonunique_lms_suffixes_32s(sa_sint_t * RESTRICT SA, sa_sint_t m,
-                                                                  fast_sint_t * pl, fast_sint_t * pr,
-                                                                  fast_sint_t omp_block_start,
-                                                                  fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    sa_sint_t * RESTRICT SAl = &SA[0];
-    sa_sint_t * RESTRICT SAr = &SA[0];
-
-    fast_sint_t i, j, l = *pl - 1, r = *pr - 1;
-    for (i = (fast_sint_t)m + omp_block_start + omp_block_size - 1, j = (fast_sint_t)m + omp_block_start + 3; i >= j;
-         i -= 4) {
-        prefetch(&SA[i - prefetch_distance]);
-
-        sa_sint_t p0 = SA[i - 0];
-        SAl[l] = p0 & SAINT_MAX;
-        l -= p0 < 0;
-        SAr[r] = p0 - 1;
-        r -= p0 > 0;
-        sa_sint_t p1 = SA[i - 1];
-        SAl[l] = p1 & SAINT_MAX;
-        l -= p1 < 0;
-        SAr[r] = p1 - 1;
-        r -= p1 > 0;
-        sa_sint_t p2 = SA[i - 2];
-        SAl[l] = p2 & SAINT_MAX;
-        l -= p2 < 0;
-        SAr[r] = p2 - 1;
-        r -= p2 > 0;
-        sa_sint_t p3 = SA[i - 3];
-        SAl[l] = p3 & SAINT_MAX;
-        l -= p3 < 0;
-        SAr[r] = p3 - 1;
-        r -= p3 > 0;
-    }
-
-    for (j -= 3; i >= j; i -= 1) {
-        sa_sint_t p = SA[i];
-        SAl[l] = p & SAINT_MAX;
-        l -= p < 0;
-        SAr[r] = p - 1;
-        r -= p > 0;
-    }
-
-    *pl = l + 1;
-    *pr = r + 1;
-}
-static sa_sint_t libsais_renumber_unique_and_nonunique_lms_suffixes_32s_omp(
-    sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t m, sa_sint_t threads,
-    LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    sa_sint_t f = 0;
-    {
-        (void)(threads);
-        (void)(thread_state);
-
-        fast_sint_t omp_thread_num = 0;
-        fast_sint_t omp_num_threads = 1;
-
-        fast_sint_t omp_block_stride = (m / omp_num_threads) & (-16);
-        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
-        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : m - omp_block_start;
-
-        if (omp_num_threads == 1) {
-            f = libsais_renumber_unique_and_nonunique_lms_suffixes_32s(T, SA, m, 0, omp_block_start, omp_block_size);
-        }
-    }
-
-    return f;
-}
-
-static void libsais_compact_unique_and_nonunique_lms_suffixes_32s_omp(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m,
-                                                                      sa_sint_t fs, sa_sint_t f, sa_sint_t threads,
-                                                                      LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    {
-        (void)(threads);
-        (void)(thread_state);
-
-        fast_sint_t omp_thread_num = 0;
-        fast_sint_t omp_num_threads = 1;
-
-        fast_sint_t omp_block_stride = (((fast_sint_t)n >> 1) / omp_num_threads) & (-16);
-        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
-        fast_sint_t omp_block_size =
-            omp_thread_num < omp_num_threads - 1 ? omp_block_stride : ((fast_sint_t)n >> 1) - omp_block_start;
-
-        if (omp_num_threads == 1) {
-            fast_sint_t l = m, r = (fast_sint_t)n + (fast_sint_t)fs;
-            libsais_compact_unique_and_nonunique_lms_suffixes_32s(SA, m, &l, &r, omp_block_start, omp_block_size);
-        }
-    }
-
-    memcpy(&SA[(fast_sint_t)n + (fast_sint_t)fs - (fast_sint_t)m], &SA[(fast_sint_t)m - (fast_sint_t)f],
-           (size_t)f * sizeof(sa_sint_t));
-}
-
-static sa_sint_t libsais_compact_lms_suffixes_32s_omp(sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                      sa_sint_t m, sa_sint_t fs, sa_sint_t threads,
-                                                      LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    sa_sint_t f = libsais_renumber_unique_and_nonunique_lms_suffixes_32s_omp(T, SA, m, threads, thread_state);
-    libsais_compact_unique_and_nonunique_lms_suffixes_32s_omp(SA, n, m, fs, f, threads, thread_state);
-
-    return f;
-}
-
-static void libsais_merge_unique_lms_suffixes_32s(sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                  sa_sint_t m, fast_sint_t l, fast_sint_t omp_block_start,
-                                                  fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    const sa_sint_t * RESTRICT SAnm = &SA[(fast_sint_t)n - (fast_sint_t)m - 1 + l];
-
-    sa_sint_t i, j;
-    fast_sint_t tmp = *SAnm++;
-    for (i = (sa_sint_t)omp_block_start, j = (sa_sint_t)omp_block_start + (sa_sint_t)omp_block_size - 6; i < j;
-         i += 4) {
-        prefetch(&T[i + prefetch_distance]);
-
-        sa_sint_t c0 = T[i + 0];
-        if (c0 < 0) {
-            T[i + 0] = c0 & SAINT_MAX;
-            SA[tmp] = i + 0;
-            i++;
-            tmp = *SAnm++;
-        }
-        sa_sint_t c1 = T[i + 1];
-        if (c1 < 0) {
-            T[i + 1] = c1 & SAINT_MAX;
-            SA[tmp] = i + 1;
-            i++;
-            tmp = *SAnm++;
-        }
-        sa_sint_t c2 = T[i + 2];
-        if (c2 < 0) {
-            T[i + 2] = c2 & SAINT_MAX;
-            SA[tmp] = i + 2;
-            i++;
-            tmp = *SAnm++;
-        }
-        sa_sint_t c3 = T[i + 3];
-        if (c3 < 0) {
-            T[i + 3] = c3 & SAINT_MAX;
-            SA[tmp] = i + 3;
-            i++;
-            tmp = *SAnm++;
-        }
-    }
-
-    for (j += 6; i < j; i += 1) {
-        sa_sint_t c = T[i];
-        if (c < 0) {
-            T[i] = c & SAINT_MAX;
-            SA[tmp] = i;
-            i++;
-            tmp = *SAnm++;
-        }
-    }
-}
-
-static void libsais_merge_nonunique_lms_suffixes_32s(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m, fast_sint_t l,
-                                                     fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    const sa_sint_t * RESTRICT SAnm = &SA[(fast_sint_t)n - (fast_sint_t)m - 1 + l];
-
-    fast_sint_t i, j;
-    sa_sint_t tmp = *SAnm++;
-    for (i = omp_block_start, j = omp_block_start + omp_block_size - 3; i < j; i += 4) {
-        prefetch(&SA[i + prefetch_distance]);
-
-        if (SA[i + 0] == 0) {
-            SA[i + 0] = tmp;
-            tmp = *SAnm++;
-        }
-        if (SA[i + 1] == 0) {
-            SA[i + 1] = tmp;
-            tmp = *SAnm++;
-        }
-        if (SA[i + 2] == 0) {
-            SA[i + 2] = tmp;
-            tmp = *SAnm++;
-        }
-        if (SA[i + 3] == 0) {
-            SA[i + 3] = tmp;
-            tmp = *SAnm++;
-        }
-    }
-
-    for (j += 3; i < j; i += 1) {
-        if (SA[i] == 0) {
-            SA[i] = tmp;
-            tmp = *SAnm++;
-        }
-    }
-}
-
-static void libsais_merge_unique_lms_suffixes_32s_omp(sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                      sa_sint_t m, sa_sint_t threads,
-                                                      LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    {
-        (void)(threads);
-        (void)(thread_state);
-
-        fast_sint_t omp_thread_num = 0;
-        fast_sint_t omp_num_threads = 1;
-
-        fast_sint_t omp_block_stride = (n / omp_num_threads) & (-16);
-        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
-        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : n - omp_block_start;
-
-        if (omp_num_threads == 1) {
-            libsais_merge_unique_lms_suffixes_32s(T, SA, n, m, 0, omp_block_start, omp_block_size);
-        }
-    }
-}
-
-static void libsais_merge_nonunique_lms_suffixes_32s_omp(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m, sa_sint_t f,
-                                                         sa_sint_t threads,
-                                                         LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    {
-        (void)(threads);
-        (void)(thread_state);
-
-        fast_sint_t omp_thread_num = 0;
-        fast_sint_t omp_num_threads = 1;
-
-        fast_sint_t omp_block_stride = (m / omp_num_threads) & (-16);
-        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
-        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : m - omp_block_start;
-
-        if (omp_num_threads == 1) {
-            libsais_merge_nonunique_lms_suffixes_32s(SA, n, m, f, omp_block_start, omp_block_size);
-        }
-    }
-}
-
-static void libsais_merge_compacted_lms_suffixes_32s_omp(sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
-                                                         sa_sint_t m, sa_sint_t f, sa_sint_t threads,
-                                                         LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    libsais_merge_unique_lms_suffixes_32s_omp(T, SA, n, m, threads, thread_state);
-    libsais_merge_nonunique_lms_suffixes_32s_omp(SA, n, m, f, threads, thread_state);
-}
-
-static void libsais_reconstruct_compacted_lms_suffixes_32s_2k_omp(sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                                  sa_sint_t n, sa_sint_t k, sa_sint_t m, sa_sint_t fs,
-                                                                  sa_sint_t f, sa_sint_t * RESTRICT buckets,
-                                                                  sa_sint_t threads,
-                                                                  LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    if (f > 0) {
-        memmove(&SA[n - m - 1], &SA[n + fs - m], (size_t)f * sizeof(sa_sint_t));
-
-        libsais_count_and_gather_compacted_lms_suffixes_32s_2k_omp(T, SA, n, k, buckets, threads, thread_state);
-        libsais_reconstruct_lms_suffixes_omp(SA, n, m - f, threads);
-
-        memcpy(&SA[n - m - 1 + f], &SA[0], ((size_t)m - (size_t)f) * sizeof(sa_sint_t));
-        memset(&SA[0], 0, (size_t)m * sizeof(sa_sint_t));
-
-        libsais_merge_compacted_lms_suffixes_32s_omp(T, SA, n, m, f, threads, thread_state);
-    } else {
-        libsais_count_and_gather_lms_suffixes_32s_2k(T, SA, n, k, buckets, 0, n);
-        libsais_reconstruct_lms_suffixes_omp(SA, n, m, threads);
-    }
-}
-
-static void libsais_reconstruct_compacted_lms_suffixes_32s_1k_omp(sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
-                                                                  sa_sint_t n, sa_sint_t m, sa_sint_t fs, sa_sint_t f,
-                                                                  sa_sint_t threads,
-                                                                  LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    if (f > 0) {
-        memmove(&SA[n - m - 1], &SA[n + fs - m], (size_t)f * sizeof(sa_sint_t));
-
-        libsais_gather_compacted_lms_suffixes_32s(T, SA, n);
-        libsais_reconstruct_lms_suffixes_omp(SA, n, m - f, threads);
-
-        memcpy(&SA[n - m - 1 + f], &SA[0], ((size_t)m - (size_t)f) * sizeof(sa_sint_t));
-        memset(&SA[0], 0, (size_t)m * sizeof(sa_sint_t));
-
-        libsais_merge_compacted_lms_suffixes_32s_omp(T, SA, n, m, f, threads, thread_state);
-    } else {
-        libsais_gather_lms_suffixes_32s(T, SA, n);
-        libsais_reconstruct_lms_suffixes_omp(SA, n, m, threads);
-    }
-}
-
-static sa_sint_t libsais_main_32s(sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t k,
-                                  sa_sint_t fs, sa_sint_t threads, LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    fs = fs < (SAINT_MAX - n) ? fs : (SAINT_MAX - n);
-
-    if (k > 0 && fs / k >= 6) {
-        sa_sint_t alignment = (fs - 1024) / k >= 6 ? 1024 : 16;
-        sa_sint_t * RESTRICT buckets =
-            (fs - alignment) / k >= 6
-                ? (sa_sint_t *)libsais_align_up(&SA[n + fs - 6 * k - alignment], (size_t)alignment * sizeof(sa_sint_t))
-                : &SA[n + fs - 6 * k];
-
-        sa_sint_t m = libsais_count_and_gather_lms_suffixes_32s_4k_omp(T, SA, n, k, buckets, threads, thread_state);
-        if (m > 1) {
-            memset(SA, 0, ((size_t)n - (size_t)m) * sizeof(sa_sint_t));
-
-            sa_sint_t first_lms_suffix = SA[n - m];
-            sa_sint_t left_suffixes_count =
-                libsais_initialize_buckets_for_lms_suffixes_radix_sort_32s_6k(T, k, buckets, first_lms_suffix);
-
-            libsais_radix_sort_lms_suffixes_32s_6k_omp(T, SA, n, m, &buckets[4 * k], threads, thread_state);
-            libsais_radix_sort_set_markers_32s_6k_omp(SA, k, &buckets[4 * k], threads);
-
-            if (threads > 1 && n >= 65536) {
-                memset(&SA[(fast_sint_t)n - (fast_sint_t)m], 0, (size_t)m * sizeof(sa_sint_t));
-            }
-
-            libsais_initialize_buckets_for_partial_sorting_32s_6k(T, k, buckets, first_lms_suffix, left_suffixes_count);
-            libsais_induce_partial_order_32s_6k_omp(T, SA, n, k, buckets, first_lms_suffix, left_suffixes_count,
-                                                    threads, thread_state);
-
-            sa_sint_t names =
-                libsais_renumber_and_mark_distinct_lms_suffixes_32s_4k_omp(SA, n, m, threads, thread_state);
-            if (names < m) {
-                sa_sint_t f = libsais_compact_lms_suffixes_32s_omp(T, SA, n, m, fs, threads, thread_state);
-
-                if (libsais_main_32s(SA + n + fs - m + f, SA, m - f, names - f, fs + n - 2 * m + f, threads,
-                                     thread_state) != 0) {
-                    return -2;
-                }
-
-                libsais_reconstruct_compacted_lms_suffixes_32s_2k_omp(T, SA, n, k, m, fs, f, buckets, threads,
-                                                                      thread_state);
-            } else {
-                libsais_count_lms_suffixes_32s_2k(T, n, k, buckets);
-            }
-
-            libsais_initialize_buckets_start_and_end_32s_4k(k, buckets);
-            libsais_place_lms_suffixes_histogram_32s_4k(SA, n, k, m, buckets);
-            libsais_induce_final_order_32s_4k(T, SA, n, k, buckets, threads, thread_state);
-        } else {
-            SA[0] = SA[n - 1];
-
-            libsais_initialize_buckets_start_and_end_32s_6k(k, buckets);
-            libsais_place_lms_suffixes_histogram_32s_6k(SA, n, k, m, buckets);
-            libsais_induce_final_order_32s_6k(T, SA, n, k, buckets, threads, thread_state);
-        }
-
-        return 0;
-    } else if (k > 0 && fs / k >= 4) {
-        sa_sint_t alignment = (fs - 1024) / k >= 4 ? 1024 : 16;
-        sa_sint_t * RESTRICT buckets =
-            (fs - alignment) / k >= 4
-                ? (sa_sint_t *)libsais_align_up(&SA[n + fs - 4 * k - alignment], (size_t)alignment * sizeof(sa_sint_t))
-                : &SA[n + fs - 4 * k];
-
-        sa_sint_t m = libsais_count_and_gather_lms_suffixes_32s_2k_omp(T, SA, n, k, buckets, threads, thread_state);
-        if (m > 1) {
-            libsais_initialize_buckets_for_radix_and_partial_sorting_32s_4k(T, k, buckets, SA[n - m]);
-
-            libsais_radix_sort_lms_suffixes_32s_2k_omp(T, SA, n, m, &buckets[1], threads, thread_state);
-            libsais_radix_sort_set_markers_32s_4k_omp(SA, k, &buckets[1], threads);
-
-            libsais_place_lms_suffixes_interval_32s_4k(SA, n, k, m - 1, buckets);
-            libsais_induce_partial_order_32s_4k_omp(T, SA, n, k, buckets, threads, thread_state);
-
-            sa_sint_t names =
-                libsais_renumber_and_mark_distinct_lms_suffixes_32s_4k_omp(SA, n, m, threads, thread_state);
-            if (names < m) {
-                sa_sint_t f = libsais_compact_lms_suffixes_32s_omp(T, SA, n, m, fs, threads, thread_state);
-
-                if (libsais_main_32s(SA + n + fs - m + f, SA, m - f, names - f, fs + n - 2 * m + f, threads,
-                                     thread_state) != 0) {
-                    return -2;
-                }
-
-                libsais_reconstruct_compacted_lms_suffixes_32s_2k_omp(T, SA, n, k, m, fs, f, buckets, threads,
-                                                                      thread_state);
-            } else {
-                libsais_count_lms_suffixes_32s_2k(T, n, k, buckets);
-            }
-        } else {
-            SA[0] = SA[n - 1];
-        }
-
-        libsais_initialize_buckets_start_and_end_32s_4k(k, buckets);
-        libsais_place_lms_suffixes_histogram_32s_4k(SA, n, k, m, buckets);
-        libsais_induce_final_order_32s_4k(T, SA, n, k, buckets, threads, thread_state);
-
-        return 0;
-    } else if (k > 0 && fs / k >= 2) {
-        sa_sint_t alignment = (fs - 1024) / k >= 2 ? 1024 : 16;
-        sa_sint_t * RESTRICT buckets =
-            (fs - alignment) / k >= 2
-                ? (sa_sint_t *)libsais_align_up(&SA[n + fs - 2 * k - alignment], (size_t)alignment * sizeof(sa_sint_t))
-                : &SA[n + fs - 2 * k];
-
-        sa_sint_t m = libsais_count_and_gather_lms_suffixes_32s_2k_omp(T, SA, n, k, buckets, threads, thread_state);
-        if (m > 1) {
-            libsais_initialize_buckets_for_lms_suffixes_radix_sort_32s_2k(T, k, buckets, SA[n - m]);
-
-            libsais_radix_sort_lms_suffixes_32s_2k_omp(T, SA, n, m, &buckets[1], threads, thread_state);
-            libsais_place_lms_suffixes_interval_32s_2k(SA, n, k, m - 1, buckets);
-
-            libsais_initialize_buckets_start_and_end_32s_2k(k, buckets);
-            libsais_induce_partial_order_32s_2k_omp(T, SA, n, k, buckets, threads, thread_state);
-
-            sa_sint_t names = libsais_renumber_and_mark_distinct_lms_suffixes_32s_1k_omp(T, SA, n, m, threads);
-            if (names < m) {
-                sa_sint_t f = libsais_compact_lms_suffixes_32s_omp(T, SA, n, m, fs, threads, thread_state);
-
-                if (libsais_main_32s(SA + n + fs - m + f, SA, m - f, names - f, fs + n - 2 * m + f, threads,
-                                     thread_state) != 0) {
-                    return -2;
-                }
-
-                libsais_reconstruct_compacted_lms_suffixes_32s_2k_omp(T, SA, n, k, m, fs, f, buckets, threads,
-                                                                      thread_state);
-            } else {
-                libsais_count_lms_suffixes_32s_2k(T, n, k, buckets);
-            }
-        } else {
-            SA[0] = SA[n - 1];
-        }
-
-        libsais_initialize_buckets_end_32s_2k(k, buckets);
-        libsais_place_lms_suffixes_histogram_32s_2k(SA, n, k, m, buckets);
-
-        libsais_initialize_buckets_start_and_end_32s_2k(k, buckets);
-        libsais_induce_final_order_32s_2k(T, SA, n, k, buckets, threads, thread_state);
-
-        return 0;
-    } else {
-        sa_sint_t * buffer =
-            fs < k ? (sa_sint_t *)libsais_alloc_aligned((size_t)k * sizeof(sa_sint_t), 4096) : (sa_sint_t *)NULL;
-
-        sa_sint_t alignment = fs - 1024 >= k ? 1024 : 16;
-        sa_sint_t * RESTRICT buckets =
-            fs - alignment >= k
-                ? (sa_sint_t *)libsais_align_up(&SA[n + fs - k - alignment], (size_t)alignment * sizeof(sa_sint_t))
-            : fs >= k ? &SA[n + fs - k]
-                      : buffer;
-
-        if (buckets == NULL) {
-            return -2;
-        }
-
-        memset(SA, 0, (size_t)n * sizeof(sa_sint_t));
-
-        libsais_count_suffixes_32s(T, n, k, buckets);
-        libsais_initialize_buckets_end_32s_1k(k, buckets);
-
-        sa_sint_t m = libsais_radix_sort_lms_suffixes_32s_1k(T, SA, n, buckets);
-        if (m > 1) {
-            libsais_induce_partial_order_32s_1k_omp(T, SA, n, k, buckets, threads, thread_state);
-
-            sa_sint_t names = libsais_renumber_and_mark_distinct_lms_suffixes_32s_1k_omp(T, SA, n, m, threads);
-            if (names < m) {
-                if (buffer != NULL) {
-                    libsais_free_aligned(buffer);
-                    buckets = NULL;
-                }
-
-                sa_sint_t f = libsais_compact_lms_suffixes_32s_omp(T, SA, n, m, fs, threads, thread_state);
-
-                if (libsais_main_32s(SA + n + fs - m + f, SA, m - f, names - f, fs + n - 2 * m + f, threads,
-                                     thread_state) != 0) {
-                    return -2;
-                }
-
-                libsais_reconstruct_compacted_lms_suffixes_32s_1k_omp(T, SA, n, m, fs, f, threads, thread_state);
-
-                if (buckets == NULL) {
-                    buckets = buffer = (sa_sint_t *)libsais_alloc_aligned((size_t)k * sizeof(sa_sint_t), 4096);
-                }
-                if (buckets == NULL) {
-                    return -2;
-                }
-            }
-
-            libsais_count_suffixes_32s(T, n, k, buckets);
-            libsais_initialize_buckets_end_32s_1k(k, buckets);
-            libsais_place_lms_suffixes_interval_32s_1k(T, SA, k, m, buckets);
-        }
-
-        libsais_induce_final_order_32s_1k(T, SA, n, k, buckets, threads, thread_state);
-        libsais_free_aligned(buffer);
-
-        return 0;
-    }
-}
-
-static sa_sint_t libsais_main_8u(const u8 * T, sa_sint_t * SA, sa_sint_t n, sa_sint_t * RESTRICT buckets, sa_sint_t bwt,
-                                 sa_sint_t r, sa_sint_t * RESTRICT I, sa_sint_t fs, sa_sint_t * freq, sa_sint_t threads,
-                                 LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
-    fs = fs < (SAINT_MAX - n) ? fs : (SAINT_MAX - n);
-
-    sa_sint_t m = libsais_count_and_gather_lms_suffixes_8u_omp(T, SA, n, buckets, threads, thread_state);
-
-    libsais_initialize_buckets_start_and_end_8u(buckets, freq);
-
-    if (m > 0) {
-        sa_sint_t first_lms_suffix = SA[n - m];
-        sa_sint_t left_suffixes_count =
-            libsais_initialize_buckets_for_lms_suffixes_radix_sort_8u(T, buckets, first_lms_suffix);
-
-        if (threads > 1 && n >= 65536) {
-            memset(SA, 0, ((size_t)n - (size_t)m) * sizeof(sa_sint_t));
-        }
-        libsais_radix_sort_lms_suffixes_8u_omp(T, SA, n, m, buckets, threads, thread_state);
-        if (threads > 1 && n >= 65536) {
-            memset(&SA[(fast_sint_t)n - (fast_sint_t)m], 0, (size_t)m * sizeof(sa_sint_t));
-        }
-
-        libsais_initialize_buckets_for_partial_sorting_8u(T, buckets, first_lms_suffix, left_suffixes_count);
-        libsais_induce_partial_order_8u_omp(T, SA, n, buckets, first_lms_suffix, left_suffixes_count, threads,
-                                            thread_state);
-
-        sa_sint_t names = libsais_renumber_and_gather_lms_suffixes_8u_omp(SA, n, m, fs, threads, thread_state);
-        if (names < m) {
-            if (libsais_main_32s(SA + n + fs - m, SA, m, names, fs + n - 2 * m, threads, thread_state) != 0) {
-                return -2;
-            }
-
-            libsais_gather_lms_suffixes_8u_omp(T, SA, n, threads, thread_state);
-            libsais_reconstruct_lms_suffixes_omp(SA, n, m, threads);
-        }
-
-        libsais_place_lms_suffixes_interval_8u(SA, n, m, buckets);
-    } else {
-        memset(SA, 0, (size_t)n * sizeof(sa_sint_t));
-    }
-
-    return libsais_induce_final_order_8u_omp(T, SA, n, bwt, r, I, buckets, threads, thread_state);
-}
-
-static sa_sint_t libsais_main(const u8 * T, sa_sint_t * SA, sa_sint_t n, sa_sint_t bwt, sa_sint_t r, sa_sint_t * I,
-                              sa_sint_t fs, sa_sint_t * freq, sa_sint_t threads) {
-    LIBSAIS_THREAD_STATE * RESTRICT thread_state = threads > 1 ? libsais_alloc_thread_state(threads) : NULL;
-    sa_sint_t * RESTRICT buckets = (sa_sint_t *)libsais_alloc_aligned(8 * ALPHABET_SIZE * sizeof(sa_sint_t), 4096);
-
-    sa_sint_t index = buckets != NULL && (thread_state != NULL || threads == 1)
-                          ? libsais_main_8u(T, SA, n, buckets, bwt, r, I, fs, freq, threads, thread_state)
-                          : -2;
-
-    libsais_free_aligned(buckets);
-    libsais_free_thread_state(thread_state);
-
-    return index;
-}
-
-static s32 libsais_main_int(sa_sint_t * T, sa_sint_t * SA, sa_sint_t n, sa_sint_t k, sa_sint_t fs, sa_sint_t threads) {
-    LIBSAIS_THREAD_STATE * RESTRICT thread_state = threads > 1 ? libsais_alloc_thread_state(threads) : NULL;
-
-    sa_sint_t index =
-        thread_state != NULL || threads == 1 ? libsais_main_32s(T, SA, n, k, fs, threads, thread_state) : -2;
-
-    libsais_free_thread_state(thread_state);
-
-    return index;
-}
-
-static sa_sint_t libsais_main_ctx(const LIBSAIS_CONTEXT * ctx, const u8 * T, sa_sint_t * SA, sa_sint_t n, sa_sint_t bwt,
-                                  sa_sint_t r, sa_sint_t * I, sa_sint_t fs, sa_sint_t * freq) {
-    return ctx != NULL && (ctx->buckets != NULL && (ctx->thread_state != NULL || ctx->threads == 1))
-               ? libsais_main_8u(T, SA, n, ctx->buckets, bwt, r, I, fs, freq, (sa_sint_t)ctx->threads,
-                                 ctx->thread_state)
-               : -2;
-}
-
-static void libsais_bwt_copy_8u(u8 * RESTRICT U, sa_sint_t * RESTRICT A, sa_sint_t n) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j;
-    for (i = 0, j = (fast_sint_t)n - 7; i < j; i += 8) {
-        prefetch(&A[i + prefetch_distance]);
-
-        U[i + 0] = (u8)A[i + 0];
-        U[i + 1] = (u8)A[i + 1];
-        U[i + 2] = (u8)A[i + 2];
-        U[i + 3] = (u8)A[i + 3];
-        U[i + 4] = (u8)A[i + 4];
-        U[i + 5] = (u8)A[i + 5];
-        U[i + 6] = (u8)A[i + 6];
-        U[i + 7] = (u8)A[i + 7];
-    }
-
-    for (j += 7; i < j; i += 1) {
-        U[i] = (u8)A[i];
-    }
-}
-static void * libsais_create_ctx(void) { return (void *)libsais_create_ctx_main(1); }
-
-static void libsais_free_ctx(void * ctx) { libsais_free_ctx_main((LIBSAIS_CONTEXT *)ctx); }
-
-static s32 libsais(const u8 * T, s32 * SA, s32 n, s32 fs, s32 * freq) {
-    if ((T == NULL) || (SA == NULL) || (n < 0) || (fs < 0)) {
-        return -1;
-    } else if (n < 2) {
-        if (freq != NULL) {
-            memset(freq, 0, ALPHABET_SIZE * sizeof(s32));
-        }
-        if (n == 1) {
-            SA[0] = 0;
-            if (freq != NULL) {
-                freq[T[0]]++;
-            }
-        }
-        return 0;
-    }
-
-    return libsais_main(T, SA, n, 0, 0, NULL, fs, freq, 1);
-}
-
-static s32 libsais_int(s32 * T, s32 * SA, s32 n, s32 k, s32 fs) {
-    if ((T == NULL) || (SA == NULL) || (n < 0) || (fs < 0)) {
-        return -1;
-    } else if (n < 2) {
-        if (n == 1) {
-            SA[0] = 0;
-        }
-        return 0;
-    }
-
-    return libsais_main_int(T, SA, n, k, fs, 1);
-}
-
-static s32 libsais_ctx(const void * ctx, const u8 * T, s32 * SA, s32 n, s32 fs, s32 * freq) {
-    if ((ctx == NULL) || (T == NULL) || (SA == NULL) || (n < 0) || (fs < 0)) {
-        return -1;
-    } else if (n < 2) {
-        if (freq != NULL) {
-            memset(freq, 0, ALPHABET_SIZE * sizeof(s32));
-        }
-        if (n == 1) {
-            SA[0] = 0;
-            if (freq != NULL) {
-                freq[T[0]]++;
-            }
-        }
-        return 0;
-    }
-
-    return libsais_main_ctx((const LIBSAIS_CONTEXT *)ctx, T, SA, n, 0, 0, NULL, fs, freq);
-}
-
-static s32 libsais_bwt(const u8 * T, u8 * U, s32 * A, s32 n, s32 fs, s32 * freq) {
-    if ((T == NULL) || (U == NULL) || (A == NULL) || (n < 0) || (fs < 0)) {
-        return -1;
-    } else if (n <= 1) {
-        if (freq != NULL) {
-            memset(freq, 0, ALPHABET_SIZE * sizeof(s32));
-        }
-        if (n == 1) {
-            U[0] = T[0];
-            if (freq != NULL) {
-                freq[T[0]]++;
-            }
-        }
-        return n;
-    }
-
-    sa_sint_t index = libsais_main(T, A, n, 1, 0, NULL, fs, freq, 1);
-    if (index >= 0) {
-        index++;
-
-        U[0] = T[n - 1];
-        libsais_bwt_copy_8u(U + 1, A, index - 1);
-        libsais_bwt_copy_8u(U + index, A + index, n - index);
-    }
-
-    return index;
-}
-
-static s32 libsais_bwt_aux(const u8 * T, u8 * U, s32 * A, s32 n, s32 fs, s32 * freq, s32 r, s32 * I) {
-    if ((T == NULL) || (U == NULL) || (A == NULL) || (n < 0) || (fs < 0) || (r < 2) || ((r & (r - 1)) != 0) ||
-        (I == NULL)) {
-        return -1;
-    } else if (n <= 1) {
-        if (freq != NULL) {
-            memset(freq, 0, ALPHABET_SIZE * sizeof(s32));
-        }
-        if (n == 1) {
-            U[0] = T[0];
-            if (freq != NULL) {
-                freq[T[0]]++;
-            }
-        }
-        I[0] = n;
-        return 0;
-    }
-
-    if (libsais_main(T, A, n, 1, r, I, fs, freq, 1) != 0) {
-        return -2;
-    }
-
-    U[0] = T[n - 1];
-    libsais_bwt_copy_8u(U + 1, A, I[0] - 1);
-    libsais_bwt_copy_8u(U + I[0], A + I[0], n - I[0]);
-
-    return 0;
-}
-
-static s32 libsais_bwt_ctx(const void * ctx, const u8 * T, u8 * U, s32 * A, s32 n, s32 fs, s32 * freq) {
-    if ((ctx == NULL) || (T == NULL) || (U == NULL) || (A == NULL) || (n < 0) || (fs < 0)) {
-        return -1;
-    } else if (n <= 1) {
-        if (freq != NULL) {
-            memset(freq, 0, ALPHABET_SIZE * sizeof(s32));
-        }
-        if (n == 1) {
-            U[0] = T[0];
-            if (freq != NULL) {
-                freq[T[0]]++;
-            }
-        }
-        return n;
-    }
-
-    sa_sint_t index = libsais_main_ctx((const LIBSAIS_CONTEXT *)ctx, T, A, n, 1, 0, NULL, fs, freq);
-    if (index >= 0) {
-        index++;
-
-        U[0] = T[n - 1];
-
-        libsais_bwt_copy_8u(U + 1, A, index - 1);
-        libsais_bwt_copy_8u(U + index, A + index, n - index);
-    }
-
-    return index;
-}
-
-static s32 libsais_bwt_aux_ctx(const void * ctx, const u8 * T, u8 * U, s32 * A, s32 n, s32 fs, s32 * freq, s32 r,
-                               s32 * I) {
-    if ((ctx == NULL) || (T == NULL) || (U == NULL) || (A == NULL) || (n < 0) || (fs < 0) || (r < 2) ||
-        ((r & (r - 1)) != 0) || (I == NULL)) {
-        return -1;
-    } else if (n <= 1) {
-        if (freq != NULL) {
-            memset(freq, 0, ALPHABET_SIZE * sizeof(s32));
-        }
-        if (n == 1) {
-            U[0] = T[0];
-            if (freq != NULL) {
-                freq[T[0]]++;
-            }
-        }
-        I[0] = n;
-        return 0;
-    }
-
-    if (libsais_main_ctx((const LIBSAIS_CONTEXT *)ctx, T, A, n, 1, r, I, fs, freq) != 0) {
-        return -2;
-    }
-
-    U[0] = T[n - 1];
-    libsais_bwt_copy_8u(U + 1, A, I[0] - 1);
-    libsais_bwt_copy_8u(U + I[0], A + I[0], n - I[0]);
-    return 0;
-}
-static LIBSAIS_UNBWT_CONTEXT * libsais_unbwt_create_ctx_main(sa_sint_t threads) {
-    LIBSAIS_UNBWT_CONTEXT * RESTRICT ctx =
-        (LIBSAIS_UNBWT_CONTEXT *)libsais_alloc_aligned(sizeof(LIBSAIS_UNBWT_CONTEXT), 64);
-    sa_uint_t * RESTRICT bucket2 =
-        (sa_uint_t *)libsais_alloc_aligned(ALPHABET_SIZE * ALPHABET_SIZE * sizeof(sa_uint_t), 4096);
-    u16 * RESTRICT fastbits = (u16 *)libsais_alloc_aligned((1 + (1 << UNBWT_FASTBITS)) * sizeof(u16), 4096);
-    sa_uint_t * RESTRICT buckets =
-        threads > 1 ? (sa_uint_t *)libsais_alloc_aligned(
-                          (size_t)threads * (ALPHABET_SIZE + (ALPHABET_SIZE * ALPHABET_SIZE)) * sizeof(sa_uint_t), 4096)
-                    : NULL;
-
-    if (ctx != NULL && bucket2 != NULL && fastbits != NULL && (buckets != NULL || threads == 1)) {
-        ctx->bucket2 = bucket2;
-        ctx->fastbits = fastbits;
-        ctx->buckets = buckets;
-        ctx->threads = threads;
-
-        return ctx;
-    }
-
-    libsais_free_aligned(buckets);
-    libsais_free_aligned(fastbits);
-    libsais_free_aligned(bucket2);
-    libsais_free_aligned(ctx);
-
-    return NULL;
-}
-
-static void libsais_unbwt_free_ctx_main(LIBSAIS_UNBWT_CONTEXT * ctx) {
-    if (ctx != NULL) {
-        libsais_free_aligned(ctx->buckets);
-        libsais_free_aligned(ctx->fastbits);
-        libsais_free_aligned(ctx->bucket2);
-        libsais_free_aligned(ctx);
-    }
-}
-
-static void libsais_unbwt_compute_histogram(const u8 * RESTRICT T, fast_sint_t n, sa_uint_t * RESTRICT count) {
-    const fast_sint_t prefetch_distance = 256;
-
-    const u8 * RESTRICT T_p = T;
-
-    if (n >= 1024) {
-        sa_uint_t copy[4 * (ALPHABET_SIZE + 16)];
-
-        memset(copy, 0, 4 * (ALPHABET_SIZE + 16) * sizeof(sa_uint_t));
-
-        sa_uint_t * RESTRICT copy0 = copy + 0 * (ALPHABET_SIZE + 16);
-        sa_uint_t * RESTRICT copy1 = copy + 1 * (ALPHABET_SIZE + 16);
-        sa_uint_t * RESTRICT copy2 = copy + 2 * (ALPHABET_SIZE + 16);
-        sa_uint_t * RESTRICT copy3 = copy + 3 * (ALPHABET_SIZE + 16);
-
-        for (; T_p < (u8 *)((ptrdiff_t)(T + 63) & (-64)); T_p += 1) {
-            copy0[T_p[0]]++;
-        }
-
-        fast_uint_t x = ((const u32 *)(const void *)T_p)[0], y = ((const u32 *)(const void *)T_p)[1];
-
-        for (; T_p < (u8 *)((ptrdiff_t)(T + n - 8) & (-64)); T_p += 64) {
-            prefetch(&T_p[prefetch_distance]);
-
-            fast_uint_t z = ((const u32 *)(const void *)T_p)[2], w = ((const u32 *)(const void *)T_p)[3];
-            copy0[(u8)x]++;
-            x >>= 8;
-            copy1[(u8)x]++;
-            x >>= 8;
-            copy2[(u8)x]++;
-            x >>= 8;
-            copy3[x]++;
-            copy0[(u8)y]++;
-            y >>= 8;
-            copy1[(u8)y]++;
-            y >>= 8;
-            copy2[(u8)y]++;
-            y >>= 8;
-            copy3[y]++;
-
-            x = ((const u32 *)(const void *)T_p)[4];
-            y = ((const u32 *)(const void *)T_p)[5];
-            copy0[(u8)z]++;
-            z >>= 8;
-            copy1[(u8)z]++;
-            z >>= 8;
-            copy2[(u8)z]++;
-            z >>= 8;
-            copy3[z]++;
-            copy0[(u8)w]++;
-            w >>= 8;
-            copy1[(u8)w]++;
-            w >>= 8;
-            copy2[(u8)w]++;
-            w >>= 8;
-            copy3[w]++;
-
-            z = ((const u32 *)(const void *)T_p)[6];
-            w = ((const u32 *)(const void *)T_p)[7];
-            copy0[(u8)x]++;
-            x >>= 8;
-            copy1[(u8)x]++;
-            x >>= 8;
-            copy2[(u8)x]++;
-            x >>= 8;
-            copy3[x]++;
-            copy0[(u8)y]++;
-            y >>= 8;
-            copy1[(u8)y]++;
-            y >>= 8;
-            copy2[(u8)y]++;
-            y >>= 8;
-            copy3[y]++;
-
-            x = ((const u32 *)(const void *)T_p)[8];
-            y = ((const u32 *)(const void *)T_p)[9];
-            copy0[(u8)z]++;
-            z >>= 8;
-            copy1[(u8)z]++;
-            z >>= 8;
-            copy2[(u8)z]++;
-            z >>= 8;
-            copy3[z]++;
-            copy0[(u8)w]++;
-            w >>= 8;
-            copy1[(u8)w]++;
-            w >>= 8;
-            copy2[(u8)w]++;
-            w >>= 8;
-            copy3[w]++;
-
-            z = ((const u32 *)(const void *)T_p)[10];
-            w = ((const u32 *)(const void *)T_p)[11];
-            copy0[(u8)x]++;
-            x >>= 8;
-            copy1[(u8)x]++;
-            x >>= 8;
-            copy2[(u8)x]++;
-            x >>= 8;
-            copy3[x]++;
-            copy0[(u8)y]++;
-            y >>= 8;
-            copy1[(u8)y]++;
-            y >>= 8;
-            copy2[(u8)y]++;
-            y >>= 8;
-            copy3[y]++;
-
-            x = ((const u32 *)(const void *)T_p)[12];
-            y = ((const u32 *)(const void *)T_p)[13];
-            copy0[(u8)z]++;
-            z >>= 8;
-            copy1[(u8)z]++;
-            z >>= 8;
-            copy2[(u8)z]++;
-            z >>= 8;
-            copy3[z]++;
-            copy0[(u8)w]++;
-            w >>= 8;
-            copy1[(u8)w]++;
-            w >>= 8;
-            copy2[(u8)w]++;
-            w >>= 8;
-            copy3[w]++;
-
-            z = ((const u32 *)(const void *)T_p)[14];
-            w = ((const u32 *)(const void *)T_p)[15];
-            copy0[(u8)x]++;
-            x >>= 8;
-            copy1[(u8)x]++;
-            x >>= 8;
-            copy2[(u8)x]++;
-            x >>= 8;
-            copy3[x]++;
-            copy0[(u8)y]++;
-            y >>= 8;
-            copy1[(u8)y]++;
-            y >>= 8;
-            copy2[(u8)y]++;
-            y >>= 8;
-            copy3[y]++;
-
-            x = ((const u32 *)(const void *)T_p)[16];
-            y = ((const u32 *)(const void *)T_p)[17];
-            copy0[(u8)z]++;
-            z >>= 8;
-            copy1[(u8)z]++;
-            z >>= 8;
-            copy2[(u8)z]++;
-            z >>= 8;
-            copy3[z]++;
-            copy0[(u8)w]++;
-            w >>= 8;
-            copy1[(u8)w]++;
-            w >>= 8;
-            copy2[(u8)w]++;
-            w >>= 8;
-            copy3[w]++;
-        }
-
-        copy0[(u8)x]++;
-        x >>= 8;
-        copy1[(u8)x]++;
-        x >>= 8;
-        copy2[(u8)x]++;
-        x >>= 8;
-        copy3[x]++;
-        copy0[(u8)y]++;
-        y >>= 8;
-        copy1[(u8)y]++;
-        y >>= 8;
-        copy2[(u8)y]++;
-        y >>= 8;
-        copy3[y]++;
-
-        T_p += 8;
-
-        fast_uint_t i;
-        for (i = 0; i < ALPHABET_SIZE; i++) {
-            count[i] += copy0[i] + copy1[i] + copy2[i] + copy3[i];
-        }
-    }
-
-    for (; T_p < T + n; T_p += 1) {
-        count[T_p[0]]++;
-    }
-}
-
-static void libsais_unbwt_transpose_bucket2(sa_uint_t * RESTRICT bucket2) {
-    fast_uint_t x, y, c, d;
-    for (x = 0; x != ALPHABET_SIZE; x += 16) {
-        for (c = x; c != x + 16; ++c) {
-            for (d = c + 1; d != x + 16; ++d) {
-                sa_uint_t tmp = bucket2[(d << 8) + c];
-                bucket2[(d << 8) + c] = bucket2[(c << 8) + d];
-                bucket2[(c << 8) + d] = tmp;
-            }
-        }
-
-        for (y = x + 16; y != ALPHABET_SIZE; y += 16) {
-            for (c = x; c != x + 16; ++c) {
-                sa_uint_t * bucket2_yc = &bucket2[(y << 8) + c];
-                sa_uint_t * bucket2_cy = &bucket2[(c << 8) + y];
-
-                sa_uint_t tmp00 = bucket2_yc[0 * 256];
-                bucket2_yc[0 * 256] = bucket2_cy[0];
-                bucket2_cy[0] = tmp00;
-                sa_uint_t tmp01 = bucket2_yc[1 * 256];
-                bucket2_yc[1 * 256] = bucket2_cy[1];
-                bucket2_cy[1] = tmp01;
-                sa_uint_t tmp02 = bucket2_yc[2 * 256];
-                bucket2_yc[2 * 256] = bucket2_cy[2];
-                bucket2_cy[2] = tmp02;
-                sa_uint_t tmp03 = bucket2_yc[3 * 256];
-                bucket2_yc[3 * 256] = bucket2_cy[3];
-                bucket2_cy[3] = tmp03;
-                sa_uint_t tmp04 = bucket2_yc[4 * 256];
-                bucket2_yc[4 * 256] = bucket2_cy[4];
-                bucket2_cy[4] = tmp04;
-                sa_uint_t tmp05 = bucket2_yc[5 * 256];
-                bucket2_yc[5 * 256] = bucket2_cy[5];
-                bucket2_cy[5] = tmp05;
-                sa_uint_t tmp06 = bucket2_yc[6 * 256];
-                bucket2_yc[6 * 256] = bucket2_cy[6];
-                bucket2_cy[6] = tmp06;
-                sa_uint_t tmp07 = bucket2_yc[7 * 256];
-                bucket2_yc[7 * 256] = bucket2_cy[7];
-                bucket2_cy[7] = tmp07;
-                sa_uint_t tmp08 = bucket2_yc[8 * 256];
-                bucket2_yc[8 * 256] = bucket2_cy[8];
-                bucket2_cy[8] = tmp08;
-                sa_uint_t tmp09 = bucket2_yc[9 * 256];
-                bucket2_yc[9 * 256] = bucket2_cy[9];
-                bucket2_cy[9] = tmp09;
-                sa_uint_t tmp10 = bucket2_yc[10 * 256];
-                bucket2_yc[10 * 256] = bucket2_cy[10];
-                bucket2_cy[10] = tmp10;
-                sa_uint_t tmp11 = bucket2_yc[11 * 256];
-                bucket2_yc[11 * 256] = bucket2_cy[11];
-                bucket2_cy[11] = tmp11;
-                sa_uint_t tmp12 = bucket2_yc[12 * 256];
-                bucket2_yc[12 * 256] = bucket2_cy[12];
-                bucket2_cy[12] = tmp12;
-                sa_uint_t tmp13 = bucket2_yc[13 * 256];
-                bucket2_yc[13 * 256] = bucket2_cy[13];
-                bucket2_cy[13] = tmp13;
-                sa_uint_t tmp14 = bucket2_yc[14 * 256];
-                bucket2_yc[14 * 256] = bucket2_cy[14];
-                bucket2_cy[14] = tmp14;
-                sa_uint_t tmp15 = bucket2_yc[15 * 256];
-                bucket2_yc[15 * 256] = bucket2_cy[15];
-                bucket2_cy[15] = tmp15;
-            }
-        }
-    }
-}
-
-static void libsais_unbwt_compute_bigram_histogram_single(const u8 * RESTRICT T, sa_uint_t * RESTRICT bucket1,
-                                                          sa_uint_t * RESTRICT bucket2, fast_uint_t index) {
-    fast_uint_t sum, c;
-    for (sum = 1, c = 0; c < ALPHABET_SIZE; ++c) {
-        fast_uint_t prev = sum;
-        sum += bucket1[c];
-        bucket1[c] = (sa_uint_t)prev;
-        if (prev != sum) {
-            sa_uint_t * RESTRICT bucket2_p = &bucket2[c << 8];
-
-            {
-                fast_uint_t hi = index;
-                if (sum < hi) {
-                    hi = sum;
-                }
-                libsais_unbwt_compute_histogram(&T[prev], (fast_sint_t)(hi - prev), bucket2_p);
-            }
-
-            {
-                fast_uint_t lo = index + 1;
-                if (prev > lo) {
-                    lo = prev;
-                }
-                libsais_unbwt_compute_histogram(&T[lo - 1], (fast_sint_t)(sum - lo), bucket2_p);
-            }
-        }
-    }
-
-    libsais_unbwt_transpose_bucket2(bucket2);
-}
-
-static void libsais_unbwt_calculate_fastbits(sa_uint_t * RESTRICT bucket2, u16 * RESTRICT fastbits, fast_uint_t lastc,
-                                             fast_uint_t shift) {
-    fast_uint_t v, w, sum, c, d;
-    for (v = 0, w = 0, sum = 1, c = 0; c < ALPHABET_SIZE; ++c) {
-        if (c == lastc) {
-            sum += 1;
-        }
-
-        for (d = 0; d < ALPHABET_SIZE; ++d, ++w) {
-            fast_uint_t prev = sum;
-            sum += bucket2[w];
-            bucket2[w] = (sa_uint_t)prev;
-            if (prev != sum) {
-                for (; v <= ((sum - 1) >> shift); ++v) {
-                    fastbits[v] = (u16)w;
-                }
-            }
-        }
-    }
-}
-
-static void libsais_unbwt_calculate_biPSI(const u8 * RESTRICT T, sa_uint_t * RESTRICT P, sa_uint_t * RESTRICT bucket1,
-                                          sa_uint_t * RESTRICT bucket2, fast_uint_t index, fast_sint_t omp_block_start,
-                                          fast_sint_t omp_block_end) {
-    {
-        fast_sint_t i = omp_block_start, j = (fast_sint_t)index;
-        if (omp_block_end < j) {
-            j = omp_block_end;
-        }
-        for (; i < j; ++i) {
-            fast_uint_t c = T[i];
-            fast_uint_t p = bucket1[c]++;
-            fast_sint_t t = (fast_sint_t)(index - p);
-
-            if (t != 0) {
-                fast_uint_t w = (((fast_uint_t)T[p + (fast_uint_t)(t >> ((sizeof(fast_sint_t) * 8) - 1))]) << 8) + c;
-                P[bucket2[w]++] = (sa_uint_t)i;
-            }
-        }
-    }
-
-    {
-        fast_sint_t i = (fast_sint_t)index, j = omp_block_end;
-        if (omp_block_start > i) {
-            i = omp_block_start;
-        }
-        for (i += 1; i <= j; ++i) {
-            fast_uint_t c = T[i - 1];
-            fast_uint_t p = bucket1[c]++;
-            fast_sint_t t = (fast_sint_t)(index - p);
-
-            if (t != 0) {
-                fast_uint_t w = (((fast_uint_t)T[p + (fast_uint_t)(t >> ((sizeof(fast_sint_t) * 8) - 1))]) << 8) + c;
-                P[bucket2[w]++] = (sa_uint_t)i;
-            }
-        }
-    }
-}
-
-static void libsais_unbwt_init_single(const u8 * RESTRICT T, sa_uint_t * RESTRICT P, sa_sint_t n,
-                                      const sa_sint_t * freq, const sa_uint_t * RESTRICT I,
-                                      sa_uint_t * RESTRICT bucket2, u16 * RESTRICT fastbits) {
-    sa_uint_t bucket1[ALPHABET_SIZE];
-
-    fast_uint_t index = I[0];
-    fast_uint_t lastc = T[0];
-    fast_uint_t shift = 0;
-    while ((n >> shift) > (1 << UNBWT_FASTBITS)) {
-        shift++;
-    }
-
-    if (freq != NULL) {
-        memcpy(bucket1, freq, ALPHABET_SIZE * sizeof(sa_uint_t));
-    } else {
-        memset(bucket1, 0, ALPHABET_SIZE * sizeof(sa_uint_t));
-        libsais_unbwt_compute_histogram(T, n, bucket1);
-    }
-
-    memset(bucket2, 0, ALPHABET_SIZE * ALPHABET_SIZE * sizeof(sa_uint_t));
-    libsais_unbwt_compute_bigram_histogram_single(T, bucket1, bucket2, index);
-
-    libsais_unbwt_calculate_fastbits(bucket2, fastbits, lastc, shift);
-    libsais_unbwt_calculate_biPSI(T, P, bucket1, bucket2, index, 0, n);
-}
-static void libsais_unbwt_decode_1(u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_uint_t * RESTRICT bucket2,
-                                   u16 * RESTRICT fastbits, fast_uint_t shift, fast_uint_t * i0, fast_uint_t k) {
-    u16 * RESTRICT U0 = (u16 *)(void *)U;
-
-    fast_uint_t i, p0 = *i0;
-
-    for (i = 0; i != k; ++i) {
-        u16 c0 = fastbits[p0 >> shift];
-        if (bucket2[c0] <= p0) {
-            do {
-                c0++;
-            } while (bucket2[c0] <= p0);
-        }
-        p0 = P[p0];
-        U0[i] = bswap16(c0);
-    }
-
-    *i0 = p0;
-}
-
-static void libsais_unbwt_decode_2(u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_uint_t * RESTRICT bucket2,
-                                   u16 * RESTRICT fastbits, fast_uint_t shift, fast_uint_t r, fast_uint_t * i0,
-                                   fast_uint_t * i1, fast_uint_t k) {
-    u16 * RESTRICT U0 = (u16 *)(void *)U;
-    u16 * RESTRICT U1 = (u16 *)(void *)(((u8 *)U0) + r);
-
-    fast_uint_t i, p0 = *i0, p1 = *i1;
-
-    for (i = 0; i != k; ++i) {
-        u16 c0 = fastbits[p0 >> shift];
-        if (bucket2[c0] <= p0) {
-            do {
-                c0++;
-            } while (bucket2[c0] <= p0);
-        }
-        p0 = P[p0];
-        U0[i] = bswap16(c0);
-        u16 c1 = fastbits[p1 >> shift];
-        if (bucket2[c1] <= p1) {
-            do {
-                c1++;
-            } while (bucket2[c1] <= p1);
-        }
-        p1 = P[p1];
-        U1[i] = bswap16(c1);
-    }
-
-    *i0 = p0;
-    *i1 = p1;
-}
-
-static void libsais_unbwt_decode_3(u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_uint_t * RESTRICT bucket2,
-                                   u16 * RESTRICT fastbits, fast_uint_t shift, fast_uint_t r, fast_uint_t * i0,
-                                   fast_uint_t * i1, fast_uint_t * i2, fast_uint_t k) {
-    u16 * RESTRICT U0 = (u16 *)(void *)U;
-    u16 * RESTRICT U1 = (u16 *)(void *)(((u8 *)U0) + r);
-    u16 * RESTRICT U2 = (u16 *)(void *)(((u8 *)U1) + r);
-
-    fast_uint_t i, p0 = *i0, p1 = *i1, p2 = *i2;
-
-    for (i = 0; i != k; ++i) {
-        u16 c0 = fastbits[p0 >> shift];
-        if (bucket2[c0] <= p0) {
-            do {
-                c0++;
-            } while (bucket2[c0] <= p0);
-        }
-        p0 = P[p0];
-        U0[i] = bswap16(c0);
-        u16 c1 = fastbits[p1 >> shift];
-        if (bucket2[c1] <= p1) {
-            do {
-                c1++;
-            } while (bucket2[c1] <= p1);
-        }
-        p1 = P[p1];
-        U1[i] = bswap16(c1);
-        u16 c2 = fastbits[p2 >> shift];
-        if (bucket2[c2] <= p2) {
-            do {
-                c2++;
-            } while (bucket2[c2] <= p2);
-        }
-        p2 = P[p2];
-        U2[i] = bswap16(c2);
-    }
-
-    *i0 = p0;
-    *i1 = p1;
-    *i2 = p2;
-}
-
-static void libsais_unbwt_decode_4(u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_uint_t * RESTRICT bucket2,
-                                   u16 * RESTRICT fastbits, fast_uint_t shift, fast_uint_t r, fast_uint_t * i0,
-                                   fast_uint_t * i1, fast_uint_t * i2, fast_uint_t * i3, fast_uint_t k) {
-    u16 * RESTRICT U0 = (u16 *)(void *)U;
-    u16 * RESTRICT U1 = (u16 *)(void *)(((u8 *)U0) + r);
-    u16 * RESTRICT U2 = (u16 *)(void *)(((u8 *)U1) + r);
-    u16 * RESTRICT U3 = (u16 *)(void *)(((u8 *)U2) + r);
-
-    fast_uint_t i, p0 = *i0, p1 = *i1, p2 = *i2, p3 = *i3;
-
-    for (i = 0; i != k; ++i) {
-        u16 c0 = fastbits[p0 >> shift];
-        if (bucket2[c0] <= p0) {
-            do {
-                c0++;
-            } while (bucket2[c0] <= p0);
-        }
-        p0 = P[p0];
-        U0[i] = bswap16(c0);
-        u16 c1 = fastbits[p1 >> shift];
-        if (bucket2[c1] <= p1) {
-            do {
-                c1++;
-            } while (bucket2[c1] <= p1);
-        }
-        p1 = P[p1];
-        U1[i] = bswap16(c1);
-        u16 c2 = fastbits[p2 >> shift];
-        if (bucket2[c2] <= p2) {
-            do {
-                c2++;
-            } while (bucket2[c2] <= p2);
-        }
-        p2 = P[p2];
-        U2[i] = bswap16(c2);
-        u16 c3 = fastbits[p3 >> shift];
-        if (bucket2[c3] <= p3) {
-            do {
-                c3++;
-            } while (bucket2[c3] <= p3);
-        }
-        p3 = P[p3];
-        U3[i] = bswap16(c3);
-    }
-
-    *i0 = p0;
-    *i1 = p1;
-    *i2 = p2;
-    *i3 = p3;
-}
-
-static void libsais_unbwt_decode_5(u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_uint_t * RESTRICT bucket2,
-                                   u16 * RESTRICT fastbits, fast_uint_t shift, fast_uint_t r, fast_uint_t * i0,
-                                   fast_uint_t * i1, fast_uint_t * i2, fast_uint_t * i3, fast_uint_t * i4,
-                                   fast_uint_t k) {
-    u16 * RESTRICT U0 = (u16 *)(void *)U;
-    u16 * RESTRICT U1 = (u16 *)(void *)(((u8 *)U0) + r);
-    u16 * RESTRICT U2 = (u16 *)(void *)(((u8 *)U1) + r);
-    u16 * RESTRICT U3 = (u16 *)(void *)(((u8 *)U2) + r);
-    u16 * RESTRICT U4 = (u16 *)(void *)(((u8 *)U3) + r);
-
-    fast_uint_t i, p0 = *i0, p1 = *i1, p2 = *i2, p3 = *i3, p4 = *i4;
-
-    for (i = 0; i != k; ++i) {
-        u16 c0 = fastbits[p0 >> shift];
-        if (bucket2[c0] <= p0) {
-            do {
-                c0++;
-            } while (bucket2[c0] <= p0);
-        }
-        p0 = P[p0];
-        U0[i] = bswap16(c0);
-        u16 c1 = fastbits[p1 >> shift];
-        if (bucket2[c1] <= p1) {
-            do {
-                c1++;
-            } while (bucket2[c1] <= p1);
-        }
-        p1 = P[p1];
-        U1[i] = bswap16(c1);
-        u16 c2 = fastbits[p2 >> shift];
-        if (bucket2[c2] <= p2) {
-            do {
-                c2++;
-            } while (bucket2[c2] <= p2);
-        }
-        p2 = P[p2];
-        U2[i] = bswap16(c2);
-        u16 c3 = fastbits[p3 >> shift];
-        if (bucket2[c3] <= p3) {
-            do {
-                c3++;
-            } while (bucket2[c3] <= p3);
-        }
-        p3 = P[p3];
-        U3[i] = bswap16(c3);
-        u16 c4 = fastbits[p4 >> shift];
-        if (bucket2[c4] <= p4) {
-            do {
-                c4++;
-            } while (bucket2[c4] <= p4);
-        }
-        p4 = P[p4];
-        U4[i] = bswap16(c4);
-    }
-
-    *i0 = p0;
-    *i1 = p1;
-    *i2 = p2;
-    *i3 = p3;
-    *i4 = p4;
-}
-
-static void libsais_unbwt_decode_6(u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_uint_t * RESTRICT bucket2,
-                                   u16 * RESTRICT fastbits, fast_uint_t shift, fast_uint_t r, fast_uint_t * i0,
-                                   fast_uint_t * i1, fast_uint_t * i2, fast_uint_t * i3, fast_uint_t * i4,
-                                   fast_uint_t * i5, fast_uint_t k) {
-    u16 * RESTRICT U0 = (u16 *)(void *)U;
-    u16 * RESTRICT U1 = (u16 *)(void *)(((u8 *)U0) + r);
-    u16 * RESTRICT U2 = (u16 *)(void *)(((u8 *)U1) + r);
-    u16 * RESTRICT U3 = (u16 *)(void *)(((u8 *)U2) + r);
-    u16 * RESTRICT U4 = (u16 *)(void *)(((u8 *)U3) + r);
-    u16 * RESTRICT U5 = (u16 *)(void *)(((u8 *)U4) + r);
-
-    fast_uint_t i, p0 = *i0, p1 = *i1, p2 = *i2, p3 = *i3, p4 = *i4, p5 = *i5;
-
-    for (i = 0; i != k; ++i) {
-        u16 c0 = fastbits[p0 >> shift];
-        if (bucket2[c0] <= p0) {
-            do {
-                c0++;
-            } while (bucket2[c0] <= p0);
-        }
-        p0 = P[p0];
-        U0[i] = bswap16(c0);
-        u16 c1 = fastbits[p1 >> shift];
-        if (bucket2[c1] <= p1) {
-            do {
-                c1++;
-            } while (bucket2[c1] <= p1);
-        }
-        p1 = P[p1];
-        U1[i] = bswap16(c1);
-        u16 c2 = fastbits[p2 >> shift];
-        if (bucket2[c2] <= p2) {
-            do {
-                c2++;
-            } while (bucket2[c2] <= p2);
-        }
-        p2 = P[p2];
-        U2[i] = bswap16(c2);
-        u16 c3 = fastbits[p3 >> shift];
-        if (bucket2[c3] <= p3) {
-            do {
-                c3++;
-            } while (bucket2[c3] <= p3);
-        }
-        p3 = P[p3];
-        U3[i] = bswap16(c3);
-        u16 c4 = fastbits[p4 >> shift];
-        if (bucket2[c4] <= p4) {
-            do {
-                c4++;
-            } while (bucket2[c4] <= p4);
-        }
-        p4 = P[p4];
-        U4[i] = bswap16(c4);
-        u16 c5 = fastbits[p5 >> shift];
-        if (bucket2[c5] <= p5) {
-            do {
-                c5++;
-            } while (bucket2[c5] <= p5);
-        }
-        p5 = P[p5];
-        U5[i] = bswap16(c5);
-    }
-
-    *i0 = p0;
-    *i1 = p1;
-    *i2 = p2;
-    *i3 = p3;
-    *i4 = p4;
-    *i5 = p5;
-}
-
-static void libsais_unbwt_decode_7(u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_uint_t * RESTRICT bucket2,
-                                   u16 * RESTRICT fastbits, fast_uint_t shift, fast_uint_t r, fast_uint_t * i0,
-                                   fast_uint_t * i1, fast_uint_t * i2, fast_uint_t * i3, fast_uint_t * i4,
-                                   fast_uint_t * i5, fast_uint_t * i6, fast_uint_t k) {
-    u16 * RESTRICT U0 = (u16 *)(void *)U;
-    u16 * RESTRICT U1 = (u16 *)(void *)(((u8 *)U0) + r);
-    u16 * RESTRICT U2 = (u16 *)(void *)(((u8 *)U1) + r);
-    u16 * RESTRICT U3 = (u16 *)(void *)(((u8 *)U2) + r);
-    u16 * RESTRICT U4 = (u16 *)(void *)(((u8 *)U3) + r);
-    u16 * RESTRICT U5 = (u16 *)(void *)(((u8 *)U4) + r);
-    u16 * RESTRICT U6 = (u16 *)(void *)(((u8 *)U5) + r);
-
-    fast_uint_t i, p0 = *i0, p1 = *i1, p2 = *i2, p3 = *i3, p4 = *i4, p5 = *i5, p6 = *i6;
-
-    for (i = 0; i != k; ++i) {
-        u16 c0 = fastbits[p0 >> shift];
-        if (bucket2[c0] <= p0) {
-            do {
-                c0++;
-            } while (bucket2[c0] <= p0);
-        }
-        p0 = P[p0];
-        U0[i] = bswap16(c0);
-        u16 c1 = fastbits[p1 >> shift];
-        if (bucket2[c1] <= p1) {
-            do {
-                c1++;
-            } while (bucket2[c1] <= p1);
-        }
-        p1 = P[p1];
-        U1[i] = bswap16(c1);
-        u16 c2 = fastbits[p2 >> shift];
-        if (bucket2[c2] <= p2) {
-            do {
-                c2++;
-            } while (bucket2[c2] <= p2);
-        }
-        p2 = P[p2];
-        U2[i] = bswap16(c2);
-        u16 c3 = fastbits[p3 >> shift];
-        if (bucket2[c3] <= p3) {
-            do {
-                c3++;
-            } while (bucket2[c3] <= p3);
-        }
-        p3 = P[p3];
-        U3[i] = bswap16(c3);
-        u16 c4 = fastbits[p4 >> shift];
-        if (bucket2[c4] <= p4) {
-            do {
-                c4++;
-            } while (bucket2[c4] <= p4);
-        }
-        p4 = P[p4];
-        U4[i] = bswap16(c4);
-        u16 c5 = fastbits[p5 >> shift];
-        if (bucket2[c5] <= p5) {
-            do {
-                c5++;
-            } while (bucket2[c5] <= p5);
-        }
-        p5 = P[p5];
-        U5[i] = bswap16(c5);
-        u16 c6 = fastbits[p6 >> shift];
-        if (bucket2[c6] <= p6) {
-            do {
-                c6++;
-            } while (bucket2[c6] <= p6);
-        }
-        p6 = P[p6];
-        U6[i] = bswap16(c6);
-    }
-
-    *i0 = p0;
-    *i1 = p1;
-    *i2 = p2;
-    *i3 = p3;
-    *i4 = p4;
-    *i5 = p5;
-    *i6 = p6;
-}
-
-static void libsais_unbwt_decode_8(u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_uint_t * RESTRICT bucket2,
-                                   u16 * RESTRICT fastbits, fast_uint_t shift, fast_uint_t r, fast_uint_t * i0,
-                                   fast_uint_t * i1, fast_uint_t * i2, fast_uint_t * i3, fast_uint_t * i4,
-                                   fast_uint_t * i5, fast_uint_t * i6, fast_uint_t * i7, fast_uint_t k) {
-    u16 * RESTRICT U0 = (u16 *)(void *)U;
-    u16 * RESTRICT U1 = (u16 *)(void *)(((u8 *)U0) + r);
-    u16 * RESTRICT U2 = (u16 *)(void *)(((u8 *)U1) + r);
-    u16 * RESTRICT U3 = (u16 *)(void *)(((u8 *)U2) + r);
-    u16 * RESTRICT U4 = (u16 *)(void *)(((u8 *)U3) + r);
-    u16 * RESTRICT U5 = (u16 *)(void *)(((u8 *)U4) + r);
-    u16 * RESTRICT U6 = (u16 *)(void *)(((u8 *)U5) + r);
-    u16 * RESTRICT U7 = (u16 *)(void *)(((u8 *)U6) + r);
-
-    fast_uint_t i, p0 = *i0, p1 = *i1, p2 = *i2, p3 = *i3, p4 = *i4, p5 = *i5, p6 = *i6, p7 = *i7;
-
-    for (i = 0; i != k; ++i) {
-        u16 c0 = fastbits[p0 >> shift];
-        if (bucket2[c0] <= p0) {
-            do {
-                c0++;
-            } while (bucket2[c0] <= p0);
-        }
-        p0 = P[p0];
-        U0[i] = bswap16(c0);
-        u16 c1 = fastbits[p1 >> shift];
-        if (bucket2[c1] <= p1) {
-            do {
-                c1++;
-            } while (bucket2[c1] <= p1);
-        }
-        p1 = P[p1];
-        U1[i] = bswap16(c1);
-        u16 c2 = fastbits[p2 >> shift];
-        if (bucket2[c2] <= p2) {
-            do {
-                c2++;
-            } while (bucket2[c2] <= p2);
-        }
-        p2 = P[p2];
-        U2[i] = bswap16(c2);
-        u16 c3 = fastbits[p3 >> shift];
-        if (bucket2[c3] <= p3) {
-            do {
-                c3++;
-            } while (bucket2[c3] <= p3);
-        }
-        p3 = P[p3];
-        U3[i] = bswap16(c3);
-        u16 c4 = fastbits[p4 >> shift];
-        if (bucket2[c4] <= p4) {
-            do {
-                c4++;
-            } while (bucket2[c4] <= p4);
-        }
-        p4 = P[p4];
-        U4[i] = bswap16(c4);
-        u16 c5 = fastbits[p5 >> shift];
-        if (bucket2[c5] <= p5) {
-            do {
-                c5++;
-            } while (bucket2[c5] <= p5);
-        }
-        p5 = P[p5];
-        U5[i] = bswap16(c5);
-        u16 c6 = fastbits[p6 >> shift];
-        if (bucket2[c6] <= p6) {
-            do {
-                c6++;
-            } while (bucket2[c6] <= p6);
-        }
-        p6 = P[p6];
-        U6[i] = bswap16(c6);
-        u16 c7 = fastbits[p7 >> shift];
-        if (bucket2[c7] <= p7) {
-            do {
-                c7++;
-            } while (bucket2[c7] <= p7);
-        }
-        p7 = P[p7];
-        U7[i] = bswap16(c7);
-    }
-
-    *i0 = p0;
-    *i1 = p1;
-    *i2 = p2;
-    *i3 = p3;
-    *i4 = p4;
-    *i5 = p5;
-    *i6 = p6;
-    *i7 = p7;
-}
-
-static void libsais_unbwt_decode(u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_sint_t n, sa_sint_t r,
-                                 const sa_uint_t * RESTRICT I, sa_uint_t * RESTRICT bucket2, u16 * RESTRICT fastbits,
-                                 fast_sint_t blocks, fast_uint_t reminder) {
-    fast_uint_t shift = 0;
-    while ((n >> shift) > (1 << UNBWT_FASTBITS)) {
-        shift++;
-    }
-    fast_uint_t offset = 0;
-
-    while (blocks > 8) {
-        fast_uint_t i0 = I[0], i1 = I[1], i2 = I[2], i3 = I[3], i4 = I[4], i5 = I[5], i6 = I[6], i7 = I[7];
-        libsais_unbwt_decode_8(U + offset, P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1, &i2, &i3, &i4, &i5,
-                               &i6, &i7, (fast_uint_t)r >> 1);
-        I += 8;
-        blocks -= 8;
-        offset += 8 * (fast_uint_t)r;
-    }
-
-    if (blocks == 1) {
-        fast_uint_t i0 = I[0];
-        libsais_unbwt_decode_1(U + offset, P, bucket2, fastbits, shift, &i0, reminder >> 1);
-    } else if (blocks == 2) {
-        fast_uint_t i0 = I[0], i1 = I[1];
-        libsais_unbwt_decode_2(U + offset, P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1, reminder >> 1);
-        libsais_unbwt_decode_1(U + offset + 2 * (reminder >> 1), P, bucket2, fastbits, shift, &i0,
-                               ((fast_uint_t)r >> 1) - (reminder >> 1));
-    } else if (blocks == 3) {
-        fast_uint_t i0 = I[0], i1 = I[1], i2 = I[2];
-        libsais_unbwt_decode_3(U + offset, P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1, &i2, reminder >> 1);
-        libsais_unbwt_decode_2(U + offset + 2 * (reminder >> 1), P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1,
-                               ((fast_uint_t)r >> 1) - (reminder >> 1));
-    } else if (blocks == 4) {
-        fast_uint_t i0 = I[0], i1 = I[1], i2 = I[2], i3 = I[3];
-        libsais_unbwt_decode_4(U + offset, P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1, &i2, &i3,
-                               reminder >> 1);
-        libsais_unbwt_decode_3(U + offset + 2 * (reminder >> 1), P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1,
-                               &i2, ((fast_uint_t)r >> 1) - (reminder >> 1));
-    } else if (blocks == 5) {
-        fast_uint_t i0 = I[0], i1 = I[1], i2 = I[2], i3 = I[3], i4 = I[4];
-        libsais_unbwt_decode_5(U + offset, P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1, &i2, &i3, &i4,
-                               reminder >> 1);
-        libsais_unbwt_decode_4(U + offset + 2 * (reminder >> 1), P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1,
-                               &i2, &i3, ((fast_uint_t)r >> 1) - (reminder >> 1));
-    } else if (blocks == 6) {
-        fast_uint_t i0 = I[0], i1 = I[1], i2 = I[2], i3 = I[3], i4 = I[4], i5 = I[5];
-        libsais_unbwt_decode_6(U + offset, P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1, &i2, &i3, &i4, &i5,
-                               reminder >> 1);
-        libsais_unbwt_decode_5(U + offset + 2 * (reminder >> 1), P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1,
-                               &i2, &i3, &i4, ((fast_uint_t)r >> 1) - (reminder >> 1));
-    } else if (blocks == 7) {
-        fast_uint_t i0 = I[0], i1 = I[1], i2 = I[2], i3 = I[3], i4 = I[4], i5 = I[5], i6 = I[6];
-        libsais_unbwt_decode_7(U + offset, P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1, &i2, &i3, &i4, &i5,
-                               &i6, reminder >> 1);
-        libsais_unbwt_decode_6(U + offset + 2 * (reminder >> 1), P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1,
-                               &i2, &i3, &i4, &i5, ((fast_uint_t)r >> 1) - (reminder >> 1));
-    } else {
-        fast_uint_t i0 = I[0], i1 = I[1], i2 = I[2], i3 = I[3], i4 = I[4], i5 = I[5], i6 = I[6], i7 = I[7];
-        libsais_unbwt_decode_8(U + offset, P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1, &i2, &i3, &i4, &i5,
-                               &i6, &i7, reminder >> 1);
-        libsais_unbwt_decode_7(U + offset + 2 * (reminder >> 1), P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1,
-                               &i2, &i3, &i4, &i5, &i6, ((fast_uint_t)r >> 1) - (reminder >> 1));
-    }
-}
-
-static void libsais_unbwt_decode_omp(const u8 * RESTRICT T, u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_sint_t n,
-                                     sa_sint_t r, const sa_uint_t * RESTRICT I, sa_uint_t * RESTRICT bucket2,
-                                     u16 * RESTRICT fastbits, sa_sint_t threads) {
-    fast_uint_t lastc = T[0];
-    fast_sint_t blocks = 1 + (((fast_sint_t)n - 1) / (fast_sint_t)r);
-    fast_uint_t reminder = (fast_uint_t)n - ((fast_uint_t)r * ((fast_uint_t)blocks - 1));
-
-    {
-        (void)(threads);
-
-        fast_sint_t omp_thread_num = 0;
-        fast_sint_t omp_num_threads = 1;
-        fast_sint_t omp_block_stride = blocks / omp_num_threads;
-        fast_sint_t omp_block_reminder = blocks % omp_num_threads;
-        fast_sint_t omp_block_size = omp_block_stride + (omp_thread_num < omp_block_reminder);
-        fast_sint_t omp_block_start = omp_block_stride * omp_thread_num +
-                                      (omp_thread_num < omp_block_reminder ? omp_thread_num : omp_block_reminder);
-
-        libsais_unbwt_decode(U + r * omp_block_start, P, n, r, I + omp_block_start, bucket2, fastbits, omp_block_size,
-                             omp_thread_num < omp_num_threads - 1 ? (fast_uint_t)r : reminder);
-    }
-
-    U[n - 1] = (u8)lastc;
-}
-
-static sa_sint_t libsais_unbwt_core(const u8 * RESTRICT T, u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_sint_t n,
-                                    const sa_sint_t * freq, sa_sint_t r, const sa_uint_t * RESTRICT I,
-                                    sa_uint_t * RESTRICT bucket2, u16 * RESTRICT fastbits, sa_uint_t * RESTRICT buckets,
-                                    sa_sint_t threads) {
-    (void)(buckets);
-
-    { libsais_unbwt_init_single(T, P, n, freq, I, bucket2, fastbits); }
-
-    libsais_unbwt_decode_omp(T, U, P, n, r, I, bucket2, fastbits, threads);
-    return 0;
-}
-
-static sa_sint_t libsais_unbwt_main(const u8 * T, u8 * U, sa_uint_t * P, sa_sint_t n, const sa_sint_t * freq,
-                                    sa_sint_t r, const sa_uint_t * I, sa_sint_t threads) {
-    fast_uint_t shift = 0;
-    while ((n >> shift) > (1 << UNBWT_FASTBITS)) {
-        shift++;
-    }
-
-    sa_uint_t * RESTRICT bucket2 =
-        (sa_uint_t *)libsais_alloc_aligned(ALPHABET_SIZE * ALPHABET_SIZE * sizeof(sa_uint_t), 4096);
-    u16 * RESTRICT fastbits = (u16 *)libsais_alloc_aligned(((size_t)1 + (size_t)(n >> shift)) * sizeof(u16), 4096);
-    memset(fastbits, 0, ((size_t)1 + (size_t)(n >> shift)) * sizeof(u16));
-    sa_uint_t * RESTRICT buckets =
-        threads > 1 && n >= 262144
-            ? (sa_uint_t *)libsais_alloc_aligned(
-                  (size_t)threads * (ALPHABET_SIZE + (ALPHABET_SIZE * ALPHABET_SIZE)) * sizeof(sa_uint_t), 4096)
-            : NULL;
-
-    sa_sint_t index = bucket2 != NULL && fastbits != NULL && (buckets != NULL || threads == 1 || n < 262144)
-                          ? libsais_unbwt_core(T, U, P, n, freq, r, I, bucket2, fastbits, buckets, threads)
-                          : -2;
-
-    libsais_free_aligned(buckets);
-    libsais_free_aligned(fastbits);
-    libsais_free_aligned(bucket2);
-
-    return index;
-}
-
-static sa_sint_t libsais_unbwt_main_ctx(const LIBSAIS_UNBWT_CONTEXT * ctx, const u8 * T, u8 * U, sa_uint_t * P,
-                                        sa_sint_t n, const sa_sint_t * freq, sa_sint_t r, const sa_uint_t * I) {
-    return ctx != NULL && ctx->bucket2 != NULL && ctx->fastbits != NULL && (ctx->buckets != NULL || ctx->threads == 1)
-               ? libsais_unbwt_core(T, U, P, n, freq, r, I, ctx->bucket2, ctx->fastbits, ctx->buckets,
-                                    (sa_sint_t)ctx->threads)
-               : -2;
-}
-
-static void * libsais_unbwt_create_ctx(void) { return (void *)libsais_unbwt_create_ctx_main(1); }
-
-static void libsais_unbwt_free_ctx(void * ctx) { libsais_unbwt_free_ctx_main((LIBSAIS_UNBWT_CONTEXT *)ctx); }
-
-static s32 libsais_unbwt_aux(const u8 * T, u8 * U, s32 * A, s32 n, const s32 * freq, s32 r, const s32 * I) {
-    if ((T == NULL) || (U == NULL) || (A == NULL) || (n < 0) || ((r != n) && ((r < 2) || ((r & (r - 1)) != 0))) ||
-        (I == NULL)) {
-        return -1;
-    } else if (n <= 1) {
-        if (I[0] != n) {
-            return -1;
-        }
-        if (n == 1) {
-            U[0] = T[0];
-        }
-        return 0;
-    }
-
-    fast_sint_t t;
-    for (t = 0; t <= (n - 1) / r; ++t) {
-        if (I[t] <= 0 || I[t] > n) {
-            return -1;
-        }
-    }
-
-    return libsais_unbwt_main(T, U, (sa_uint_t *)A, n, freq, r, (const sa_uint_t *)I, 1);
-}
-
-static s32 libsais_unbwt_aux_ctx(const void * ctx, const u8 * T, u8 * U, s32 * A, s32 n, const s32 * freq, s32 r,
-                                 const s32 * I) {
-    if ((T == NULL) || (U == NULL) || (A == NULL) || (n < 0) || ((r != n) && ((r < 2) || ((r & (r - 1)) != 0))) ||
-        (I == NULL)) {
-        return -1;
-    } else if (n <= 1) {
-        if (I[0] != n) {
-            return -1;
-        }
-        if (n == 1) {
-            U[0] = T[0];
-        }
-        return 0;
-    }
-
-    fast_sint_t t;
-    for (t = 0; t <= (n - 1) / r; ++t) {
-        if (I[t] <= 0 || I[t] > n) {
-            return -1;
-        }
-    }
-
-    return libsais_unbwt_main_ctx((const LIBSAIS_UNBWT_CONTEXT *)ctx, T, U, (sa_uint_t *)A, n, freq, r,
-                                  (const sa_uint_t *)I);
-}
-
-static s32 libsais_unbwt(const u8 * T, u8 * U, s32 * A, s32 n, const s32 * freq, s32 i) {
-    return libsais_unbwt_aux(T, U, A, n, freq, n, &i);
-}
-
-static s32 libsais_unbwt_ctx(const void * ctx, const u8 * T, u8 * U, s32 * A, s32 n, const s32 * freq, s32 i) {
-    return libsais_unbwt_aux_ctx(ctx, T, U, A, n, freq, n, &i);
-}
-
-static void libsais_compute_phi(const sa_sint_t * RESTRICT SA, sa_sint_t * RESTRICT PLCP, sa_sint_t n,
-                                fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j;
-    sa_sint_t k = omp_block_start > 0 ? SA[omp_block_start - 1] : n;
-    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 3; i < j; i += 4) {
-        prefetchw(&PLCP[SA[i + prefetch_distance + 0]]);
-        prefetchw(&PLCP[SA[i + prefetch_distance + 1]]);
-
-        PLCP[SA[i + 0]] = k;
-        k = SA[i + 0];
-        PLCP[SA[i + 1]] = k;
-        k = SA[i + 1];
-
-        prefetchw(&PLCP[SA[i + prefetch_distance + 2]]);
-        prefetchw(&PLCP[SA[i + prefetch_distance + 3]]);
-
-        PLCP[SA[i + 2]] = k;
-        k = SA[i + 2];
-        PLCP[SA[i + 3]] = k;
-        k = SA[i + 3];
-    }
-
-    for (j += prefetch_distance + 3; i < j; i += 1) {
-        PLCP[SA[i]] = k;
-        k = SA[i];
-    }
-}
-
-static void libsais_compute_phi_omp(const sa_sint_t * RESTRICT SA, sa_sint_t * RESTRICT PLCP, sa_sint_t n,
-                                    sa_sint_t threads) {
-    {
-        (void)(threads);
-
-        fast_sint_t omp_thread_num = 0;
-        fast_sint_t omp_num_threads = 1;
-
-        fast_sint_t omp_block_stride = (n / omp_num_threads) & (-16);
-        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
-        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : n - omp_block_start;
-
-        libsais_compute_phi(SA, PLCP, n, omp_block_start, omp_block_size);
-    }
-}
-
-static void libsais_compute_plcp(const u8 * RESTRICT T, sa_sint_t * RESTRICT PLCP, fast_sint_t n,
-                                 fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j, l = 0;
-    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance; i < j; i += 1) {
-        prefetch(&T[PLCP[i + prefetch_distance] + l]);
-
-        fast_sint_t k = PLCP[i], m = n - (i > k ? i : k);
-        while (l < m && T[i + l] == T[k + l]) {
-            l++;
-        }
-
-        PLCP[i] = (sa_sint_t)l;
-        l -= (l != 0);
-    }
-
-    for (j += prefetch_distance; i < j; i += 1) {
-        fast_sint_t k = PLCP[i], m = n - (i > k ? i : k);
-        while (l < m && T[i + l] == T[k + l]) {
-            l++;
-        }
-
-        PLCP[i] = (sa_sint_t)l;
-        l -= (l != 0);
-    }
-}
-
-static void libsais_compute_plcp_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT PLCP, sa_sint_t n, sa_sint_t threads) {
-    {
-        (void)(threads);
-
-        fast_sint_t omp_thread_num = 0;
-        fast_sint_t omp_num_threads = 1;
-
-        fast_sint_t omp_block_stride = (n / omp_num_threads) & (-16);
-        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
-        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : n - omp_block_start;
-
-        libsais_compute_plcp(T, PLCP, n, omp_block_start, omp_block_size);
-    }
-}
-
-static void libsais_compute_lcp(const sa_sint_t * RESTRICT PLCP, const sa_sint_t * RESTRICT SA,
-                                sa_sint_t * RESTRICT LCP, fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
-    const fast_sint_t prefetch_distance = 32;
-
-    fast_sint_t i, j;
-    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 3; i < j; i += 4) {
-        prefetch(&PLCP[SA[i + prefetch_distance + 0]]);
-        prefetch(&PLCP[SA[i + prefetch_distance + 1]]);
-
-        LCP[i + 0] = PLCP[SA[i + 0]];
-        LCP[i + 1] = PLCP[SA[i + 1]];
-
-        prefetch(&PLCP[SA[i + prefetch_distance + 2]]);
-        prefetch(&PLCP[SA[i + prefetch_distance + 3]]);
-
-        LCP[i + 2] = PLCP[SA[i + 2]];
-        LCP[i + 3] = PLCP[SA[i + 3]];
-    }
-
-    for (j += prefetch_distance + 3; i < j; i += 1) {
-        LCP[i] = PLCP[SA[i]];
-    }
-}
-
-static void libsais_compute_lcp_omp(const sa_sint_t * RESTRICT PLCP, const sa_sint_t * RESTRICT SA,
-                                    sa_sint_t * RESTRICT LCP, sa_sint_t n, sa_sint_t threads) {
-    {
-        (void)(threads);
-
-        fast_sint_t omp_thread_num = 0;
-        fast_sint_t omp_num_threads = 1;
-
-        fast_sint_t omp_block_stride = (n / omp_num_threads) & (-16);
-        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
-        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : n - omp_block_start;
-
-        libsais_compute_lcp(PLCP, SA, LCP, omp_block_start, omp_block_size);
-    }
-}
-
-static s32 libsais_plcp(const u8 * T, const s32 * SA, s32 * PLCP, s32 n) {
-    if ((T == NULL) || (SA == NULL) || (PLCP == NULL) || (n < 0)) {
-        return -1;
-    } else if (n <= 1) {
-        if (n == 1) {
-            PLCP[0] = 0;
-        }
-        return 0;
-    }
-
-    libsais_compute_phi_omp(SA, PLCP, n, 1);
-    libsais_compute_plcp_omp(T, PLCP, n, 1);
-
-    return 0;
-}
-
-static s32 libsais_lcp(const s32 * PLCP, const s32 * SA, s32 * LCP, s32 n) {
-    if ((PLCP == NULL) || (SA == NULL) || (LCP == NULL) || (n < 0)) {
-        return -1;
-    } else if (n <= 1) {
-        if (n == 1) {
-            LCP[0] = PLCP[SA[0]];
-        }
-        return 0;
-    }
-
-    libsais_compute_lcp_omp(PLCP, SA, LCP, n, 1);
-
-    return 0;
-}
-
-#endif
+/*--
+
+This file is a part of libsais, a library for linear time suffix array,
+longest common prefix array and burrows wheeler transform construction.
+
+   Copyright (c) 2021-2022 Ilya Grebnov <ilya.grebnov@gmail.com>
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+Please see the file LICENSE for full copyright information.
+
+The stability patches that fix undefined behaviour in unbwt routines:
+
+   Copyright (c) 2022 Kamila Szewczyk <kspalaiologos@gmail.com>
+
+   Licensed under the same license as the original software.
+
+--*/
+
+#ifndef LIBSAIS_H
+#define LIBSAIS_H
+
+#include "common.h"
+
+/* libsais source code amalgamate. */
+
+#include <limits.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define UNUSED(_x) (void)(_x)
+
+typedef s32 sa_sint_t;
+typedef u32 sa_uint_t;
+typedef ptrdiff_t fast_sint_t;
+typedef size_t fast_uint_t;
+
+#define SAINT_BIT (32)
+#define SAINT_MAX INT32_MAX
+#define SAINT_MIN INT32_MIN
+
+#define ALPHABET_SIZE (1 << CHAR_BIT)
+#define UNBWT_FASTBITS (17)
+
+#define SUFFIX_GROUP_BIT (SAINT_BIT - 1)
+#define SUFFIX_GROUP_MARKER (((sa_sint_t)1) << (SUFFIX_GROUP_BIT - 1))
+
+#define BUCKETS_INDEX2(_c, _s) (((_c) << 1) + (_s))
+#define BUCKETS_INDEX4(_c, _s) (((_c) << 2) + (_s))
+
+#define LIBSAIS_PER_THREAD_CACHE_SIZE (24576)
+
+typedef struct LIBSAIS_THREAD_CACHE {
+    sa_sint_t symbol;
+    sa_sint_t index;
+} LIBSAIS_THREAD_CACHE;
+
+typedef union LIBSAIS_THREAD_STATE {
+    struct {
+        fast_sint_t position;
+        fast_sint_t count;
+
+        fast_sint_t m;
+        fast_sint_t last_lms_suffix;
+
+        sa_sint_t * buckets;
+        LIBSAIS_THREAD_CACHE * cache;
+    } state;
+
+    u8 padding[64];
+} LIBSAIS_THREAD_STATE;
+
+typedef struct LIBSAIS_CONTEXT {
+    sa_sint_t * buckets;
+    LIBSAIS_THREAD_STATE * thread_state;
+    fast_sint_t threads;
+} LIBSAIS_CONTEXT;
+
+typedef struct LIBSAIS_UNBWT_CONTEXT {
+    sa_uint_t * bucket2;
+    u16 * fastbits;
+    sa_uint_t * buckets;
+    fast_sint_t threads;
+} LIBSAIS_UNBWT_CONTEXT;
+
+static void * libsais_align_up(const void * address, size_t alignment) {
+    return (void *)((((ptrdiff_t)address) + ((ptrdiff_t)alignment) - 1) & (-((ptrdiff_t)alignment)));
+}
+
+static void * libsais_alloc_aligned(size_t size, size_t alignment) {
+    void * address = malloc(size + sizeof(short) + alignment - 1);
+    if (address != NULL) {
+        void * aligned_address = libsais_align_up((void *)((ptrdiff_t)address + (ptrdiff_t)(sizeof(short))), alignment);
+        ((short *)aligned_address)[-1] = (short)((ptrdiff_t)aligned_address - (ptrdiff_t)address);
+
+        return aligned_address;
+    }
+
+    return NULL;
+}
+
+static void libsais_free_aligned(void * aligned_address) {
+    if (aligned_address != NULL) {
+        free((void *)((ptrdiff_t)aligned_address - ((short *)aligned_address)[-1]));
+    }
+}
+
+static LIBSAIS_THREAD_STATE * libsais_alloc_thread_state(sa_sint_t threads) {
+    LIBSAIS_THREAD_STATE * RESTRICT thread_state =
+        (LIBSAIS_THREAD_STATE *)libsais_alloc_aligned((size_t)threads * sizeof(LIBSAIS_THREAD_STATE), 4096);
+    sa_sint_t * RESTRICT thread_buckets =
+        (sa_sint_t *)libsais_alloc_aligned((size_t)threads * 4 * ALPHABET_SIZE * sizeof(sa_sint_t), 4096);
+    LIBSAIS_THREAD_CACHE * RESTRICT thread_cache = (LIBSAIS_THREAD_CACHE *)libsais_alloc_aligned(
+        (size_t)threads * LIBSAIS_PER_THREAD_CACHE_SIZE * sizeof(LIBSAIS_THREAD_CACHE), 4096);
+
+    if (thread_state != NULL && thread_buckets != NULL && thread_cache != NULL) {
+        fast_sint_t t;
+        for (t = 0; t < threads; ++t) {
+            thread_state[t].state.buckets = thread_buckets;
+            thread_buckets += 4 * ALPHABET_SIZE;
+            thread_state[t].state.cache = thread_cache;
+            thread_cache += LIBSAIS_PER_THREAD_CACHE_SIZE;
+        }
+
+        return thread_state;
+    }
+
+    libsais_free_aligned(thread_cache);
+    libsais_free_aligned(thread_buckets);
+    libsais_free_aligned(thread_state);
+    return NULL;
+}
+
+static void libsais_free_thread_state(LIBSAIS_THREAD_STATE * thread_state) {
+    if (thread_state != NULL) {
+        libsais_free_aligned(thread_state[0].state.cache);
+        libsais_free_aligned(thread_state[0].state.buckets);
+        libsais_free_aligned(thread_state);
+    }
+}
+
+static LIBSAIS_CONTEXT * libsais_create_ctx_main(sa_sint_t threads) {
+    LIBSAIS_CONTEXT * RESTRICT ctx = (LIBSAIS_CONTEXT *)libsais_alloc_aligned(sizeof(LIBSAIS_CONTEXT), 64);
+    sa_sint_t * RESTRICT buckets = (sa_sint_t *)libsais_alloc_aligned(8 * ALPHABET_SIZE * sizeof(sa_sint_t), 4096);
+    LIBSAIS_THREAD_STATE * RESTRICT thread_state = threads > 1 ? libsais_alloc_thread_state(threads) : NULL;
+
+    if (ctx != NULL && buckets != NULL && (thread_state != NULL || threads == 1)) {
+        ctx->buckets = buckets;
+        ctx->threads = threads;
+        ctx->thread_state = thread_state;
+
+        return ctx;
+    }
+
+    libsais_free_thread_state(thread_state);
+    libsais_free_aligned(buckets);
+    libsais_free_aligned(ctx);
+    return NULL;
+}
+
+static void libsais_free_ctx_main(LIBSAIS_CONTEXT * ctx) {
+    if (ctx != NULL) {
+        libsais_free_thread_state(ctx->thread_state);
+        libsais_free_aligned(ctx->buckets);
+        libsais_free_aligned(ctx);
+    }
+}
+static void libsais_gather_lms_suffixes_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n, fast_sint_t m,
+                                           fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
+    if (omp_block_size > 0) {
+        const fast_sint_t prefetch_distance = 128;
+
+        fast_sint_t i, j = omp_block_start + omp_block_size, c0 = T[omp_block_start + omp_block_size - 1], c1 = -1;
+
+        while (j < n && (c1 = T[j]) == c0) {
+            ++j;
+        }
+
+        fast_uint_t s = c0 >= c1;
+
+        for (i = omp_block_start + omp_block_size - 2, j = omp_block_start + 3; i >= j; i -= 4) {
+            prefetch(&T[i - prefetch_distance]);
+
+            c1 = T[i - 0];
+            s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i + 1);
+            m -= ((s & 3) == 1);
+            c0 = T[i - 1];
+            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i - 0);
+            m -= ((s & 3) == 1);
+            c1 = T[i - 2];
+            s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i - 1);
+            m -= ((s & 3) == 1);
+            c0 = T[i - 3];
+            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i - 2);
+            m -= ((s & 3) == 1);
+        }
+
+        for (j -= 3; i >= j; i -= 1) {
+            c1 = c0;
+            c0 = T[i];
+            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i + 1);
+            m -= ((s & 3) == 1);
+        }
+
+        SA[m] = (sa_sint_t)(i + 1);
+    }
+}
+
+static void libsais_gather_lms_suffixes_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                               sa_sint_t threads, LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    {
+        (void)(threads);
+        (void)(thread_state);
+
+        fast_sint_t omp_thread_num = 0;
+        fast_sint_t omp_num_threads = 1;
+
+        fast_sint_t omp_block_stride = (n / omp_num_threads) & (-16);
+        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
+        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : n - omp_block_start;
+
+        if (omp_num_threads == 1) {
+            libsais_gather_lms_suffixes_8u(T, SA, n, (fast_sint_t)n - 1, omp_block_start, omp_block_size);
+        }
+    }
+}
+
+static sa_sint_t libsais_gather_lms_suffixes_32s(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n) {
+    const fast_sint_t prefetch_distance = 32;
+
+    sa_sint_t i = n - 2;
+    sa_sint_t m = n - 1;
+    fast_uint_t s = 1;
+    fast_sint_t c0 = T[n - 1];
+    fast_sint_t c1 = 0;
+
+    for (; i >= 3; i -= 4) {
+        prefetch(&T[i - prefetch_distance]);
+
+        c1 = T[i - 0];
+        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+        SA[m] = i + 1;
+        m -= ((s & 3) == 1);
+        c0 = T[i - 1];
+        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+        SA[m] = i - 0;
+        m -= ((s & 3) == 1);
+        c1 = T[i - 2];
+        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+        SA[m] = i - 1;
+        m -= ((s & 3) == 1);
+        c0 = T[i - 3];
+        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+        SA[m] = i - 2;
+        m -= ((s & 3) == 1);
+    }
+
+    for (; i >= 0; i -= 1) {
+        c1 = c0;
+        c0 = T[i];
+        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+        SA[m] = i + 1;
+        m -= ((s & 3) == 1);
+    }
+
+    return n - 1 - m;
+}
+
+static sa_sint_t libsais_gather_compacted_lms_suffixes_32s(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                           sa_sint_t n) {
+    const fast_sint_t prefetch_distance = 32;
+
+    sa_sint_t i = n - 2;
+    sa_sint_t m = n - 1;
+    fast_uint_t s = 1;
+    fast_sint_t c0 = T[n - 1];
+    fast_sint_t c1 = 0;
+
+    for (; i >= 3; i -= 4) {
+        prefetch(&T[i - prefetch_distance]);
+
+        c1 = T[i - 0];
+        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+        SA[m] = i + 1;
+        m -= ((fast_sint_t)(s & 3) == (c0 >= 0));
+        c0 = T[i - 1];
+        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+        SA[m] = i - 0;
+        m -= ((fast_sint_t)(s & 3) == (c1 >= 0));
+        c1 = T[i - 2];
+        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+        SA[m] = i - 1;
+        m -= ((fast_sint_t)(s & 3) == (c0 >= 0));
+        c0 = T[i - 3];
+        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+        SA[m] = i - 2;
+        m -= ((fast_sint_t)(s & 3) == (c1 >= 0));
+    }
+
+    for (; i >= 0; i -= 1) {
+        c1 = c0;
+        c0 = T[i];
+        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+        SA[m] = i + 1;
+        m -= ((fast_sint_t)(s & 3) == (c1 >= 0));
+    }
+
+    return n - 1 - m;
+}
+static void libsais_count_lms_suffixes_32s_2k(const sa_sint_t * RESTRICT T, sa_sint_t n, sa_sint_t k,
+                                              sa_sint_t * RESTRICT buckets) {
+    const fast_sint_t prefetch_distance = 32;
+
+    memset(buckets, 0, 2 * (size_t)k * sizeof(sa_sint_t));
+
+    sa_sint_t i = n - 2;
+    fast_uint_t s = 1;
+    fast_sint_t c0 = T[n - 1];
+    fast_sint_t c1 = 0;
+
+    for (; i >= prefetch_distance + 3; i -= 4) {
+        prefetch(&T[i - 2 * prefetch_distance]);
+
+        prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 0], 0)]);
+        prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 1], 0)]);
+        prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 2], 0)]);
+        prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 3], 0)]);
+
+        c1 = T[i - 0];
+        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+        buckets[BUCKETS_INDEX2((fast_uint_t)c0, (s & 3) == 1)]++;
+
+        c0 = T[i - 1];
+        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+        buckets[BUCKETS_INDEX2((fast_uint_t)c1, (s & 3) == 1)]++;
+
+        c1 = T[i - 2];
+        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+        buckets[BUCKETS_INDEX2((fast_uint_t)c0, (s & 3) == 1)]++;
+
+        c0 = T[i - 3];
+        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+        buckets[BUCKETS_INDEX2((fast_uint_t)c1, (s & 3) == 1)]++;
+    }
+
+    for (; i >= 0; i -= 1) {
+        c1 = c0;
+        c0 = T[i];
+        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+        buckets[BUCKETS_INDEX2((fast_uint_t)c1, (s & 3) == 1)]++;
+    }
+
+    buckets[BUCKETS_INDEX2((fast_uint_t)c0, 0)]++;
+}
+static sa_sint_t libsais_count_and_gather_lms_suffixes_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                          sa_sint_t * RESTRICT buckets, fast_sint_t omp_block_start,
+                                                          fast_sint_t omp_block_size) {
+    memset(buckets, 0, 4 * ALPHABET_SIZE * sizeof(sa_sint_t));
+
+    fast_sint_t m = omp_block_start + omp_block_size - 1;
+
+    if (omp_block_size > 0) {
+        const fast_sint_t prefetch_distance = 128;
+
+        fast_sint_t i, j = m + 1, c0 = T[m], c1 = -1;
+
+        while (j < n && (c1 = T[j]) == c0) {
+            ++j;
+        }
+
+        fast_uint_t s = c0 >= c1;
+
+        for (i = m - 1, j = omp_block_start + 3; i >= j; i -= 4) {
+            prefetch(&T[i - prefetch_distance]);
+
+            c1 = T[i - 0];
+            s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i + 1);
+            m -= ((s & 3) == 1);
+            buckets[BUCKETS_INDEX4((fast_uint_t)c0, s & 3)]++;
+
+            c0 = T[i - 1];
+            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i - 0);
+            m -= ((s & 3) == 1);
+            buckets[BUCKETS_INDEX4((fast_uint_t)c1, s & 3)]++;
+
+            c1 = T[i - 2];
+            s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i - 1);
+            m -= ((s & 3) == 1);
+            buckets[BUCKETS_INDEX4((fast_uint_t)c0, s & 3)]++;
+
+            c0 = T[i - 3];
+            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i - 2);
+            m -= ((s & 3) == 1);
+            buckets[BUCKETS_INDEX4((fast_uint_t)c1, s & 3)]++;
+        }
+
+        for (j -= 3; i >= j; i -= 1) {
+            c1 = c0;
+            c0 = T[i];
+            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i + 1);
+            m -= ((s & 3) == 1);
+            buckets[BUCKETS_INDEX4((fast_uint_t)c1, s & 3)]++;
+        }
+
+        c1 = (i >= 0) ? T[i] : -1;
+        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+        SA[m] = (sa_sint_t)(i + 1);
+        m -= ((s & 3) == 1);
+        buckets[BUCKETS_INDEX4((fast_uint_t)c0, s & 3)]++;
+    }
+
+    return (sa_sint_t)(omp_block_start + omp_block_size - 1 - m);
+}
+
+static sa_sint_t libsais_count_and_gather_lms_suffixes_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                              sa_sint_t n, sa_sint_t * RESTRICT buckets,
+                                                              sa_sint_t threads,
+                                                              LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    sa_sint_t m = 0;
+
+    {
+        (void)(threads);
+        (void)(thread_state);
+
+        fast_sint_t omp_thread_num = 0;
+        fast_sint_t omp_num_threads = 1;
+
+        fast_sint_t omp_block_stride = (n / omp_num_threads) & (-16);
+        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
+        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : n - omp_block_start;
+
+        if (omp_num_threads == 1) {
+            m = libsais_count_and_gather_lms_suffixes_8u(T, SA, n, buckets, omp_block_start, omp_block_size);
+        }
+    }
+
+    return m;
+}
+
+static sa_sint_t libsais_count_and_gather_lms_suffixes_32s_4k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                              sa_sint_t n, sa_sint_t k, sa_sint_t * RESTRICT buckets,
+                                                              fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
+    memset(buckets, 0, 4 * (size_t)k * sizeof(sa_sint_t));
+
+    fast_sint_t m = omp_block_start + omp_block_size - 1;
+
+    if (omp_block_size > 0) {
+        const fast_sint_t prefetch_distance = 32;
+
+        fast_sint_t i, j = m + 1, c0 = T[m], c1 = -1;
+
+        while (j < n && (c1 = T[j]) == c0) {
+            ++j;
+        }
+
+        fast_uint_t s = c0 >= c1;
+
+        for (i = m - 1, j = omp_block_start + prefetch_distance + 3; i >= j; i -= 4) {
+            prefetch(&T[i - 2 * prefetch_distance]);
+
+            prefetchw(&buckets[BUCKETS_INDEX4(T[i - prefetch_distance - 0], 0)]);
+            prefetchw(&buckets[BUCKETS_INDEX4(T[i - prefetch_distance - 1], 0)]);
+            prefetchw(&buckets[BUCKETS_INDEX4(T[i - prefetch_distance - 2], 0)]);
+            prefetchw(&buckets[BUCKETS_INDEX4(T[i - prefetch_distance - 3], 0)]);
+
+            c1 = T[i - 0];
+            s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i + 1);
+            m -= ((s & 3) == 1);
+            buckets[BUCKETS_INDEX4((fast_uint_t)c0, s & 3)]++;
+
+            c0 = T[i - 1];
+            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i - 0);
+            m -= ((s & 3) == 1);
+            buckets[BUCKETS_INDEX4((fast_uint_t)c1, s & 3)]++;
+
+            c1 = T[i - 2];
+            s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i - 1);
+            m -= ((s & 3) == 1);
+            buckets[BUCKETS_INDEX4((fast_uint_t)c0, s & 3)]++;
+
+            c0 = T[i - 3];
+            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i - 2);
+            m -= ((s & 3) == 1);
+            buckets[BUCKETS_INDEX4((fast_uint_t)c1, s & 3)]++;
+        }
+
+        for (j -= prefetch_distance + 3; i >= j; i -= 1) {
+            c1 = c0;
+            c0 = T[i];
+            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i + 1);
+            m -= ((s & 3) == 1);
+            buckets[BUCKETS_INDEX4((fast_uint_t)c1, s & 3)]++;
+        }
+
+        c1 = (i >= 0) ? T[i] : -1;
+        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+        SA[m] = (sa_sint_t)(i + 1);
+        m -= ((s & 3) == 1);
+        buckets[BUCKETS_INDEX4((fast_uint_t)c0, s & 3)]++;
+    }
+
+    return (sa_sint_t)(omp_block_start + omp_block_size - 1 - m);
+}
+
+static sa_sint_t libsais_count_and_gather_lms_suffixes_32s_2k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                              sa_sint_t n, sa_sint_t k, sa_sint_t * RESTRICT buckets,
+                                                              fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
+    memset(buckets, 0, 2 * (size_t)k * sizeof(sa_sint_t));
+
+    fast_sint_t m = omp_block_start + omp_block_size - 1;
+
+    if (omp_block_size > 0) {
+        const fast_sint_t prefetch_distance = 32;
+
+        fast_sint_t i, j = m + 1, c0 = T[m], c1 = -1;
+
+        while (j < n && (c1 = T[j]) == c0) {
+            ++j;
+        }
+
+        fast_uint_t s = c0 >= c1;
+
+        for (i = m - 1, j = omp_block_start + prefetch_distance + 3; i >= j; i -= 4) {
+            prefetch(&T[i - 2 * prefetch_distance]);
+
+            prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 0], 0)]);
+            prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 1], 0)]);
+            prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 2], 0)]);
+            prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 3], 0)]);
+
+            c1 = T[i - 0];
+            s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i + 1);
+            m -= ((s & 3) == 1);
+            buckets[BUCKETS_INDEX2((fast_uint_t)c0, (s & 3) == 1)]++;
+
+            c0 = T[i - 1];
+            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i - 0);
+            m -= ((s & 3) == 1);
+            buckets[BUCKETS_INDEX2((fast_uint_t)c1, (s & 3) == 1)]++;
+
+            c1 = T[i - 2];
+            s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i - 1);
+            m -= ((s & 3) == 1);
+            buckets[BUCKETS_INDEX2((fast_uint_t)c0, (s & 3) == 1)]++;
+
+            c0 = T[i - 3];
+            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i - 2);
+            m -= ((s & 3) == 1);
+            buckets[BUCKETS_INDEX2((fast_uint_t)c1, (s & 3) == 1)]++;
+        }
+
+        for (j -= prefetch_distance + 3; i >= j; i -= 1) {
+            c1 = c0;
+            c0 = T[i];
+            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i + 1);
+            m -= ((s & 3) == 1);
+            buckets[BUCKETS_INDEX2((fast_uint_t)c1, (s & 3) == 1)]++;
+        }
+
+        c1 = (i >= 0) ? T[i] : -1;
+        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+        SA[m] = (sa_sint_t)(i + 1);
+        m -= ((s & 3) == 1);
+        buckets[BUCKETS_INDEX2((fast_uint_t)c0, (s & 3) == 1)]++;
+    }
+
+    return (sa_sint_t)(omp_block_start + omp_block_size - 1 - m);
+}
+
+static sa_sint_t libsais_count_and_gather_compacted_lms_suffixes_32s_2k(const sa_sint_t * RESTRICT T,
+                                                                        sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                                        sa_sint_t k, sa_sint_t * RESTRICT buckets,
+                                                                        fast_sint_t omp_block_start,
+                                                                        fast_sint_t omp_block_size) {
+    memset(buckets, 0, 2 * (size_t)k * sizeof(sa_sint_t));
+
+    fast_sint_t m = omp_block_start + omp_block_size - 1;
+
+    if (omp_block_size > 0) {
+        const fast_sint_t prefetch_distance = 32;
+
+        fast_sint_t i, j = m + 1, c0 = T[m], c1 = -1;
+
+        while (j < n && (c1 = T[j]) == c0) {
+            ++j;
+        }
+
+        fast_uint_t s = c0 >= c1;
+
+        for (i = m - 1, j = omp_block_start + prefetch_distance + 3; i >= j; i -= 4) {
+            prefetch(&T[i - 2 * prefetch_distance]);
+
+            prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 0] & SAINT_MAX, 0)]);
+            prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 1] & SAINT_MAX, 0)]);
+            prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 2] & SAINT_MAX, 0)]);
+            prefetchw(&buckets[BUCKETS_INDEX2(T[i - prefetch_distance - 3] & SAINT_MAX, 0)]);
+
+            c1 = T[i - 0];
+            s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i + 1);
+            m -= ((fast_sint_t)(s & 3) == (c0 >= 0));
+            c0 &= SAINT_MAX;
+            buckets[BUCKETS_INDEX2((fast_uint_t)c0, (s & 3) == 1)]++;
+
+            c0 = T[i - 1];
+            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i - 0);
+            m -= ((fast_sint_t)(s & 3) == (c1 >= 0));
+            c1 &= SAINT_MAX;
+            buckets[BUCKETS_INDEX2((fast_uint_t)c1, (s & 3) == 1)]++;
+
+            c1 = T[i - 2];
+            s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i - 1);
+            m -= ((fast_sint_t)(s & 3) == (c0 >= 0));
+            c0 &= SAINT_MAX;
+            buckets[BUCKETS_INDEX2((fast_uint_t)c0, (s & 3) == 1)]++;
+
+            c0 = T[i - 3];
+            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i - 2);
+            m -= ((fast_sint_t)(s & 3) == (c1 >= 0));
+            c1 &= SAINT_MAX;
+            buckets[BUCKETS_INDEX2((fast_uint_t)c1, (s & 3) == 1)]++;
+        }
+
+        for (j -= prefetch_distance + 3; i >= j; i -= 1) {
+            c1 = c0;
+            c0 = T[i];
+            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+            SA[m] = (sa_sint_t)(i + 1);
+            m -= ((fast_sint_t)(s & 3) == (c1 >= 0));
+            c1 &= SAINT_MAX;
+            buckets[BUCKETS_INDEX2((fast_uint_t)c1, (s & 3) == 1)]++;
+        }
+
+        c1 = (i >= 0) ? T[i] : -1;
+        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+        SA[m] = (sa_sint_t)(i + 1);
+        m -= ((fast_sint_t)(s & 3) == (c0 >= 0));
+        c0 &= SAINT_MAX;
+        buckets[BUCKETS_INDEX2((fast_uint_t)c0, (s & 3) == 1)]++;
+    }
+
+    return (sa_sint_t)(omp_block_start + omp_block_size - 1 - m);
+}
+static sa_sint_t libsais_count_and_gather_lms_suffixes_32s_4k_nofs_omp(const sa_sint_t * RESTRICT T,
+                                                                       sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                                       sa_sint_t k, sa_sint_t * RESTRICT buckets,
+                                                                       sa_sint_t threads) {
+    sa_sint_t m = 0;
+    {
+        (void)(threads);
+
+        fast_sint_t omp_num_threads = 1;
+
+        if (omp_num_threads == 1) {
+            m = libsais_count_and_gather_lms_suffixes_32s_4k(T, SA, n, k, buckets, 0, n);
+        }
+    }
+
+    return m;
+}
+
+static sa_sint_t libsais_count_and_gather_lms_suffixes_32s_2k_nofs_omp(const sa_sint_t * RESTRICT T,
+                                                                       sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                                       sa_sint_t k, sa_sint_t * RESTRICT buckets,
+                                                                       sa_sint_t threads) {
+    sa_sint_t m = 0;
+    {
+        (void)(threads);
+
+        fast_sint_t omp_num_threads = 1;
+
+        if (omp_num_threads == 1) {
+            m = libsais_count_and_gather_lms_suffixes_32s_2k(T, SA, n, k, buckets, 0, n);
+        }
+    }
+
+    return m;
+}
+
+static sa_sint_t libsais_count_and_gather_compacted_lms_suffixes_32s_2k_nofs_omp(const sa_sint_t * RESTRICT T,
+                                                                                 sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                                                 sa_sint_t k,
+                                                                                 sa_sint_t * RESTRICT buckets,
+                                                                                 sa_sint_t threads) {
+    sa_sint_t m = 0;
+    {
+        (void)(threads);
+
+        fast_sint_t omp_num_threads = 1;
+
+        if (omp_num_threads == 1) {
+            m = libsais_count_and_gather_compacted_lms_suffixes_32s_2k(T, SA, n, k, buckets, 0, n);
+        }
+    }
+
+    return m;
+}
+
+static sa_sint_t libsais_count_and_gather_lms_suffixes_32s_4k_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                                  sa_sint_t n, sa_sint_t k,
+                                                                  sa_sint_t * RESTRICT buckets, sa_sint_t threads,
+                                                                  LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    sa_sint_t m;
+    (void)(thread_state);
+
+    { m = libsais_count_and_gather_lms_suffixes_32s_4k_nofs_omp(T, SA, n, k, buckets, threads); }
+
+    return m;
+}
+
+static sa_sint_t libsais_count_and_gather_lms_suffixes_32s_2k_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                                  sa_sint_t n, sa_sint_t k,
+                                                                  sa_sint_t * RESTRICT buckets, sa_sint_t threads,
+                                                                  LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    sa_sint_t m;
+    (void)(thread_state);
+
+    { m = libsais_count_and_gather_lms_suffixes_32s_2k_nofs_omp(T, SA, n, k, buckets, threads); }
+
+    return m;
+}
+
+static void libsais_count_and_gather_compacted_lms_suffixes_32s_2k_omp(const sa_sint_t * RESTRICT T,
+                                                                       sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                                       sa_sint_t k, sa_sint_t * RESTRICT buckets,
+                                                                       sa_sint_t threads,
+                                                                       LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    (void)(thread_state);
+
+    { libsais_count_and_gather_compacted_lms_suffixes_32s_2k_nofs_omp(T, SA, n, k, buckets, threads); }
+}
+
+static void libsais_count_suffixes_32s(const sa_sint_t * RESTRICT T, sa_sint_t n, sa_sint_t k,
+                                       sa_sint_t * RESTRICT buckets) {
+    const fast_sint_t prefetch_distance = 32;
+
+    memset(buckets, 0, (size_t)k * sizeof(sa_sint_t));
+
+    fast_sint_t i, j;
+    for (i = 0, j = (fast_sint_t)n - 7; i < j; i += 8) {
+        prefetch(&T[i + prefetch_distance]);
+
+        buckets[T[i + 0]]++;
+        buckets[T[i + 1]]++;
+        buckets[T[i + 2]]++;
+        buckets[T[i + 3]]++;
+        buckets[T[i + 4]]++;
+        buckets[T[i + 5]]++;
+        buckets[T[i + 6]]++;
+        buckets[T[i + 7]]++;
+    }
+
+    for (j += 7; i < j; i += 1) {
+        buckets[T[i]]++;
+    }
+}
+
+static void libsais_initialize_buckets_start_and_end_8u(sa_sint_t * RESTRICT buckets, sa_sint_t * RESTRICT freq) {
+    sa_sint_t * RESTRICT bucket_start = &buckets[6 * ALPHABET_SIZE];
+    sa_sint_t * RESTRICT bucket_end = &buckets[7 * ALPHABET_SIZE];
+
+    if (freq != NULL) {
+        fast_sint_t i, j;
+        sa_sint_t sum = 0;
+        for (i = BUCKETS_INDEX4(0, 0), j = 0; i <= BUCKETS_INDEX4(ALPHABET_SIZE - 1, 0);
+             i += BUCKETS_INDEX4(1, 0), j += 1) {
+            bucket_start[j] = sum;
+            sum += (freq[j] = buckets[i + BUCKETS_INDEX4(0, 0)] + buckets[i + BUCKETS_INDEX4(0, 1)] +
+                              buckets[i + BUCKETS_INDEX4(0, 2)] + buckets[i + BUCKETS_INDEX4(0, 3)]);
+            bucket_end[j] = sum;
+        }
+    } else {
+        fast_sint_t i, j;
+        sa_sint_t sum = 0;
+        for (i = BUCKETS_INDEX4(0, 0), j = 0; i <= BUCKETS_INDEX4(ALPHABET_SIZE - 1, 0);
+             i += BUCKETS_INDEX4(1, 0), j += 1) {
+            bucket_start[j] = sum;
+            sum += buckets[i + BUCKETS_INDEX4(0, 0)] + buckets[i + BUCKETS_INDEX4(0, 1)] +
+                   buckets[i + BUCKETS_INDEX4(0, 2)] + buckets[i + BUCKETS_INDEX4(0, 3)];
+            bucket_end[j] = sum;
+        }
+    }
+}
+
+static void libsais_initialize_buckets_start_and_end_32s_6k(sa_sint_t k, sa_sint_t * RESTRICT buckets) {
+    sa_sint_t * RESTRICT bucket_start = &buckets[4 * k];
+    sa_sint_t * RESTRICT bucket_end = &buckets[5 * k];
+
+    fast_sint_t i, j;
+    sa_sint_t sum = 0;
+    for (i = BUCKETS_INDEX4(0, 0), j = 0; i <= BUCKETS_INDEX4((fast_sint_t)k - 1, 0);
+         i += BUCKETS_INDEX4(1, 0), j += 1) {
+        bucket_start[j] = sum;
+        sum += buckets[i + BUCKETS_INDEX4(0, 0)] + buckets[i + BUCKETS_INDEX4(0, 1)] +
+               buckets[i + BUCKETS_INDEX4(0, 2)] + buckets[i + BUCKETS_INDEX4(0, 3)];
+        bucket_end[j] = sum;
+    }
+}
+
+static void libsais_initialize_buckets_start_and_end_32s_4k(sa_sint_t k, sa_sint_t * RESTRICT buckets) {
+    sa_sint_t * RESTRICT bucket_start = &buckets[2 * k];
+    sa_sint_t * RESTRICT bucket_end = &buckets[3 * k];
+
+    fast_sint_t i, j;
+    sa_sint_t sum = 0;
+    for (i = BUCKETS_INDEX2(0, 0), j = 0; i <= BUCKETS_INDEX2((fast_sint_t)k - 1, 0);
+         i += BUCKETS_INDEX2(1, 0), j += 1) {
+        bucket_start[j] = sum;
+        sum += buckets[i + BUCKETS_INDEX2(0, 0)] + buckets[i + BUCKETS_INDEX2(0, 1)];
+        bucket_end[j] = sum;
+    }
+}
+
+static void libsais_initialize_buckets_end_32s_2k(sa_sint_t k, sa_sint_t * RESTRICT buckets) {
+    fast_sint_t i;
+    sa_sint_t sum0 = 0;
+    for (i = BUCKETS_INDEX2(0, 0); i <= BUCKETS_INDEX2((fast_sint_t)k - 1, 0); i += BUCKETS_INDEX2(1, 0)) {
+        sum0 += buckets[i + BUCKETS_INDEX2(0, 0)] + buckets[i + BUCKETS_INDEX2(0, 1)];
+        buckets[i + BUCKETS_INDEX2(0, 0)] = sum0;
+    }
+}
+
+static void libsais_initialize_buckets_start_and_end_32s_2k(sa_sint_t k, sa_sint_t * RESTRICT buckets) {
+    fast_sint_t i, j;
+    for (i = BUCKETS_INDEX2(0, 0), j = 0; i <= BUCKETS_INDEX2((fast_sint_t)k - 1, 0);
+         i += BUCKETS_INDEX2(1, 0), j += 1) {
+        buckets[j] = buckets[i];
+    }
+
+    buckets[k] = 0;
+    memcpy(&buckets[k + 1], buckets, ((size_t)k - 1) * sizeof(sa_sint_t));
+}
+
+static void libsais_initialize_buckets_start_32s_1k(sa_sint_t k, sa_sint_t * RESTRICT buckets) {
+    fast_sint_t i;
+    sa_sint_t sum = 0;
+    for (i = 0; i <= (fast_sint_t)k - 1; i += 1) {
+        sa_sint_t tmp = buckets[i];
+        buckets[i] = sum;
+        sum += tmp;
+    }
+}
+
+static void libsais_initialize_buckets_end_32s_1k(sa_sint_t k, sa_sint_t * RESTRICT buckets) {
+    fast_sint_t i;
+    sa_sint_t sum = 0;
+    for (i = 0; i <= (fast_sint_t)k - 1; i += 1) {
+        sum += buckets[i];
+        buckets[i] = sum;
+    }
+}
+
+static sa_sint_t libsais_initialize_buckets_for_lms_suffixes_radix_sort_8u(const u8 * RESTRICT T,
+                                                                           sa_sint_t * RESTRICT buckets,
+                                                                           sa_sint_t first_lms_suffix) {
+    {
+        fast_uint_t s = 0;
+        fast_sint_t c0 = T[first_lms_suffix];
+        fast_sint_t c1 = 0;
+
+        for (; --first_lms_suffix >= 0;) {
+            c1 = c0;
+            c0 = T[first_lms_suffix];
+            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+            buckets[BUCKETS_INDEX4((fast_uint_t)c1, s & 3)]--;
+        }
+
+        buckets[BUCKETS_INDEX4((fast_uint_t)c0, (s << 1) & 3)]--;
+    }
+
+    {
+        sa_sint_t * RESTRICT temp_bucket = &buckets[4 * ALPHABET_SIZE];
+
+        fast_sint_t i, j;
+        sa_sint_t sum = 0;
+        for (i = BUCKETS_INDEX4(0, 0), j = BUCKETS_INDEX2(0, 0); i <= BUCKETS_INDEX4(ALPHABET_SIZE - 1, 0);
+             i += BUCKETS_INDEX4(1, 0), j += BUCKETS_INDEX2(1, 0)) {
+            temp_bucket[j + BUCKETS_INDEX2(0, 1)] = sum;
+            sum += buckets[i + BUCKETS_INDEX4(0, 1)] + buckets[i + BUCKETS_INDEX4(0, 3)];
+            temp_bucket[j] = sum;
+        }
+
+        return sum;
+    }
+}
+
+static void libsais_initialize_buckets_for_lms_suffixes_radix_sort_32s_2k(const sa_sint_t * RESTRICT T, sa_sint_t k,
+                                                                          sa_sint_t * RESTRICT buckets,
+                                                                          sa_sint_t first_lms_suffix) {
+    buckets[BUCKETS_INDEX2(T[first_lms_suffix], 0)]++;
+    buckets[BUCKETS_INDEX2(T[first_lms_suffix], 1)]--;
+
+    fast_sint_t i;
+    sa_sint_t sum0 = 0, sum1 = 0;
+    for (i = BUCKETS_INDEX2(0, 0); i <= BUCKETS_INDEX2((fast_sint_t)k - 1, 0); i += BUCKETS_INDEX2(1, 0)) {
+        sum0 += buckets[i + BUCKETS_INDEX2(0, 0)] + buckets[i + BUCKETS_INDEX2(0, 1)];
+        sum1 += buckets[i + BUCKETS_INDEX2(0, 1)];
+
+        buckets[i + BUCKETS_INDEX2(0, 0)] = sum0;
+        buckets[i + BUCKETS_INDEX2(0, 1)] = sum1;
+    }
+}
+
+static sa_sint_t libsais_initialize_buckets_for_lms_suffixes_radix_sort_32s_6k(const sa_sint_t * RESTRICT T,
+                                                                               sa_sint_t k,
+                                                                               sa_sint_t * RESTRICT buckets,
+                                                                               sa_sint_t first_lms_suffix) {
+    {
+        fast_uint_t s = 0;
+        fast_sint_t c0 = T[first_lms_suffix];
+        fast_sint_t c1 = 0;
+
+        for (; --first_lms_suffix >= 0;) {
+            c1 = c0;
+            c0 = T[first_lms_suffix];
+            s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+            buckets[BUCKETS_INDEX4((fast_uint_t)c1, s & 3)]--;
+        }
+
+        buckets[BUCKETS_INDEX4((fast_uint_t)c0, (s << 1) & 3)]--;
+    }
+
+    {
+        sa_sint_t * RESTRICT temp_bucket = &buckets[4 * k];
+
+        fast_sint_t i, j;
+        sa_sint_t sum = 0;
+        for (i = BUCKETS_INDEX4(0, 0), j = 0; i <= BUCKETS_INDEX4((fast_sint_t)k - 1, 0);
+             i += BUCKETS_INDEX4(1, 0), j += 1) {
+            sum += buckets[i + BUCKETS_INDEX4(0, 1)] + buckets[i + BUCKETS_INDEX4(0, 3)];
+            temp_bucket[j] = sum;
+        }
+
+        return sum;
+    }
+}
+
+static void libsais_initialize_buckets_for_radix_and_partial_sorting_32s_4k(const sa_sint_t * RESTRICT T, sa_sint_t k,
+                                                                            sa_sint_t * RESTRICT buckets,
+                                                                            sa_sint_t first_lms_suffix) {
+    sa_sint_t * RESTRICT bucket_start = &buckets[2 * k];
+    sa_sint_t * RESTRICT bucket_end = &buckets[3 * k];
+
+    buckets[BUCKETS_INDEX2(T[first_lms_suffix], 0)]++;
+    buckets[BUCKETS_INDEX2(T[first_lms_suffix], 1)]--;
+
+    fast_sint_t i, j;
+    sa_sint_t sum0 = 0, sum1 = 0;
+    for (i = BUCKETS_INDEX2(0, 0), j = 0; i <= BUCKETS_INDEX2((fast_sint_t)k - 1, 0);
+         i += BUCKETS_INDEX2(1, 0), j += 1) {
+        bucket_start[j] = sum1;
+
+        sum0 += buckets[i + BUCKETS_INDEX2(0, 1)];
+        sum1 += buckets[i + BUCKETS_INDEX2(0, 0)] + buckets[i + BUCKETS_INDEX2(0, 1)];
+        buckets[i + BUCKETS_INDEX2(0, 1)] = sum0;
+
+        bucket_end[j] = sum1;
+    }
+}
+
+static void libsais_radix_sort_lms_suffixes_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                               sa_sint_t * RESTRICT induction_bucket, fast_sint_t omp_block_start,
+                                               fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j;
+    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + prefetch_distance + 3; i >= j; i -= 4) {
+        prefetch(&SA[i - 2 * prefetch_distance]);
+
+        prefetch(&T[SA[i - prefetch_distance - 0]]);
+        prefetch(&T[SA[i - prefetch_distance - 1]]);
+        prefetch(&T[SA[i - prefetch_distance - 2]]);
+        prefetch(&T[SA[i - prefetch_distance - 3]]);
+
+        sa_sint_t p0 = SA[i - 0];
+        SA[--induction_bucket[BUCKETS_INDEX2(T[p0], 0)]] = p0;
+        sa_sint_t p1 = SA[i - 1];
+        SA[--induction_bucket[BUCKETS_INDEX2(T[p1], 0)]] = p1;
+        sa_sint_t p2 = SA[i - 2];
+        SA[--induction_bucket[BUCKETS_INDEX2(T[p2], 0)]] = p2;
+        sa_sint_t p3 = SA[i - 3];
+        SA[--induction_bucket[BUCKETS_INDEX2(T[p3], 0)]] = p3;
+    }
+
+    for (j -= prefetch_distance + 3; i >= j; i -= 1) {
+        sa_sint_t p = SA[i];
+        SA[--induction_bucket[BUCKETS_INDEX2(T[p], 0)]] = p;
+    }
+}
+
+static void libsais_radix_sort_lms_suffixes_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                   sa_sint_t m, sa_sint_t * RESTRICT buckets, sa_sint_t threads,
+                                                   LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    {
+        (void)(threads);
+        (void)(thread_state);
+
+        fast_sint_t omp_num_threads = 1;
+
+        if (omp_num_threads == 1) {
+            libsais_radix_sort_lms_suffixes_8u(T, SA, &buckets[4 * ALPHABET_SIZE], (fast_sint_t)n - (fast_sint_t)m + 1,
+                                               (fast_sint_t)m - 1);
+        }
+    }
+}
+
+static void libsais_radix_sort_lms_suffixes_32s_6k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                   sa_sint_t * RESTRICT induction_bucket, fast_sint_t omp_block_start,
+                                                   fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j;
+    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + 2 * prefetch_distance + 3; i >= j; i -= 4) {
+        prefetch(&SA[i - 3 * prefetch_distance]);
+
+        prefetch(&T[SA[i - 2 * prefetch_distance - 0]]);
+        prefetch(&T[SA[i - 2 * prefetch_distance - 1]]);
+        prefetch(&T[SA[i - 2 * prefetch_distance - 2]]);
+        prefetch(&T[SA[i - 2 * prefetch_distance - 3]]);
+
+        prefetchw(&induction_bucket[T[SA[i - prefetch_distance - 0]]]);
+        prefetchw(&induction_bucket[T[SA[i - prefetch_distance - 1]]]);
+        prefetchw(&induction_bucket[T[SA[i - prefetch_distance - 2]]]);
+        prefetchw(&induction_bucket[T[SA[i - prefetch_distance - 3]]]);
+
+        sa_sint_t p0 = SA[i - 0];
+        SA[--induction_bucket[T[p0]]] = p0;
+        sa_sint_t p1 = SA[i - 1];
+        SA[--induction_bucket[T[p1]]] = p1;
+        sa_sint_t p2 = SA[i - 2];
+        SA[--induction_bucket[T[p2]]] = p2;
+        sa_sint_t p3 = SA[i - 3];
+        SA[--induction_bucket[T[p3]]] = p3;
+    }
+
+    for (j -= 2 * prefetch_distance + 3; i >= j; i -= 1) {
+        sa_sint_t p = SA[i];
+        SA[--induction_bucket[T[p]]] = p;
+    }
+}
+
+static void libsais_radix_sort_lms_suffixes_32s_2k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                   sa_sint_t * RESTRICT induction_bucket, fast_sint_t omp_block_start,
+                                                   fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j;
+    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + 2 * prefetch_distance + 3; i >= j; i -= 4) {
+        prefetch(&SA[i - 3 * prefetch_distance]);
+
+        prefetch(&T[SA[i - 2 * prefetch_distance - 0]]);
+        prefetch(&T[SA[i - 2 * prefetch_distance - 1]]);
+        prefetch(&T[SA[i - 2 * prefetch_distance - 2]]);
+        prefetch(&T[SA[i - 2 * prefetch_distance - 3]]);
+
+        prefetchw(&induction_bucket[BUCKETS_INDEX2(T[SA[i - prefetch_distance - 0]], 0)]);
+        prefetchw(&induction_bucket[BUCKETS_INDEX2(T[SA[i - prefetch_distance - 1]], 0)]);
+        prefetchw(&induction_bucket[BUCKETS_INDEX2(T[SA[i - prefetch_distance - 2]], 0)]);
+        prefetchw(&induction_bucket[BUCKETS_INDEX2(T[SA[i - prefetch_distance - 3]], 0)]);
+
+        sa_sint_t p0 = SA[i - 0];
+        SA[--induction_bucket[BUCKETS_INDEX2(T[p0], 0)]] = p0;
+        sa_sint_t p1 = SA[i - 1];
+        SA[--induction_bucket[BUCKETS_INDEX2(T[p1], 0)]] = p1;
+        sa_sint_t p2 = SA[i - 2];
+        SA[--induction_bucket[BUCKETS_INDEX2(T[p2], 0)]] = p2;
+        sa_sint_t p3 = SA[i - 3];
+        SA[--induction_bucket[BUCKETS_INDEX2(T[p3], 0)]] = p3;
+    }
+
+    for (j -= 2 * prefetch_distance + 3; i >= j; i -= 1) {
+        sa_sint_t p = SA[i];
+        SA[--induction_bucket[BUCKETS_INDEX2(T[p], 0)]] = p;
+    }
+}
+static void libsais_radix_sort_lms_suffixes_32s_6k_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                       sa_sint_t n, sa_sint_t m, sa_sint_t * RESTRICT induction_bucket,
+                                                       sa_sint_t threads,
+                                                       LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    if (threads == 1 || m < 65536) {
+        libsais_radix_sort_lms_suffixes_32s_6k(T, SA, induction_bucket, (fast_sint_t)n - (fast_sint_t)m + 1,
+                                               (fast_sint_t)m - 1);
+    }
+    (void)(thread_state);
+}
+
+static void libsais_radix_sort_lms_suffixes_32s_2k_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                       sa_sint_t n, sa_sint_t m, sa_sint_t * RESTRICT induction_bucket,
+                                                       sa_sint_t threads,
+                                                       LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    if (threads == 1 || m < 65536) {
+        libsais_radix_sort_lms_suffixes_32s_2k(T, SA, induction_bucket, (fast_sint_t)n - (fast_sint_t)m + 1,
+                                               (fast_sint_t)m - 1);
+    }
+    (void)(thread_state);
+}
+
+static sa_sint_t libsais_radix_sort_lms_suffixes_32s_1k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                        sa_sint_t n, sa_sint_t * RESTRICT buckets) {
+    const fast_sint_t prefetch_distance = 32;
+
+    sa_sint_t i = n - 2;
+    sa_sint_t m = 0;
+    fast_uint_t s = 1;
+    fast_sint_t c0 = T[n - 1];
+    fast_sint_t c1 = 0;
+    fast_sint_t c2 = 0;
+
+    for (; i >= prefetch_distance + 3; i -= 4) {
+        prefetch(&T[i - 2 * prefetch_distance]);
+
+        prefetchw(&buckets[T[i - prefetch_distance - 0]]);
+        prefetchw(&buckets[T[i - prefetch_distance - 1]]);
+        prefetchw(&buckets[T[i - prefetch_distance - 2]]);
+        prefetchw(&buckets[T[i - prefetch_distance - 3]]);
+
+        c1 = T[i - 0];
+        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+        if ((s & 3) == 1) {
+            SA[--buckets[c2 = c0]] = i + 1;
+            m++;
+        }
+
+        c0 = T[i - 1];
+        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+        if ((s & 3) == 1) {
+            SA[--buckets[c2 = c1]] = i - 0;
+            m++;
+        }
+
+        c1 = T[i - 2];
+        s = (s << 1) + (fast_uint_t)(c1 > (c0 - (fast_sint_t)(s & 1)));
+        if ((s & 3) == 1) {
+            SA[--buckets[c2 = c0]] = i - 1;
+            m++;
+        }
+
+        c0 = T[i - 3];
+        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+        if ((s & 3) == 1) {
+            SA[--buckets[c2 = c1]] = i - 2;
+            m++;
+        }
+    }
+
+    for (; i >= 0; i -= 1) {
+        c1 = c0;
+        c0 = T[i];
+        s = (s << 1) + (fast_uint_t)(c0 > (c1 - (fast_sint_t)(s & 1)));
+        if ((s & 3) == 1) {
+            SA[--buckets[c2 = c1]] = i + 1;
+            m++;
+        }
+    }
+
+    if (m > 1) {
+        SA[buckets[c2]] = 0;
+    }
+
+    return m;
+}
+
+static void libsais_radix_sort_set_markers_32s_6k(sa_sint_t * RESTRICT SA, sa_sint_t * RESTRICT induction_bucket,
+                                                  fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j;
+    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 3; i < j; i += 4) {
+        prefetch(&induction_bucket[i + 2 * prefetch_distance]);
+
+        prefetchw(&SA[induction_bucket[i + prefetch_distance + 0]]);
+        prefetchw(&SA[induction_bucket[i + prefetch_distance + 1]]);
+        prefetchw(&SA[induction_bucket[i + prefetch_distance + 2]]);
+        prefetchw(&SA[induction_bucket[i + prefetch_distance + 3]]);
+
+        SA[induction_bucket[i + 0]] |= SAINT_MIN;
+        SA[induction_bucket[i + 1]] |= SAINT_MIN;
+        SA[induction_bucket[i + 2]] |= SAINT_MIN;
+        SA[induction_bucket[i + 3]] |= SAINT_MIN;
+    }
+
+    for (j += prefetch_distance + 3; i < j; i += 1) {
+        SA[induction_bucket[i]] |= SAINT_MIN;
+    }
+}
+
+static void libsais_radix_sort_set_markers_32s_4k(sa_sint_t * RESTRICT SA, sa_sint_t * RESTRICT induction_bucket,
+                                                  fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j;
+    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 3; i < j; i += 4) {
+        prefetch(&induction_bucket[BUCKETS_INDEX2(i + 2 * prefetch_distance, 0)]);
+
+        prefetchw(&SA[induction_bucket[BUCKETS_INDEX2(i + prefetch_distance + 0, 0)]]);
+        prefetchw(&SA[induction_bucket[BUCKETS_INDEX2(i + prefetch_distance + 1, 0)]]);
+        prefetchw(&SA[induction_bucket[BUCKETS_INDEX2(i + prefetch_distance + 2, 0)]]);
+        prefetchw(&SA[induction_bucket[BUCKETS_INDEX2(i + prefetch_distance + 3, 0)]]);
+
+        SA[induction_bucket[BUCKETS_INDEX2(i + 0, 0)]] |= SUFFIX_GROUP_MARKER;
+        SA[induction_bucket[BUCKETS_INDEX2(i + 1, 0)]] |= SUFFIX_GROUP_MARKER;
+        SA[induction_bucket[BUCKETS_INDEX2(i + 2, 0)]] |= SUFFIX_GROUP_MARKER;
+        SA[induction_bucket[BUCKETS_INDEX2(i + 3, 0)]] |= SUFFIX_GROUP_MARKER;
+    }
+
+    for (j += prefetch_distance + 3; i < j; i += 1) {
+        SA[induction_bucket[BUCKETS_INDEX2(i, 0)]] |= SUFFIX_GROUP_MARKER;
+    }
+}
+
+static void libsais_radix_sort_set_markers_32s_6k_omp(sa_sint_t * RESTRICT SA, sa_sint_t k,
+                                                      sa_sint_t * RESTRICT induction_bucket, sa_sint_t threads) {
+    {
+        (void)(threads);
+
+        fast_sint_t omp_block_start = 0;
+        fast_sint_t omp_block_size = (fast_sint_t)k - 1;
+        libsais_radix_sort_set_markers_32s_6k(SA, induction_bucket, omp_block_start, omp_block_size);
+    }
+}
+
+static void libsais_radix_sort_set_markers_32s_4k_omp(sa_sint_t * RESTRICT SA, sa_sint_t k,
+                                                      sa_sint_t * RESTRICT induction_bucket, sa_sint_t threads) {
+    {
+        (void)(threads);
+
+        fast_sint_t omp_block_start = 0;
+        fast_sint_t omp_block_size = (fast_sint_t)k - 1;
+        libsais_radix_sort_set_markers_32s_4k(SA, induction_bucket, omp_block_start, omp_block_size);
+    }
+}
+
+static void libsais_initialize_buckets_for_partial_sorting_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT buckets,
+                                                              sa_sint_t first_lms_suffix,
+                                                              sa_sint_t left_suffixes_count) {
+    sa_sint_t * RESTRICT temp_bucket = &buckets[4 * ALPHABET_SIZE];
+
+    buckets[BUCKETS_INDEX4((fast_uint_t)T[first_lms_suffix], 1)]++;
+
+    fast_sint_t i, j;
+    sa_sint_t sum0 = left_suffixes_count + 1, sum1 = 0;
+    for (i = BUCKETS_INDEX4(0, 0), j = BUCKETS_INDEX2(0, 0); i <= BUCKETS_INDEX4(ALPHABET_SIZE - 1, 0);
+         i += BUCKETS_INDEX4(1, 0), j += BUCKETS_INDEX2(1, 0)) {
+        temp_bucket[j + BUCKETS_INDEX2(0, 0)] = sum0;
+
+        sum0 += buckets[i + BUCKETS_INDEX4(0, 0)] + buckets[i + BUCKETS_INDEX4(0, 2)];
+        sum1 += buckets[i + BUCKETS_INDEX4(0, 1)];
+
+        buckets[j + BUCKETS_INDEX2(0, 0)] = sum0;
+        buckets[j + BUCKETS_INDEX2(0, 1)] = sum1;
+    }
+}
+
+static void libsais_initialize_buckets_for_partial_sorting_32s_6k(const sa_sint_t * RESTRICT T, sa_sint_t k,
+                                                                  sa_sint_t * RESTRICT buckets,
+                                                                  sa_sint_t first_lms_suffix,
+                                                                  sa_sint_t left_suffixes_count) {
+    sa_sint_t * RESTRICT temp_bucket = &buckets[4 * k];
+
+    fast_sint_t i, j;
+    sa_sint_t sum0 = left_suffixes_count + 1, sum1 = 0, sum2 = 0;
+    for (first_lms_suffix = T[first_lms_suffix], i = BUCKETS_INDEX4(0, 0), j = BUCKETS_INDEX2(0, 0);
+         i <= BUCKETS_INDEX4((fast_sint_t)first_lms_suffix - 1, 0);
+         i += BUCKETS_INDEX4(1, 0), j += BUCKETS_INDEX2(1, 0)) {
+        sa_sint_t SS = buckets[i + BUCKETS_INDEX4(0, 0)];
+        sa_sint_t LS = buckets[i + BUCKETS_INDEX4(0, 1)];
+        sa_sint_t SL = buckets[i + BUCKETS_INDEX4(0, 2)];
+        sa_sint_t LL = buckets[i + BUCKETS_INDEX4(0, 3)];
+
+        buckets[i + BUCKETS_INDEX4(0, 0)] = sum0;
+        buckets[i + BUCKETS_INDEX4(0, 1)] = sum2;
+        buckets[i + BUCKETS_INDEX4(0, 2)] = 0;
+        buckets[i + BUCKETS_INDEX4(0, 3)] = 0;
+
+        sum0 += SS + SL;
+        sum1 += LS;
+        sum2 += LS + LL;
+
+        temp_bucket[j + BUCKETS_INDEX2(0, 0)] = sum0;
+        temp_bucket[j + BUCKETS_INDEX2(0, 1)] = sum1;
+    }
+
+    for (sum1 += 1; i <= BUCKETS_INDEX4((fast_sint_t)k - 1, 0); i += BUCKETS_INDEX4(1, 0), j += BUCKETS_INDEX2(1, 0)) {
+        sa_sint_t SS = buckets[i + BUCKETS_INDEX4(0, 0)];
+        sa_sint_t LS = buckets[i + BUCKETS_INDEX4(0, 1)];
+        sa_sint_t SL = buckets[i + BUCKETS_INDEX4(0, 2)];
+        sa_sint_t LL = buckets[i + BUCKETS_INDEX4(0, 3)];
+
+        buckets[i + BUCKETS_INDEX4(0, 0)] = sum0;
+        buckets[i + BUCKETS_INDEX4(0, 1)] = sum2;
+        buckets[i + BUCKETS_INDEX4(0, 2)] = 0;
+        buckets[i + BUCKETS_INDEX4(0, 3)] = 0;
+
+        sum0 += SS + SL;
+        sum1 += LS;
+        sum2 += LS + LL;
+
+        temp_bucket[j + BUCKETS_INDEX2(0, 0)] = sum0;
+        temp_bucket[j + BUCKETS_INDEX2(0, 1)] = sum1;
+    }
+}
+
+static sa_sint_t libsais_partial_sorting_scan_left_to_right_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                               sa_sint_t * RESTRICT buckets, sa_sint_t d,
+                                                               fast_sint_t omp_block_start,
+                                                               fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    sa_sint_t * RESTRICT induction_bucket = &buckets[4 * ALPHABET_SIZE];
+    sa_sint_t * RESTRICT distinct_names = &buckets[2 * ALPHABET_SIZE];
+
+    fast_sint_t i, j;
+    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 1; i < j; i += 2) {
+        prefetch(&SA[i + 2 * prefetch_distance]);
+
+        prefetch(&T[SA[i + prefetch_distance + 0] & SAINT_MAX] - 1);
+        prefetch(&T[SA[i + prefetch_distance + 0] & SAINT_MAX] - 2);
+        prefetch(&T[SA[i + prefetch_distance + 1] & SAINT_MAX] - 1);
+        prefetch(&T[SA[i + prefetch_distance + 1] & SAINT_MAX] - 2);
+
+        sa_sint_t p0 = SA[i + 0];
+        d += (p0 < 0);
+        p0 &= SAINT_MAX;
+        sa_sint_t v0 = BUCKETS_INDEX2(T[p0 - 1], T[p0 - 2] >= T[p0 - 1]);
+        SA[induction_bucket[v0]++] = (p0 - 1) | ((sa_sint_t)(distinct_names[v0] != d) << (SAINT_BIT - 1));
+        distinct_names[v0] = d;
+
+        sa_sint_t p1 = SA[i + 1];
+        d += (p1 < 0);
+        p1 &= SAINT_MAX;
+        sa_sint_t v1 = BUCKETS_INDEX2(T[p1 - 1], T[p1 - 2] >= T[p1 - 1]);
+        SA[induction_bucket[v1]++] = (p1 - 1) | ((sa_sint_t)(distinct_names[v1] != d) << (SAINT_BIT - 1));
+        distinct_names[v1] = d;
+    }
+
+    for (j += prefetch_distance + 1; i < j; i += 1) {
+        sa_sint_t p = SA[i];
+        d += (p < 0);
+        p &= SAINT_MAX;
+        sa_sint_t v = BUCKETS_INDEX2(T[p - 1], T[p - 2] >= T[p - 1]);
+        SA[induction_bucket[v]++] = (p - 1) | ((sa_sint_t)(distinct_names[v] != d) << (SAINT_BIT - 1));
+        distinct_names[v] = d;
+    }
+
+    return d;
+}
+static sa_sint_t libsais_partial_sorting_scan_left_to_right_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                                   sa_sint_t n, sa_sint_t * RESTRICT buckets,
+                                                                   sa_sint_t left_suffixes_count, sa_sint_t d,
+                                                                   sa_sint_t threads,
+                                                                   LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    sa_sint_t * RESTRICT induction_bucket = &buckets[4 * ALPHABET_SIZE];
+    sa_sint_t * RESTRICT distinct_names = &buckets[2 * ALPHABET_SIZE];
+
+    SA[induction_bucket[BUCKETS_INDEX2(T[n - 1], T[n - 2] >= T[n - 1])]++] = (n - 1) | SAINT_MIN;
+    distinct_names[BUCKETS_INDEX2(T[n - 1], T[n - 2] >= T[n - 1])] = ++d;
+
+    if (threads == 1 || left_suffixes_count < 65536) {
+        d = libsais_partial_sorting_scan_left_to_right_8u(T, SA, buckets, d, 0, left_suffixes_count);
+    }
+    (void)(thread_state);
+    return d;
+}
+
+static sa_sint_t libsais_partial_sorting_scan_left_to_right_32s_6k(const sa_sint_t * RESTRICT T,
+                                                                   sa_sint_t * RESTRICT SA,
+                                                                   sa_sint_t * RESTRICT buckets, sa_sint_t d,
+                                                                   fast_sint_t omp_block_start,
+                                                                   fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j;
+    for (i = omp_block_start, j = omp_block_start + omp_block_size - 2 * prefetch_distance - 1; i < j; i += 2) {
+        prefetch(&SA[i + 3 * prefetch_distance]);
+
+        prefetch(&T[SA[i + 2 * prefetch_distance + 0] & SAINT_MAX] - 1);
+        prefetch(&T[SA[i + 2 * prefetch_distance + 0] & SAINT_MAX] - 2);
+        prefetch(&T[SA[i + 2 * prefetch_distance + 1] & SAINT_MAX] - 1);
+        prefetch(&T[SA[i + 2 * prefetch_distance + 1] & SAINT_MAX] - 2);
+
+        sa_sint_t p0 = SA[i + prefetch_distance + 0] & SAINT_MAX;
+        sa_sint_t v0 = BUCKETS_INDEX4(T[p0 - (p0 > 0)], 0);
+        prefetchw(&buckets[v0]);
+        sa_sint_t p1 = SA[i + prefetch_distance + 1] & SAINT_MAX;
+        sa_sint_t v1 = BUCKETS_INDEX4(T[p1 - (p1 > 0)], 0);
+        prefetchw(&buckets[v1]);
+
+        sa_sint_t p2 = SA[i + 0];
+        d += (p2 < 0);
+        p2 &= SAINT_MAX;
+        sa_sint_t v2 = BUCKETS_INDEX4(T[p2 - 1], T[p2 - 2] >= T[p2 - 1]);
+        SA[buckets[v2]++] = (p2 - 1) | ((sa_sint_t)(buckets[2 + v2] != d) << (SAINT_BIT - 1));
+        buckets[2 + v2] = d;
+
+        sa_sint_t p3 = SA[i + 1];
+        d += (p3 < 0);
+        p3 &= SAINT_MAX;
+        sa_sint_t v3 = BUCKETS_INDEX4(T[p3 - 1], T[p3 - 2] >= T[p3 - 1]);
+        SA[buckets[v3]++] = (p3 - 1) | ((sa_sint_t)(buckets[2 + v3] != d) << (SAINT_BIT - 1));
+        buckets[2 + v3] = d;
+    }
+
+    for (j += 2 * prefetch_distance + 1; i < j; i += 1) {
+        sa_sint_t p = SA[i];
+        d += (p < 0);
+        p &= SAINT_MAX;
+        sa_sint_t v = BUCKETS_INDEX4(T[p - 1], T[p - 2] >= T[p - 1]);
+        SA[buckets[v]++] = (p - 1) | ((sa_sint_t)(buckets[2 + v] != d) << (SAINT_BIT - 1));
+        buckets[2 + v] = d;
+    }
+
+    return d;
+}
+
+static sa_sint_t libsais_partial_sorting_scan_left_to_right_32s_4k(const sa_sint_t * RESTRICT T,
+                                                                   sa_sint_t * RESTRICT SA, sa_sint_t k,
+                                                                   sa_sint_t * RESTRICT buckets, sa_sint_t d,
+                                                                   fast_sint_t omp_block_start,
+                                                                   fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    sa_sint_t * RESTRICT induction_bucket = &buckets[2 * k];
+    sa_sint_t * RESTRICT distinct_names = &buckets[0 * k];
+
+    fast_sint_t i, j;
+    for (i = omp_block_start, j = omp_block_start + omp_block_size - 2 * prefetch_distance - 1; i < j; i += 2) {
+        prefetchw(&SA[i + 3 * prefetch_distance]);
+
+        sa_sint_t s0 = SA[i + 2 * prefetch_distance + 0];
+        const sa_sint_t * Ts0 = &T[s0 & ~SUFFIX_GROUP_MARKER] - 1;
+        prefetch(s0 > 0 ? Ts0 : NULL);
+        Ts0--;
+        prefetch(s0 > 0 ? Ts0 : NULL);
+        sa_sint_t s1 = SA[i + 2 * prefetch_distance + 1];
+        const sa_sint_t * Ts1 = &T[s1 & ~SUFFIX_GROUP_MARKER] - 1;
+        prefetch(s1 > 0 ? Ts1 : NULL);
+        Ts1--;
+        prefetch(s1 > 0 ? Ts1 : NULL);
+        sa_sint_t s2 = SA[i + 1 * prefetch_distance + 0];
+        if (s2 > 0) {
+            const fast_sint_t Ts2 = T[(s2 & ~SUFFIX_GROUP_MARKER) - 1];
+            prefetchw(&induction_bucket[Ts2]);
+            prefetchw(&distinct_names[BUCKETS_INDEX2(Ts2, 0)]);
+        }
+        sa_sint_t s3 = SA[i + 1 * prefetch_distance + 1];
+        if (s3 > 0) {
+            const fast_sint_t Ts3 = T[(s3 & ~SUFFIX_GROUP_MARKER) - 1];
+            prefetchw(&induction_bucket[Ts3]);
+            prefetchw(&distinct_names[BUCKETS_INDEX2(Ts3, 0)]);
+        }
+
+        sa_sint_t p0 = SA[i + 0];
+        SA[i + 0] = p0 & SAINT_MAX;
+        if (p0 > 0) {
+            SA[i + 0] = 0;
+            d += (p0 >> (SUFFIX_GROUP_BIT - 1));
+            p0 &= ~SUFFIX_GROUP_MARKER;
+            sa_sint_t v0 = BUCKETS_INDEX2(T[p0 - 1], T[p0 - 2] < T[p0 - 1]);
+            SA[induction_bucket[T[p0 - 1]]++] = (p0 - 1) | ((sa_sint_t)(T[p0 - 2] < T[p0 - 1]) << (SAINT_BIT - 1)) |
+                                                ((sa_sint_t)(distinct_names[v0] != d) << (SUFFIX_GROUP_BIT - 1));
+            distinct_names[v0] = d;
+        }
+
+        sa_sint_t p1 = SA[i + 1];
+        SA[i + 1] = p1 & SAINT_MAX;
+        if (p1 > 0) {
+            SA[i + 1] = 0;
+            d += (p1 >> (SUFFIX_GROUP_BIT - 1));
+            p1 &= ~SUFFIX_GROUP_MARKER;
+            sa_sint_t v1 = BUCKETS_INDEX2(T[p1 - 1], T[p1 - 2] < T[p1 - 1]);
+            SA[induction_bucket[T[p1 - 1]]++] = (p1 - 1) | ((sa_sint_t)(T[p1 - 2] < T[p1 - 1]) << (SAINT_BIT - 1)) |
+                                                ((sa_sint_t)(distinct_names[v1] != d) << (SUFFIX_GROUP_BIT - 1));
+            distinct_names[v1] = d;
+        }
+    }
+
+    for (j += 2 * prefetch_distance + 1; i < j; i += 1) {
+        sa_sint_t p = SA[i];
+        SA[i] = p & SAINT_MAX;
+        if (p > 0) {
+            SA[i] = 0;
+            d += (p >> (SUFFIX_GROUP_BIT - 1));
+            p &= ~SUFFIX_GROUP_MARKER;
+            sa_sint_t v = BUCKETS_INDEX2(T[p - 1], T[p - 2] < T[p - 1]);
+            SA[induction_bucket[T[p - 1]]++] = (p - 1) | ((sa_sint_t)(T[p - 2] < T[p - 1]) << (SAINT_BIT - 1)) |
+                                               ((sa_sint_t)(distinct_names[v] != d) << (SUFFIX_GROUP_BIT - 1));
+            distinct_names[v] = d;
+        }
+    }
+
+    return d;
+}
+
+static void libsais_partial_sorting_scan_left_to_right_32s_1k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                              sa_sint_t * RESTRICT induction_bucket,
+                                                              fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j;
+    for (i = omp_block_start, j = omp_block_start + omp_block_size - 2 * prefetch_distance - 1; i < j; i += 2) {
+        prefetchw(&SA[i + 3 * prefetch_distance]);
+
+        sa_sint_t s0 = SA[i + 2 * prefetch_distance + 0];
+        const sa_sint_t * Ts0 = &T[s0] - 1;
+        prefetch(s0 > 0 ? Ts0 : NULL);
+        sa_sint_t s1 = SA[i + 2 * prefetch_distance + 1];
+        const sa_sint_t * Ts1 = &T[s1] - 1;
+        prefetch(s1 > 0 ? Ts1 : NULL);
+        sa_sint_t s2 = SA[i + 1 * prefetch_distance + 0];
+        if (s2 > 0) {
+            prefetchw(&induction_bucket[T[s2 - 1]]);
+            prefetch(&T[s2] - 2);
+        }
+        sa_sint_t s3 = SA[i + 1 * prefetch_distance + 1];
+        if (s3 > 0) {
+            prefetchw(&induction_bucket[T[s3 - 1]]);
+            prefetch(&T[s3] - 2);
+        }
+
+        sa_sint_t p0 = SA[i + 0];
+        SA[i + 0] = p0 & SAINT_MAX;
+        if (p0 > 0) {
+            SA[i + 0] = 0;
+            SA[induction_bucket[T[p0 - 1]]++] = (p0 - 1) | ((sa_sint_t)(T[p0 - 2] < T[p0 - 1]) << (SAINT_BIT - 1));
+        }
+        sa_sint_t p1 = SA[i + 1];
+        SA[i + 1] = p1 & SAINT_MAX;
+        if (p1 > 0) {
+            SA[i + 1] = 0;
+            SA[induction_bucket[T[p1 - 1]]++] = (p1 - 1) | ((sa_sint_t)(T[p1 - 2] < T[p1 - 1]) << (SAINT_BIT - 1));
+        }
+    }
+
+    for (j += 2 * prefetch_distance + 1; i < j; i += 1) {
+        sa_sint_t p = SA[i];
+        SA[i] = p & SAINT_MAX;
+        if (p > 0) {
+            SA[i] = 0;
+            SA[induction_bucket[T[p - 1]]++] = (p - 1) | ((sa_sint_t)(T[p - 2] < T[p - 1]) << (SAINT_BIT - 1));
+        }
+    }
+}
+static sa_sint_t libsais_partial_sorting_scan_left_to_right_32s_6k_omp(
+    const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t * RESTRICT buckets,
+    sa_sint_t left_suffixes_count, sa_sint_t d, sa_sint_t threads, LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    SA[buckets[BUCKETS_INDEX4(T[n - 1], T[n - 2] >= T[n - 1])]++] = (n - 1) | SAINT_MIN;
+    buckets[2 + BUCKETS_INDEX4(T[n - 1], T[n - 2] >= T[n - 1])] = ++d;
+
+    if (threads == 1 || left_suffixes_count < 65536) {
+        d = libsais_partial_sorting_scan_left_to_right_32s_6k(T, SA, buckets, d, 0, left_suffixes_count);
+    }
+    (void)(thread_state);
+    return d;
+}
+
+static sa_sint_t libsais_partial_sorting_scan_left_to_right_32s_4k_omp(const sa_sint_t * RESTRICT T,
+                                                                       sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                                       sa_sint_t k, sa_sint_t * RESTRICT buckets,
+                                                                       sa_sint_t d, sa_sint_t threads,
+                                                                       LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    sa_sint_t * RESTRICT induction_bucket = &buckets[2 * k];
+    sa_sint_t * RESTRICT distinct_names = &buckets[0 * k];
+
+    SA[induction_bucket[T[n - 1]]++] =
+        (n - 1) | ((sa_sint_t)(T[n - 2] < T[n - 1]) << (SAINT_BIT - 1)) | SUFFIX_GROUP_MARKER;
+    distinct_names[BUCKETS_INDEX2(T[n - 1], T[n - 2] < T[n - 1])] = ++d;
+
+    if (threads == 1 || n < 65536) {
+        d = libsais_partial_sorting_scan_left_to_right_32s_4k(T, SA, k, buckets, d, 0, n);
+    }
+    (void)(thread_state);
+    return d;
+}
+
+static void libsais_partial_sorting_scan_left_to_right_32s_1k_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                                  sa_sint_t n, sa_sint_t * RESTRICT buckets,
+                                                                  sa_sint_t threads,
+                                                                  LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    SA[buckets[T[n - 1]]++] = (n - 1) | ((sa_sint_t)(T[n - 2] < T[n - 1]) << (SAINT_BIT - 1));
+
+    if (threads == 1 || n < 65536) {
+        libsais_partial_sorting_scan_left_to_right_32s_1k(T, SA, buckets, 0, n);
+    }
+    (void)(thread_state);
+}
+
+static void libsais_partial_sorting_shift_markers_8u_omp(sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                         const sa_sint_t * RESTRICT buckets, sa_sint_t threads) {
+    const fast_sint_t prefetch_distance = 32;
+
+    const sa_sint_t * RESTRICT temp_bucket = &buckets[4 * ALPHABET_SIZE];
+
+    fast_sint_t c;
+    (void)(threads);
+    (void)(n);
+
+    for (c = BUCKETS_INDEX2(ALPHABET_SIZE - 1, 0); c >= BUCKETS_INDEX2(1, 0); c -= BUCKETS_INDEX2(1, 0)) {
+        fast_sint_t i, j;
+        sa_sint_t s = SAINT_MIN;
+        for (i = (fast_sint_t)temp_bucket[c] - 1, j = (fast_sint_t)buckets[c - BUCKETS_INDEX2(1, 0)] + 3; i >= j;
+             i -= 4) {
+            prefetchw(&SA[i - prefetch_distance]);
+
+            sa_sint_t p0 = SA[i - 0], q0 = (p0 & SAINT_MIN) ^ s;
+            s = s ^ q0;
+            SA[i - 0] = p0 ^ q0;
+            sa_sint_t p1 = SA[i - 1], q1 = (p1 & SAINT_MIN) ^ s;
+            s = s ^ q1;
+            SA[i - 1] = p1 ^ q1;
+            sa_sint_t p2 = SA[i - 2], q2 = (p2 & SAINT_MIN) ^ s;
+            s = s ^ q2;
+            SA[i - 2] = p2 ^ q2;
+            sa_sint_t p3 = SA[i - 3], q3 = (p3 & SAINT_MIN) ^ s;
+            s = s ^ q3;
+            SA[i - 3] = p3 ^ q3;
+        }
+
+        for (j -= 3; i >= j; i -= 1) {
+            sa_sint_t p = SA[i], q = (p & SAINT_MIN) ^ s;
+            s = s ^ q;
+            SA[i] = p ^ q;
+        }
+    }
+}
+
+static void libsais_partial_sorting_shift_markers_32s_6k_omp(sa_sint_t * RESTRICT SA, sa_sint_t k,
+                                                             const sa_sint_t * RESTRICT buckets, sa_sint_t threads) {
+    const fast_sint_t prefetch_distance = 32;
+
+    const sa_sint_t * RESTRICT temp_bucket = &buckets[4 * k];
+
+    fast_sint_t c;
+    (void)(threads);
+
+    for (c = (fast_sint_t)k - 1; c >= 1; c -= 1) {
+        fast_sint_t i, j;
+        sa_sint_t s = SAINT_MIN;
+        for (i = (fast_sint_t)buckets[BUCKETS_INDEX4(c, 0)] - 1,
+            j = (fast_sint_t)temp_bucket[BUCKETS_INDEX2(c - 1, 0)] + 3;
+             i >= j; i -= 4) {
+            prefetchw(&SA[i - prefetch_distance]);
+
+            sa_sint_t p0 = SA[i - 0], q0 = (p0 & SAINT_MIN) ^ s;
+            s = s ^ q0;
+            SA[i - 0] = p0 ^ q0;
+            sa_sint_t p1 = SA[i - 1], q1 = (p1 & SAINT_MIN) ^ s;
+            s = s ^ q1;
+            SA[i - 1] = p1 ^ q1;
+            sa_sint_t p2 = SA[i - 2], q2 = (p2 & SAINT_MIN) ^ s;
+            s = s ^ q2;
+            SA[i - 2] = p2 ^ q2;
+            sa_sint_t p3 = SA[i - 3], q3 = (p3 & SAINT_MIN) ^ s;
+            s = s ^ q3;
+            SA[i - 3] = p3 ^ q3;
+        }
+
+        for (j -= 3; i >= j; i -= 1) {
+            sa_sint_t p = SA[i], q = (p & SAINT_MIN) ^ s;
+            s = s ^ q;
+            SA[i] = p ^ q;
+        }
+    }
+}
+
+static void libsais_partial_sorting_shift_markers_32s_4k(sa_sint_t * RESTRICT SA, sa_sint_t n) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i;
+    sa_sint_t s = SUFFIX_GROUP_MARKER;
+    for (i = (fast_sint_t)n - 1; i >= 3; i -= 4) {
+        prefetchw(&SA[i - prefetch_distance]);
+
+        sa_sint_t p0 = SA[i - 0],
+                  q0 = ((p0 & SUFFIX_GROUP_MARKER) ^ s) & ((sa_sint_t)(p0 > 0) << ((SUFFIX_GROUP_BIT - 1)));
+        s = s ^ q0;
+        SA[i - 0] = p0 ^ q0;
+        sa_sint_t p1 = SA[i - 1],
+                  q1 = ((p1 & SUFFIX_GROUP_MARKER) ^ s) & ((sa_sint_t)(p1 > 0) << ((SUFFIX_GROUP_BIT - 1)));
+        s = s ^ q1;
+        SA[i - 1] = p1 ^ q1;
+        sa_sint_t p2 = SA[i - 2],
+                  q2 = ((p2 & SUFFIX_GROUP_MARKER) ^ s) & ((sa_sint_t)(p2 > 0) << ((SUFFIX_GROUP_BIT - 1)));
+        s = s ^ q2;
+        SA[i - 2] = p2 ^ q2;
+        sa_sint_t p3 = SA[i - 3],
+                  q3 = ((p3 & SUFFIX_GROUP_MARKER) ^ s) & ((sa_sint_t)(p3 > 0) << ((SUFFIX_GROUP_BIT - 1)));
+        s = s ^ q3;
+        SA[i - 3] = p3 ^ q3;
+    }
+
+    for (; i >= 0; i -= 1) {
+        sa_sint_t p = SA[i], q = ((p & SUFFIX_GROUP_MARKER) ^ s) & ((sa_sint_t)(p > 0) << ((SUFFIX_GROUP_BIT - 1)));
+        s = s ^ q;
+        SA[i] = p ^ q;
+    }
+}
+
+static void libsais_partial_sorting_shift_buckets_32s_6k(sa_sint_t k, sa_sint_t * RESTRICT buckets) {
+    sa_sint_t * RESTRICT temp_bucket = &buckets[4 * k];
+
+    fast_sint_t i;
+    for (i = BUCKETS_INDEX2(0, 0); i <= BUCKETS_INDEX2((fast_sint_t)k - 1, 0); i += BUCKETS_INDEX2(1, 0)) {
+        buckets[2 * i + BUCKETS_INDEX4(0, 0)] = temp_bucket[i + BUCKETS_INDEX2(0, 0)];
+        buckets[2 * i + BUCKETS_INDEX4(0, 1)] = temp_bucket[i + BUCKETS_INDEX2(0, 1)];
+    }
+}
+
+static sa_sint_t libsais_partial_sorting_scan_right_to_left_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                               sa_sint_t * RESTRICT buckets, sa_sint_t d,
+                                                               fast_sint_t omp_block_start,
+                                                               fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    sa_sint_t * RESTRICT induction_bucket = &buckets[0 * ALPHABET_SIZE];
+    sa_sint_t * RESTRICT distinct_names = &buckets[2 * ALPHABET_SIZE];
+
+    fast_sint_t i, j;
+    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + prefetch_distance + 1; i >= j; i -= 2) {
+        prefetch(&SA[i - 2 * prefetch_distance]);
+
+        prefetch(&T[SA[i - prefetch_distance - 0] & SAINT_MAX] - 1);
+        prefetch(&T[SA[i - prefetch_distance - 0] & SAINT_MAX] - 2);
+        prefetch(&T[SA[i - prefetch_distance - 1] & SAINT_MAX] - 1);
+        prefetch(&T[SA[i - prefetch_distance - 1] & SAINT_MAX] - 2);
+
+        sa_sint_t p0 = SA[i - 0];
+        d += (p0 < 0);
+        p0 &= SAINT_MAX;
+        sa_sint_t v0 = BUCKETS_INDEX2(T[p0 - 1], T[p0 - 2] > T[p0 - 1]);
+        SA[--induction_bucket[v0]] = (p0 - 1) | ((sa_sint_t)(distinct_names[v0] != d) << (SAINT_BIT - 1));
+        distinct_names[v0] = d;
+
+        sa_sint_t p1 = SA[i - 1];
+        d += (p1 < 0);
+        p1 &= SAINT_MAX;
+        sa_sint_t v1 = BUCKETS_INDEX2(T[p1 - 1], T[p1 - 2] > T[p1 - 1]);
+        SA[--induction_bucket[v1]] = (p1 - 1) | ((sa_sint_t)(distinct_names[v1] != d) << (SAINT_BIT - 1));
+        distinct_names[v1] = d;
+    }
+
+    for (j -= prefetch_distance + 1; i >= j; i -= 1) {
+        sa_sint_t p = SA[i];
+        d += (p < 0);
+        p &= SAINT_MAX;
+        sa_sint_t v = BUCKETS_INDEX2(T[p - 1], T[p - 2] > T[p - 1]);
+        SA[--induction_bucket[v]] = (p - 1) | ((sa_sint_t)(distinct_names[v] != d) << (SAINT_BIT - 1));
+        distinct_names[v] = d;
+    }
+
+    return d;
+}
+static void libsais_partial_sorting_scan_right_to_left_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                              sa_sint_t n, sa_sint_t * RESTRICT buckets,
+                                                              sa_sint_t first_lms_suffix, sa_sint_t left_suffixes_count,
+                                                              sa_sint_t d, sa_sint_t threads,
+                                                              LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    fast_sint_t scan_start = (fast_sint_t)left_suffixes_count + 1;
+    fast_sint_t scan_end = (fast_sint_t)n - (fast_sint_t)first_lms_suffix;
+
+    if (threads == 1 || (scan_end - scan_start) < 65536) {
+        libsais_partial_sorting_scan_right_to_left_8u(T, SA, buckets, d, scan_start, scan_end - scan_start);
+    }
+    (void)(thread_state);
+}
+
+static sa_sint_t libsais_partial_sorting_scan_right_to_left_32s_6k(const sa_sint_t * RESTRICT T,
+                                                                   sa_sint_t * RESTRICT SA,
+                                                                   sa_sint_t * RESTRICT buckets, sa_sint_t d,
+                                                                   fast_sint_t omp_block_start,
+                                                                   fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j;
+    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + 2 * prefetch_distance + 1; i >= j; i -= 2) {
+        prefetch(&SA[i - 3 * prefetch_distance]);
+
+        prefetch(&T[SA[i - 2 * prefetch_distance - 0] & SAINT_MAX] - 1);
+        prefetch(&T[SA[i - 2 * prefetch_distance - 0] & SAINT_MAX] - 2);
+        prefetch(&T[SA[i - 2 * prefetch_distance - 1] & SAINT_MAX] - 1);
+        prefetch(&T[SA[i - 2 * prefetch_distance - 1] & SAINT_MAX] - 2);
+
+        sa_sint_t p0 = SA[i - prefetch_distance - 0] & SAINT_MAX;
+        sa_sint_t v0 = BUCKETS_INDEX4(T[p0 - (p0 > 0)], 0);
+        prefetchw(&buckets[v0]);
+        sa_sint_t p1 = SA[i - prefetch_distance - 1] & SAINT_MAX;
+        sa_sint_t v1 = BUCKETS_INDEX4(T[p1 - (p1 > 0)], 0);
+        prefetchw(&buckets[v1]);
+
+        sa_sint_t p2 = SA[i - 0];
+        d += (p2 < 0);
+        p2 &= SAINT_MAX;
+        sa_sint_t v2 = BUCKETS_INDEX4(T[p2 - 1], T[p2 - 2] > T[p2 - 1]);
+        SA[--buckets[v2]] = (p2 - 1) | ((sa_sint_t)(buckets[2 + v2] != d) << (SAINT_BIT - 1));
+        buckets[2 + v2] = d;
+
+        sa_sint_t p3 = SA[i - 1];
+        d += (p3 < 0);
+        p3 &= SAINT_MAX;
+        sa_sint_t v3 = BUCKETS_INDEX4(T[p3 - 1], T[p3 - 2] > T[p3 - 1]);
+        SA[--buckets[v3]] = (p3 - 1) | ((sa_sint_t)(buckets[2 + v3] != d) << (SAINT_BIT - 1));
+        buckets[2 + v3] = d;
+    }
+
+    for (j -= 2 * prefetch_distance + 1; i >= j; i -= 1) {
+        sa_sint_t p = SA[i];
+        d += (p < 0);
+        p &= SAINT_MAX;
+        sa_sint_t v = BUCKETS_INDEX4(T[p - 1], T[p - 2] > T[p - 1]);
+        SA[--buckets[v]] = (p - 1) | ((sa_sint_t)(buckets[2 + v] != d) << (SAINT_BIT - 1));
+        buckets[2 + v] = d;
+    }
+
+    return d;
+}
+
+static sa_sint_t libsais_partial_sorting_scan_right_to_left_32s_4k(const sa_sint_t * RESTRICT T,
+                                                                   sa_sint_t * RESTRICT SA, sa_sint_t k,
+                                                                   sa_sint_t * RESTRICT buckets, sa_sint_t d,
+                                                                   fast_sint_t omp_block_start,
+                                                                   fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    sa_sint_t * RESTRICT induction_bucket = &buckets[3 * k];
+    sa_sint_t * RESTRICT distinct_names = &buckets[0 * k];
+
+    fast_sint_t i, j;
+    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + 2 * prefetch_distance + 1; i >= j; i -= 2) {
+        prefetchw(&SA[i - 3 * prefetch_distance]);
+
+        sa_sint_t s0 = SA[i - 2 * prefetch_distance - 0];
+        const sa_sint_t * Ts0 = &T[s0 & ~SUFFIX_GROUP_MARKER] - 1;
+        prefetch(s0 > 0 ? Ts0 : NULL);
+        Ts0--;
+        prefetch(s0 > 0 ? Ts0 : NULL);
+        sa_sint_t s1 = SA[i - 2 * prefetch_distance - 1];
+        const sa_sint_t * Ts1 = &T[s1 & ~SUFFIX_GROUP_MARKER] - 1;
+        prefetch(s1 > 0 ? Ts1 : NULL);
+        Ts1--;
+        prefetch(s1 > 0 ? Ts1 : NULL);
+        sa_sint_t s2 = SA[i - 1 * prefetch_distance - 0];
+        if (s2 > 0) {
+            const fast_sint_t Ts2 = T[(s2 & ~SUFFIX_GROUP_MARKER) - 1];
+            prefetchw(&induction_bucket[Ts2]);
+            prefetchw(&distinct_names[BUCKETS_INDEX2(Ts2, 0)]);
+        }
+        sa_sint_t s3 = SA[i - 1 * prefetch_distance - 1];
+        if (s3 > 0) {
+            const fast_sint_t Ts3 = T[(s3 & ~SUFFIX_GROUP_MARKER) - 1];
+            prefetchw(&induction_bucket[Ts3]);
+            prefetchw(&distinct_names[BUCKETS_INDEX2(Ts3, 0)]);
+        }
+
+        sa_sint_t p0 = SA[i - 0];
+        if (p0 > 0) {
+            SA[i - 0] = 0;
+            d += (p0 >> (SUFFIX_GROUP_BIT - 1));
+            p0 &= ~SUFFIX_GROUP_MARKER;
+            sa_sint_t v0 = BUCKETS_INDEX2(T[p0 - 1], T[p0 - 2] > T[p0 - 1]);
+            SA[--induction_bucket[T[p0 - 1]]] = (p0 - 1) | ((sa_sint_t)(T[p0 - 2] > T[p0 - 1]) << (SAINT_BIT - 1)) |
+                                                ((sa_sint_t)(distinct_names[v0] != d) << (SUFFIX_GROUP_BIT - 1));
+            distinct_names[v0] = d;
+        }
+
+        sa_sint_t p1 = SA[i - 1];
+        if (p1 > 0) {
+            SA[i - 1] = 0;
+            d += (p1 >> (SUFFIX_GROUP_BIT - 1));
+            p1 &= ~SUFFIX_GROUP_MARKER;
+            sa_sint_t v1 = BUCKETS_INDEX2(T[p1 - 1], T[p1 - 2] > T[p1 - 1]);
+            SA[--induction_bucket[T[p1 - 1]]] = (p1 - 1) | ((sa_sint_t)(T[p1 - 2] > T[p1 - 1]) << (SAINT_BIT - 1)) |
+                                                ((sa_sint_t)(distinct_names[v1] != d) << (SUFFIX_GROUP_BIT - 1));
+            distinct_names[v1] = d;
+        }
+    }
+
+    for (j -= 2 * prefetch_distance + 1; i >= j; i -= 1) {
+        sa_sint_t p = SA[i];
+        if (p > 0) {
+            SA[i] = 0;
+            d += (p >> (SUFFIX_GROUP_BIT - 1));
+            p &= ~SUFFIX_GROUP_MARKER;
+            sa_sint_t v = BUCKETS_INDEX2(T[p - 1], T[p - 2] > T[p - 1]);
+            SA[--induction_bucket[T[p - 1]]] = (p - 1) | ((sa_sint_t)(T[p - 2] > T[p - 1]) << (SAINT_BIT - 1)) |
+                                               ((sa_sint_t)(distinct_names[v] != d) << (SUFFIX_GROUP_BIT - 1));
+            distinct_names[v] = d;
+        }
+    }
+
+    return d;
+}
+
+static void libsais_partial_sorting_scan_right_to_left_32s_1k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                              sa_sint_t * RESTRICT induction_bucket,
+                                                              fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j;
+    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + 2 * prefetch_distance + 1; i >= j; i -= 2) {
+        prefetchw(&SA[i - 3 * prefetch_distance]);
+
+        sa_sint_t s0 = SA[i - 2 * prefetch_distance - 0];
+        const sa_sint_t * Ts0 = &T[s0] - 1;
+        prefetch(s0 > 0 ? Ts0 : NULL);
+        sa_sint_t s1 = SA[i - 2 * prefetch_distance - 1];
+        const sa_sint_t * Ts1 = &T[s1] - 1;
+        prefetch(s1 > 0 ? Ts1 : NULL);
+        sa_sint_t s2 = SA[i - 1 * prefetch_distance - 0];
+        if (s2 > 0) {
+            prefetchw(&induction_bucket[T[s2 - 1]]);
+            prefetch(&T[s2] - 2);
+        }
+        sa_sint_t s3 = SA[i - 1 * prefetch_distance - 1];
+        if (s3 > 0) {
+            prefetchw(&induction_bucket[T[s3 - 1]]);
+            prefetch(&T[s3] - 2);
+        }
+
+        sa_sint_t p0 = SA[i - 0];
+        if (p0 > 0) {
+            SA[i - 0] = 0;
+            SA[--induction_bucket[T[p0 - 1]]] = (p0 - 1) | ((sa_sint_t)(T[p0 - 2] > T[p0 - 1]) << (SAINT_BIT - 1));
+        }
+        sa_sint_t p1 = SA[i - 1];
+        if (p1 > 0) {
+            SA[i - 1] = 0;
+            SA[--induction_bucket[T[p1 - 1]]] = (p1 - 1) | ((sa_sint_t)(T[p1 - 2] > T[p1 - 1]) << (SAINT_BIT - 1));
+        }
+    }
+
+    for (j -= 2 * prefetch_distance + 1; i >= j; i -= 1) {
+        sa_sint_t p = SA[i];
+        if (p > 0) {
+            SA[i] = 0;
+            SA[--induction_bucket[T[p - 1]]] = (p - 1) | ((sa_sint_t)(T[p - 2] > T[p - 1]) << (SAINT_BIT - 1));
+        }
+    }
+}
+static sa_sint_t libsais_partial_sorting_scan_right_to_left_32s_6k_omp(
+    const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t * RESTRICT buckets,
+    sa_sint_t first_lms_suffix, sa_sint_t left_suffixes_count, sa_sint_t d, sa_sint_t threads,
+    LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    fast_sint_t scan_start = (fast_sint_t)left_suffixes_count + 1;
+    fast_sint_t scan_end = (fast_sint_t)n - (fast_sint_t)first_lms_suffix;
+
+    if (threads == 1 || (scan_end - scan_start) < 65536) {
+        d = libsais_partial_sorting_scan_right_to_left_32s_6k(T, SA, buckets, d, scan_start, scan_end - scan_start);
+    }
+    (void)(thread_state);
+    return d;
+}
+
+static sa_sint_t libsais_partial_sorting_scan_right_to_left_32s_4k_omp(const sa_sint_t * RESTRICT T,
+                                                                       sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                                       sa_sint_t k, sa_sint_t * RESTRICT buckets,
+                                                                       sa_sint_t d, sa_sint_t threads,
+                                                                       LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    if (threads == 1 || n < 65536) {
+        d = libsais_partial_sorting_scan_right_to_left_32s_4k(T, SA, k, buckets, d, 0, n);
+    }
+    (void)(thread_state);
+    return d;
+}
+
+static void libsais_partial_sorting_scan_right_to_left_32s_1k_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                                  sa_sint_t n, sa_sint_t * RESTRICT buckets,
+                                                                  sa_sint_t threads,
+                                                                  LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    if (threads == 1 || n < 65536) {
+        libsais_partial_sorting_scan_right_to_left_32s_1k(T, SA, buckets, 0, n);
+    }
+    (void)(thread_state);
+}
+
+static fast_sint_t libsais_partial_sorting_gather_lms_suffixes_32s_4k(sa_sint_t * RESTRICT SA,
+                                                                      fast_sint_t omp_block_start,
+                                                                      fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j, l;
+    for (i = omp_block_start, j = omp_block_start + omp_block_size - 3, l = omp_block_start; i < j; i += 4) {
+        prefetch(&SA[i + prefetch_distance]);
+
+        sa_sint_t s0 = SA[i + 0];
+        SA[l] = (s0 - SUFFIX_GROUP_MARKER) & (~SUFFIX_GROUP_MARKER);
+        l += (s0 < 0);
+        sa_sint_t s1 = SA[i + 1];
+        SA[l] = (s1 - SUFFIX_GROUP_MARKER) & (~SUFFIX_GROUP_MARKER);
+        l += (s1 < 0);
+        sa_sint_t s2 = SA[i + 2];
+        SA[l] = (s2 - SUFFIX_GROUP_MARKER) & (~SUFFIX_GROUP_MARKER);
+        l += (s2 < 0);
+        sa_sint_t s3 = SA[i + 3];
+        SA[l] = (s3 - SUFFIX_GROUP_MARKER) & (~SUFFIX_GROUP_MARKER);
+        l += (s3 < 0);
+    }
+
+    for (j += 3; i < j; i += 1) {
+        sa_sint_t s = SA[i];
+        SA[l] = (s - SUFFIX_GROUP_MARKER) & (~SUFFIX_GROUP_MARKER);
+        l += (s < 0);
+    }
+
+    return l;
+}
+
+static fast_sint_t libsais_partial_sorting_gather_lms_suffixes_32s_1k(sa_sint_t * RESTRICT SA,
+                                                                      fast_sint_t omp_block_start,
+                                                                      fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j, l;
+    for (i = omp_block_start, j = omp_block_start + omp_block_size - 3, l = omp_block_start; i < j; i += 4) {
+        prefetch(&SA[i + prefetch_distance]);
+
+        sa_sint_t s0 = SA[i + 0];
+        SA[l] = s0 & SAINT_MAX;
+        l += (s0 < 0);
+        sa_sint_t s1 = SA[i + 1];
+        SA[l] = s1 & SAINT_MAX;
+        l += (s1 < 0);
+        sa_sint_t s2 = SA[i + 2];
+        SA[l] = s2 & SAINT_MAX;
+        l += (s2 < 0);
+        sa_sint_t s3 = SA[i + 3];
+        SA[l] = s3 & SAINT_MAX;
+        l += (s3 < 0);
+    }
+
+    for (j += 3; i < j; i += 1) {
+        sa_sint_t s = SA[i];
+        SA[l] = s & SAINT_MAX;
+        l += (s < 0);
+    }
+
+    return l;
+}
+
+static void libsais_partial_sorting_gather_lms_suffixes_32s_4k_omp(sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                                   sa_sint_t threads,
+                                                                   LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    {
+        (void)(threads);
+        (void)(thread_state);
+
+        fast_sint_t omp_thread_num = 0;
+        fast_sint_t omp_num_threads = 1;
+
+        fast_sint_t omp_block_stride = (n / omp_num_threads) & (-16);
+        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
+        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : n - omp_block_start;
+
+        if (omp_num_threads == 1) {
+            libsais_partial_sorting_gather_lms_suffixes_32s_4k(SA, omp_block_start, omp_block_size);
+        }
+    }
+}
+
+static void libsais_partial_sorting_gather_lms_suffixes_32s_1k_omp(sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                                   sa_sint_t threads,
+                                                                   LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    {
+        (void)(threads);
+        (void)(thread_state);
+
+        fast_sint_t omp_thread_num = 0;
+        fast_sint_t omp_num_threads = 1;
+
+        fast_sint_t omp_block_stride = (n / omp_num_threads) & (-16);
+        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
+        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : n - omp_block_start;
+
+        if (omp_num_threads == 1) {
+            libsais_partial_sorting_gather_lms_suffixes_32s_1k(SA, omp_block_start, omp_block_size);
+        }
+    }
+}
+
+static void libsais_induce_partial_order_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                sa_sint_t * RESTRICT buckets, sa_sint_t first_lms_suffix,
+                                                sa_sint_t left_suffixes_count, sa_sint_t threads,
+                                                LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    memset(&buckets[2 * ALPHABET_SIZE], 0, 2 * ALPHABET_SIZE * sizeof(sa_sint_t));
+
+    sa_sint_t d = libsais_partial_sorting_scan_left_to_right_8u_omp(T, SA, n, buckets, left_suffixes_count, 0, threads,
+                                                                    thread_state);
+    libsais_partial_sorting_shift_markers_8u_omp(SA, n, buckets, threads);
+    libsais_partial_sorting_scan_right_to_left_8u_omp(T, SA, n, buckets, first_lms_suffix, left_suffixes_count, d,
+                                                      threads, thread_state);
+}
+
+static void libsais_induce_partial_order_32s_6k_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                    sa_sint_t k, sa_sint_t * RESTRICT buckets,
+                                                    sa_sint_t first_lms_suffix, sa_sint_t left_suffixes_count,
+                                                    sa_sint_t threads, LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    sa_sint_t d = libsais_partial_sorting_scan_left_to_right_32s_6k_omp(T, SA, n, buckets, left_suffixes_count, 0,
+                                                                        threads, thread_state);
+    libsais_partial_sorting_shift_markers_32s_6k_omp(SA, k, buckets, threads);
+    libsais_partial_sorting_shift_buckets_32s_6k(k, buckets);
+    libsais_partial_sorting_scan_right_to_left_32s_6k_omp(T, SA, n, buckets, first_lms_suffix, left_suffixes_count, d,
+                                                          threads, thread_state);
+}
+
+static void libsais_induce_partial_order_32s_4k_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                    sa_sint_t k, sa_sint_t * RESTRICT buckets, sa_sint_t threads,
+                                                    LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    memset(buckets, 0, 2 * (size_t)k * sizeof(sa_sint_t));
+
+    sa_sint_t d = libsais_partial_sorting_scan_left_to_right_32s_4k_omp(T, SA, n, k, buckets, 0, threads, thread_state);
+    libsais_partial_sorting_shift_markers_32s_4k(SA, n);
+    libsais_partial_sorting_scan_right_to_left_32s_4k_omp(T, SA, n, k, buckets, d, threads, thread_state);
+    libsais_partial_sorting_gather_lms_suffixes_32s_4k_omp(SA, n, threads, thread_state);
+}
+
+static void libsais_induce_partial_order_32s_2k_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                    sa_sint_t k, sa_sint_t * RESTRICT buckets, sa_sint_t threads,
+                                                    LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    libsais_partial_sorting_scan_left_to_right_32s_1k_omp(T, SA, n, &buckets[1 * k], threads, thread_state);
+    libsais_partial_sorting_scan_right_to_left_32s_1k_omp(T, SA, n, &buckets[0 * k], threads, thread_state);
+    libsais_partial_sorting_gather_lms_suffixes_32s_1k_omp(SA, n, threads, thread_state);
+}
+
+static void libsais_induce_partial_order_32s_1k_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                    sa_sint_t k, sa_sint_t * RESTRICT buckets, sa_sint_t threads,
+                                                    LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    libsais_count_suffixes_32s(T, n, k, buckets);
+    libsais_initialize_buckets_start_32s_1k(k, buckets);
+    libsais_partial_sorting_scan_left_to_right_32s_1k_omp(T, SA, n, buckets, threads, thread_state);
+
+    libsais_count_suffixes_32s(T, n, k, buckets);
+    libsais_initialize_buckets_end_32s_1k(k, buckets);
+    libsais_partial_sorting_scan_right_to_left_32s_1k_omp(T, SA, n, buckets, threads, thread_state);
+
+    libsais_partial_sorting_gather_lms_suffixes_32s_1k_omp(SA, n, threads, thread_state);
+}
+
+static sa_sint_t libsais_renumber_lms_suffixes_8u(sa_sint_t * RESTRICT SA, sa_sint_t m, sa_sint_t name,
+                                                  fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    sa_sint_t * RESTRICT SAm = &SA[m];
+
+    fast_sint_t i, j;
+    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 3; i < j; i += 4) {
+        prefetch(&SA[i + 2 * prefetch_distance]);
+
+        prefetchw(&SAm[(SA[i + prefetch_distance + 0] & SAINT_MAX) >> 1]);
+        prefetchw(&SAm[(SA[i + prefetch_distance + 1] & SAINT_MAX) >> 1]);
+        prefetchw(&SAm[(SA[i + prefetch_distance + 2] & SAINT_MAX) >> 1]);
+        prefetchw(&SAm[(SA[i + prefetch_distance + 3] & SAINT_MAX) >> 1]);
+
+        sa_sint_t p0 = SA[i + 0];
+        SAm[(p0 & SAINT_MAX) >> 1] = name | SAINT_MIN;
+        name += p0 < 0;
+        sa_sint_t p1 = SA[i + 1];
+        SAm[(p1 & SAINT_MAX) >> 1] = name | SAINT_MIN;
+        name += p1 < 0;
+        sa_sint_t p2 = SA[i + 2];
+        SAm[(p2 & SAINT_MAX) >> 1] = name | SAINT_MIN;
+        name += p2 < 0;
+        sa_sint_t p3 = SA[i + 3];
+        SAm[(p3 & SAINT_MAX) >> 1] = name | SAINT_MIN;
+        name += p3 < 0;
+    }
+
+    for (j += prefetch_distance + 3; i < j; i += 1) {
+        sa_sint_t p = SA[i];
+        SAm[(p & SAINT_MAX) >> 1] = name | SAINT_MIN;
+        name += p < 0;
+    }
+
+    return name;
+}
+
+static fast_sint_t libsais_gather_marked_suffixes_8u(sa_sint_t * RESTRICT SA, sa_sint_t m, fast_sint_t l,
+                                                     fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    l -= 1;
+
+    fast_sint_t i, j;
+    for (i = (fast_sint_t)m + omp_block_start + omp_block_size - 1, j = (fast_sint_t)m + omp_block_start + 3; i >= j;
+         i -= 4) {
+        prefetch(&SA[i - prefetch_distance]);
+
+        sa_sint_t s0 = SA[i - 0];
+        SA[l] = s0 & SAINT_MAX;
+        l -= s0 < 0;
+        sa_sint_t s1 = SA[i - 1];
+        SA[l] = s1 & SAINT_MAX;
+        l -= s1 < 0;
+        sa_sint_t s2 = SA[i - 2];
+        SA[l] = s2 & SAINT_MAX;
+        l -= s2 < 0;
+        sa_sint_t s3 = SA[i - 3];
+        SA[l] = s3 & SAINT_MAX;
+        l -= s3 < 0;
+    }
+
+    for (j -= 3; i >= j; i -= 1) {
+        sa_sint_t s = SA[i];
+        SA[l] = s & SAINT_MAX;
+        l -= s < 0;
+    }
+
+    l += 1;
+
+    return l;
+}
+
+static sa_sint_t libsais_renumber_lms_suffixes_8u_omp(sa_sint_t * RESTRICT SA, sa_sint_t m, sa_sint_t threads,
+                                                      LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    sa_sint_t name = 0;
+    {
+        (void)(threads);
+        (void)(thread_state);
+
+        fast_sint_t omp_thread_num = 0;
+        fast_sint_t omp_num_threads = 1;
+
+        fast_sint_t omp_block_stride = (m / omp_num_threads) & (-16);
+        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
+        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : m - omp_block_start;
+
+        if (omp_num_threads == 1) {
+            name = libsais_renumber_lms_suffixes_8u(SA, m, 0, omp_block_start, omp_block_size);
+        }
+    }
+
+    return name;
+}
+
+static void libsais_gather_marked_lms_suffixes_8u_omp(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m, sa_sint_t fs,
+                                                      sa_sint_t threads, LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    {
+        (void)(threads);
+        (void)(thread_state);
+
+        fast_sint_t omp_thread_num = 0;
+        fast_sint_t omp_num_threads = 1;
+
+        fast_sint_t omp_block_stride = (((fast_sint_t)n >> 1) / omp_num_threads) & (-16);
+        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
+        fast_sint_t omp_block_size =
+            omp_thread_num < omp_num_threads - 1 ? omp_block_stride : ((fast_sint_t)n >> 1) - omp_block_start;
+
+        if (omp_num_threads == 1) {
+            libsais_gather_marked_suffixes_8u(SA, m, (fast_sint_t)n + (fast_sint_t)fs, omp_block_start, omp_block_size);
+        }
+    }
+}
+
+static sa_sint_t libsais_renumber_and_gather_lms_suffixes_8u_omp(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m,
+                                                                 sa_sint_t fs, sa_sint_t threads,
+                                                                 LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    memset(&SA[m], 0, ((size_t)n >> 1) * sizeof(sa_sint_t));
+
+    sa_sint_t name = libsais_renumber_lms_suffixes_8u_omp(SA, m, threads, thread_state);
+    if (name < m) {
+        libsais_gather_marked_lms_suffixes_8u_omp(SA, n, m, fs, threads, thread_state);
+    } else {
+        fast_sint_t i;
+        for (i = 0; i < m; i += 1) {
+            SA[i] &= SAINT_MAX;
+        }
+    }
+
+    return name;
+}
+
+static sa_sint_t libsais_renumber_distinct_lms_suffixes_32s_4k(sa_sint_t * RESTRICT SA, sa_sint_t m, sa_sint_t name,
+                                                               fast_sint_t omp_block_start,
+                                                               fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    sa_sint_t * RESTRICT SAm = &SA[m];
+
+    fast_sint_t i, j;
+    sa_sint_t p0, p1, p2, p3 = 0;
+    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 3; i < j; i += 4) {
+        prefetchw(&SA[i + 2 * prefetch_distance]);
+
+        prefetchw(&SAm[(SA[i + prefetch_distance + 0] & SAINT_MAX) >> 1]);
+        prefetchw(&SAm[(SA[i + prefetch_distance + 1] & SAINT_MAX) >> 1]);
+        prefetchw(&SAm[(SA[i + prefetch_distance + 2] & SAINT_MAX) >> 1]);
+        prefetchw(&SAm[(SA[i + prefetch_distance + 3] & SAINT_MAX) >> 1]);
+
+        p0 = SA[i + 0];
+        SAm[(SA[i + 0] = p0 & SAINT_MAX) >> 1] = name | (p0 & p3 & SAINT_MIN);
+        name += p0 < 0;
+        p1 = SA[i + 1];
+        SAm[(SA[i + 1] = p1 & SAINT_MAX) >> 1] = name | (p1 & p0 & SAINT_MIN);
+        name += p1 < 0;
+        p2 = SA[i + 2];
+        SAm[(SA[i + 2] = p2 & SAINT_MAX) >> 1] = name | (p2 & p1 & SAINT_MIN);
+        name += p2 < 0;
+        p3 = SA[i + 3];
+        SAm[(SA[i + 3] = p3 & SAINT_MAX) >> 1] = name | (p3 & p2 & SAINT_MIN);
+        name += p3 < 0;
+    }
+
+    for (j += prefetch_distance + 3; i < j; i += 1) {
+        p2 = p3;
+        p3 = SA[i];
+        SAm[(SA[i] = p3 & SAINT_MAX) >> 1] = name | (p3 & p2 & SAINT_MIN);
+        name += p3 < 0;
+    }
+
+    return name;
+}
+
+static void libsais_mark_distinct_lms_suffixes_32s(sa_sint_t * RESTRICT SA, sa_sint_t m, fast_sint_t omp_block_start,
+                                                   fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j;
+    sa_sint_t p0, p1, p2, p3 = 0;
+    for (i = (fast_sint_t)m + omp_block_start, j = (fast_sint_t)m + omp_block_start + omp_block_size - 3; i < j;
+         i += 4) {
+        prefetchw(&SA[i + prefetch_distance]);
+
+        p0 = SA[i + 0];
+        SA[i + 0] = p0 & (p3 | SAINT_MAX);
+        p0 = (p0 == 0) ? p3 : p0;
+        p1 = SA[i + 1];
+        SA[i + 1] = p1 & (p0 | SAINT_MAX);
+        p1 = (p1 == 0) ? p0 : p1;
+        p2 = SA[i + 2];
+        SA[i + 2] = p2 & (p1 | SAINT_MAX);
+        p2 = (p2 == 0) ? p1 : p2;
+        p3 = SA[i + 3];
+        SA[i + 3] = p3 & (p2 | SAINT_MAX);
+        p3 = (p3 == 0) ? p2 : p3;
+    }
+
+    for (j += 3; i < j; i += 1) {
+        p2 = p3;
+        p3 = SA[i];
+        SA[i] = p3 & (p2 | SAINT_MAX);
+        p3 = (p3 == 0) ? p2 : p3;
+    }
+}
+
+static void libsais_clamp_lms_suffixes_length_32s(sa_sint_t * RESTRICT SA, sa_sint_t m, fast_sint_t omp_block_start,
+                                                  fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    sa_sint_t * RESTRICT SAm = &SA[m];
+
+    fast_sint_t i, j;
+    for (i = omp_block_start, j = omp_block_start + omp_block_size - 3; i < j; i += 4) {
+        prefetchw(&SAm[i + prefetch_distance]);
+
+        SAm[i + 0] = (SAm[i + 0] < 0 ? SAm[i + 0] : 0) & SAINT_MAX;
+        SAm[i + 1] = (SAm[i + 1] < 0 ? SAm[i + 1] : 0) & SAINT_MAX;
+        SAm[i + 2] = (SAm[i + 2] < 0 ? SAm[i + 2] : 0) & SAINT_MAX;
+        SAm[i + 3] = (SAm[i + 3] < 0 ? SAm[i + 3] : 0) & SAINT_MAX;
+    }
+
+    for (j += 3; i < j; i += 1) {
+        SAm[i] = (SAm[i] < 0 ? SAm[i] : 0) & SAINT_MAX;
+    }
+}
+
+static sa_sint_t libsais_renumber_distinct_lms_suffixes_32s_4k_omp(sa_sint_t * RESTRICT SA, sa_sint_t m,
+                                                                   sa_sint_t threads,
+                                                                   LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    sa_sint_t name = 0;
+    {
+        (void)(threads);
+        (void)(thread_state);
+
+        fast_sint_t omp_thread_num = 0;
+        fast_sint_t omp_num_threads = 1;
+
+        fast_sint_t omp_block_stride = (m / omp_num_threads) & (-16);
+        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
+        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : m - omp_block_start;
+
+        if (omp_num_threads == 1) {
+            name = libsais_renumber_distinct_lms_suffixes_32s_4k(SA, m, 1, omp_block_start, omp_block_size);
+        }
+    }
+
+    return name - 1;
+}
+
+static void libsais_mark_distinct_lms_suffixes_32s_omp(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m,
+                                                       sa_sint_t threads) {
+    {
+        (void)(threads);
+
+        fast_sint_t omp_block_start = 0;
+        fast_sint_t omp_block_size = (fast_sint_t)n >> 1;
+
+        libsais_mark_distinct_lms_suffixes_32s(SA, m, omp_block_start, omp_block_size);
+    }
+}
+
+static void libsais_clamp_lms_suffixes_length_32s_omp(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m,
+                                                      sa_sint_t threads) {
+    {
+        (void)(threads);
+
+        fast_sint_t omp_block_start = 0;
+        fast_sint_t omp_block_size = (fast_sint_t)n >> 1;
+
+        libsais_clamp_lms_suffixes_length_32s(SA, m, omp_block_start, omp_block_size);
+    }
+}
+
+static sa_sint_t libsais_renumber_and_mark_distinct_lms_suffixes_32s_4k_omp(
+    sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m, sa_sint_t threads,
+    LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    memset(&SA[m], 0, ((size_t)n >> 1) * sizeof(sa_sint_t));
+
+    sa_sint_t name = libsais_renumber_distinct_lms_suffixes_32s_4k_omp(SA, m, threads, thread_state);
+    if (name < m) {
+        libsais_mark_distinct_lms_suffixes_32s_omp(SA, n, m, threads);
+    }
+
+    return name;
+}
+
+static sa_sint_t libsais_renumber_and_mark_distinct_lms_suffixes_32s_1k_omp(sa_sint_t * RESTRICT T,
+                                                                            sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                                            sa_sint_t m, sa_sint_t threads) {
+    const fast_sint_t prefetch_distance = 32;
+
+    sa_sint_t * RESTRICT SAm = &SA[m];
+
+    {
+        libsais_gather_lms_suffixes_32s(T, SA, n);
+
+        memset(&SA[m], 0, ((size_t)n - (size_t)m - (size_t)m) * sizeof(sa_sint_t));
+
+        fast_sint_t i, j;
+        for (i = (fast_sint_t)n - (fast_sint_t)m, j = (fast_sint_t)n - 1 - prefetch_distance - 3; i < j; i += 4) {
+            prefetch(&SA[i + 2 * prefetch_distance]);
+
+            prefetchw(&SAm[((sa_uint_t)SA[i + prefetch_distance + 0]) >> 1]);
+            prefetchw(&SAm[((sa_uint_t)SA[i + prefetch_distance + 1]) >> 1]);
+            prefetchw(&SAm[((sa_uint_t)SA[i + prefetch_distance + 2]) >> 1]);
+            prefetchw(&SAm[((sa_uint_t)SA[i + prefetch_distance + 3]) >> 1]);
+
+            SAm[((sa_uint_t)SA[i + 0]) >> 1] = SA[i + 1] - SA[i + 0] + 1 + SAINT_MIN;
+            SAm[((sa_uint_t)SA[i + 1]) >> 1] = SA[i + 2] - SA[i + 1] + 1 + SAINT_MIN;
+            SAm[((sa_uint_t)SA[i + 2]) >> 1] = SA[i + 3] - SA[i + 2] + 1 + SAINT_MIN;
+            SAm[((sa_uint_t)SA[i + 3]) >> 1] = SA[i + 4] - SA[i + 3] + 1 + SAINT_MIN;
+        }
+
+        for (j += prefetch_distance + 3; i < j; i += 1) {
+            SAm[((sa_uint_t)SA[i]) >> 1] = SA[i + 1] - SA[i] + 1 + SAINT_MIN;
+        }
+
+        SAm[((sa_uint_t)SA[n - 1]) >> 1] = 1 + SAINT_MIN;
+    }
+
+    { libsais_clamp_lms_suffixes_length_32s_omp(SA, n, m, threads); }
+
+    sa_sint_t name = 1;
+
+    {
+        fast_sint_t i, j, p = SA[0], plen = SAm[p >> 1];
+        sa_sint_t pdiff = SAINT_MIN;
+        for (i = 1, j = m - prefetch_distance - 1; i < j; i += 2) {
+            prefetch(&SA[i + 2 * prefetch_distance]);
+
+            prefetchw(&SAm[((sa_uint_t)SA[i + prefetch_distance + 0]) >> 1]);
+            prefetch(&T[((sa_uint_t)SA[i + prefetch_distance + 0])]);
+            prefetchw(&SAm[((sa_uint_t)SA[i + prefetch_distance + 1]) >> 1]);
+            prefetch(&T[((sa_uint_t)SA[i + prefetch_distance + 1])]);
+
+            fast_sint_t q = SA[i + 0], qlen = SAm[q >> 1];
+            sa_sint_t qdiff = SAINT_MIN;
+            if (plen == qlen) {
+                fast_sint_t l = 0;
+                do {
+                    if (T[p + l] != T[q + l]) {
+                        break;
+                    }
+                } while (++l < qlen);
+                qdiff = (sa_sint_t)(l - qlen) & SAINT_MIN;
+            }
+            SAm[p >> 1] = name | (pdiff & qdiff);
+            name += (qdiff < 0);
+
+            p = SA[i + 1];
+            plen = SAm[p >> 1];
+            pdiff = SAINT_MIN;
+            if (qlen == plen) {
+                fast_sint_t l = 0;
+                do {
+                    if (T[q + l] != T[p + l]) {
+                        break;
+                    }
+                } while (++l < plen);
+                pdiff = (sa_sint_t)(l - plen) & SAINT_MIN;
+            }
+            SAm[q >> 1] = name | (qdiff & pdiff);
+            name += (pdiff < 0);
+        }
+
+        for (j += prefetch_distance + 1; i < j; i += 1) {
+            fast_sint_t q = SA[i], qlen = SAm[q >> 1];
+            sa_sint_t qdiff = SAINT_MIN;
+            if (plen == qlen) {
+                fast_sint_t l = 0;
+                do {
+                    if (T[p + l] != T[q + l]) {
+                        break;
+                    }
+                } while (++l < plen);
+                qdiff = (sa_sint_t)(l - plen) & SAINT_MIN;
+            }
+            SAm[p >> 1] = name | (pdiff & qdiff);
+            name += (qdiff < 0);
+
+            p = q;
+            plen = qlen;
+            pdiff = qdiff;
+        }
+
+        SAm[p >> 1] = name | pdiff;
+        name++;
+    }
+
+    if (name <= m) {
+        libsais_mark_distinct_lms_suffixes_32s_omp(SA, n, m, threads);
+    }
+
+    return name - 1;
+}
+
+static void libsais_reconstruct_lms_suffixes(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m,
+                                             fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    const sa_sint_t * RESTRICT SAnm = &SA[n - m];
+
+    fast_sint_t i, j;
+    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 3; i < j; i += 4) {
+        prefetchw(&SA[i + 2 * prefetch_distance]);
+
+        prefetch(&SAnm[SA[i + prefetch_distance + 0]]);
+        prefetch(&SAnm[SA[i + prefetch_distance + 1]]);
+        prefetch(&SAnm[SA[i + prefetch_distance + 2]]);
+        prefetch(&SAnm[SA[i + prefetch_distance + 3]]);
+
+        SA[i + 0] = SAnm[SA[i + 0]];
+        SA[i + 1] = SAnm[SA[i + 1]];
+        SA[i + 2] = SAnm[SA[i + 2]];
+        SA[i + 3] = SAnm[SA[i + 3]];
+    }
+
+    for (j += prefetch_distance + 3; i < j; i += 1) {
+        SA[i] = SAnm[SA[i]];
+    }
+}
+
+static void libsais_reconstruct_lms_suffixes_omp(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m, sa_sint_t threads) {
+    {
+        (void)(threads);
+
+        fast_sint_t omp_block_start = 0;
+        fast_sint_t omp_block_size = m;
+        libsais_reconstruct_lms_suffixes(SA, n, m, omp_block_start, omp_block_size);
+    }
+}
+
+static void libsais_place_lms_suffixes_interval_8u(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m,
+                                                   const sa_sint_t * RESTRICT buckets) {
+    const sa_sint_t * RESTRICT bucket_end = &buckets[7 * ALPHABET_SIZE];
+
+    fast_sint_t c, j = n;
+    for (c = ALPHABET_SIZE - 2; c >= 0; --c) {
+        fast_sint_t l = (fast_sint_t)buckets[BUCKETS_INDEX2(c, 1) + BUCKETS_INDEX2(1, 0)] -
+                        (fast_sint_t)buckets[BUCKETS_INDEX2(c, 1)];
+        if (l > 0) {
+            fast_sint_t i = bucket_end[c];
+            if (j - i > 0) {
+                memset(&SA[i], 0, (size_t)(j - i) * sizeof(sa_sint_t));
+            }
+
+            memmove(&SA[j = (i - l)], &SA[m -= (sa_sint_t)l], (size_t)l * sizeof(sa_sint_t));
+        }
+    }
+
+    memset(&SA[0], 0, (size_t)j * sizeof(sa_sint_t));
+}
+
+static void libsais_place_lms_suffixes_interval_32s_4k(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t k, sa_sint_t m,
+                                                       const sa_sint_t * RESTRICT buckets) {
+    const sa_sint_t * RESTRICT bucket_end = &buckets[3 * k];
+
+    fast_sint_t c, j = n;
+    for (c = (fast_sint_t)k - 2; c >= 0; --c) {
+        fast_sint_t l = (fast_sint_t)buckets[BUCKETS_INDEX2(c, 1) + BUCKETS_INDEX2(1, 0)] -
+                        (fast_sint_t)buckets[BUCKETS_INDEX2(c, 1)];
+        if (l > 0) {
+            fast_sint_t i = bucket_end[c];
+            if (j - i > 0) {
+                memset(&SA[i], 0, (size_t)(j - i) * sizeof(sa_sint_t));
+            }
+
+            memmove(&SA[j = (i - l)], &SA[m -= (sa_sint_t)l], (size_t)l * sizeof(sa_sint_t));
+        }
+    }
+
+    memset(&SA[0], 0, (size_t)j * sizeof(sa_sint_t));
+}
+
+static void libsais_place_lms_suffixes_interval_32s_2k(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t k, sa_sint_t m,
+                                                       const sa_sint_t * RESTRICT buckets) {
+    fast_sint_t j = n;
+
+    if (k > 1) {
+        fast_sint_t c;
+        for (c = BUCKETS_INDEX2((fast_sint_t)k - 2, 0); c >= BUCKETS_INDEX2(0, 0); c -= BUCKETS_INDEX2(1, 0)) {
+            fast_sint_t l =
+                (fast_sint_t)buckets[c + BUCKETS_INDEX2(1, 1)] - (fast_sint_t)buckets[c + BUCKETS_INDEX2(0, 1)];
+            if (l > 0) {
+                fast_sint_t i = buckets[c];
+                if (j - i > 0) {
+                    memset(&SA[i], 0, (size_t)(j - i) * sizeof(sa_sint_t));
+                }
+
+                memmove(&SA[j = (i - l)], &SA[m -= (sa_sint_t)l], (size_t)l * sizeof(sa_sint_t));
+            }
+        }
+    }
+
+    memset(&SA[0], 0, (size_t)j * sizeof(sa_sint_t));
+}
+
+static void libsais_place_lms_suffixes_interval_32s_1k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                       sa_sint_t k, sa_sint_t m, sa_sint_t * RESTRICT buckets) {
+    const fast_sint_t prefetch_distance = 32;
+
+    sa_sint_t c = k - 1;
+    fast_sint_t i, l = buckets[c];
+    for (i = (fast_sint_t)m - 1; i >= prefetch_distance + 3; i -= 4) {
+        prefetch(&SA[i - 2 * prefetch_distance]);
+
+        prefetch(&T[SA[i - prefetch_distance - 0]]);
+        prefetch(&T[SA[i - prefetch_distance - 1]]);
+        prefetch(&T[SA[i - prefetch_distance - 2]]);
+        prefetch(&T[SA[i - prefetch_distance - 3]]);
+
+        sa_sint_t p0 = SA[i - 0];
+        if (T[p0] != c) {
+            c = T[p0];
+            memset(&SA[buckets[c]], 0, (size_t)(l - buckets[c]) * sizeof(sa_sint_t));
+            l = buckets[c];
+        }
+        SA[--l] = p0;
+        sa_sint_t p1 = SA[i - 1];
+        if (T[p1] != c) {
+            c = T[p1];
+            memset(&SA[buckets[c]], 0, (size_t)(l - buckets[c]) * sizeof(sa_sint_t));
+            l = buckets[c];
+        }
+        SA[--l] = p1;
+        sa_sint_t p2 = SA[i - 2];
+        if (T[p2] != c) {
+            c = T[p2];
+            memset(&SA[buckets[c]], 0, (size_t)(l - buckets[c]) * sizeof(sa_sint_t));
+            l = buckets[c];
+        }
+        SA[--l] = p2;
+        sa_sint_t p3 = SA[i - 3];
+        if (T[p3] != c) {
+            c = T[p3];
+            memset(&SA[buckets[c]], 0, (size_t)(l - buckets[c]) * sizeof(sa_sint_t));
+            l = buckets[c];
+        }
+        SA[--l] = p3;
+    }
+
+    for (; i >= 0; i -= 1) {
+        sa_sint_t p = SA[i];
+        if (T[p] != c) {
+            c = T[p];
+            memset(&SA[buckets[c]], 0, (size_t)(l - buckets[c]) * sizeof(sa_sint_t));
+            l = buckets[c];
+        }
+        SA[--l] = p;
+    }
+
+    memset(&SA[0], 0, (size_t)l * sizeof(sa_sint_t));
+}
+
+static void libsais_place_lms_suffixes_histogram_32s_6k(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t k, sa_sint_t m,
+                                                        const sa_sint_t * RESTRICT buckets) {
+    const sa_sint_t * RESTRICT bucket_end = &buckets[5 * k];
+
+    fast_sint_t c, j = n;
+    for (c = (fast_sint_t)k - 2; c >= 0; --c) {
+        fast_sint_t l = (fast_sint_t)buckets[BUCKETS_INDEX4(c, 1)];
+        if (l > 0) {
+            fast_sint_t i = bucket_end[c];
+            if (j - i > 0) {
+                memset(&SA[i], 0, (size_t)(j - i) * sizeof(sa_sint_t));
+            }
+
+            memmove(&SA[j = (i - l)], &SA[m -= (sa_sint_t)l], (size_t)l * sizeof(sa_sint_t));
+        }
+    }
+
+    memset(&SA[0], 0, (size_t)j * sizeof(sa_sint_t));
+}
+
+static void libsais_place_lms_suffixes_histogram_32s_4k(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t k, sa_sint_t m,
+                                                        const sa_sint_t * RESTRICT buckets) {
+    const sa_sint_t * RESTRICT bucket_end = &buckets[3 * k];
+
+    fast_sint_t c, j = n;
+    for (c = (fast_sint_t)k - 2; c >= 0; --c) {
+        fast_sint_t l = (fast_sint_t)buckets[BUCKETS_INDEX2(c, 1)];
+        if (l > 0) {
+            fast_sint_t i = bucket_end[c];
+            if (j - i > 0) {
+                memset(&SA[i], 0, (size_t)(j - i) * sizeof(sa_sint_t));
+            }
+
+            memmove(&SA[j = (i - l)], &SA[m -= (sa_sint_t)l], (size_t)l * sizeof(sa_sint_t));
+        }
+    }
+
+    memset(&SA[0], 0, (size_t)j * sizeof(sa_sint_t));
+}
+
+static void libsais_place_lms_suffixes_histogram_32s_2k(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t k, sa_sint_t m,
+                                                        const sa_sint_t * RESTRICT buckets) {
+    fast_sint_t j = n;
+
+    if (k > 1) {
+        fast_sint_t c;
+        for (c = BUCKETS_INDEX2((fast_sint_t)k - 2, 0); c >= BUCKETS_INDEX2(0, 0); c -= BUCKETS_INDEX2(1, 0)) {
+            fast_sint_t l = (fast_sint_t)buckets[c + BUCKETS_INDEX2(0, 1)];
+            if (l > 0) {
+                fast_sint_t i = buckets[c];
+                if (j - i > 0) {
+                    memset(&SA[i], 0, (size_t)(j - i) * sizeof(sa_sint_t));
+                }
+
+                memmove(&SA[j = (i - l)], &SA[m -= (sa_sint_t)l], (size_t)l * sizeof(sa_sint_t));
+            }
+        }
+    }
+
+    memset(&SA[0], 0, (size_t)j * sizeof(sa_sint_t));
+}
+
+static void libsais_final_bwt_scan_left_to_right_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                    sa_sint_t * RESTRICT induction_bucket, fast_sint_t omp_block_start,
+                                                    fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j;
+    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 1; i < j; i += 2) {
+        prefetchw(&SA[i + 2 * prefetch_distance]);
+
+        sa_sint_t s0 = SA[i + prefetch_distance + 0];
+        const u8 * Ts0 = &T[s0] - 1;
+        prefetch(s0 > 0 ? Ts0 : NULL);
+        Ts0--;
+        prefetch(s0 > 0 ? Ts0 : NULL);
+        sa_sint_t s1 = SA[i + prefetch_distance + 1];
+        const u8 * Ts1 = &T[s1] - 1;
+        prefetch(s1 > 0 ? Ts1 : NULL);
+        Ts1--;
+        prefetch(s1 > 0 ? Ts1 : NULL);
+
+        sa_sint_t p0 = SA[i + 0];
+        SA[i + 0] = p0 & SAINT_MAX;
+        if (p0 > 0) {
+            p0--;
+            SA[i + 0] = T[p0] | SAINT_MIN;
+            SA[induction_bucket[T[p0]]++] = p0 | ((sa_sint_t)(T[p0 - (p0 > 0)] < T[p0]) << (SAINT_BIT - 1));
+        }
+        sa_sint_t p1 = SA[i + 1];
+        SA[i + 1] = p1 & SAINT_MAX;
+        if (p1 > 0) {
+            p1--;
+            SA[i + 1] = T[p1] | SAINT_MIN;
+            SA[induction_bucket[T[p1]]++] = p1 | ((sa_sint_t)(T[p1 - (p1 > 0)] < T[p1]) << (SAINT_BIT - 1));
+        }
+    }
+
+    for (j += prefetch_distance + 1; i < j; i += 1) {
+        sa_sint_t p = SA[i];
+        SA[i] = p & SAINT_MAX;
+        if (p > 0) {
+            p--;
+            SA[i] = T[p] | SAINT_MIN;
+            SA[induction_bucket[T[p]]++] = p | ((sa_sint_t)(T[p - (p > 0)] < T[p]) << (SAINT_BIT - 1));
+        }
+    }
+}
+
+static void libsais_final_bwt_aux_scan_left_to_right_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t rm,
+                                                        sa_sint_t * RESTRICT I, sa_sint_t * RESTRICT induction_bucket,
+                                                        fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j;
+    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 1; i < j; i += 2) {
+        prefetchw(&SA[i + 2 * prefetch_distance]);
+
+        sa_sint_t s0 = SA[i + prefetch_distance + 0];
+        const u8 * Ts0 = &T[s0] - 1;
+        prefetch(s0 > 0 ? Ts0 : NULL);
+        Ts0--;
+        prefetch(s0 > 0 ? Ts0 : NULL);
+        sa_sint_t s1 = SA[i + prefetch_distance + 1];
+        const u8 * Ts1 = &T[s1] - 1;
+        prefetch(s1 > 0 ? Ts1 : NULL);
+        Ts1--;
+        prefetch(s1 > 0 ? Ts1 : NULL);
+
+        sa_sint_t p0 = SA[i + 0];
+        SA[i + 0] = p0 & SAINT_MAX;
+        if (p0 > 0) {
+            p0--;
+            SA[i + 0] = T[p0] | SAINT_MIN;
+            SA[induction_bucket[T[p0]]++] = p0 | ((sa_sint_t)(T[p0 - (p0 > 0)] < T[p0]) << (SAINT_BIT - 1));
+            if ((p0 & rm) == 0) {
+                I[p0 / (rm + 1)] = induction_bucket[T[p0]];
+            }
+        }
+        sa_sint_t p1 = SA[i + 1];
+        SA[i + 1] = p1 & SAINT_MAX;
+        if (p1 > 0) {
+            p1--;
+            SA[i + 1] = T[p1] | SAINT_MIN;
+            SA[induction_bucket[T[p1]]++] = p1 | ((sa_sint_t)(T[p1 - (p1 > 0)] < T[p1]) << (SAINT_BIT - 1));
+            if ((p1 & rm) == 0) {
+                I[p1 / (rm + 1)] = induction_bucket[T[p1]];
+            }
+        }
+    }
+
+    for (j += prefetch_distance + 1; i < j; i += 1) {
+        sa_sint_t p = SA[i];
+        SA[i] = p & SAINT_MAX;
+        if (p > 0) {
+            p--;
+            SA[i] = T[p] | SAINT_MIN;
+            SA[induction_bucket[T[p]]++] = p | ((sa_sint_t)(T[p - (p > 0)] < T[p]) << (SAINT_BIT - 1));
+            if ((p & rm) == 0) {
+                I[p / (rm + 1)] = induction_bucket[T[p]];
+            }
+        }
+    }
+}
+
+static void libsais_final_sorting_scan_left_to_right_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                        sa_sint_t * RESTRICT induction_bucket,
+                                                        fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j;
+    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 1; i < j; i += 2) {
+        prefetchw(&SA[i + 2 * prefetch_distance]);
+
+        sa_sint_t s0 = SA[i + prefetch_distance + 0];
+        const u8 * Ts0 = &T[s0] - 1;
+        prefetch(s0 > 0 ? Ts0 : NULL);
+        Ts0--;
+        prefetch(s0 > 0 ? Ts0 : NULL);
+        sa_sint_t s1 = SA[i + prefetch_distance + 1];
+        const u8 * Ts1 = &T[s1] - 1;
+        prefetch(s1 > 0 ? Ts1 : NULL);
+        Ts1--;
+        prefetch(s1 > 0 ? Ts1 : NULL);
+
+        sa_sint_t p0 = SA[i + 0];
+        SA[i + 0] = p0 ^ SAINT_MIN;
+        if (p0 > 0) {
+            p0--;
+            SA[induction_bucket[T[p0]]++] = p0 | ((sa_sint_t)(T[p0 - (p0 > 0)] < T[p0]) << (SAINT_BIT - 1));
+        }
+        sa_sint_t p1 = SA[i + 1];
+        SA[i + 1] = p1 ^ SAINT_MIN;
+        if (p1 > 0) {
+            p1--;
+            SA[induction_bucket[T[p1]]++] = p1 | ((sa_sint_t)(T[p1 - (p1 > 0)] < T[p1]) << (SAINT_BIT - 1));
+        }
+    }
+
+    for (j += prefetch_distance + 1; i < j; i += 1) {
+        sa_sint_t p = SA[i];
+        SA[i] = p ^ SAINT_MIN;
+        if (p > 0) {
+            p--;
+            SA[induction_bucket[T[p]]++] = p | ((sa_sint_t)(T[p - (p > 0)] < T[p]) << (SAINT_BIT - 1));
+        }
+    }
+}
+
+static void libsais_final_sorting_scan_left_to_right_32s(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                         sa_sint_t * RESTRICT induction_bucket,
+                                                         fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j;
+    for (i = omp_block_start, j = omp_block_start + omp_block_size - 2 * prefetch_distance - 1; i < j; i += 2) {
+        prefetchw(&SA[i + 3 * prefetch_distance]);
+
+        sa_sint_t s0 = SA[i + 2 * prefetch_distance + 0];
+        const sa_sint_t * Ts0 = &T[s0] - 1;
+        prefetch(s0 > 0 ? Ts0 : NULL);
+        sa_sint_t s1 = SA[i + 2 * prefetch_distance + 1];
+        const sa_sint_t * Ts1 = &T[s1] - 1;
+        prefetch(s1 > 0 ? Ts1 : NULL);
+        sa_sint_t s2 = SA[i + 1 * prefetch_distance + 0];
+        if (s2 > 0) {
+            prefetchw(&induction_bucket[T[s2 - 1]]);
+            prefetch(&T[s2] - 2);
+        }
+        sa_sint_t s3 = SA[i + 1 * prefetch_distance + 1];
+        if (s3 > 0) {
+            prefetchw(&induction_bucket[T[s3 - 1]]);
+            prefetch(&T[s3] - 2);
+        }
+
+        sa_sint_t p0 = SA[i + 0];
+        SA[i + 0] = p0 ^ SAINT_MIN;
+        if (p0 > 0) {
+            p0--;
+            SA[induction_bucket[T[p0]]++] = p0 | ((sa_sint_t)(T[p0 - (p0 > 0)] < T[p0]) << (SAINT_BIT - 1));
+        }
+        sa_sint_t p1 = SA[i + 1];
+        SA[i + 1] = p1 ^ SAINT_MIN;
+        if (p1 > 0) {
+            p1--;
+            SA[induction_bucket[T[p1]]++] = p1 | ((sa_sint_t)(T[p1 - (p1 > 0)] < T[p1]) << (SAINT_BIT - 1));
+        }
+    }
+
+    for (j += 2 * prefetch_distance + 1; i < j; i += 1) {
+        sa_sint_t p = SA[i];
+        SA[i] = p ^ SAINT_MIN;
+        if (p > 0) {
+            p--;
+            SA[induction_bucket[T[p]]++] = p | ((sa_sint_t)(T[p - (p > 0)] < T[p]) << (SAINT_BIT - 1));
+        }
+    }
+}
+static void libsais_final_bwt_scan_left_to_right_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, fast_sint_t n,
+                                                        sa_sint_t * RESTRICT induction_bucket, sa_sint_t threads,
+                                                        LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    SA[induction_bucket[T[(sa_sint_t)n - 1]]++] =
+        ((sa_sint_t)n - 1) | ((sa_sint_t)(T[(sa_sint_t)n - 2] < T[(sa_sint_t)n - 1]) << (SAINT_BIT - 1));
+
+    if (threads == 1 || n < 65536) {
+        libsais_final_bwt_scan_left_to_right_8u(T, SA, induction_bucket, 0, n);
+    }
+    (void)(thread_state);
+}
+
+static void libsais_final_bwt_aux_scan_left_to_right_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                            fast_sint_t n, sa_sint_t rm, sa_sint_t * RESTRICT I,
+                                                            sa_sint_t * RESTRICT induction_bucket, sa_sint_t threads,
+                                                            LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    SA[induction_bucket[T[(sa_sint_t)n - 1]]++] =
+        ((sa_sint_t)n - 1) | ((sa_sint_t)(T[(sa_sint_t)n - 2] < T[(sa_sint_t)n - 1]) << (SAINT_BIT - 1));
+
+    if ((((sa_sint_t)n - 1) & rm) == 0) {
+        I[((sa_sint_t)n - 1) / (rm + 1)] = induction_bucket[T[(sa_sint_t)n - 1]];
+    }
+
+    if (threads == 1 || n < 65536) {
+        libsais_final_bwt_aux_scan_left_to_right_8u(T, SA, rm, I, induction_bucket, 0, n);
+    }
+    (void)(thread_state);
+}
+
+static void libsais_final_sorting_scan_left_to_right_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                            fast_sint_t n, sa_sint_t * RESTRICT induction_bucket,
+                                                            sa_sint_t threads,
+                                                            LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    SA[induction_bucket[T[(sa_sint_t)n - 1]]++] =
+        ((sa_sint_t)n - 1) | ((sa_sint_t)(T[(sa_sint_t)n - 2] < T[(sa_sint_t)n - 1]) << (SAINT_BIT - 1));
+
+    if (threads == 1 || n < 65536) {
+        libsais_final_sorting_scan_left_to_right_8u(T, SA, induction_bucket, 0, n);
+    }
+    (void)(thread_state);
+}
+
+static void libsais_final_sorting_scan_left_to_right_32s_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                             sa_sint_t n, sa_sint_t * RESTRICT induction_bucket,
+                                                             sa_sint_t threads,
+                                                             LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    SA[induction_bucket[T[n - 1]]++] = (n - 1) | ((sa_sint_t)(T[n - 2] < T[n - 1]) << (SAINT_BIT - 1));
+
+    if (threads == 1 || n < 65536) {
+        libsais_final_sorting_scan_left_to_right_32s(T, SA, induction_bucket, 0, n);
+    }
+    (void)(thread_state);
+}
+
+static sa_sint_t libsais_final_bwt_scan_right_to_left_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                         sa_sint_t * RESTRICT induction_bucket,
+                                                         fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j;
+    sa_sint_t index = -1;
+    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + prefetch_distance + 1; i >= j; i -= 2) {
+        prefetchw(&SA[i - 2 * prefetch_distance]);
+
+        sa_sint_t s0 = SA[i - prefetch_distance - 0];
+        const u8 * Ts0 = &T[s0] - 1;
+        prefetch(s0 > 0 ? Ts0 : NULL);
+        Ts0--;
+        prefetch(s0 > 0 ? Ts0 : NULL);
+        sa_sint_t s1 = SA[i - prefetch_distance - 1];
+        const u8 * Ts1 = &T[s1] - 1;
+        prefetch(s1 > 0 ? Ts1 : NULL);
+        Ts1--;
+        prefetch(s1 > 0 ? Ts1 : NULL);
+
+        sa_sint_t p0 = SA[i - 0];
+        index = (p0 == 0) ? (sa_sint_t)(i - 0) : index;
+        SA[i - 0] = p0 & SAINT_MAX;
+        if (p0 > 0) {
+            p0--;
+            u8 c0 = T[p0 - (p0 > 0)], c1 = T[p0];
+            SA[i - 0] = c1;
+            sa_sint_t t = c0 | SAINT_MIN;
+            SA[--induction_bucket[c1]] = (c0 <= c1) ? p0 : t;
+        }
+
+        sa_sint_t p1 = SA[i - 1];
+        index = (p1 == 0) ? (sa_sint_t)(i - 1) : index;
+        SA[i - 1] = p1 & SAINT_MAX;
+        if (p1 > 0) {
+            p1--;
+            u8 c0 = T[p1 - (p1 > 0)], c1 = T[p1];
+            SA[i - 1] = c1;
+            sa_sint_t t = c0 | SAINT_MIN;
+            SA[--induction_bucket[c1]] = (c0 <= c1) ? p1 : t;
+        }
+    }
+
+    for (j -= prefetch_distance + 1; i >= j; i -= 1) {
+        sa_sint_t p = SA[i];
+        index = (p == 0) ? (sa_sint_t)i : index;
+        SA[i] = p & SAINT_MAX;
+        if (p > 0) {
+            p--;
+            u8 c0 = T[p - (p > 0)], c1 = T[p];
+            SA[i] = c1;
+            sa_sint_t t = c0 | SAINT_MIN;
+            SA[--induction_bucket[c1]] = (c0 <= c1) ? p : t;
+        }
+    }
+
+    return index;
+}
+
+static void libsais_final_bwt_aux_scan_right_to_left_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t rm,
+                                                        sa_sint_t * RESTRICT I, sa_sint_t * RESTRICT induction_bucket,
+                                                        fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j;
+    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + prefetch_distance + 1; i >= j; i -= 2) {
+        prefetchw(&SA[i - 2 * prefetch_distance]);
+
+        sa_sint_t s0 = SA[i - prefetch_distance - 0];
+        const u8 * Ts0 = &T[s0] - 1;
+        prefetch(s0 > 0 ? Ts0 : NULL);
+        Ts0--;
+        prefetch(s0 > 0 ? Ts0 : NULL);
+        sa_sint_t s1 = SA[i - prefetch_distance - 1];
+        const u8 * Ts1 = &T[s1] - 1;
+        prefetch(s1 > 0 ? Ts1 : NULL);
+        Ts1--;
+        prefetch(s1 > 0 ? Ts1 : NULL);
+
+        sa_sint_t p0 = SA[i - 0];
+        SA[i - 0] = p0 & SAINT_MAX;
+        if (p0 > 0) {
+            p0--;
+            u8 c0 = T[p0 - (p0 > 0)], c1 = T[p0];
+            SA[i - 0] = c1;
+            sa_sint_t t = c0 | SAINT_MIN;
+            SA[--induction_bucket[c1]] = (c0 <= c1) ? p0 : t;
+            if ((p0 & rm) == 0) {
+                I[p0 / (rm + 1)] = induction_bucket[T[p0]] + 1;
+            }
+        }
+
+        sa_sint_t p1 = SA[i - 1];
+        SA[i - 1] = p1 & SAINT_MAX;
+        if (p1 > 0) {
+            p1--;
+            u8 c0 = T[p1 - (p1 > 0)], c1 = T[p1];
+            SA[i - 1] = c1;
+            sa_sint_t t = c0 | SAINT_MIN;
+            SA[--induction_bucket[c1]] = (c0 <= c1) ? p1 : t;
+            if ((p1 & rm) == 0) {
+                I[p1 / (rm + 1)] = induction_bucket[T[p1]] + 1;
+            }
+        }
+    }
+
+    for (j -= prefetch_distance + 1; i >= j; i -= 1) {
+        sa_sint_t p = SA[i];
+        SA[i] = p & SAINT_MAX;
+        if (p > 0) {
+            p--;
+            u8 c0 = T[p - (p > 0)], c1 = T[p];
+            SA[i] = c1;
+            sa_sint_t t = c0 | SAINT_MIN;
+            SA[--induction_bucket[c1]] = (c0 <= c1) ? p : t;
+            if ((p & rm) == 0) {
+                I[p / (rm + 1)] = induction_bucket[T[p]] + 1;
+            }
+        }
+    }
+}
+
+static void libsais_final_sorting_scan_right_to_left_8u(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                        sa_sint_t * RESTRICT induction_bucket,
+                                                        fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j;
+    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + prefetch_distance + 1; i >= j; i -= 2) {
+        prefetchw(&SA[i - 2 * prefetch_distance]);
+
+        sa_sint_t s0 = SA[i - prefetch_distance - 0];
+        const u8 * Ts0 = &T[s0] - 1;
+        prefetch(s0 > 0 ? Ts0 : NULL);
+        Ts0--;
+        prefetch(s0 > 0 ? Ts0 : NULL);
+        sa_sint_t s1 = SA[i - prefetch_distance - 1];
+        const u8 * Ts1 = &T[s1] - 1;
+        prefetch(s1 > 0 ? Ts1 : NULL);
+        Ts1--;
+        prefetch(s1 > 0 ? Ts1 : NULL);
+
+        sa_sint_t p0 = SA[i - 0];
+        SA[i - 0] = p0 & SAINT_MAX;
+        if (p0 > 0) {
+            p0--;
+            SA[--induction_bucket[T[p0]]] = p0 | ((sa_sint_t)(T[p0 - (p0 > 0)] > T[p0]) << (SAINT_BIT - 1));
+        }
+        sa_sint_t p1 = SA[i - 1];
+        SA[i - 1] = p1 & SAINT_MAX;
+        if (p1 > 0) {
+            p1--;
+            SA[--induction_bucket[T[p1]]] = p1 | ((sa_sint_t)(T[p1 - (p1 > 0)] > T[p1]) << (SAINT_BIT - 1));
+        }
+    }
+
+    for (j -= prefetch_distance + 1; i >= j; i -= 1) {
+        sa_sint_t p = SA[i];
+        SA[i] = p & SAINT_MAX;
+        if (p > 0) {
+            p--;
+            SA[--induction_bucket[T[p]]] = p | ((sa_sint_t)(T[p - (p > 0)] > T[p]) << (SAINT_BIT - 1));
+        }
+    }
+}
+
+static void libsais_final_sorting_scan_right_to_left_32s(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                         sa_sint_t * RESTRICT induction_bucket,
+                                                         fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j;
+    for (i = omp_block_start + omp_block_size - 1, j = omp_block_start + 2 * prefetch_distance + 1; i >= j; i -= 2) {
+        prefetchw(&SA[i - 3 * prefetch_distance]);
+
+        sa_sint_t s0 = SA[i - 2 * prefetch_distance - 0];
+        const sa_sint_t * Ts0 = &T[s0] - 1;
+        prefetch(s0 > 0 ? Ts0 : NULL);
+        sa_sint_t s1 = SA[i - 2 * prefetch_distance - 1];
+        const sa_sint_t * Ts1 = &T[s1] - 1;
+        prefetch(s1 > 0 ? Ts1 : NULL);
+        sa_sint_t s2 = SA[i - 1 * prefetch_distance - 0];
+        if (s2 > 0) {
+            prefetchw(&induction_bucket[T[s2 - 1]]);
+            prefetch(&T[s2] - 2);
+        }
+        sa_sint_t s3 = SA[i - 1 * prefetch_distance - 1];
+        if (s3 > 0) {
+            prefetchw(&induction_bucket[T[s3 - 1]]);
+            prefetch(&T[s3] - 2);
+        }
+
+        sa_sint_t p0 = SA[i - 0];
+        SA[i - 0] = p0 & SAINT_MAX;
+        if (p0 > 0) {
+            p0--;
+            SA[--induction_bucket[T[p0]]] = p0 | ((sa_sint_t)(T[p0 - (p0 > 0)] > T[p0]) << (SAINT_BIT - 1));
+        }
+        sa_sint_t p1 = SA[i - 1];
+        SA[i - 1] = p1 & SAINT_MAX;
+        if (p1 > 0) {
+            p1--;
+            SA[--induction_bucket[T[p1]]] = p1 | ((sa_sint_t)(T[p1 - (p1 > 0)] > T[p1]) << (SAINT_BIT - 1));
+        }
+    }
+
+    for (j -= 2 * prefetch_distance + 1; i >= j; i -= 1) {
+        sa_sint_t p = SA[i];
+        SA[i] = p & SAINT_MAX;
+        if (p > 0) {
+            p--;
+            SA[--induction_bucket[T[p]]] = p | ((sa_sint_t)(T[p - (p > 0)] > T[p]) << (SAINT_BIT - 1));
+        }
+    }
+}
+static sa_sint_t libsais_final_bwt_scan_right_to_left_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                             sa_sint_t n, sa_sint_t * RESTRICT induction_bucket,
+                                                             sa_sint_t threads,
+                                                             LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    sa_sint_t index = -1;
+
+    if (threads == 1 || n < 65536) {
+        index = libsais_final_bwt_scan_right_to_left_8u(T, SA, induction_bucket, 0, n);
+    }
+    (void)(thread_state);
+    return index;
+}
+
+static void libsais_final_bwt_aux_scan_right_to_left_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                            sa_sint_t rm, sa_sint_t * RESTRICT I,
+                                                            sa_sint_t * RESTRICT induction_bucket, sa_sint_t threads,
+                                                            LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    if (threads == 1 || n < 65536) {
+        libsais_final_bwt_aux_scan_right_to_left_8u(T, SA, rm, I, induction_bucket, 0, n);
+    }
+    (void)(thread_state);
+}
+
+static void libsais_final_sorting_scan_right_to_left_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                            sa_sint_t * RESTRICT induction_bucket, sa_sint_t threads,
+                                                            LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    if (threads == 1 || n < 65536) {
+        libsais_final_sorting_scan_right_to_left_8u(T, SA, induction_bucket, 0, n);
+    }
+    (void)(thread_state);
+}
+
+static void libsais_final_sorting_scan_right_to_left_32s_omp(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                             sa_sint_t n, sa_sint_t * RESTRICT induction_bucket,
+                                                             sa_sint_t threads,
+                                                             LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    if (threads == 1 || n < 65536) {
+        libsais_final_sorting_scan_right_to_left_32s(T, SA, induction_bucket, 0, n);
+    }
+    (void)(thread_state);
+}
+
+static void libsais_clear_lms_suffixes_omp(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t k,
+                                           sa_sint_t * RESTRICT bucket_start, sa_sint_t * RESTRICT bucket_end,
+                                           sa_sint_t threads) {
+    fast_sint_t c;
+    (void)(threads);
+    (void)(n);
+
+    for (c = 0; c < k; ++c) {
+        if (bucket_end[c] > bucket_start[c]) {
+            memset(&SA[bucket_start[c]], 0, ((size_t)bucket_end[c] - (size_t)bucket_start[c]) * sizeof(sa_sint_t));
+        }
+    }
+}
+
+static sa_sint_t libsais_induce_final_order_8u_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                   sa_sint_t bwt, sa_sint_t r, sa_sint_t * RESTRICT I,
+                                                   sa_sint_t * RESTRICT buckets, sa_sint_t threads,
+                                                   LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    if (!bwt) {
+        libsais_final_sorting_scan_left_to_right_8u_omp(T, SA, n, &buckets[6 * ALPHABET_SIZE], threads, thread_state);
+        if (threads > 1 && n >= 65536) {
+            libsais_clear_lms_suffixes_omp(SA, n, ALPHABET_SIZE, &buckets[6 * ALPHABET_SIZE],
+                                           &buckets[7 * ALPHABET_SIZE], threads);
+        }
+        libsais_final_sorting_scan_right_to_left_8u_omp(T, SA, n, &buckets[7 * ALPHABET_SIZE], threads, thread_state);
+        return 0;
+    } else if (I != NULL) {
+        libsais_final_bwt_aux_scan_left_to_right_8u_omp(T, SA, n, r - 1, I, &buckets[6 * ALPHABET_SIZE], threads,
+                                                        thread_state);
+        if (threads > 1 && n >= 65536) {
+            libsais_clear_lms_suffixes_omp(SA, n, ALPHABET_SIZE, &buckets[6 * ALPHABET_SIZE],
+                                           &buckets[7 * ALPHABET_SIZE], threads);
+        }
+        libsais_final_bwt_aux_scan_right_to_left_8u_omp(T, SA, n, r - 1, I, &buckets[7 * ALPHABET_SIZE], threads,
+                                                        thread_state);
+        return 0;
+    } else {
+        libsais_final_bwt_scan_left_to_right_8u_omp(T, SA, n, &buckets[6 * ALPHABET_SIZE], threads, thread_state);
+        if (threads > 1 && n >= 65536) {
+            libsais_clear_lms_suffixes_omp(SA, n, ALPHABET_SIZE, &buckets[6 * ALPHABET_SIZE],
+                                           &buckets[7 * ALPHABET_SIZE], threads);
+        }
+        return libsais_final_bwt_scan_right_to_left_8u_omp(T, SA, n, &buckets[7 * ALPHABET_SIZE], threads,
+                                                           thread_state);
+    }
+}
+
+static void libsais_induce_final_order_32s_6k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                              sa_sint_t k, sa_sint_t * RESTRICT buckets, sa_sint_t threads,
+                                              LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    libsais_final_sorting_scan_left_to_right_32s_omp(T, SA, n, &buckets[4 * k], threads, thread_state);
+    libsais_final_sorting_scan_right_to_left_32s_omp(T, SA, n, &buckets[5 * k], threads, thread_state);
+}
+
+static void libsais_induce_final_order_32s_4k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                              sa_sint_t k, sa_sint_t * RESTRICT buckets, sa_sint_t threads,
+                                              LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    libsais_final_sorting_scan_left_to_right_32s_omp(T, SA, n, &buckets[2 * k], threads, thread_state);
+    libsais_final_sorting_scan_right_to_left_32s_omp(T, SA, n, &buckets[3 * k], threads, thread_state);
+}
+
+static void libsais_induce_final_order_32s_2k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                              sa_sint_t k, sa_sint_t * RESTRICT buckets, sa_sint_t threads,
+                                              LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    libsais_final_sorting_scan_left_to_right_32s_omp(T, SA, n, &buckets[1 * k], threads, thread_state);
+    libsais_final_sorting_scan_right_to_left_32s_omp(T, SA, n, &buckets[0 * k], threads, thread_state);
+}
+
+static void libsais_induce_final_order_32s_1k(const sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                              sa_sint_t k, sa_sint_t * RESTRICT buckets, sa_sint_t threads,
+                                              LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    libsais_count_suffixes_32s(T, n, k, buckets);
+    libsais_initialize_buckets_start_32s_1k(k, buckets);
+    libsais_final_sorting_scan_left_to_right_32s_omp(T, SA, n, buckets, threads, thread_state);
+
+    libsais_count_suffixes_32s(T, n, k, buckets);
+    libsais_initialize_buckets_end_32s_1k(k, buckets);
+    libsais_final_sorting_scan_right_to_left_32s_omp(T, SA, n, buckets, threads, thread_state);
+}
+
+static sa_sint_t libsais_renumber_unique_and_nonunique_lms_suffixes_32s(sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                                        sa_sint_t m, sa_sint_t f,
+                                                                        fast_sint_t omp_block_start,
+                                                                        fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    sa_sint_t * RESTRICT SAm = &SA[m];
+
+    sa_sint_t i, j;
+    for (i = (sa_sint_t)omp_block_start,
+        j = (sa_sint_t)omp_block_start + (sa_sint_t)omp_block_size - 2 * (sa_sint_t)prefetch_distance - 3;
+         i < j; i += 4) {
+        prefetch(&SA[i + 3 * prefetch_distance]);
+
+        prefetchw(&SAm[((sa_uint_t)SA[i + 2 * prefetch_distance + 0]) >> 1]);
+        prefetchw(&SAm[((sa_uint_t)SA[i + 2 * prefetch_distance + 1]) >> 1]);
+        prefetchw(&SAm[((sa_uint_t)SA[i + 2 * prefetch_distance + 2]) >> 1]);
+        prefetchw(&SAm[((sa_uint_t)SA[i + 2 * prefetch_distance + 3]) >> 1]);
+
+        sa_uint_t q0 = (sa_uint_t)SA[i + prefetch_distance + 0];
+        const sa_sint_t * Tq0 = &T[q0];
+        prefetchw(SAm[q0 >> 1] < 0 ? Tq0 : NULL);
+        sa_uint_t q1 = (sa_uint_t)SA[i + prefetch_distance + 1];
+        const sa_sint_t * Tq1 = &T[q1];
+        prefetchw(SAm[q1 >> 1] < 0 ? Tq1 : NULL);
+        sa_uint_t q2 = (sa_uint_t)SA[i + prefetch_distance + 2];
+        const sa_sint_t * Tq2 = &T[q2];
+        prefetchw(SAm[q2 >> 1] < 0 ? Tq2 : NULL);
+        sa_uint_t q3 = (sa_uint_t)SA[i + prefetch_distance + 3];
+        const sa_sint_t * Tq3 = &T[q3];
+        prefetchw(SAm[q3 >> 1] < 0 ? Tq3 : NULL);
+
+        sa_uint_t p0 = (sa_uint_t)SA[i + 0];
+        sa_sint_t s0 = SAm[p0 >> 1];
+        if (s0 < 0) {
+            T[p0] |= SAINT_MIN;
+            f++;
+            s0 = i + 0 + SAINT_MIN + f;
+        }
+        SAm[p0 >> 1] = s0 - f;
+        sa_uint_t p1 = (sa_uint_t)SA[i + 1];
+        sa_sint_t s1 = SAm[p1 >> 1];
+        if (s1 < 0) {
+            T[p1] |= SAINT_MIN;
+            f++;
+            s1 = i + 1 + SAINT_MIN + f;
+        }
+        SAm[p1 >> 1] = s1 - f;
+        sa_uint_t p2 = (sa_uint_t)SA[i + 2];
+        sa_sint_t s2 = SAm[p2 >> 1];
+        if (s2 < 0) {
+            T[p2] |= SAINT_MIN;
+            f++;
+            s2 = i + 2 + SAINT_MIN + f;
+        }
+        SAm[p2 >> 1] = s2 - f;
+        sa_uint_t p3 = (sa_uint_t)SA[i + 3];
+        sa_sint_t s3 = SAm[p3 >> 1];
+        if (s3 < 0) {
+            T[p3] |= SAINT_MIN;
+            f++;
+            s3 = i + 3 + SAINT_MIN + f;
+        }
+        SAm[p3 >> 1] = s3 - f;
+    }
+
+    for (j += 2 * (sa_sint_t)prefetch_distance + 3; i < j; i += 1) {
+        sa_uint_t p = (sa_uint_t)SA[i];
+        sa_sint_t s = SAm[p >> 1];
+        if (s < 0) {
+            T[p] |= SAINT_MIN;
+            f++;
+            s = i + SAINT_MIN + f;
+        }
+        SAm[p >> 1] = s - f;
+    }
+
+    return f;
+}
+
+static void libsais_compact_unique_and_nonunique_lms_suffixes_32s(sa_sint_t * RESTRICT SA, sa_sint_t m,
+                                                                  fast_sint_t * pl, fast_sint_t * pr,
+                                                                  fast_sint_t omp_block_start,
+                                                                  fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    sa_sint_t * RESTRICT SAl = &SA[0];
+    sa_sint_t * RESTRICT SAr = &SA[0];
+
+    fast_sint_t i, j, l = *pl - 1, r = *pr - 1;
+    for (i = (fast_sint_t)m + omp_block_start + omp_block_size - 1, j = (fast_sint_t)m + omp_block_start + 3; i >= j;
+         i -= 4) {
+        prefetch(&SA[i - prefetch_distance]);
+
+        sa_sint_t p0 = SA[i - 0];
+        SAl[l] = p0 & SAINT_MAX;
+        l -= p0 < 0;
+        SAr[r] = p0 - 1;
+        r -= p0 > 0;
+        sa_sint_t p1 = SA[i - 1];
+        SAl[l] = p1 & SAINT_MAX;
+        l -= p1 < 0;
+        SAr[r] = p1 - 1;
+        r -= p1 > 0;
+        sa_sint_t p2 = SA[i - 2];
+        SAl[l] = p2 & SAINT_MAX;
+        l -= p2 < 0;
+        SAr[r] = p2 - 1;
+        r -= p2 > 0;
+        sa_sint_t p3 = SA[i - 3];
+        SAl[l] = p3 & SAINT_MAX;
+        l -= p3 < 0;
+        SAr[r] = p3 - 1;
+        r -= p3 > 0;
+    }
+
+    for (j -= 3; i >= j; i -= 1) {
+        sa_sint_t p = SA[i];
+        SAl[l] = p & SAINT_MAX;
+        l -= p < 0;
+        SAr[r] = p - 1;
+        r -= p > 0;
+    }
+
+    *pl = l + 1;
+    *pr = r + 1;
+}
+static sa_sint_t libsais_renumber_unique_and_nonunique_lms_suffixes_32s_omp(
+    sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t m, sa_sint_t threads,
+    LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    sa_sint_t f = 0;
+    {
+        (void)(threads);
+        (void)(thread_state);
+
+        fast_sint_t omp_thread_num = 0;
+        fast_sint_t omp_num_threads = 1;
+
+        fast_sint_t omp_block_stride = (m / omp_num_threads) & (-16);
+        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
+        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : m - omp_block_start;
+
+        if (omp_num_threads == 1) {
+            f = libsais_renumber_unique_and_nonunique_lms_suffixes_32s(T, SA, m, 0, omp_block_start, omp_block_size);
+        }
+    }
+
+    return f;
+}
+
+static void libsais_compact_unique_and_nonunique_lms_suffixes_32s_omp(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m,
+                                                                      sa_sint_t fs, sa_sint_t f, sa_sint_t threads,
+                                                                      LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    {
+        (void)(threads);
+        (void)(thread_state);
+
+        fast_sint_t omp_thread_num = 0;
+        fast_sint_t omp_num_threads = 1;
+
+        fast_sint_t omp_block_stride = (((fast_sint_t)n >> 1) / omp_num_threads) & (-16);
+        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
+        fast_sint_t omp_block_size =
+            omp_thread_num < omp_num_threads - 1 ? omp_block_stride : ((fast_sint_t)n >> 1) - omp_block_start;
+
+        if (omp_num_threads == 1) {
+            fast_sint_t l = m, r = (fast_sint_t)n + (fast_sint_t)fs;
+            libsais_compact_unique_and_nonunique_lms_suffixes_32s(SA, m, &l, &r, omp_block_start, omp_block_size);
+        }
+    }
+
+    memcpy(&SA[(fast_sint_t)n + (fast_sint_t)fs - (fast_sint_t)m], &SA[(fast_sint_t)m - (fast_sint_t)f],
+           (size_t)f * sizeof(sa_sint_t));
+}
+
+static sa_sint_t libsais_compact_lms_suffixes_32s_omp(sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                      sa_sint_t m, sa_sint_t fs, sa_sint_t threads,
+                                                      LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    sa_sint_t f = libsais_renumber_unique_and_nonunique_lms_suffixes_32s_omp(T, SA, m, threads, thread_state);
+    libsais_compact_unique_and_nonunique_lms_suffixes_32s_omp(SA, n, m, fs, f, threads, thread_state);
+
+    return f;
+}
+
+static void libsais_merge_unique_lms_suffixes_32s(sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                  sa_sint_t m, fast_sint_t l, fast_sint_t omp_block_start,
+                                                  fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    const sa_sint_t * RESTRICT SAnm = &SA[(fast_sint_t)n - (fast_sint_t)m - 1 + l];
+
+    sa_sint_t i, j;
+    fast_sint_t tmp = *SAnm++;
+    for (i = (sa_sint_t)omp_block_start, j = (sa_sint_t)omp_block_start + (sa_sint_t)omp_block_size - 6; i < j;
+         i += 4) {
+        prefetch(&T[i + prefetch_distance]);
+
+        sa_sint_t c0 = T[i + 0];
+        if (c0 < 0) {
+            T[i + 0] = c0 & SAINT_MAX;
+            SA[tmp] = i + 0;
+            i++;
+            tmp = *SAnm++;
+        }
+        sa_sint_t c1 = T[i + 1];
+        if (c1 < 0) {
+            T[i + 1] = c1 & SAINT_MAX;
+            SA[tmp] = i + 1;
+            i++;
+            tmp = *SAnm++;
+        }
+        sa_sint_t c2 = T[i + 2];
+        if (c2 < 0) {
+            T[i + 2] = c2 & SAINT_MAX;
+            SA[tmp] = i + 2;
+            i++;
+            tmp = *SAnm++;
+        }
+        sa_sint_t c3 = T[i + 3];
+        if (c3 < 0) {
+            T[i + 3] = c3 & SAINT_MAX;
+            SA[tmp] = i + 3;
+            i++;
+            tmp = *SAnm++;
+        }
+    }
+
+    for (j += 6; i < j; i += 1) {
+        sa_sint_t c = T[i];
+        if (c < 0) {
+            T[i] = c & SAINT_MAX;
+            SA[tmp] = i;
+            i++;
+            tmp = *SAnm++;
+        }
+    }
+}
+
+static void libsais_merge_nonunique_lms_suffixes_32s(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m, fast_sint_t l,
+                                                     fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    const sa_sint_t * RESTRICT SAnm = &SA[(fast_sint_t)n - (fast_sint_t)m - 1 + l];
+
+    fast_sint_t i, j;
+    sa_sint_t tmp = *SAnm++;
+    for (i = omp_block_start, j = omp_block_start + omp_block_size - 3; i < j; i += 4) {
+        prefetch(&SA[i + prefetch_distance]);
+
+        if (SA[i + 0] == 0) {
+            SA[i + 0] = tmp;
+            tmp = *SAnm++;
+        }
+        if (SA[i + 1] == 0) {
+            SA[i + 1] = tmp;
+            tmp = *SAnm++;
+        }
+        if (SA[i + 2] == 0) {
+            SA[i + 2] = tmp;
+            tmp = *SAnm++;
+        }
+        if (SA[i + 3] == 0) {
+            SA[i + 3] = tmp;
+            tmp = *SAnm++;
+        }
+    }
+
+    for (j += 3; i < j; i += 1) {
+        if (SA[i] == 0) {
+            SA[i] = tmp;
+            tmp = *SAnm++;
+        }
+    }
+}
+
+static void libsais_merge_unique_lms_suffixes_32s_omp(sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                      sa_sint_t m, sa_sint_t threads,
+                                                      LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    {
+        (void)(threads);
+        (void)(thread_state);
+
+        fast_sint_t omp_thread_num = 0;
+        fast_sint_t omp_num_threads = 1;
+
+        fast_sint_t omp_block_stride = (n / omp_num_threads) & (-16);
+        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
+        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : n - omp_block_start;
+
+        if (omp_num_threads == 1) {
+            libsais_merge_unique_lms_suffixes_32s(T, SA, n, m, 0, omp_block_start, omp_block_size);
+        }
+    }
+}
+
+static void libsais_merge_nonunique_lms_suffixes_32s_omp(sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t m, sa_sint_t f,
+                                                         sa_sint_t threads,
+                                                         LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    {
+        (void)(threads);
+        (void)(thread_state);
+
+        fast_sint_t omp_thread_num = 0;
+        fast_sint_t omp_num_threads = 1;
+
+        fast_sint_t omp_block_stride = (m / omp_num_threads) & (-16);
+        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
+        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : m - omp_block_start;
+
+        if (omp_num_threads == 1) {
+            libsais_merge_nonunique_lms_suffixes_32s(SA, n, m, f, omp_block_start, omp_block_size);
+        }
+    }
+}
+
+static void libsais_merge_compacted_lms_suffixes_32s_omp(sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n,
+                                                         sa_sint_t m, sa_sint_t f, sa_sint_t threads,
+                                                         LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    libsais_merge_unique_lms_suffixes_32s_omp(T, SA, n, m, threads, thread_state);
+    libsais_merge_nonunique_lms_suffixes_32s_omp(SA, n, m, f, threads, thread_state);
+}
+
+static void libsais_reconstruct_compacted_lms_suffixes_32s_2k_omp(sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                                  sa_sint_t n, sa_sint_t k, sa_sint_t m, sa_sint_t fs,
+                                                                  sa_sint_t f, sa_sint_t * RESTRICT buckets,
+                                                                  sa_sint_t threads,
+                                                                  LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    if (f > 0) {
+        memmove(&SA[n - m - 1], &SA[n + fs - m], (size_t)f * sizeof(sa_sint_t));
+
+        libsais_count_and_gather_compacted_lms_suffixes_32s_2k_omp(T, SA, n, k, buckets, threads, thread_state);
+        libsais_reconstruct_lms_suffixes_omp(SA, n, m - f, threads);
+
+        memcpy(&SA[n - m - 1 + f], &SA[0], ((size_t)m - (size_t)f) * sizeof(sa_sint_t));
+        memset(&SA[0], 0, (size_t)m * sizeof(sa_sint_t));
+
+        libsais_merge_compacted_lms_suffixes_32s_omp(T, SA, n, m, f, threads, thread_state);
+    } else {
+        libsais_count_and_gather_lms_suffixes_32s_2k(T, SA, n, k, buckets, 0, n);
+        libsais_reconstruct_lms_suffixes_omp(SA, n, m, threads);
+    }
+}
+
+static void libsais_reconstruct_compacted_lms_suffixes_32s_1k_omp(sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA,
+                                                                  sa_sint_t n, sa_sint_t m, sa_sint_t fs, sa_sint_t f,
+                                                                  sa_sint_t threads,
+                                                                  LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    if (f > 0) {
+        memmove(&SA[n - m - 1], &SA[n + fs - m], (size_t)f * sizeof(sa_sint_t));
+
+        libsais_gather_compacted_lms_suffixes_32s(T, SA, n);
+        libsais_reconstruct_lms_suffixes_omp(SA, n, m - f, threads);
+
+        memcpy(&SA[n - m - 1 + f], &SA[0], ((size_t)m - (size_t)f) * sizeof(sa_sint_t));
+        memset(&SA[0], 0, (size_t)m * sizeof(sa_sint_t));
+
+        libsais_merge_compacted_lms_suffixes_32s_omp(T, SA, n, m, f, threads, thread_state);
+    } else {
+        libsais_gather_lms_suffixes_32s(T, SA, n);
+        libsais_reconstruct_lms_suffixes_omp(SA, n, m, threads);
+    }
+}
+
+static sa_sint_t libsais_main_32s(sa_sint_t * RESTRICT T, sa_sint_t * RESTRICT SA, sa_sint_t n, sa_sint_t k,
+                                  sa_sint_t fs, sa_sint_t threads, LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    fs = fs < (SAINT_MAX - n) ? fs : (SAINT_MAX - n);
+
+    if (k > 0 && fs / k >= 6) {
+        sa_sint_t alignment = (fs - 1024) / k >= 6 ? 1024 : 16;
+        sa_sint_t * RESTRICT buckets =
+            (fs - alignment) / k >= 6
+                ? (sa_sint_t *)libsais_align_up(&SA[n + fs - 6 * k - alignment], (size_t)alignment * sizeof(sa_sint_t))
+                : &SA[n + fs - 6 * k];
+
+        sa_sint_t m = libsais_count_and_gather_lms_suffixes_32s_4k_omp(T, SA, n, k, buckets, threads, thread_state);
+        if (m > 1) {
+            memset(SA, 0, ((size_t)n - (size_t)m) * sizeof(sa_sint_t));
+
+            sa_sint_t first_lms_suffix = SA[n - m];
+            sa_sint_t left_suffixes_count =
+                libsais_initialize_buckets_for_lms_suffixes_radix_sort_32s_6k(T, k, buckets, first_lms_suffix);
+
+            libsais_radix_sort_lms_suffixes_32s_6k_omp(T, SA, n, m, &buckets[4 * k], threads, thread_state);
+            libsais_radix_sort_set_markers_32s_6k_omp(SA, k, &buckets[4 * k], threads);
+
+            if (threads > 1 && n >= 65536) {
+                memset(&SA[(fast_sint_t)n - (fast_sint_t)m], 0, (size_t)m * sizeof(sa_sint_t));
+            }
+
+            libsais_initialize_buckets_for_partial_sorting_32s_6k(T, k, buckets, first_lms_suffix, left_suffixes_count);
+            libsais_induce_partial_order_32s_6k_omp(T, SA, n, k, buckets, first_lms_suffix, left_suffixes_count,
+                                                    threads, thread_state);
+
+            sa_sint_t names =
+                libsais_renumber_and_mark_distinct_lms_suffixes_32s_4k_omp(SA, n, m, threads, thread_state);
+            if (names < m) {
+                sa_sint_t f = libsais_compact_lms_suffixes_32s_omp(T, SA, n, m, fs, threads, thread_state);
+
+                if (libsais_main_32s(SA + n + fs - m + f, SA, m - f, names - f, fs + n - 2 * m + f, threads,
+                                     thread_state) != 0) {
+                    return -2;
+                }
+
+                libsais_reconstruct_compacted_lms_suffixes_32s_2k_omp(T, SA, n, k, m, fs, f, buckets, threads,
+                                                                      thread_state);
+            } else {
+                libsais_count_lms_suffixes_32s_2k(T, n, k, buckets);
+            }
+
+            libsais_initialize_buckets_start_and_end_32s_4k(k, buckets);
+            libsais_place_lms_suffixes_histogram_32s_4k(SA, n, k, m, buckets);
+            libsais_induce_final_order_32s_4k(T, SA, n, k, buckets, threads, thread_state);
+        } else {
+            SA[0] = SA[n - 1];
+
+            libsais_initialize_buckets_start_and_end_32s_6k(k, buckets);
+            libsais_place_lms_suffixes_histogram_32s_6k(SA, n, k, m, buckets);
+            libsais_induce_final_order_32s_6k(T, SA, n, k, buckets, threads, thread_state);
+        }
+
+        return 0;
+    } else if (k > 0 && fs / k >= 4) {
+        sa_sint_t alignment = (fs - 1024) / k >= 4 ? 1024 : 16;
+        sa_sint_t * RESTRICT buckets =
+            (fs - alignment) / k >= 4
+                ? (sa_sint_t *)libsais_align_up(&SA[n + fs - 4 * k - alignment], (size_t)alignment * sizeof(sa_sint_t))
+                : &SA[n + fs - 4 * k];
+
+        sa_sint_t m = libsais_count_and_gather_lms_suffixes_32s_2k_omp(T, SA, n, k, buckets, threads, thread_state);
+        if (m > 1) {
+            libsais_initialize_buckets_for_radix_and_partial_sorting_32s_4k(T, k, buckets, SA[n - m]);
+
+            libsais_radix_sort_lms_suffixes_32s_2k_omp(T, SA, n, m, &buckets[1], threads, thread_state);
+            libsais_radix_sort_set_markers_32s_4k_omp(SA, k, &buckets[1], threads);
+
+            libsais_place_lms_suffixes_interval_32s_4k(SA, n, k, m - 1, buckets);
+            libsais_induce_partial_order_32s_4k_omp(T, SA, n, k, buckets, threads, thread_state);
+
+            sa_sint_t names =
+                libsais_renumber_and_mark_distinct_lms_suffixes_32s_4k_omp(SA, n, m, threads, thread_state);
+            if (names < m) {
+                sa_sint_t f = libsais_compact_lms_suffixes_32s_omp(T, SA, n, m, fs, threads, thread_state);
+
+                if (libsais_main_32s(SA + n + fs - m + f, SA, m - f, names - f, fs + n - 2 * m + f, threads,
+                                     thread_state) != 0) {
+                    return -2;
+                }
+
+                libsais_reconstruct_compacted_lms_suffixes_32s_2k_omp(T, SA, n, k, m, fs, f, buckets, threads,
+                                                                      thread_state);
+            } else {
+                libsais_count_lms_suffixes_32s_2k(T, n, k, buckets);
+            }
+        } else {
+            SA[0] = SA[n - 1];
+        }
+
+        libsais_initialize_buckets_start_and_end_32s_4k(k, buckets);
+        libsais_place_lms_suffixes_histogram_32s_4k(SA, n, k, m, buckets);
+        libsais_induce_final_order_32s_4k(T, SA, n, k, buckets, threads, thread_state);
+
+        return 0;
+    } else if (k > 0 && fs / k >= 2) {
+        sa_sint_t alignment = (fs - 1024) / k >= 2 ? 1024 : 16;
+        sa_sint_t * RESTRICT buckets =
+            (fs - alignment) / k >= 2
+                ? (sa_sint_t *)libsais_align_up(&SA[n + fs - 2 * k - alignment], (size_t)alignment * sizeof(sa_sint_t))
+                : &SA[n + fs - 2 * k];
+
+        sa_sint_t m = libsais_count_and_gather_lms_suffixes_32s_2k_omp(T, SA, n, k, buckets, threads, thread_state);
+        if (m > 1) {
+            libsais_initialize_buckets_for_lms_suffixes_radix_sort_32s_2k(T, k, buckets, SA[n - m]);
+
+            libsais_radix_sort_lms_suffixes_32s_2k_omp(T, SA, n, m, &buckets[1], threads, thread_state);
+            libsais_place_lms_suffixes_interval_32s_2k(SA, n, k, m - 1, buckets);
+
+            libsais_initialize_buckets_start_and_end_32s_2k(k, buckets);
+            libsais_induce_partial_order_32s_2k_omp(T, SA, n, k, buckets, threads, thread_state);
+
+            sa_sint_t names = libsais_renumber_and_mark_distinct_lms_suffixes_32s_1k_omp(T, SA, n, m, threads);
+            if (names < m) {
+                sa_sint_t f = libsais_compact_lms_suffixes_32s_omp(T, SA, n, m, fs, threads, thread_state);
+
+                if (libsais_main_32s(SA + n + fs - m + f, SA, m - f, names - f, fs + n - 2 * m + f, threads,
+                                     thread_state) != 0) {
+                    return -2;
+                }
+
+                libsais_reconstruct_compacted_lms_suffixes_32s_2k_omp(T, SA, n, k, m, fs, f, buckets, threads,
+                                                                      thread_state);
+            } else {
+                libsais_count_lms_suffixes_32s_2k(T, n, k, buckets);
+            }
+        } else {
+            SA[0] = SA[n - 1];
+        }
+
+        libsais_initialize_buckets_end_32s_2k(k, buckets);
+        libsais_place_lms_suffixes_histogram_32s_2k(SA, n, k, m, buckets);
+
+        libsais_initialize_buckets_start_and_end_32s_2k(k, buckets);
+        libsais_induce_final_order_32s_2k(T, SA, n, k, buckets, threads, thread_state);
+
+        return 0;
+    } else {
+        sa_sint_t * buffer =
+            fs < k ? (sa_sint_t *)libsais_alloc_aligned((size_t)k * sizeof(sa_sint_t), 4096) : (sa_sint_t *)NULL;
+
+        sa_sint_t alignment = fs - 1024 >= k ? 1024 : 16;
+        sa_sint_t * RESTRICT buckets =
+            fs - alignment >= k
+                ? (sa_sint_t *)libsais_align_up(&SA[n + fs - k - alignment], (size_t)alignment * sizeof(sa_sint_t))
+            : fs >= k ? &SA[n + fs - k]
+                      : buffer;
+
+        if (buckets == NULL) {
+            return -2;
+        }
+
+        memset(SA, 0, (size_t)n * sizeof(sa_sint_t));
+
+        libsais_count_suffixes_32s(T, n, k, buckets);
+        libsais_initialize_buckets_end_32s_1k(k, buckets);
+
+        sa_sint_t m = libsais_radix_sort_lms_suffixes_32s_1k(T, SA, n, buckets);
+        if (m > 1) {
+            libsais_induce_partial_order_32s_1k_omp(T, SA, n, k, buckets, threads, thread_state);
+
+            sa_sint_t names = libsais_renumber_and_mark_distinct_lms_suffixes_32s_1k_omp(T, SA, n, m, threads);
+            if (names < m) {
+                if (buffer != NULL) {
+                    libsais_free_aligned(buffer);
+                    buckets = NULL;
+                }
+
+                sa_sint_t f = libsais_compact_lms_suffixes_32s_omp(T, SA, n, m, fs, threads, thread_state);
+
+                if (libsais_main_32s(SA + n + fs - m + f, SA, m - f, names - f, fs + n - 2 * m + f, threads,
+                                     thread_state) != 0) {
+                    return -2;
+                }
+
+                libsais_reconstruct_compacted_lms_suffixes_32s_1k_omp(T, SA, n, m, fs, f, threads, thread_state);
+
+                if (buckets == NULL) {
+                    buckets = buffer = (sa_sint_t *)libsais_alloc_aligned((size_t)k * sizeof(sa_sint_t), 4096);
+                }
+                if (buckets == NULL) {
+                    return -2;
+                }
+            }
+
+            libsais_count_suffixes_32s(T, n, k, buckets);
+            libsais_initialize_buckets_end_32s_1k(k, buckets);
+            libsais_place_lms_suffixes_interval_32s_1k(T, SA, k, m, buckets);
+        }
+
+        libsais_induce_final_order_32s_1k(T, SA, n, k, buckets, threads, thread_state);
+        libsais_free_aligned(buffer);
+
+        return 0;
+    }
+}
+
+static sa_sint_t libsais_main_8u(const u8 * T, sa_sint_t * SA, sa_sint_t n, sa_sint_t * RESTRICT buckets, sa_sint_t bwt,
+                                 sa_sint_t r, sa_sint_t * RESTRICT I, sa_sint_t fs, sa_sint_t * freq, sa_sint_t threads,
+                                 LIBSAIS_THREAD_STATE * RESTRICT thread_state) {
+    fs = fs < (SAINT_MAX - n) ? fs : (SAINT_MAX - n);
+
+    sa_sint_t m = libsais_count_and_gather_lms_suffixes_8u_omp(T, SA, n, buckets, threads, thread_state);
+
+    libsais_initialize_buckets_start_and_end_8u(buckets, freq);
+
+    if (m > 0) {
+        sa_sint_t first_lms_suffix = SA[n - m];
+        sa_sint_t left_suffixes_count =
+            libsais_initialize_buckets_for_lms_suffixes_radix_sort_8u(T, buckets, first_lms_suffix);
+
+        if (threads > 1 && n >= 65536) {
+            memset(SA, 0, ((size_t)n - (size_t)m) * sizeof(sa_sint_t));
+        }
+        libsais_radix_sort_lms_suffixes_8u_omp(T, SA, n, m, buckets, threads, thread_state);
+        if (threads > 1 && n >= 65536) {
+            memset(&SA[(fast_sint_t)n - (fast_sint_t)m], 0, (size_t)m * sizeof(sa_sint_t));
+        }
+
+        libsais_initialize_buckets_for_partial_sorting_8u(T, buckets, first_lms_suffix, left_suffixes_count);
+        libsais_induce_partial_order_8u_omp(T, SA, n, buckets, first_lms_suffix, left_suffixes_count, threads,
+                                            thread_state);
+
+        sa_sint_t names = libsais_renumber_and_gather_lms_suffixes_8u_omp(SA, n, m, fs, threads, thread_state);
+        if (names < m) {
+            if (libsais_main_32s(SA + n + fs - m, SA, m, names, fs + n - 2 * m, threads, thread_state) != 0) {
+                return -2;
+            }
+
+            libsais_gather_lms_suffixes_8u_omp(T, SA, n, threads, thread_state);
+            libsais_reconstruct_lms_suffixes_omp(SA, n, m, threads);
+        }
+
+        libsais_place_lms_suffixes_interval_8u(SA, n, m, buckets);
+    } else {
+        memset(SA, 0, (size_t)n * sizeof(sa_sint_t));
+    }
+
+    return libsais_induce_final_order_8u_omp(T, SA, n, bwt, r, I, buckets, threads, thread_state);
+}
+
+static sa_sint_t libsais_main(const u8 * T, sa_sint_t * SA, sa_sint_t n, sa_sint_t bwt, sa_sint_t r, sa_sint_t * I,
+                              sa_sint_t fs, sa_sint_t * freq, sa_sint_t threads) {
+    LIBSAIS_THREAD_STATE * RESTRICT thread_state = threads > 1 ? libsais_alloc_thread_state(threads) : NULL;
+    sa_sint_t * RESTRICT buckets = (sa_sint_t *)libsais_alloc_aligned(8 * ALPHABET_SIZE * sizeof(sa_sint_t), 4096);
+
+    sa_sint_t index = buckets != NULL && (thread_state != NULL || threads == 1)
+                          ? libsais_main_8u(T, SA, n, buckets, bwt, r, I, fs, freq, threads, thread_state)
+                          : -2;
+
+    libsais_free_aligned(buckets);
+    libsais_free_thread_state(thread_state);
+
+    return index;
+}
+
+static s32 libsais_main_int(sa_sint_t * T, sa_sint_t * SA, sa_sint_t n, sa_sint_t k, sa_sint_t fs, sa_sint_t threads) {
+    LIBSAIS_THREAD_STATE * RESTRICT thread_state = threads > 1 ? libsais_alloc_thread_state(threads) : NULL;
+
+    sa_sint_t index =
+        thread_state != NULL || threads == 1 ? libsais_main_32s(T, SA, n, k, fs, threads, thread_state) : -2;
+
+    libsais_free_thread_state(thread_state);
+
+    return index;
+}
+
+static sa_sint_t libsais_main_ctx(const LIBSAIS_CONTEXT * ctx, const u8 * T, sa_sint_t * SA, sa_sint_t n, sa_sint_t bwt,
+                                  sa_sint_t r, sa_sint_t * I, sa_sint_t fs, sa_sint_t * freq) {
+    return ctx != NULL && (ctx->buckets != NULL && (ctx->thread_state != NULL || ctx->threads == 1))
+               ? libsais_main_8u(T, SA, n, ctx->buckets, bwt, r, I, fs, freq, (sa_sint_t)ctx->threads,
+                                 ctx->thread_state)
+               : -2;
+}
+
+static void libsais_bwt_copy_8u(u8 * RESTRICT U, sa_sint_t * RESTRICT A, sa_sint_t n) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j;
+    for (i = 0, j = (fast_sint_t)n - 7; i < j; i += 8) {
+        prefetch(&A[i + prefetch_distance]);
+
+        U[i + 0] = (u8)A[i + 0];
+        U[i + 1] = (u8)A[i + 1];
+        U[i + 2] = (u8)A[i + 2];
+        U[i + 3] = (u8)A[i + 3];
+        U[i + 4] = (u8)A[i + 4];
+        U[i + 5] = (u8)A[i + 5];
+        U[i + 6] = (u8)A[i + 6];
+        U[i + 7] = (u8)A[i + 7];
+    }
+
+    for (j += 7; i < j; i += 1) {
+        U[i] = (u8)A[i];
+    }
+}
+static void * libsais_create_ctx(void) { return (void *)libsais_create_ctx_main(1); }
+
+static void libsais_free_ctx(void * ctx) { libsais_free_ctx_main((LIBSAIS_CONTEXT *)ctx); }
+
+static s32 libsais(const u8 * T, s32 * SA, s32 n, s32 fs, s32 * freq) {
+    if ((T == NULL) || (SA == NULL) || (n < 0) || (fs < 0)) {
+        return -1;
+    } else if (n < 2) {
+        if (freq != NULL) {
+            memset(freq, 0, ALPHABET_SIZE * sizeof(s32));
+        }
+        if (n == 1) {
+            SA[0] = 0;
+            if (freq != NULL) {
+                freq[T[0]]++;
+            }
+        }
+        return 0;
+    }
+
+    return libsais_main(T, SA, n, 0, 0, NULL, fs, freq, 1);
+}
+
+static s32 libsais_int(s32 * T, s32 * SA, s32 n, s32 k, s32 fs) {
+    if ((T == NULL) || (SA == NULL) || (n < 0) || (fs < 0)) {
+        return -1;
+    } else if (n < 2) {
+        if (n == 1) {
+            SA[0] = 0;
+        }
+        return 0;
+    }
+
+    return libsais_main_int(T, SA, n, k, fs, 1);
+}
+
+static s32 libsais_ctx(const void * ctx, const u8 * T, s32 * SA, s32 n, s32 fs, s32 * freq) {
+    if ((ctx == NULL) || (T == NULL) || (SA == NULL) || (n < 0) || (fs < 0)) {
+        return -1;
+    } else if (n < 2) {
+        if (freq != NULL) {
+            memset(freq, 0, ALPHABET_SIZE * sizeof(s32));
+        }
+        if (n == 1) {
+            SA[0] = 0;
+            if (freq != NULL) {
+                freq[T[0]]++;
+            }
+        }
+        return 0;
+    }
+
+    return libsais_main_ctx((const LIBSAIS_CONTEXT *)ctx, T, SA, n, 0, 0, NULL, fs, freq);
+}
+
+static s32 libsais_bwt(const u8 * T, u8 * U, s32 * A, s32 n, s32 fs, s32 * freq) {
+    if ((T == NULL) || (U == NULL) || (A == NULL) || (n < 0) || (fs < 0)) {
+        return -1;
+    } else if (n <= 1) {
+        if (freq != NULL) {
+            memset(freq, 0, ALPHABET_SIZE * sizeof(s32));
+        }
+        if (n == 1) {
+            U[0] = T[0];
+            if (freq != NULL) {
+                freq[T[0]]++;
+            }
+        }
+        return n;
+    }
+
+    sa_sint_t index = libsais_main(T, A, n, 1, 0, NULL, fs, freq, 1);
+    if (index >= 0) {
+        index++;
+
+        U[0] = T[n - 1];
+        libsais_bwt_copy_8u(U + 1, A, index - 1);
+        libsais_bwt_copy_8u(U + index, A + index, n - index);
+    }
+
+    return index;
+}
+
+static s32 libsais_bwt_aux(const u8 * T, u8 * U, s32 * A, s32 n, s32 fs, s32 * freq, s32 r, s32 * I) {
+    if ((T == NULL) || (U == NULL) || (A == NULL) || (n < 0) || (fs < 0) || (r < 2) || ((r & (r - 1)) != 0) ||
+        (I == NULL)) {
+        return -1;
+    } else if (n <= 1) {
+        if (freq != NULL) {
+            memset(freq, 0, ALPHABET_SIZE * sizeof(s32));
+        }
+        if (n == 1) {
+            U[0] = T[0];
+            if (freq != NULL) {
+                freq[T[0]]++;
+            }
+        }
+        I[0] = n;
+        return 0;
+    }
+
+    if (libsais_main(T, A, n, 1, r, I, fs, freq, 1) != 0) {
+        return -2;
+    }
+
+    U[0] = T[n - 1];
+    libsais_bwt_copy_8u(U + 1, A, I[0] - 1);
+    libsais_bwt_copy_8u(U + I[0], A + I[0], n - I[0]);
+
+    return 0;
+}
+
+static s32 libsais_bwt_ctx(const void * ctx, const u8 * T, u8 * U, s32 * A, s32 n, s32 fs, s32 * freq) {
+    if ((ctx == NULL) || (T == NULL) || (U == NULL) || (A == NULL) || (n < 0) || (fs < 0)) {
+        return -1;
+    } else if (n <= 1) {
+        if (freq != NULL) {
+            memset(freq, 0, ALPHABET_SIZE * sizeof(s32));
+        }
+        if (n == 1) {
+            U[0] = T[0];
+            if (freq != NULL) {
+                freq[T[0]]++;
+            }
+        }
+        return n;
+    }
+
+    sa_sint_t index = libsais_main_ctx((const LIBSAIS_CONTEXT *)ctx, T, A, n, 1, 0, NULL, fs, freq);
+    if (index >= 0) {
+        index++;
+
+        U[0] = T[n - 1];
+
+        libsais_bwt_copy_8u(U + 1, A, index - 1);
+        libsais_bwt_copy_8u(U + index, A + index, n - index);
+    }
+
+    return index;
+}
+
+static s32 libsais_bwt_aux_ctx(const void * ctx, const u8 * T, u8 * U, s32 * A, s32 n, s32 fs, s32 * freq, s32 r,
+                               s32 * I) {
+    if ((ctx == NULL) || (T == NULL) || (U == NULL) || (A == NULL) || (n < 0) || (fs < 0) || (r < 2) ||
+        ((r & (r - 1)) != 0) || (I == NULL)) {
+        return -1;
+    } else if (n <= 1) {
+        if (freq != NULL) {
+            memset(freq, 0, ALPHABET_SIZE * sizeof(s32));
+        }
+        if (n == 1) {
+            U[0] = T[0];
+            if (freq != NULL) {
+                freq[T[0]]++;
+            }
+        }
+        I[0] = n;
+        return 0;
+    }
+
+    if (libsais_main_ctx((const LIBSAIS_CONTEXT *)ctx, T, A, n, 1, r, I, fs, freq) != 0) {
+        return -2;
+    }
+
+    U[0] = T[n - 1];
+    libsais_bwt_copy_8u(U + 1, A, I[0] - 1);
+    libsais_bwt_copy_8u(U + I[0], A + I[0], n - I[0]);
+    return 0;
+}
+static LIBSAIS_UNBWT_CONTEXT * libsais_unbwt_create_ctx_main(sa_sint_t threads) {
+    LIBSAIS_UNBWT_CONTEXT * RESTRICT ctx =
+        (LIBSAIS_UNBWT_CONTEXT *)libsais_alloc_aligned(sizeof(LIBSAIS_UNBWT_CONTEXT), 64);
+    sa_uint_t * RESTRICT bucket2 =
+        (sa_uint_t *)libsais_alloc_aligned(ALPHABET_SIZE * ALPHABET_SIZE * sizeof(sa_uint_t), 4096);
+    u16 * RESTRICT fastbits = (u16 *)libsais_alloc_aligned((1 + (1 << UNBWT_FASTBITS)) * sizeof(u16), 4096);
+    sa_uint_t * RESTRICT buckets =
+        threads > 1 ? (sa_uint_t *)libsais_alloc_aligned(
+                          (size_t)threads * (ALPHABET_SIZE + (ALPHABET_SIZE * ALPHABET_SIZE)) * sizeof(sa_uint_t), 4096)
+                    : NULL;
+
+    if (ctx != NULL && bucket2 != NULL && fastbits != NULL && (buckets != NULL || threads == 1)) {
+        ctx->bucket2 = bucket2;
+        ctx->fastbits = fastbits;
+        ctx->buckets = buckets;
+        ctx->threads = threads;
+
+        return ctx;
+    }
+
+    libsais_free_aligned(buckets);
+    libsais_free_aligned(fastbits);
+    libsais_free_aligned(bucket2);
+    libsais_free_aligned(ctx);
+
+    return NULL;
+}
+
+static void libsais_unbwt_free_ctx_main(LIBSAIS_UNBWT_CONTEXT * ctx) {
+    if (ctx != NULL) {
+        libsais_free_aligned(ctx->buckets);
+        libsais_free_aligned(ctx->fastbits);
+        libsais_free_aligned(ctx->bucket2);
+        libsais_free_aligned(ctx);
+    }
+}
+
+static void libsais_unbwt_compute_histogram(const u8 * RESTRICT T, fast_sint_t n, sa_uint_t * RESTRICT count) {
+    const fast_sint_t prefetch_distance = 256;
+
+    const u8 * RESTRICT T_p = T;
+
+    if (n >= 1024) {
+        sa_uint_t copy[4 * (ALPHABET_SIZE + 16)];
+
+        memset(copy, 0, 4 * (ALPHABET_SIZE + 16) * sizeof(sa_uint_t));
+
+        sa_uint_t * RESTRICT copy0 = copy + 0 * (ALPHABET_SIZE + 16);
+        sa_uint_t * RESTRICT copy1 = copy + 1 * (ALPHABET_SIZE + 16);
+        sa_uint_t * RESTRICT copy2 = copy + 2 * (ALPHABET_SIZE + 16);
+        sa_uint_t * RESTRICT copy3 = copy + 3 * (ALPHABET_SIZE + 16);
+
+        for (; T_p < (u8 *)((ptrdiff_t)(T + 63) & (-64)); T_p += 1) {
+            copy0[T_p[0]]++;
+        }
+
+        fast_uint_t x = ((const u32 *)(const void *)T_p)[0], y = ((const u32 *)(const void *)T_p)[1];
+
+        for (; T_p < (u8 *)((ptrdiff_t)(T + n - 8) & (-64)); T_p += 64) {
+            prefetch(&T_p[prefetch_distance]);
+
+            fast_uint_t z = ((const u32 *)(const void *)T_p)[2], w = ((const u32 *)(const void *)T_p)[3];
+            copy0[(u8)x]++;
+            x >>= 8;
+            copy1[(u8)x]++;
+            x >>= 8;
+            copy2[(u8)x]++;
+            x >>= 8;
+            copy3[x]++;
+            copy0[(u8)y]++;
+            y >>= 8;
+            copy1[(u8)y]++;
+            y >>= 8;
+            copy2[(u8)y]++;
+            y >>= 8;
+            copy3[y]++;
+
+            x = ((const u32 *)(const void *)T_p)[4];
+            y = ((const u32 *)(const void *)T_p)[5];
+            copy0[(u8)z]++;
+            z >>= 8;
+            copy1[(u8)z]++;
+            z >>= 8;
+            copy2[(u8)z]++;
+            z >>= 8;
+            copy3[z]++;
+            copy0[(u8)w]++;
+            w >>= 8;
+            copy1[(u8)w]++;
+            w >>= 8;
+            copy2[(u8)w]++;
+            w >>= 8;
+            copy3[w]++;
+
+            z = ((const u32 *)(const void *)T_p)[6];
+            w = ((const u32 *)(const void *)T_p)[7];
+            copy0[(u8)x]++;
+            x >>= 8;
+            copy1[(u8)x]++;
+            x >>= 8;
+            copy2[(u8)x]++;
+            x >>= 8;
+            copy3[x]++;
+            copy0[(u8)y]++;
+            y >>= 8;
+            copy1[(u8)y]++;
+            y >>= 8;
+            copy2[(u8)y]++;
+            y >>= 8;
+            copy3[y]++;
+
+            x = ((const u32 *)(const void *)T_p)[8];
+            y = ((const u32 *)(const void *)T_p)[9];
+            copy0[(u8)z]++;
+            z >>= 8;
+            copy1[(u8)z]++;
+            z >>= 8;
+            copy2[(u8)z]++;
+            z >>= 8;
+            copy3[z]++;
+            copy0[(u8)w]++;
+            w >>= 8;
+            copy1[(u8)w]++;
+            w >>= 8;
+            copy2[(u8)w]++;
+            w >>= 8;
+            copy3[w]++;
+
+            z = ((const u32 *)(const void *)T_p)[10];
+            w = ((const u32 *)(const void *)T_p)[11];
+            copy0[(u8)x]++;
+            x >>= 8;
+            copy1[(u8)x]++;
+            x >>= 8;
+            copy2[(u8)x]++;
+            x >>= 8;
+            copy3[x]++;
+            copy0[(u8)y]++;
+            y >>= 8;
+            copy1[(u8)y]++;
+            y >>= 8;
+            copy2[(u8)y]++;
+            y >>= 8;
+            copy3[y]++;
+
+            x = ((const u32 *)(const void *)T_p)[12];
+            y = ((const u32 *)(const void *)T_p)[13];
+            copy0[(u8)z]++;
+            z >>= 8;
+            copy1[(u8)z]++;
+            z >>= 8;
+            copy2[(u8)z]++;
+            z >>= 8;
+            copy3[z]++;
+            copy0[(u8)w]++;
+            w >>= 8;
+            copy1[(u8)w]++;
+            w >>= 8;
+            copy2[(u8)w]++;
+            w >>= 8;
+            copy3[w]++;
+
+            z = ((const u32 *)(const void *)T_p)[14];
+            w = ((const u32 *)(const void *)T_p)[15];
+            copy0[(u8)x]++;
+            x >>= 8;
+            copy1[(u8)x]++;
+            x >>= 8;
+            copy2[(u8)x]++;
+            x >>= 8;
+            copy3[x]++;
+            copy0[(u8)y]++;
+            y >>= 8;
+            copy1[(u8)y]++;
+            y >>= 8;
+            copy2[(u8)y]++;
+            y >>= 8;
+            copy3[y]++;
+
+            x = ((const u32 *)(const void *)T_p)[16];
+            y = ((const u32 *)(const void *)T_p)[17];
+            copy0[(u8)z]++;
+            z >>= 8;
+            copy1[(u8)z]++;
+            z >>= 8;
+            copy2[(u8)z]++;
+            z >>= 8;
+            copy3[z]++;
+            copy0[(u8)w]++;
+            w >>= 8;
+            copy1[(u8)w]++;
+            w >>= 8;
+            copy2[(u8)w]++;
+            w >>= 8;
+            copy3[w]++;
+        }
+
+        copy0[(u8)x]++;
+        x >>= 8;
+        copy1[(u8)x]++;
+        x >>= 8;
+        copy2[(u8)x]++;
+        x >>= 8;
+        copy3[x]++;
+        copy0[(u8)y]++;
+        y >>= 8;
+        copy1[(u8)y]++;
+        y >>= 8;
+        copy2[(u8)y]++;
+        y >>= 8;
+        copy3[y]++;
+
+        T_p += 8;
+
+        fast_uint_t i;
+        for (i = 0; i < ALPHABET_SIZE; i++) {
+            count[i] += copy0[i] + copy1[i] + copy2[i] + copy3[i];
+        }
+    }
+
+    for (; T_p < T + n; T_p += 1) {
+        count[T_p[0]]++;
+    }
+}
+
+static void libsais_unbwt_transpose_bucket2(sa_uint_t * RESTRICT bucket2) {
+    fast_uint_t x, y, c, d;
+    for (x = 0; x != ALPHABET_SIZE; x += 16) {
+        for (c = x; c != x + 16; ++c) {
+            for (d = c + 1; d != x + 16; ++d) {
+                sa_uint_t tmp = bucket2[(d << 8) + c];
+                bucket2[(d << 8) + c] = bucket2[(c << 8) + d];
+                bucket2[(c << 8) + d] = tmp;
+            }
+        }
+
+        for (y = x + 16; y != ALPHABET_SIZE; y += 16) {
+            for (c = x; c != x + 16; ++c) {
+                sa_uint_t * bucket2_yc = &bucket2[(y << 8) + c];
+                sa_uint_t * bucket2_cy = &bucket2[(c << 8) + y];
+
+                sa_uint_t tmp00 = bucket2_yc[0 * 256];
+                bucket2_yc[0 * 256] = bucket2_cy[0];
+                bucket2_cy[0] = tmp00;
+                sa_uint_t tmp01 = bucket2_yc[1 * 256];
+                bucket2_yc[1 * 256] = bucket2_cy[1];
+                bucket2_cy[1] = tmp01;
+                sa_uint_t tmp02 = bucket2_yc[2 * 256];
+                bucket2_yc[2 * 256] = bucket2_cy[2];
+                bucket2_cy[2] = tmp02;
+                sa_uint_t tmp03 = bucket2_yc[3 * 256];
+                bucket2_yc[3 * 256] = bucket2_cy[3];
+                bucket2_cy[3] = tmp03;
+                sa_uint_t tmp04 = bucket2_yc[4 * 256];
+                bucket2_yc[4 * 256] = bucket2_cy[4];
+                bucket2_cy[4] = tmp04;
+                sa_uint_t tmp05 = bucket2_yc[5 * 256];
+                bucket2_yc[5 * 256] = bucket2_cy[5];
+                bucket2_cy[5] = tmp05;
+                sa_uint_t tmp06 = bucket2_yc[6 * 256];
+                bucket2_yc[6 * 256] = bucket2_cy[6];
+                bucket2_cy[6] = tmp06;
+                sa_uint_t tmp07 = bucket2_yc[7 * 256];
+                bucket2_yc[7 * 256] = bucket2_cy[7];
+                bucket2_cy[7] = tmp07;
+                sa_uint_t tmp08 = bucket2_yc[8 * 256];
+                bucket2_yc[8 * 256] = bucket2_cy[8];
+                bucket2_cy[8] = tmp08;
+                sa_uint_t tmp09 = bucket2_yc[9 * 256];
+                bucket2_yc[9 * 256] = bucket2_cy[9];
+                bucket2_cy[9] = tmp09;
+                sa_uint_t tmp10 = bucket2_yc[10 * 256];
+                bucket2_yc[10 * 256] = bucket2_cy[10];
+                bucket2_cy[10] = tmp10;
+                sa_uint_t tmp11 = bucket2_yc[11 * 256];
+                bucket2_yc[11 * 256] = bucket2_cy[11];
+                bucket2_cy[11] = tmp11;
+                sa_uint_t tmp12 = bucket2_yc[12 * 256];
+                bucket2_yc[12 * 256] = bucket2_cy[12];
+                bucket2_cy[12] = tmp12;
+                sa_uint_t tmp13 = bucket2_yc[13 * 256];
+                bucket2_yc[13 * 256] = bucket2_cy[13];
+                bucket2_cy[13] = tmp13;
+                sa_uint_t tmp14 = bucket2_yc[14 * 256];
+                bucket2_yc[14 * 256] = bucket2_cy[14];
+                bucket2_cy[14] = tmp14;
+                sa_uint_t tmp15 = bucket2_yc[15 * 256];
+                bucket2_yc[15 * 256] = bucket2_cy[15];
+                bucket2_cy[15] = tmp15;
+            }
+        }
+    }
+}
+
+static void libsais_unbwt_compute_bigram_histogram_single(const u8 * RESTRICT T, sa_uint_t * RESTRICT bucket1,
+                                                          sa_uint_t * RESTRICT bucket2, fast_uint_t index) {
+    fast_uint_t sum, c;
+    for (sum = 1, c = 0; c < ALPHABET_SIZE; ++c) {
+        fast_uint_t prev = sum;
+        sum += bucket1[c];
+        bucket1[c] = (sa_uint_t)prev;
+        if (prev != sum) {
+            sa_uint_t * RESTRICT bucket2_p = &bucket2[c << 8];
+
+            {
+                fast_uint_t hi = index;
+                if (sum < hi) {
+                    hi = sum;
+                }
+                libsais_unbwt_compute_histogram(&T[prev], (fast_sint_t)(hi - prev), bucket2_p);
+            }
+
+            {
+                fast_uint_t lo = index + 1;
+                if (prev > lo) {
+                    lo = prev;
+                }
+                libsais_unbwt_compute_histogram(&T[lo - 1], (fast_sint_t)(sum - lo), bucket2_p);
+            }
+        }
+    }
+
+    libsais_unbwt_transpose_bucket2(bucket2);
+}
+
+static void libsais_unbwt_calculate_fastbits(sa_uint_t * RESTRICT bucket2, u16 * RESTRICT fastbits, fast_uint_t lastc,
+                                             fast_uint_t shift) {
+    fast_uint_t v, w, sum, c, d;
+    for (v = 0, w = 0, sum = 1, c = 0; c < ALPHABET_SIZE; ++c) {
+        if (c == lastc) {
+            sum += 1;
+        }
+
+        for (d = 0; d < ALPHABET_SIZE; ++d, ++w) {
+            fast_uint_t prev = sum;
+            sum += bucket2[w];
+            bucket2[w] = (sa_uint_t)prev;
+            if (prev != sum) {
+                for (; v <= ((sum - 1) >> shift); ++v) {
+                    fastbits[v] = (u16)w;
+                }
+            }
+        }
+    }
+}
+
+static void libsais_unbwt_calculate_biPSI(const u8 * RESTRICT T, sa_uint_t * RESTRICT P, sa_uint_t * RESTRICT bucket1,
+                                          sa_uint_t * RESTRICT bucket2, fast_uint_t index, fast_sint_t omp_block_start,
+                                          fast_sint_t omp_block_end) {
+    {
+        fast_sint_t i = omp_block_start, j = (fast_sint_t)index;
+        if (omp_block_end < j) {
+            j = omp_block_end;
+        }
+        for (; i < j; ++i) {
+            fast_uint_t c = T[i];
+            fast_uint_t p = bucket1[c]++;
+            fast_sint_t t = (fast_sint_t)(index - p);
+
+            if (t != 0) {
+                fast_uint_t w = (((fast_uint_t)T[p + (fast_uint_t)(t >> ((sizeof(fast_sint_t) * 8) - 1))]) << 8) + c;
+                P[bucket2[w]++] = (sa_uint_t)i;
+            }
+        }
+    }
+
+    {
+        fast_sint_t i = (fast_sint_t)index, j = omp_block_end;
+        if (omp_block_start > i) {
+            i = omp_block_start;
+        }
+        for (i += 1; i <= j; ++i) {
+            fast_uint_t c = T[i - 1];
+            fast_uint_t p = bucket1[c]++;
+            fast_sint_t t = (fast_sint_t)(index - p);
+
+            if (t != 0) {
+                fast_uint_t w = (((fast_uint_t)T[p + (fast_uint_t)(t >> ((sizeof(fast_sint_t) * 8) - 1))]) << 8) + c;
+                P[bucket2[w]++] = (sa_uint_t)i;
+            }
+        }
+    }
+}
+
+static void libsais_unbwt_init_single(const u8 * RESTRICT T, sa_uint_t * RESTRICT P, sa_sint_t n,
+                                      const sa_sint_t * freq, const sa_uint_t * RESTRICT I,
+                                      sa_uint_t * RESTRICT bucket2, u16 * RESTRICT fastbits) {
+    sa_uint_t bucket1[ALPHABET_SIZE];
+
+    fast_uint_t index = I[0];
+    fast_uint_t lastc = T[0];
+    fast_uint_t shift = 0;
+    while ((n >> shift) > (1 << UNBWT_FASTBITS)) {
+        shift++;
+    }
+
+    if (freq != NULL) {
+        memcpy(bucket1, freq, ALPHABET_SIZE * sizeof(sa_uint_t));
+    } else {
+        memset(bucket1, 0, ALPHABET_SIZE * sizeof(sa_uint_t));
+        libsais_unbwt_compute_histogram(T, n, bucket1);
+    }
+
+    memset(bucket2, 0, ALPHABET_SIZE * ALPHABET_SIZE * sizeof(sa_uint_t));
+    libsais_unbwt_compute_bigram_histogram_single(T, bucket1, bucket2, index);
+
+    libsais_unbwt_calculate_fastbits(bucket2, fastbits, lastc, shift);
+    libsais_unbwt_calculate_biPSI(T, P, bucket1, bucket2, index, 0, n);
+}
+static void libsais_unbwt_decode_1(u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_uint_t * RESTRICT bucket2,
+                                   u16 * RESTRICT fastbits, fast_uint_t shift, fast_uint_t * i0, fast_uint_t k) {
+    u16 * RESTRICT U0 = (u16 *)(void *)U;
+
+    fast_uint_t i, p0 = *i0;
+
+    for (i = 0; i != k; ++i) {
+        u16 c0 = fastbits[p0 >> shift];
+        if (bucket2[c0] <= p0) {
+            do {
+                c0++;
+            } while (bucket2[c0] <= p0);
+        }
+        p0 = P[p0];
+        U0[i] = bswap16(c0);
+    }
+
+    *i0 = p0;
+}
+
+static void libsais_unbwt_decode_2(u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_uint_t * RESTRICT bucket2,
+                                   u16 * RESTRICT fastbits, fast_uint_t shift, fast_uint_t r, fast_uint_t * i0,
+                                   fast_uint_t * i1, fast_uint_t k) {
+    u16 * RESTRICT U0 = (u16 *)(void *)U;
+    u16 * RESTRICT U1 = (u16 *)(void *)(((u8 *)U0) + r);
+
+    fast_uint_t i, p0 = *i0, p1 = *i1;
+
+    for (i = 0; i != k; ++i) {
+        u16 c0 = fastbits[p0 >> shift];
+        if (bucket2[c0] <= p0) {
+            do {
+                c0++;
+            } while (bucket2[c0] <= p0);
+        }
+        p0 = P[p0];
+        U0[i] = bswap16(c0);
+        u16 c1 = fastbits[p1 >> shift];
+        if (bucket2[c1] <= p1) {
+            do {
+                c1++;
+            } while (bucket2[c1] <= p1);
+        }
+        p1 = P[p1];
+        U1[i] = bswap16(c1);
+    }
+
+    *i0 = p0;
+    *i1 = p1;
+}
+
+static void libsais_unbwt_decode_3(u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_uint_t * RESTRICT bucket2,
+                                   u16 * RESTRICT fastbits, fast_uint_t shift, fast_uint_t r, fast_uint_t * i0,
+                                   fast_uint_t * i1, fast_uint_t * i2, fast_uint_t k) {
+    u16 * RESTRICT U0 = (u16 *)(void *)U;
+    u16 * RESTRICT U1 = (u16 *)(void *)(((u8 *)U0) + r);
+    u16 * RESTRICT U2 = (u16 *)(void *)(((u8 *)U1) + r);
+
+    fast_uint_t i, p0 = *i0, p1 = *i1, p2 = *i2;
+
+    for (i = 0; i != k; ++i) {
+        u16 c0 = fastbits[p0 >> shift];
+        if (bucket2[c0] <= p0) {
+            do {
+                c0++;
+            } while (bucket2[c0] <= p0);
+        }
+        p0 = P[p0];
+        U0[i] = bswap16(c0);
+        u16 c1 = fastbits[p1 >> shift];
+        if (bucket2[c1] <= p1) {
+            do {
+                c1++;
+            } while (bucket2[c1] <= p1);
+        }
+        p1 = P[p1];
+        U1[i] = bswap16(c1);
+        u16 c2 = fastbits[p2 >> shift];
+        if (bucket2[c2] <= p2) {
+            do {
+                c2++;
+            } while (bucket2[c2] <= p2);
+        }
+        p2 = P[p2];
+        U2[i] = bswap16(c2);
+    }
+
+    *i0 = p0;
+    *i1 = p1;
+    *i2 = p2;
+}
+
+static void libsais_unbwt_decode_4(u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_uint_t * RESTRICT bucket2,
+                                   u16 * RESTRICT fastbits, fast_uint_t shift, fast_uint_t r, fast_uint_t * i0,
+                                   fast_uint_t * i1, fast_uint_t * i2, fast_uint_t * i3, fast_uint_t k) {
+    u16 * RESTRICT U0 = (u16 *)(void *)U;
+    u16 * RESTRICT U1 = (u16 *)(void *)(((u8 *)U0) + r);
+    u16 * RESTRICT U2 = (u16 *)(void *)(((u8 *)U1) + r);
+    u16 * RESTRICT U3 = (u16 *)(void *)(((u8 *)U2) + r);
+
+    fast_uint_t i, p0 = *i0, p1 = *i1, p2 = *i2, p3 = *i3;
+
+    for (i = 0; i != k; ++i) {
+        u16 c0 = fastbits[p0 >> shift];
+        if (bucket2[c0] <= p0) {
+            do {
+                c0++;
+            } while (bucket2[c0] <= p0);
+        }
+        p0 = P[p0];
+        U0[i] = bswap16(c0);
+        u16 c1 = fastbits[p1 >> shift];
+        if (bucket2[c1] <= p1) {
+            do {
+                c1++;
+            } while (bucket2[c1] <= p1);
+        }
+        p1 = P[p1];
+        U1[i] = bswap16(c1);
+        u16 c2 = fastbits[p2 >> shift];
+        if (bucket2[c2] <= p2) {
+            do {
+                c2++;
+            } while (bucket2[c2] <= p2);
+        }
+        p2 = P[p2];
+        U2[i] = bswap16(c2);
+        u16 c3 = fastbits[p3 >> shift];
+        if (bucket2[c3] <= p3) {
+            do {
+                c3++;
+            } while (bucket2[c3] <= p3);
+        }
+        p3 = P[p3];
+        U3[i] = bswap16(c3);
+    }
+
+    *i0 = p0;
+    *i1 = p1;
+    *i2 = p2;
+    *i3 = p3;
+}
+
+static void libsais_unbwt_decode_5(u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_uint_t * RESTRICT bucket2,
+                                   u16 * RESTRICT fastbits, fast_uint_t shift, fast_uint_t r, fast_uint_t * i0,
+                                   fast_uint_t * i1, fast_uint_t * i2, fast_uint_t * i3, fast_uint_t * i4,
+                                   fast_uint_t k) {
+    u16 * RESTRICT U0 = (u16 *)(void *)U;
+    u16 * RESTRICT U1 = (u16 *)(void *)(((u8 *)U0) + r);
+    u16 * RESTRICT U2 = (u16 *)(void *)(((u8 *)U1) + r);
+    u16 * RESTRICT U3 = (u16 *)(void *)(((u8 *)U2) + r);
+    u16 * RESTRICT U4 = (u16 *)(void *)(((u8 *)U3) + r);
+
+    fast_uint_t i, p0 = *i0, p1 = *i1, p2 = *i2, p3 = *i3, p4 = *i4;
+
+    for (i = 0; i != k; ++i) {
+        u16 c0 = fastbits[p0 >> shift];
+        if (bucket2[c0] <= p0) {
+            do {
+                c0++;
+            } while (bucket2[c0] <= p0);
+        }
+        p0 = P[p0];
+        U0[i] = bswap16(c0);
+        u16 c1 = fastbits[p1 >> shift];
+        if (bucket2[c1] <= p1) {
+            do {
+                c1++;
+            } while (bucket2[c1] <= p1);
+        }
+        p1 = P[p1];
+        U1[i] = bswap16(c1);
+        u16 c2 = fastbits[p2 >> shift];
+        if (bucket2[c2] <= p2) {
+            do {
+                c2++;
+            } while (bucket2[c2] <= p2);
+        }
+        p2 = P[p2];
+        U2[i] = bswap16(c2);
+        u16 c3 = fastbits[p3 >> shift];
+        if (bucket2[c3] <= p3) {
+            do {
+                c3++;
+            } while (bucket2[c3] <= p3);
+        }
+        p3 = P[p3];
+        U3[i] = bswap16(c3);
+        u16 c4 = fastbits[p4 >> shift];
+        if (bucket2[c4] <= p4) {
+            do {
+                c4++;
+            } while (bucket2[c4] <= p4);
+        }
+        p4 = P[p4];
+        U4[i] = bswap16(c4);
+    }
+
+    *i0 = p0;
+    *i1 = p1;
+    *i2 = p2;
+    *i3 = p3;
+    *i4 = p4;
+}
+
+static void libsais_unbwt_decode_6(u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_uint_t * RESTRICT bucket2,
+                                   u16 * RESTRICT fastbits, fast_uint_t shift, fast_uint_t r, fast_uint_t * i0,
+                                   fast_uint_t * i1, fast_uint_t * i2, fast_uint_t * i3, fast_uint_t * i4,
+                                   fast_uint_t * i5, fast_uint_t k) {
+    u16 * RESTRICT U0 = (u16 *)(void *)U;
+    u16 * RESTRICT U1 = (u16 *)(void *)(((u8 *)U0) + r);
+    u16 * RESTRICT U2 = (u16 *)(void *)(((u8 *)U1) + r);
+    u16 * RESTRICT U3 = (u16 *)(void *)(((u8 *)U2) + r);
+    u16 * RESTRICT U4 = (u16 *)(void *)(((u8 *)U3) + r);
+    u16 * RESTRICT U5 = (u16 *)(void *)(((u8 *)U4) + r);
+
+    fast_uint_t i, p0 = *i0, p1 = *i1, p2 = *i2, p3 = *i3, p4 = *i4, p5 = *i5;
+
+    for (i = 0; i != k; ++i) {
+        u16 c0 = fastbits[p0 >> shift];
+        if (bucket2[c0] <= p0) {
+            do {
+                c0++;
+            } while (bucket2[c0] <= p0);
+        }
+        p0 = P[p0];
+        U0[i] = bswap16(c0);
+        u16 c1 = fastbits[p1 >> shift];
+        if (bucket2[c1] <= p1) {
+            do {
+                c1++;
+            } while (bucket2[c1] <= p1);
+        }
+        p1 = P[p1];
+        U1[i] = bswap16(c1);
+        u16 c2 = fastbits[p2 >> shift];
+        if (bucket2[c2] <= p2) {
+            do {
+                c2++;
+            } while (bucket2[c2] <= p2);
+        }
+        p2 = P[p2];
+        U2[i] = bswap16(c2);
+        u16 c3 = fastbits[p3 >> shift];
+        if (bucket2[c3] <= p3) {
+            do {
+                c3++;
+            } while (bucket2[c3] <= p3);
+        }
+        p3 = P[p3];
+        U3[i] = bswap16(c3);
+        u16 c4 = fastbits[p4 >> shift];
+        if (bucket2[c4] <= p4) {
+            do {
+                c4++;
+            } while (bucket2[c4] <= p4);
+        }
+        p4 = P[p4];
+        U4[i] = bswap16(c4);
+        u16 c5 = fastbits[p5 >> shift];
+        if (bucket2[c5] <= p5) {
+            do {
+                c5++;
+            } while (bucket2[c5] <= p5);
+        }
+        p5 = P[p5];
+        U5[i] = bswap16(c5);
+    }
+
+    *i0 = p0;
+    *i1 = p1;
+    *i2 = p2;
+    *i3 = p3;
+    *i4 = p4;
+    *i5 = p5;
+}
+
+static void libsais_unbwt_decode_7(u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_uint_t * RESTRICT bucket2,
+                                   u16 * RESTRICT fastbits, fast_uint_t shift, fast_uint_t r, fast_uint_t * i0,
+                                   fast_uint_t * i1, fast_uint_t * i2, fast_uint_t * i3, fast_uint_t * i4,
+                                   fast_uint_t * i5, fast_uint_t * i6, fast_uint_t k) {
+    u16 * RESTRICT U0 = (u16 *)(void *)U;
+    u16 * RESTRICT U1 = (u16 *)(void *)(((u8 *)U0) + r);
+    u16 * RESTRICT U2 = (u16 *)(void *)(((u8 *)U1) + r);
+    u16 * RESTRICT U3 = (u16 *)(void *)(((u8 *)U2) + r);
+    u16 * RESTRICT U4 = (u16 *)(void *)(((u8 *)U3) + r);
+    u16 * RESTRICT U5 = (u16 *)(void *)(((u8 *)U4) + r);
+    u16 * RESTRICT U6 = (u16 *)(void *)(((u8 *)U5) + r);
+
+    fast_uint_t i, p0 = *i0, p1 = *i1, p2 = *i2, p3 = *i3, p4 = *i4, p5 = *i5, p6 = *i6;
+
+    for (i = 0; i != k; ++i) {
+        u16 c0 = fastbits[p0 >> shift];
+        if (bucket2[c0] <= p0) {
+            do {
+                c0++;
+            } while (bucket2[c0] <= p0);
+        }
+        p0 = P[p0];
+        U0[i] = bswap16(c0);
+        u16 c1 = fastbits[p1 >> shift];
+        if (bucket2[c1] <= p1) {
+            do {
+                c1++;
+            } while (bucket2[c1] <= p1);
+        }
+        p1 = P[p1];
+        U1[i] = bswap16(c1);
+        u16 c2 = fastbits[p2 >> shift];
+        if (bucket2[c2] <= p2) {
+            do {
+                c2++;
+            } while (bucket2[c2] <= p2);
+        }
+        p2 = P[p2];
+        U2[i] = bswap16(c2);
+        u16 c3 = fastbits[p3 >> shift];
+        if (bucket2[c3] <= p3) {
+            do {
+                c3++;
+            } while (bucket2[c3] <= p3);
+        }
+        p3 = P[p3];
+        U3[i] = bswap16(c3);
+        u16 c4 = fastbits[p4 >> shift];
+        if (bucket2[c4] <= p4) {
+            do {
+                c4++;
+            } while (bucket2[c4] <= p4);
+        }
+        p4 = P[p4];
+        U4[i] = bswap16(c4);
+        u16 c5 = fastbits[p5 >> shift];
+        if (bucket2[c5] <= p5) {
+            do {
+                c5++;
+            } while (bucket2[c5] <= p5);
+        }
+        p5 = P[p5];
+        U5[i] = bswap16(c5);
+        u16 c6 = fastbits[p6 >> shift];
+        if (bucket2[c6] <= p6) {
+            do {
+                c6++;
+            } while (bucket2[c6] <= p6);
+        }
+        p6 = P[p6];
+        U6[i] = bswap16(c6);
+    }
+
+    *i0 = p0;
+    *i1 = p1;
+    *i2 = p2;
+    *i3 = p3;
+    *i4 = p4;
+    *i5 = p5;
+    *i6 = p6;
+}
+
+static void libsais_unbwt_decode_8(u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_uint_t * RESTRICT bucket2,
+                                   u16 * RESTRICT fastbits, fast_uint_t shift, fast_uint_t r, fast_uint_t * i0,
+                                   fast_uint_t * i1, fast_uint_t * i2, fast_uint_t * i3, fast_uint_t * i4,
+                                   fast_uint_t * i5, fast_uint_t * i6, fast_uint_t * i7, fast_uint_t k) {
+    u16 * RESTRICT U0 = (u16 *)(void *)U;
+    u16 * RESTRICT U1 = (u16 *)(void *)(((u8 *)U0) + r);
+    u16 * RESTRICT U2 = (u16 *)(void *)(((u8 *)U1) + r);
+    u16 * RESTRICT U3 = (u16 *)(void *)(((u8 *)U2) + r);
+    u16 * RESTRICT U4 = (u16 *)(void *)(((u8 *)U3) + r);
+    u16 * RESTRICT U5 = (u16 *)(void *)(((u8 *)U4) + r);
+    u16 * RESTRICT U6 = (u16 *)(void *)(((u8 *)U5) + r);
+    u16 * RESTRICT U7 = (u16 *)(void *)(((u8 *)U6) + r);
+
+    fast_uint_t i, p0 = *i0, p1 = *i1, p2 = *i2, p3 = *i3, p4 = *i4, p5 = *i5, p6 = *i6, p7 = *i7;
+
+    for (i = 0; i != k; ++i) {
+        u16 c0 = fastbits[p0 >> shift];
+        if (bucket2[c0] <= p0) {
+            do {
+                c0++;
+            } while (bucket2[c0] <= p0);
+        }
+        p0 = P[p0];
+        U0[i] = bswap16(c0);
+        u16 c1 = fastbits[p1 >> shift];
+        if (bucket2[c1] <= p1) {
+            do {
+                c1++;
+            } while (bucket2[c1] <= p1);
+        }
+        p1 = P[p1];
+        U1[i] = bswap16(c1);
+        u16 c2 = fastbits[p2 >> shift];
+        if (bucket2[c2] <= p2) {
+            do {
+                c2++;
+            } while (bucket2[c2] <= p2);
+        }
+        p2 = P[p2];
+        U2[i] = bswap16(c2);
+        u16 c3 = fastbits[p3 >> shift];
+        if (bucket2[c3] <= p3) {
+            do {
+                c3++;
+            } while (bucket2[c3] <= p3);
+        }
+        p3 = P[p3];
+        U3[i] = bswap16(c3);
+        u16 c4 = fastbits[p4 >> shift];
+        if (bucket2[c4] <= p4) {
+            do {
+                c4++;
+            } while (bucket2[c4] <= p4);
+        }
+        p4 = P[p4];
+        U4[i] = bswap16(c4);
+        u16 c5 = fastbits[p5 >> shift];
+        if (bucket2[c5] <= p5) {
+            do {
+                c5++;
+            } while (bucket2[c5] <= p5);
+        }
+        p5 = P[p5];
+        U5[i] = bswap16(c5);
+        u16 c6 = fastbits[p6 >> shift];
+        if (bucket2[c6] <= p6) {
+            do {
+                c6++;
+            } while (bucket2[c6] <= p6);
+        }
+        p6 = P[p6];
+        U6[i] = bswap16(c6);
+        u16 c7 = fastbits[p7 >> shift];
+        if (bucket2[c7] <= p7) {
+            do {
+                c7++;
+            } while (bucket2[c7] <= p7);
+        }
+        p7 = P[p7];
+        U7[i] = bswap16(c7);
+    }
+
+    *i0 = p0;
+    *i1 = p1;
+    *i2 = p2;
+    *i3 = p3;
+    *i4 = p4;
+    *i5 = p5;
+    *i6 = p6;
+    *i7 = p7;
+}
+
+static void libsais_unbwt_decode(u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_sint_t n, sa_sint_t r,
+                                 const sa_uint_t * RESTRICT I, sa_uint_t * RESTRICT bucket2, u16 * RESTRICT fastbits,
+                                 fast_sint_t blocks, fast_uint_t reminder) {
+    fast_uint_t shift = 0;
+    while ((n >> shift) > (1 << UNBWT_FASTBITS)) {
+        shift++;
+    }
+    fast_uint_t offset = 0;
+
+    while (blocks > 8) {
+        fast_uint_t i0 = I[0], i1 = I[1], i2 = I[2], i3 = I[3], i4 = I[4], i5 = I[5], i6 = I[6], i7 = I[7];
+        libsais_unbwt_decode_8(U + offset, P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1, &i2, &i3, &i4, &i5,
+                               &i6, &i7, (fast_uint_t)r >> 1);
+        I += 8;
+        blocks -= 8;
+        offset += 8 * (fast_uint_t)r;
+    }
+
+    if (blocks == 1) {
+        fast_uint_t i0 = I[0];
+        libsais_unbwt_decode_1(U + offset, P, bucket2, fastbits, shift, &i0, reminder >> 1);
+    } else if (blocks == 2) {
+        fast_uint_t i0 = I[0], i1 = I[1];
+        libsais_unbwt_decode_2(U + offset, P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1, reminder >> 1);
+        libsais_unbwt_decode_1(U + offset + 2 * (reminder >> 1), P, bucket2, fastbits, shift, &i0,
+                               ((fast_uint_t)r >> 1) - (reminder >> 1));
+    } else if (blocks == 3) {
+        fast_uint_t i0 = I[0], i1 = I[1], i2 = I[2];
+        libsais_unbwt_decode_3(U + offset, P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1, &i2, reminder >> 1);
+        libsais_unbwt_decode_2(U + offset + 2 * (reminder >> 1), P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1,
+                               ((fast_uint_t)r >> 1) - (reminder >> 1));
+    } else if (blocks == 4) {
+        fast_uint_t i0 = I[0], i1 = I[1], i2 = I[2], i3 = I[3];
+        libsais_unbwt_decode_4(U + offset, P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1, &i2, &i3,
+                               reminder >> 1);
+        libsais_unbwt_decode_3(U + offset + 2 * (reminder >> 1), P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1,
+                               &i2, ((fast_uint_t)r >> 1) - (reminder >> 1));
+    } else if (blocks == 5) {
+        fast_uint_t i0 = I[0], i1 = I[1], i2 = I[2], i3 = I[3], i4 = I[4];
+        libsais_unbwt_decode_5(U + offset, P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1, &i2, &i3, &i4,
+                               reminder >> 1);
+        libsais_unbwt_decode_4(U + offset + 2 * (reminder >> 1), P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1,
+                               &i2, &i3, ((fast_uint_t)r >> 1) - (reminder >> 1));
+    } else if (blocks == 6) {
+        fast_uint_t i0 = I[0], i1 = I[1], i2 = I[2], i3 = I[3], i4 = I[4], i5 = I[5];
+        libsais_unbwt_decode_6(U + offset, P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1, &i2, &i3, &i4, &i5,
+                               reminder >> 1);
+        libsais_unbwt_decode_5(U + offset + 2 * (reminder >> 1), P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1,
+                               &i2, &i3, &i4, ((fast_uint_t)r >> 1) - (reminder >> 1));
+    } else if (blocks == 7) {
+        fast_uint_t i0 = I[0], i1 = I[1], i2 = I[2], i3 = I[3], i4 = I[4], i5 = I[5], i6 = I[6];
+        libsais_unbwt_decode_7(U + offset, P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1, &i2, &i3, &i4, &i5,
+                               &i6, reminder >> 1);
+        libsais_unbwt_decode_6(U + offset + 2 * (reminder >> 1), P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1,
+                               &i2, &i3, &i4, &i5, ((fast_uint_t)r >> 1) - (reminder >> 1));
+    } else {
+        fast_uint_t i0 = I[0], i1 = I[1], i2 = I[2], i3 = I[3], i4 = I[4], i5 = I[5], i6 = I[6], i7 = I[7];
+        libsais_unbwt_decode_8(U + offset, P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1, &i2, &i3, &i4, &i5,
+                               &i6, &i7, reminder >> 1);
+        libsais_unbwt_decode_7(U + offset + 2 * (reminder >> 1), P, bucket2, fastbits, shift, (fast_uint_t)r, &i0, &i1,
+                               &i2, &i3, &i4, &i5, &i6, ((fast_uint_t)r >> 1) - (reminder >> 1));
+    }
+}
+
+static void libsais_unbwt_decode_omp(const u8 * RESTRICT T, u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_sint_t n,
+                                     sa_sint_t r, const sa_uint_t * RESTRICT I, sa_uint_t * RESTRICT bucket2,
+                                     u16 * RESTRICT fastbits, sa_sint_t threads) {
+    fast_uint_t lastc = T[0];
+    fast_sint_t blocks = 1 + (((fast_sint_t)n - 1) / (fast_sint_t)r);
+    fast_uint_t reminder = (fast_uint_t)n - ((fast_uint_t)r * ((fast_uint_t)blocks - 1));
+
+    {
+        (void)(threads);
+
+        fast_sint_t omp_thread_num = 0;
+        fast_sint_t omp_num_threads = 1;
+        fast_sint_t omp_block_stride = blocks / omp_num_threads;
+        fast_sint_t omp_block_reminder = blocks % omp_num_threads;
+        fast_sint_t omp_block_size = omp_block_stride + (omp_thread_num < omp_block_reminder);
+        fast_sint_t omp_block_start = omp_block_stride * omp_thread_num +
+                                      (omp_thread_num < omp_block_reminder ? omp_thread_num : omp_block_reminder);
+
+        libsais_unbwt_decode(U + r * omp_block_start, P, n, r, I + omp_block_start, bucket2, fastbits, omp_block_size,
+                             omp_thread_num < omp_num_threads - 1 ? (fast_uint_t)r : reminder);
+    }
+
+    U[n - 1] = (u8)lastc;
+}
+
+static sa_sint_t libsais_unbwt_core(const u8 * RESTRICT T, u8 * RESTRICT U, sa_uint_t * RESTRICT P, sa_sint_t n,
+                                    const sa_sint_t * freq, sa_sint_t r, const sa_uint_t * RESTRICT I,
+                                    sa_uint_t * RESTRICT bucket2, u16 * RESTRICT fastbits, sa_uint_t * RESTRICT buckets,
+                                    sa_sint_t threads) {
+    (void)(buckets);
+
+    { libsais_unbwt_init_single(T, P, n, freq, I, bucket2, fastbits); }
+
+    libsais_unbwt_decode_omp(T, U, P, n, r, I, bucket2, fastbits, threads);
+    return 0;
+}
+
+static sa_sint_t libsais_unbwt_main(const u8 * T, u8 * U, sa_uint_t * P, sa_sint_t n, const sa_sint_t * freq,
+                                    sa_sint_t r, const sa_uint_t * I, sa_sint_t threads) {
+    fast_uint_t shift = 0;
+    while ((n >> shift) > (1 << UNBWT_FASTBITS)) {
+        shift++;
+    }
+
+    sa_uint_t * RESTRICT bucket2 =
+        (sa_uint_t *)libsais_alloc_aligned(ALPHABET_SIZE * ALPHABET_SIZE * sizeof(sa_uint_t), 4096);
+    u16 * RESTRICT fastbits = (u16 *)libsais_alloc_aligned(((size_t)1 + (size_t)(n >> shift)) * sizeof(u16), 4096);
+    memset(fastbits, 0, ((size_t)1 + (size_t)(n >> shift)) * sizeof(u16));
+    sa_uint_t * RESTRICT buckets =
+        threads > 1 && n >= 262144
+            ? (sa_uint_t *)libsais_alloc_aligned(
+                  (size_t)threads * (ALPHABET_SIZE + (ALPHABET_SIZE * ALPHABET_SIZE)) * sizeof(sa_uint_t), 4096)
+            : NULL;
+
+    sa_sint_t index = bucket2 != NULL && fastbits != NULL && (buckets != NULL || threads == 1 || n < 262144)
+                          ? libsais_unbwt_core(T, U, P, n, freq, r, I, bucket2, fastbits, buckets, threads)
+                          : -2;
+
+    libsais_free_aligned(buckets);
+    libsais_free_aligned(fastbits);
+    libsais_free_aligned(bucket2);
+
+    return index;
+}
+
+static sa_sint_t libsais_unbwt_main_ctx(const LIBSAIS_UNBWT_CONTEXT * ctx, const u8 * T, u8 * U, sa_uint_t * P,
+                                        sa_sint_t n, const sa_sint_t * freq, sa_sint_t r, const sa_uint_t * I) {
+    return ctx != NULL && ctx->bucket2 != NULL && ctx->fastbits != NULL && (ctx->buckets != NULL || ctx->threads == 1)
+               ? libsais_unbwt_core(T, U, P, n, freq, r, I, ctx->bucket2, ctx->fastbits, ctx->buckets,
+                                    (sa_sint_t)ctx->threads)
+               : -2;
+}
+
+static void * libsais_unbwt_create_ctx(void) { return (void *)libsais_unbwt_create_ctx_main(1); }
+
+static void libsais_unbwt_free_ctx(void * ctx) { libsais_unbwt_free_ctx_main((LIBSAIS_UNBWT_CONTEXT *)ctx); }
+
+static s32 libsais_unbwt_aux(const u8 * T, u8 * U, s32 * A, s32 n, const s32 * freq, s32 r, const s32 * I) {
+    if ((T == NULL) || (U == NULL) || (A == NULL) || (n < 0) || ((r != n) && ((r < 2) || ((r & (r - 1)) != 0))) ||
+        (I == NULL)) {
+        return -1;
+    } else if (n <= 1) {
+        if (I[0] != n) {
+            return -1;
+        }
+        if (n == 1) {
+            U[0] = T[0];
+        }
+        return 0;
+    }
+
+    fast_sint_t t;
+    for (t = 0; t <= (n - 1) / r; ++t) {
+        if (I[t] <= 0 || I[t] > n) {
+            return -1;
+        }
+    }
+
+    return libsais_unbwt_main(T, U, (sa_uint_t *)A, n, freq, r, (const sa_uint_t *)I, 1);
+}
+
+static s32 libsais_unbwt_aux_ctx(const void * ctx, const u8 * T, u8 * U, s32 * A, s32 n, const s32 * freq, s32 r,
+                                 const s32 * I) {
+    if ((T == NULL) || (U == NULL) || (A == NULL) || (n < 0) || ((r != n) && ((r < 2) || ((r & (r - 1)) != 0))) ||
+        (I == NULL)) {
+        return -1;
+    } else if (n <= 1) {
+        if (I[0] != n) {
+            return -1;
+        }
+        if (n == 1) {
+            U[0] = T[0];
+        }
+        return 0;
+    }
+
+    fast_sint_t t;
+    for (t = 0; t <= (n - 1) / r; ++t) {
+        if (I[t] <= 0 || I[t] > n) {
+            return -1;
+        }
+    }
+
+    return libsais_unbwt_main_ctx((const LIBSAIS_UNBWT_CONTEXT *)ctx, T, U, (sa_uint_t *)A, n, freq, r,
+                                  (const sa_uint_t *)I);
+}
+
+static s32 libsais_unbwt(const u8 * T, u8 * U, s32 * A, s32 n, const s32 * freq, s32 i) {
+    return libsais_unbwt_aux(T, U, A, n, freq, n, &i);
+}
+
+static s32 libsais_unbwt_ctx(const void * ctx, const u8 * T, u8 * U, s32 * A, s32 n, const s32 * freq, s32 i) {
+    return libsais_unbwt_aux_ctx(ctx, T, U, A, n, freq, n, &i);
+}
+
+static void libsais_compute_phi(const sa_sint_t * RESTRICT SA, sa_sint_t * RESTRICT PLCP, sa_sint_t n,
+                                fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j;
+    sa_sint_t k = omp_block_start > 0 ? SA[omp_block_start - 1] : n;
+    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 3; i < j; i += 4) {
+        prefetchw(&PLCP[SA[i + prefetch_distance + 0]]);
+        prefetchw(&PLCP[SA[i + prefetch_distance + 1]]);
+
+        PLCP[SA[i + 0]] = k;
+        k = SA[i + 0];
+        PLCP[SA[i + 1]] = k;
+        k = SA[i + 1];
+
+        prefetchw(&PLCP[SA[i + prefetch_distance + 2]]);
+        prefetchw(&PLCP[SA[i + prefetch_distance + 3]]);
+
+        PLCP[SA[i + 2]] = k;
+        k = SA[i + 2];
+        PLCP[SA[i + 3]] = k;
+        k = SA[i + 3];
+    }
+
+    for (j += prefetch_distance + 3; i < j; i += 1) {
+        PLCP[SA[i]] = k;
+        k = SA[i];
+    }
+}
+
+static void libsais_compute_phi_omp(const sa_sint_t * RESTRICT SA, sa_sint_t * RESTRICT PLCP, sa_sint_t n,
+                                    sa_sint_t threads) {
+    {
+        (void)(threads);
+
+        fast_sint_t omp_thread_num = 0;
+        fast_sint_t omp_num_threads = 1;
+
+        fast_sint_t omp_block_stride = (n / omp_num_threads) & (-16);
+        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
+        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : n - omp_block_start;
+
+        libsais_compute_phi(SA, PLCP, n, omp_block_start, omp_block_size);
+    }
+}
+
+static void libsais_compute_plcp(const u8 * RESTRICT T, sa_sint_t * RESTRICT PLCP, fast_sint_t n,
+                                 fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j, l = 0;
+    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance; i < j; i += 1) {
+        prefetch(&T[PLCP[i + prefetch_distance] + l]);
+
+        fast_sint_t k = PLCP[i], m = n - (i > k ? i : k);
+        while (l < m && T[i + l] == T[k + l]) {
+            l++;
+        }
+
+        PLCP[i] = (sa_sint_t)l;
+        l -= (l != 0);
+    }
+
+    for (j += prefetch_distance; i < j; i += 1) {
+        fast_sint_t k = PLCP[i], m = n - (i > k ? i : k);
+        while (l < m && T[i + l] == T[k + l]) {
+            l++;
+        }
+
+        PLCP[i] = (sa_sint_t)l;
+        l -= (l != 0);
+    }
+}
+
+static void libsais_compute_plcp_omp(const u8 * RESTRICT T, sa_sint_t * RESTRICT PLCP, sa_sint_t n, sa_sint_t threads) {
+    {
+        (void)(threads);
+
+        fast_sint_t omp_thread_num = 0;
+        fast_sint_t omp_num_threads = 1;
+
+        fast_sint_t omp_block_stride = (n / omp_num_threads) & (-16);
+        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
+        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : n - omp_block_start;
+
+        libsais_compute_plcp(T, PLCP, n, omp_block_start, omp_block_size);
+    }
+}
+
+static void libsais_compute_lcp(const sa_sint_t * RESTRICT PLCP, const sa_sint_t * RESTRICT SA,
+                                sa_sint_t * RESTRICT LCP, fast_sint_t omp_block_start, fast_sint_t omp_block_size) {
+    const fast_sint_t prefetch_distance = 32;
+
+    fast_sint_t i, j;
+    for (i = omp_block_start, j = omp_block_start + omp_block_size - prefetch_distance - 3; i < j; i += 4) {
+        prefetch(&PLCP[SA[i + prefetch_distance + 0]]);
+        prefetch(&PLCP[SA[i + prefetch_distance + 1]]);
+
+        LCP[i + 0] = PLCP[SA[i + 0]];
+        LCP[i + 1] = PLCP[SA[i + 1]];
+
+        prefetch(&PLCP[SA[i + prefetch_distance + 2]]);
+        prefetch(&PLCP[SA[i + prefetch_distance + 3]]);
+
+        LCP[i + 2] = PLCP[SA[i + 2]];
+        LCP[i + 3] = PLCP[SA[i + 3]];
+    }
+
+    for (j += prefetch_distance + 3; i < j; i += 1) {
+        LCP[i] = PLCP[SA[i]];
+    }
+}
+
+static void libsais_compute_lcp_omp(const sa_sint_t * RESTRICT PLCP, const sa_sint_t * RESTRICT SA,
+                                    sa_sint_t * RESTRICT LCP, sa_sint_t n, sa_sint_t threads) {
+    {
+        (void)(threads);
+
+        fast_sint_t omp_thread_num = 0;
+        fast_sint_t omp_num_threads = 1;
+
+        fast_sint_t omp_block_stride = (n / omp_num_threads) & (-16);
+        fast_sint_t omp_block_start = omp_thread_num * omp_block_stride;
+        fast_sint_t omp_block_size = omp_thread_num < omp_num_threads - 1 ? omp_block_stride : n - omp_block_start;
+
+        libsais_compute_lcp(PLCP, SA, LCP, omp_block_start, omp_block_size);
+    }
+}
+
+static s32 libsais_plcp(const u8 * T, const s32 * SA, s32 * PLCP, s32 n) {
+    if ((T == NULL) || (SA == NULL) || (PLCP == NULL) || (n < 0)) {
+        return -1;
+    } else if (n <= 1) {
+        if (n == 1) {
+            PLCP[0] = 0;
+        }
+        return 0;
+    }
+
+    libsais_compute_phi_omp(SA, PLCP, n, 1);
+    libsais_compute_plcp_omp(T, PLCP, n, 1);
+
+    return 0;
+}
+
+static s32 libsais_lcp(const s32 * PLCP, const s32 * SA, s32 * LCP, s32 n) {
+    if ((PLCP == NULL) || (SA == NULL) || (LCP == NULL) || (n < 0)) {
+        return -1;
+    } else if (n <= 1) {
+        if (n == 1) {
+            LCP[0] = PLCP[SA[0]];
+        }
+        return 0;
+    }
+
+    libsais_compute_lcp_omp(PLCP, SA, LCP, n, 1);
+
+    return 0;
+}
+
+#endif
```

### Comparing `bzip3-0.1.2rc1/dep/src/libbz3.c` & `bzip3-0.1.3rc1/dep/src/libbz3.c`

 * *Files 12% similar despite different names*

```diff
@@ -1,898 +1,918 @@
-
-/*
- * BZip3 - A spiritual successor to BZip2.
- * Copyright (C) 2022 Kamila Szewczyk
- *
- * This program is free software: you can redistribute it and/or modify it
- * under the terms of the GNU Lesser General Public License as published by the Free
- * Software Foundation, either version 3 of the License, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU Lesser General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "libbz3.h"
-
-#include <stdlib.h>
-#include <string.h>
-
-#include "libsais.h"
-
-/* CRC32 implementation. Since CRC32 generally takes less than 1% of the runtime on real-world data (e.g. the
-   Silesia corpus), I decided against using hardware CRC32. This implementation is simple, fast, fool-proof and
-   good enough to be used with bzip3. */
-
-static const u32 crc32Table[256] = {
-    0x00000000L, 0xF26B8303L, 0xE13B70F7L, 0x1350F3F4L, 0xC79A971FL, 0x35F1141CL, 0x26A1E7E8L, 0xD4CA64EBL, 0x8AD958CFL,
-    0x78B2DBCCL, 0x6BE22838L, 0x9989AB3BL, 0x4D43CFD0L, 0xBF284CD3L, 0xAC78BF27L, 0x5E133C24L, 0x105EC76FL, 0xE235446CL,
-    0xF165B798L, 0x030E349BL, 0xD7C45070L, 0x25AFD373L, 0x36FF2087L, 0xC494A384L, 0x9A879FA0L, 0x68EC1CA3L, 0x7BBCEF57L,
-    0x89D76C54L, 0x5D1D08BFL, 0xAF768BBCL, 0xBC267848L, 0x4E4DFB4BL, 0x20BD8EDEL, 0xD2D60DDDL, 0xC186FE29L, 0x33ED7D2AL,
-    0xE72719C1L, 0x154C9AC2L, 0x061C6936L, 0xF477EA35L, 0xAA64D611L, 0x580F5512L, 0x4B5FA6E6L, 0xB93425E5L, 0x6DFE410EL,
-    0x9F95C20DL, 0x8CC531F9L, 0x7EAEB2FAL, 0x30E349B1L, 0xC288CAB2L, 0xD1D83946L, 0x23B3BA45L, 0xF779DEAEL, 0x05125DADL,
-    0x1642AE59L, 0xE4292D5AL, 0xBA3A117EL, 0x4851927DL, 0x5B016189L, 0xA96AE28AL, 0x7DA08661L, 0x8FCB0562L, 0x9C9BF696L,
-    0x6EF07595L, 0x417B1DBCL, 0xB3109EBFL, 0xA0406D4BL, 0x522BEE48L, 0x86E18AA3L, 0x748A09A0L, 0x67DAFA54L, 0x95B17957L,
-    0xCBA24573L, 0x39C9C670L, 0x2A993584L, 0xD8F2B687L, 0x0C38D26CL, 0xFE53516FL, 0xED03A29BL, 0x1F682198L, 0x5125DAD3L,
-    0xA34E59D0L, 0xB01EAA24L, 0x42752927L, 0x96BF4DCCL, 0x64D4CECFL, 0x77843D3BL, 0x85EFBE38L, 0xDBFC821CL, 0x2997011FL,
-    0x3AC7F2EBL, 0xC8AC71E8L, 0x1C661503L, 0xEE0D9600L, 0xFD5D65F4L, 0x0F36E6F7L, 0x61C69362L, 0x93AD1061L, 0x80FDE395L,
-    0x72966096L, 0xA65C047DL, 0x5437877EL, 0x4767748AL, 0xB50CF789L, 0xEB1FCBADL, 0x197448AEL, 0x0A24BB5AL, 0xF84F3859L,
-    0x2C855CB2L, 0xDEEEDFB1L, 0xCDBE2C45L, 0x3FD5AF46L, 0x7198540DL, 0x83F3D70EL, 0x90A324FAL, 0x62C8A7F9L, 0xB602C312L,
-    0x44694011L, 0x5739B3E5L, 0xA55230E6L, 0xFB410CC2L, 0x092A8FC1L, 0x1A7A7C35L, 0xE811FF36L, 0x3CDB9BDDL, 0xCEB018DEL,
-    0xDDE0EB2AL, 0x2F8B6829L, 0x82F63B78L, 0x709DB87BL, 0x63CD4B8FL, 0x91A6C88CL, 0x456CAC67L, 0xB7072F64L, 0xA457DC90L,
-    0x563C5F93L, 0x082F63B7L, 0xFA44E0B4L, 0xE9141340L, 0x1B7F9043L, 0xCFB5F4A8L, 0x3DDE77ABL, 0x2E8E845FL, 0xDCE5075CL,
-    0x92A8FC17L, 0x60C37F14L, 0x73938CE0L, 0x81F80FE3L, 0x55326B08L, 0xA759E80BL, 0xB4091BFFL, 0x466298FCL, 0x1871A4D8L,
-    0xEA1A27DBL, 0xF94AD42FL, 0x0B21572CL, 0xDFEB33C7L, 0x2D80B0C4L, 0x3ED04330L, 0xCCBBC033L, 0xA24BB5A6L, 0x502036A5L,
-    0x4370C551L, 0xB11B4652L, 0x65D122B9L, 0x97BAA1BAL, 0x84EA524EL, 0x7681D14DL, 0x2892ED69L, 0xDAF96E6AL, 0xC9A99D9EL,
-    0x3BC21E9DL, 0xEF087A76L, 0x1D63F975L, 0x0E330A81L, 0xFC588982L, 0xB21572C9L, 0x407EF1CAL, 0x532E023EL, 0xA145813DL,
-    0x758FE5D6L, 0x87E466D5L, 0x94B49521L, 0x66DF1622L, 0x38CC2A06L, 0xCAA7A905L, 0xD9F75AF1L, 0x2B9CD9F2L, 0xFF56BD19L,
-    0x0D3D3E1AL, 0x1E6DCDEEL, 0xEC064EEDL, 0xC38D26C4L, 0x31E6A5C7L, 0x22B65633L, 0xD0DDD530L, 0x0417B1DBL, 0xF67C32D8L,
-    0xE52CC12CL, 0x1747422FL, 0x49547E0BL, 0xBB3FFD08L, 0xA86F0EFCL, 0x5A048DFFL, 0x8ECEE914L, 0x7CA56A17L, 0x6FF599E3L,
-    0x9D9E1AE0L, 0xD3D3E1ABL, 0x21B862A8L, 0x32E8915CL, 0xC083125FL, 0x144976B4L, 0xE622F5B7L, 0xF5720643L, 0x07198540L,
-    0x590AB964L, 0xAB613A67L, 0xB831C993L, 0x4A5A4A90L, 0x9E902E7BL, 0x6CFBAD78L, 0x7FAB5E8CL, 0x8DC0DD8FL, 0xE330A81AL,
-    0x115B2B19L, 0x020BD8EDL, 0xF0605BEEL, 0x24AA3F05L, 0xD6C1BC06L, 0xC5914FF2L, 0x37FACCF1L, 0x69E9F0D5L, 0x9B8273D6L,
-    0x88D28022L, 0x7AB90321L, 0xAE7367CAL, 0x5C18E4C9L, 0x4F48173DL, 0xBD23943EL, 0xF36E6F75L, 0x0105EC76L, 0x12551F82L,
-    0xE03E9C81L, 0x34F4F86AL, 0xC69F7B69L, 0xD5CF889DL, 0x27A40B9EL, 0x79B737BAL, 0x8BDCB4B9L, 0x988C474DL, 0x6AE7C44EL,
-    0xBE2DA0A5L, 0x4C4623A6L, 0x5F16D052L, 0xAD7D5351L
-};
-
-static u32 crc32sum(u32 crc, u8 * RESTRICT buf, size_t size) {
-    while (size--) crc = crc32Table[((crc >> 24) ^ *(buf++)) & 0xff] ^ (crc << 8);
-    return crc;
-}
-
-/* LZP code. These constants were manually tuned to give the best compression ratio while using relatively
-   little resources. The LZP dictionary is only around 1MiB in size and the minimum match length was chosen
-   so that LZP would not interfere too much with the Burrows-Wheeler transform and the arithmetic coder, and
-   just collapse long redundant data instead (for a major speed-up at a low compression ratio cost - in fact,
-   LZP preprocessing often improves compression in some cases). */
-
-/* A heavily modified version of libbsc's LZP predictor w/ unaligned accesses follows. This one has single thread
-   performance and provides better compression ratio. It is also mostly UB-free and less brittle during
-   AFL fuzzing. */
-
-#define LZP_DICTIONARY 18
-#define LZP_MIN_MATCH 40
-
-#define MATCH 0xf2
-
-static s32 lzp_encode_block(const u8 * RESTRICT in, const u8 * in_end, u8 * RESTRICT out, u8 * out_end,
-                            s32 * RESTRICT lut) {
-    const u8 * ins = in;
-    const u8 * outs = out;
-    const u8 * out_eob = out_end - 8;
-    const u8 * heur = in;
-
-    u32 ctx;
-
-    for (s32 i = 0; i < 4; ++i) *out++ = *in++;
-
-    ctx = ((u32)in[-1]) | (((u32)in[-2]) << 8) | (((u32)in[-3]) << 16) | (((u32)in[-4]) << 24);
-
-    while (in < in_end - LZP_MIN_MATCH - 32 && out < out_eob) {
-        u32 idx = (ctx >> 15 ^ ctx ^ ctx >> 3) & ((s32)(1 << LZP_DICTIONARY) - 1);
-        s32 val = lut[idx];
-        lut[idx] = in - ins;
-        if (val > 0) {
-            const u8 * RESTRICT ref = ins + val;
-            if (memcmp(in + LZP_MIN_MATCH - 4, ref + LZP_MIN_MATCH - 4, sizeof(u32)) == 0 &&
-                memcmp(in, ref, sizeof(u32)) == 0) {
-                if (heur > in && *(u32 *)heur != *(u32 *)(ref + (heur - in))) goto not_found;
-
-                s32 len = 4;
-                for (; in + len < in_end - LZP_MIN_MATCH - 32; len += sizeof(u32)) {
-                    if (*(u32 *)(in + len) != *(u32 *)(ref + len)) break;
-                }
-
-                if (len < LZP_MIN_MATCH) {
-                    if (heur < in + len) heur = in + len;
-                    goto not_found;
-                }
-
-                len += in[len] == ref[len];
-                len += in[len] == ref[len];
-                len += in[len] == ref[len];
-
-                in += len;
-                ctx = ((u32)in[-1]) | (((u32)in[-2]) << 8) | (((u32)in[-3]) << 16) | (((u32)in[-4]) << 24);
-
-                *out++ = MATCH;
-
-                len -= LZP_MIN_MATCH;
-                while (len >= 254) {
-                    len -= 254;
-                    *out++ = 254;
-                    if (out >= out_eob) break;
-                }
-
-                *out++ = len;
-            } else {
-            not_found:;
-                u8 next = *out++ = *in++;
-                ctx = ctx << 8 | next;
-                if (next == MATCH) *out++ = 255;
-            }
-        } else {
-            ctx = (ctx << 8) | (*out++ = *in++);
-        }
-    }
-
-    ctx = ((u32)in[-1]) | (((u32)in[-2]) << 8) | (((u32)in[-3]) << 16) | (((u32)in[-4]) << 24);
-
-    while (in < in_end && out < out_eob) {
-        u32 idx = (ctx >> 15 ^ ctx ^ ctx >> 3) & ((s32)(1 << LZP_DICTIONARY) - 1);
-        s32 val = lut[idx];
-        lut[idx] = (s32)(in - ins);
-
-        u8 next = *out++ = *in++;
-        ctx = ctx << 8 | next;
-        if (next == MATCH && val > 0) *out++ = 255;
-    }
-
-    return out >= out_eob ? -1 : (s32)(out - outs);
-}
-
-static s32 lzp_decode_block(const u8 * RESTRICT in, const u8 * in_end, s32 * RESTRICT lut, u8 * RESTRICT out,
-                            const u8 * out_end) {
-    const u8 * outs = out;
-
-    for (s32 i = 0; i < 4; ++i) *out++ = *in++;
-
-    u32 ctx = ((u32)out[-1]) | (((u32)out[-2]) << 8) | (((u32)out[-3]) << 16) | (((u32)out[-4]) << 24);
-
-    while (in < in_end && out < out_end) {
-        u32 idx = (ctx >> 15 ^ ctx ^ ctx >> 3) & ((s32)(1 << LZP_DICTIONARY) - 1);
-        s32 val = lut[idx];
-        lut[idx] = (s32)(out - outs);
-        if (*in == MATCH && val > 0) {
-            in++;
-            if (*in != 255) {
-                s32 len = LZP_MIN_MATCH;
-                while (1) {
-                    if (in == in_end) return -1;
-                    len += *in;
-                    if (*in++ != 254) break;
-                }
-
-                const u8 * ref = outs + val;
-                u8 * oe = out + len;
-                if (oe > out_end) oe = out_end;
-
-                while (out < oe) *out++ = *ref++;
-
-                ctx = ((u32)out[-1]) | (((u32)out[-2]) << 8) | (((u32)out[-3]) << 16) | (((u32)out[-4]) << 24);
-            } else {
-                in++;
-                ctx = (ctx << 8) | (*out++ = MATCH);
-            }
-        } else {
-            ctx = (ctx << 8) | (*out++ = *in++);
-        }
-    }
-
-    return out - outs;
-}
-
-static s32 lzp_compress(const u8 * RESTRICT in, u8 * RESTRICT out, s32 n, s32 * RESTRICT lut) {
-    if (n < LZP_MIN_MATCH + 32) return -1;
-
-    memset(lut, 0, sizeof(s32) * (1 << LZP_DICTIONARY));
-
-    return lzp_encode_block(in, in + n, out, out + n, lut);
-}
-
-static s32 lzp_decompress(const u8 * RESTRICT in, u8 * RESTRICT out, s32 n, s32 max, s32 * RESTRICT lut) {
-    if (n < 4) return -1;
-
-    memset(lut, 0, sizeof(s32) * (1 << LZP_DICTIONARY));
-
-    return lzp_decode_block(in, in + n, lut, out, out + max);
-}
-
-/* RLE code. Unlike RLE in other compressors, we collapse all runs if they yield a net gain
-   for a given character and encode this as a set bit in the RLE metadata. This improves the
-   performance and reduces the amount of collapsing done in normal blocks (so that BWT+AC can
-   be more efficient) while we still filter out all the pathological data. */
-
-static s32 mrlec(u8 * in, s32 inlen, u8 * out) {
-    u8 * ip = in;
-    u8 * in_end = in + inlen;
-    s32 op = 0;
-    s32 c, pc = -1;
-    s32 t[256] = { 0 };
-    s32 run = 0;
-    while ((c = (ip < in_end ? *ip++ : -1)) != -1) {
-        if (c == pc)
-            t[c] += (++run % 255) != 0;
-        else
-            --t[c], run = 0;
-        pc = c;
-    }
-    for (s32 i = 0; i < 32; ++i) {
-        c = 0;
-        for (s32 j = 0; j < 8; ++j) c += (t[i * 8 + j] > 0) << j;
-        out[op++] = c;
-    }
-    ip = in;
-    c = pc = -1;
-    run = 0;
-    do {
-        c = ip < in_end ? *ip++ : -1;
-        if (c == pc)
-            ++run;
-        else if (run > 0 && t[pc] > 0) {
-            out[op++] = pc;
-            for (; run > 255; run -= 255) out[op++] = 255;
-            out[op++] = run - 1;
-            run = 1;
-        } else
-            for (++run; run > 1; --run) out[op++] = pc;
-        pc = c;
-    } while (c != -1);
-
-    return op;
-}
-
-static void mrled(u8 * RESTRICT in, u8 * RESTRICT out, s32 outlen) {
-    s32 op = 0, ip = 0;
-
-    s32 c, pc = -1;
-    s32 t[256] = { 0 };
-    s32 run = 0;
-
-    for (s32 i = 0; i < 32; ++i) {
-        c = in[ip++];
-        for (s32 j = 0; j < 8; ++j) t[i * 8 + j] = (c >> j) & 1;
-    }
-
-    while (op < outlen) {
-        c = in[ip++];
-        if (t[c]) {
-            for (run = 0; (pc = in[ip++]) == 255; run += 255)
-                ;
-            run += pc + 1;
-            for (; run > 0 && op < outlen; --run) out[op++] = c;
-        } else
-            out[op++] = c;
-    }
-}
-
-/* The entropy coder. Uses an arithmetic coder implementation outlined in Matt Mahoney's DCE. */
-
-typedef struct {
-    /* Input/output. */
-    u8 *in_queue, *out_queue;
-    s32 input_ptr, output_ptr, input_max;
-
-    /* C0, C1 - used for making the initial prediction, C2 used for an APM with a slightly low
-       learning rate (6) and 512 contexts. kanzi merges C0 and C1, uses slightly different
-       counter initialisation code and prediction code which from my tests tends to be suboptimal. */
-    u16 C0[256], C1[256][256], C2[512][17];
-} state;
-
-#define write_out(s, c) (s)->out_queue[(s)->output_ptr++] = (c)
-#define read_in(s) ((s)->input_ptr < (s)->input_max ? (s)->in_queue[(s)->input_ptr++] : -1)
-
-#define update0(p, x) (p) = ((p) - ((p) >> x))
-#define update1(p, x) (p) = ((p) + (((p) ^ 65535) >> x))
-
-static void begin(state * s) {
-    prefetch(s);
-    for (int i = 0; i < 256; i++) s->C0[i] = 1 << 15;
-    for (int i = 0; i < 256; i++)
-        for (int j = 0; j < 256; j++) s->C1[i][j] = 1 << 15;
-    for (int i = 0; i < 2; i++)
-        for (int j = 0; j < 256; j++)
-            for (int k = 0; k < 17; k++) s->C2[2 * j + i][k] = (k << 12) - (k == 16);  // Firm difference from stdpack.
-}
-
-static void encode_bytes(state * s, u8 * buf, s32 size) {
-    /* Arithmetic coding, detecting runs of characters in the file */
-    u32 high = 0xFFFFFFFF, low = 0, c1 = 0, c2 = 0, run = 0;
-
-    for (s32 i = 0; i < size; i++) {
-        u8 c = buf[i];
-
-        if (c1 == c2)
-            ++run;
-        else
-            run = 0;
-
-        const int f = run > 2;
-
-        int ctx = 1;
-
-        while (ctx < 256) {
-            const int p0 = s->C0[ctx];
-            const int p1 = s->C1[c1][ctx];
-            const int p2 = s->C1[c2][ctx];
-            const int p = ((p0 + p1) * 7 + p2 + p2) >> 4;
-
-            const int j = p >> 12;
-            const int x1 = s->C2[2 * ctx + f][j];
-            const int x2 = s->C2[2 * ctx + f][j + 1];
-            const int ssep = x1 + (((x2 - x1) * (p & 4095)) >> 12);
-
-            if (c & 128) {
-                high = low + (((u64)(high - low) * (ssep * 3 + p)) >> 18);
-
-                while ((low ^ high) < (1 << 24)) {
-                    write_out(s, low >> 24);
-                    low <<= 8;
-                    high = (high << 8) + 0xFF;
-                }
-
-                update1(s->C0[ctx], 2);
-                update1(s->C1[c1][ctx], 4);
-                update1(s->C2[2 * ctx + f][j], 6);
-                update1(s->C2[2 * ctx + f][j + 1], 6);
-                ctx += ctx + 1;
-            } else {
-                low += (((u64)(high - low) * (ssep * 3 + p)) >> 18) + 1;
-
-                // Write identical bits.
-                while ((low ^ high) < (1 << 24)) {
-                    write_out(s, low >> 24);  // Same as high >> 24
-                    low <<= 8;
-                    high = (high << 8) + 0xFF;
-                }
-
-                update0(s->C0[ctx], 2);
-                update0(s->C1[c1][ctx], 4);
-                update0(s->C2[2 * ctx + f][j], 6);
-                update0(s->C2[2 * ctx + f][j + 1], 6);
-                ctx += ctx;
-            }
-
-            c <<= 1;
-        }
-
-        c2 = c1;
-        c1 = ctx & 255;
-    }
-
-    write_out(s, low >> 24);
-    low <<= 8;
-    write_out(s, low >> 24);
-    low <<= 8;
-    write_out(s, low >> 24);
-    low <<= 8;
-    write_out(s, low >> 24);
-    low <<= 8;
-}
-
-static void decode_bytes(state * s, u8 * c, s32 size) {
-    u32 high = 0xFFFFFFFF, low = 0, c1 = 0, c2 = 0, run = 0, code = 0;
-
-    code = (code << 8) + read_in(s);
-    code = (code << 8) + read_in(s);
-    code = (code << 8) + read_in(s);
-    code = (code << 8) + read_in(s);
-
-    for (s32 i = 0; i < size; i++) {
-        if (c1 == c2)
-            ++run;
-        else
-            run = 0;
-
-        const int f = run > 2;
-
-        int ctx = 1;
-
-        while (ctx < 256) {
-            const int p0 = s->C0[ctx];
-            const int p1 = s->C1[c1][ctx];
-            const int p2 = s->C1[c2][ctx];
-            const int p = ((p0 + p1) * 7 + p2 + p2) >> 4;
-
-            const int j = p >> 12;
-            const int x1 = s->C2[2 * ctx + f][j];
-            const int x2 = s->C2[2 * ctx + f][j + 1];
-            const int ssep = x1 + (((x2 - x1) * (p & 4095)) >> 12);
-
-            const u32 mid = low + (((u64)(high - low) * (ssep * 3 + p)) >> 18);
-            const u8 bit = code <= mid;
-            if (bit)
-                high = mid;
-            else
-                low = mid + 1;
-            while ((low ^ high) < (1 << 24)) {
-                low <<= 8;
-                high = (high << 8) + 255;
-                code = (code << 8) + read_in(s);
-            }
-
-            if (bit) {
-                update1(s->C0[ctx], 2);
-                update1(s->C1[c1][ctx], 4);
-                update1(s->C2[2 * ctx + f][j], 6);
-                update1(s->C2[2 * ctx + f][j + 1], 6);
-                ctx += ctx + 1;
-            } else {
-                update0(s->C0[ctx], 2);
-                update0(s->C1[c1][ctx], 4);
-                update0(s->C2[2 * ctx + f][j], 6);
-                update0(s->C2[2 * ctx + f][j + 1], 6);
-                ctx += ctx;
-            }
-        }
-
-        c2 = c1;
-        c[i] = c1 = ctx & 255;
-    }
-}
-
-/* Public API. */
-
-struct bz3_state {
-    u8 * swap_buffer;
-    s32 block_size;
-    s32 *sais_array, *lzp_lut;
-    state * cm_state;
-    s8 last_error;
-};
-
-BZIP3_API s8 bz3_last_error(struct bz3_state * state) { return state->last_error; }
-
-BZIP3_API const char * bz3_version(void) { return VERSION; }
-
-BZIP3_API size_t bz3_bound(size_t input_size) { return input_size + input_size / 50 + 32; }
-
-BZIP3_API const char * bz3_strerror(struct bz3_state * state) {
-    switch (state->last_error) {
-        case BZ3_OK:
-            return "No error";
-        case BZ3_ERR_OUT_OF_BOUNDS:
-            return "Data index out of bounds";
-        case BZ3_ERR_BWT:
-            return "Burrows-Wheeler transform failed";
-        case BZ3_ERR_CRC:
-            return "CRC32 check failed";
-        case BZ3_ERR_MALFORMED_HEADER:
-            return "Malformed header";
-        case BZ3_ERR_TRUNCATED_DATA:
-            return "Truncated data";
-        case BZ3_ERR_DATA_TOO_BIG:
-            return "Too much data";
-        default:
-            return "Unknown error";
-    }
-}
-
-BZIP3_API struct bz3_state * bz3_new(s32 block_size) {
-    if (block_size < KiB(65) || block_size > MiB(511)) {
-        return NULL;
-    }
-
-    struct bz3_state * bz3_state = malloc(sizeof(struct bz3_state));
-
-    if (!bz3_state) {
-        return NULL;
-    }
-
-    bz3_state->cm_state = malloc(sizeof(state));
-
-    bz3_state->swap_buffer = malloc(bz3_bound(block_size));
-    bz3_state->sais_array = malloc((block_size + 128) * sizeof(s32));
-    memset(bz3_state->sais_array, 0, sizeof(s32) * (block_size + 128));
-
-    bz3_state->lzp_lut = calloc(1 << LZP_DICTIONARY, sizeof(s32));
-
-    if (!bz3_state->cm_state || !bz3_state->swap_buffer || !bz3_state->sais_array || !bz3_state->lzp_lut) {
-        if (bz3_state->cm_state) free(bz3_state->cm_state);
-        if (bz3_state->swap_buffer) free(bz3_state->swap_buffer);
-        if (bz3_state->sais_array) free(bz3_state->sais_array);
-        if (bz3_state->lzp_lut) free(bz3_state->lzp_lut);
-        free(bz3_state);
-        return NULL;
-    }
-
-    bz3_state->block_size = block_size;
-
-    bz3_state->last_error = BZ3_OK;
-
-    return bz3_state;
-}
-
-BZIP3_API void bz3_free(struct bz3_state * state) {
-    free(state->swap_buffer);
-    free(state->sais_array);
-    free(state->cm_state);
-    free(state->lzp_lut);
-    free(state);
-}
-
-#define swap(x, y)    \
-    {                 \
-        u8 * tmp = x; \
-        x = y;        \
-        y = tmp;      \
-    }
-
-BZIP3_API s32 bz3_encode_block(struct bz3_state * state, u8 * buffer, s32 data_size) {
-    u8 *b1 = buffer, *b2 = state->swap_buffer;
-
-    if (data_size > state->block_size) {
-        state->last_error = BZ3_ERR_DATA_TOO_BIG;
-        return -1;
-    }
-
-    u32 crc32 = crc32sum(1, b1, data_size);
-
-    // Ignore small blocks. They won't benefit from the entropy coding step.
-    if (data_size < 64) {
-        memmove(b1 + 8, b1, data_size);
-        write_neutral_s32(b1, crc32);
-        write_neutral_s32(b1 + 4, -1);
-        return data_size + 8;
-    }
-
-    // Back to front:
-    // bit 1: lzp | no lzp
-    // bit 2: srt | no srt
-    s8 model = 0;
-    s32 lzp_size, rle_size;
-
-    rle_size = mrlec(b1, data_size, b2);
-    if (rle_size < data_size + 64) {
-        swap(b1, b2);
-        data_size = rle_size;
-        model |= 4;
-    }
-
-    lzp_size = lzp_compress(b1, b2, data_size, state->lzp_lut);
-    if (lzp_size > 0 && lzp_size < data_size + 64) {
-        swap(b1, b2);
-        data_size = lzp_size;
-        model |= 2;
-    }
-
-    s32 bwt_idx = libsais_bwt(b1, b2, state->sais_array, data_size, 0, NULL);
-    if (bwt_idx < 0) {
-        state->last_error = BZ3_ERR_BWT;
-        return -1;
-    }
-
-    // Compute the amount of overhead dwords.
-    s32 overhead = 2;           // CRC32 + BWT index
-    if (model & 2) overhead++;  // LZP
-    if (model & 4) overhead++;  // RLE
-
-    begin(state->cm_state);
-    state->cm_state->out_queue = b1 + overhead * 4 + 1;
-    state->cm_state->output_ptr = 0;
-    encode_bytes(state->cm_state, b2, data_size);
-    data_size = state->cm_state->output_ptr;
-
-    // Write the header. Starting with common entries.
-    write_neutral_s32(b1, crc32);
-    write_neutral_s32(b1 + 4, bwt_idx);
-    b1[8] = model;
-
-    s32 p = 0;
-    if (model & 2) write_neutral_s32(b1 + 9 + 4 * p++, lzp_size);
-    if (model & 4) write_neutral_s32(b1 + 9 + 4 * p++, rle_size);
-
-    state->last_error = BZ3_OK;
-
-    if (b1 != buffer) memcpy(buffer, b1, data_size + overhead * 4 + 1);
-
-    return data_size + overhead * 4 + 1;
-}
-
-BZIP3_API s32 bz3_decode_block(struct bz3_state * state, u8 * buffer, s32 data_size, s32 orig_size) {
-    // Read the header.
-    u32 crc32 = read_neutral_s32(buffer);
-    s32 bwt_idx = read_neutral_s32(buffer + 4);
-
-    if (data_size > bz3_bound(state->block_size) || data_size < 0) {
-        state->last_error = BZ3_ERR_MALFORMED_HEADER;
-        return -1;
-    }
-
-    if (bwt_idx == -1) {
-        if (data_size - 8 > 64) {
-            state->last_error = BZ3_ERR_MALFORMED_HEADER;
-            return -1;
-        }
-
-        memmove(buffer, buffer + 8, data_size - 8);
-
-        if (crc32sum(1, buffer, data_size - 8) != crc32) {
-            state->last_error = BZ3_ERR_CRC;
-            return -1;
-        }
-
-        return data_size - 8;
-    }
-
-    s8 model = buffer[8];
-    s32 lzp_size = -1, rle_size = -1, p = 0;
-
-    if (model & 2) lzp_size = read_neutral_s32(buffer + 9 + 4 * p++);
-    if (model & 4) rle_size = read_neutral_s32(buffer + 9 + 4 * p++);
-
-    p += 2;
-
-    data_size -= p * 4 + 1;
-
-    if (((model & 2) && (lzp_size > bz3_bound(state->block_size) || lzp_size < 0)) ||
-        ((model & 4) && (rle_size > bz3_bound(state->block_size) || rle_size < 0))) {
-        state->last_error = BZ3_ERR_MALFORMED_HEADER;
-        return -1;
-    }
-
-    if (orig_size > bz3_bound(state->block_size) || orig_size < 0) {
-        state->last_error = BZ3_ERR_MALFORMED_HEADER;
-        return -1;
-    }
-
-    // Decode the data.
-    u8 *b1 = buffer, *b2 = state->swap_buffer;
-
-    begin(state->cm_state);
-    state->cm_state->in_queue = b1 + p * 4 + 1;
-    state->cm_state->input_ptr = 0;
-    state->cm_state->input_max = data_size;
-
-    s32 size_src;
-
-    if (model & 2)
-        size_src = lzp_size;
-    else if (model & 4)
-        size_src = rle_size;
-    else
-        size_src = orig_size;
-
-    decode_bytes(state->cm_state, b2, size_src);
-    swap(b1, b2);
-
-    if (bwt_idx >= size_src) {
-        state->last_error = BZ3_ERR_MALFORMED_HEADER;
-        return -1;
-    }
-
-    // Undo BWT
-    if (libsais_unbwt(b1, b2, state->sais_array, size_src, NULL, bwt_idx) < 0) {
-        state->last_error = BZ3_ERR_BWT;
-        return -1;
-    }
-    swap(b1, b2);
-
-    // Undo LZP
-    if (model & 2) {
-        size_src = lzp_decompress(b1, b2, lzp_size, bz3_bound(state->block_size), state->lzp_lut);
-        if (size_src == -1) {
-            state->last_error = BZ3_ERR_CRC;
-            return -1;
-        }
-        swap(b1, b2);
-    }
-
-    if (model & 4) {
-        mrled(b1, b2, orig_size);
-        size_src = orig_size;
-        swap(b1, b2);
-    }
-
-    state->last_error = BZ3_OK;
-
-    if (size_src > bz3_bound(state->block_size) || size_src < 0) {
-        state->last_error = BZ3_ERR_MALFORMED_HEADER;
-        return -1;
-    }
-
-    if (b1 != buffer) memcpy(buffer, b1, size_src);
-
-    if (crc32 != crc32sum(1, buffer, size_src)) {
-        state->last_error = BZ3_ERR_CRC;
-        return -1;
-    }
-
-    return size_src;
-}
-
-#undef swap
-
-#ifdef PTHREAD
-
-    #include <pthread.h>
-
-typedef struct {
-    struct bz3_state * state;
-    u8 * buffer;
-    s32 size;
-} encode_thread_msg;
-
-typedef struct {
-    struct bz3_state * state;
-    u8 * buffer;
-    s32 size;
-    s32 orig_size;
-} decode_thread_msg;
-
-static void * bz3_init_encode_thread(void * _msg) {
-    encode_thread_msg * msg = _msg;
-    msg->size = bz3_encode_block(msg->state, msg->buffer, msg->size);
-    pthread_exit(NULL);
-    return NULL;  // unreachable
-}
-
-static void * bz3_init_decode_thread(void * _msg) {
-    decode_thread_msg * msg = _msg;
-    bz3_decode_block(msg->state, msg->buffer, msg->size, msg->orig_size);
-    pthread_exit(NULL);
-    return NULL;  // unreachable
-}
-
-BZIP3_API void bz3_encode_blocks(struct bz3_state * states[], u8 * buffers[], s32 sizes[], s32 n) {
-    encode_thread_msg messages[n];
-    pthread_t threads[n];
-    for (s32 i = 0; i < n; i++) {
-        messages[i].state = states[i];
-        messages[i].buffer = buffers[i];
-        messages[i].size = sizes[i];
-        pthread_create(&threads[i], NULL, bz3_init_encode_thread, &messages[i]);
-    }
-    for (s32 i = 0; i < n; i++) pthread_join(threads[i], NULL);
-    for (s32 i = 0; i < n; i++) sizes[i] = messages[i].size;
-}
-
-BZIP3_API void bz3_decode_blocks(struct bz3_state * states[], u8 * buffers[], s32 sizes[], s32 orig_sizes[], s32 n) {
-    decode_thread_msg messages[n];
-    pthread_t threads[n];
-    for (s32 i = 0; i < n; i++) {
-        messages[i].state = states[i];
-        messages[i].buffer = buffers[i];
-        messages[i].size = sizes[i];
-        messages[i].orig_size = orig_sizes[i];
-        pthread_create(&threads[i], NULL, bz3_init_decode_thread, &messages[i]);
-    }
-    for (s32 i = 0; i < n; i++) pthread_join(threads[i], NULL);
-}
-
-#endif
-
-/* High level API implementations. */
-
-BZIP3_API int bz3_compress(u32 block_size, const u8 * const in, u8 * out, size_t in_size, size_t * out_size) {
-    if (block_size > in_size) block_size = in_size + 16;
-    block_size = block_size <= KiB(65) ? KiB(65) : block_size;
-
-    struct bz3_state * state = bz3_new(block_size);
-    if (!state) return BZ3_ERR_INIT;
-
-    u8 * compression_buf = malloc(block_size);
-    if (!compression_buf) {
-        bz3_free(state);
-        return BZ3_ERR_INIT;
-    }
-
-    size_t buf_max = *out_size;
-    *out_size = 0;
-
-    u32 n_blocks = in_size / block_size;
-    if (in_size % block_size) n_blocks++;
-
-    if (buf_max < 13 || buf_max < bz3_bound(in_size)) {
-        bz3_free(state);
-        free(compression_buf);
-        return BZ3_ERR_DATA_TOO_BIG;
-    }
-
-    out[0] = 'B';
-    out[1] = 'Z';
-    out[2] = '3';
-    out[3] = 'v';
-    out[4] = '1';
-    write_neutral_s32(out + 5, block_size);
-    write_neutral_s32(out + 9, n_blocks);
-    *out_size += 13;
-
-    // Compress and write the blocks.
-    for (u32 i = 0; i < n_blocks; i++) {
-        s32 size = block_size;
-        if (i == n_blocks - 1) size = in_size % block_size;
-        memcpy(compression_buf, in, size);
-        s32 out_size_block = bz3_encode_block(state, compression_buf, size);
-        if (bz3_last_error(state) != BZ3_OK) {
-            s8 last_error = state->last_error;
-            bz3_free(state);
-            free(compression_buf);
-            return last_error;
-        }
-        memcpy(out + *out_size + 8, compression_buf, out_size_block);
-        write_neutral_s32(out + *out_size, out_size_block);
-        write_neutral_s32(out + *out_size + 4, size);
-        *out_size += out_size_block + 8;
-    }
-
-    bz3_free(state);
-    free(compression_buf);
-    return BZ3_OK;
-}
-
-BZIP3_API int bz3_decompress(const uint8_t * in, uint8_t * out, size_t in_size, size_t * out_size) {
-    if (in_size < 13) return BZ3_ERR_MALFORMED_HEADER;
-    if (in[0] != 'B' || in[1] != 'Z' || in[2] != '3' || in[3] != 'v' || in[4] != '1') {
-        return BZ3_ERR_MALFORMED_HEADER;
-    }
-    u32 block_size = read_neutral_s32(in + 5);
-    u32 n_blocks = read_neutral_s32(in + 9);
-    in_size -= 13;
-    in += 13;
-
-    struct bz3_state * state = bz3_new(block_size);
-    if (!state) return BZ3_ERR_INIT;
-
-    u8 * compression_buf = malloc(block_size);
-    if (!compression_buf) {
-        bz3_free(state);
-        return BZ3_ERR_INIT;
-    }
-
-    size_t buf_max = *out_size;
-    *out_size = 0;
-
-    for (u32 i = 0; i < n_blocks; i++) {
-        if (in_size < 8) {
-        malformed_header:
-            bz3_free(state);
-            free(compression_buf);
-            return BZ3_ERR_MALFORMED_HEADER;
-        }
-        s32 size = read_neutral_s32(in);
-        if (size < 0 || size > block_size) goto malformed_header;
-        if (in_size < size + 8) {
-            bz3_free(state);
-            free(compression_buf);
-            return BZ3_ERR_TRUNCATED_DATA;
-        }
-        s32 orig_size = read_neutral_s32(in + 4);
-        if (orig_size < 0) goto malformed_header;
-        if (buf_max < *out_size + orig_size) {
-            bz3_free(state);
-            free(compression_buf);
-            return BZ3_ERR_DATA_TOO_BIG;
-        }
-        memcpy(compression_buf, in + 8, size);
-        bz3_decode_block(state, compression_buf, size, orig_size);
-        if (bz3_last_error(state) != BZ3_OK) {
-            s8 last_error = state->last_error;
-            bz3_free(state);
-            free(compression_buf);
-            return last_error;
-        }
-        memcpy(out + *out_size, compression_buf, orig_size);
-        *out_size += orig_size;
-        in += size + 8;
-        in_size -= size + 8;
-    }
-
-    bz3_free(state);
-    return BZ3_OK;
-}
+
+/*
+ * BZip3 - A spiritual successor to BZip2.
+ * Copyright (C) 2022-2023 Kamila Szewczyk
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by the Free
+ * Software Foundation, either version 3 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "libbz3.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "libsais.h"
+
+/* CRC32 implementation. Since CRC32 generally takes less than 1% of the runtime on real-world data (e.g. the
+   Silesia corpus), I decided against using hardware CRC32. This implementation is simple, fast, fool-proof and
+   good enough to be used with bzip3. */
+
+static const u32 crc32Table[256] = {
+    0x00000000L, 0xF26B8303L, 0xE13B70F7L, 0x1350F3F4L, 0xC79A971FL, 0x35F1141CL, 0x26A1E7E8L, 0xD4CA64EBL, 0x8AD958CFL,
+    0x78B2DBCCL, 0x6BE22838L, 0x9989AB3BL, 0x4D43CFD0L, 0xBF284CD3L, 0xAC78BF27L, 0x5E133C24L, 0x105EC76FL, 0xE235446CL,
+    0xF165B798L, 0x030E349BL, 0xD7C45070L, 0x25AFD373L, 0x36FF2087L, 0xC494A384L, 0x9A879FA0L, 0x68EC1CA3L, 0x7BBCEF57L,
+    0x89D76C54L, 0x5D1D08BFL, 0xAF768BBCL, 0xBC267848L, 0x4E4DFB4BL, 0x20BD8EDEL, 0xD2D60DDDL, 0xC186FE29L, 0x33ED7D2AL,
+    0xE72719C1L, 0x154C9AC2L, 0x061C6936L, 0xF477EA35L, 0xAA64D611L, 0x580F5512L, 0x4B5FA6E6L, 0xB93425E5L, 0x6DFE410EL,
+    0x9F95C20DL, 0x8CC531F9L, 0x7EAEB2FAL, 0x30E349B1L, 0xC288CAB2L, 0xD1D83946L, 0x23B3BA45L, 0xF779DEAEL, 0x05125DADL,
+    0x1642AE59L, 0xE4292D5AL, 0xBA3A117EL, 0x4851927DL, 0x5B016189L, 0xA96AE28AL, 0x7DA08661L, 0x8FCB0562L, 0x9C9BF696L,
+    0x6EF07595L, 0x417B1DBCL, 0xB3109EBFL, 0xA0406D4BL, 0x522BEE48L, 0x86E18AA3L, 0x748A09A0L, 0x67DAFA54L, 0x95B17957L,
+    0xCBA24573L, 0x39C9C670L, 0x2A993584L, 0xD8F2B687L, 0x0C38D26CL, 0xFE53516FL, 0xED03A29BL, 0x1F682198L, 0x5125DAD3L,
+    0xA34E59D0L, 0xB01EAA24L, 0x42752927L, 0x96BF4DCCL, 0x64D4CECFL, 0x77843D3BL, 0x85EFBE38L, 0xDBFC821CL, 0x2997011FL,
+    0x3AC7F2EBL, 0xC8AC71E8L, 0x1C661503L, 0xEE0D9600L, 0xFD5D65F4L, 0x0F36E6F7L, 0x61C69362L, 0x93AD1061L, 0x80FDE395L,
+    0x72966096L, 0xA65C047DL, 0x5437877EL, 0x4767748AL, 0xB50CF789L, 0xEB1FCBADL, 0x197448AEL, 0x0A24BB5AL, 0xF84F3859L,
+    0x2C855CB2L, 0xDEEEDFB1L, 0xCDBE2C45L, 0x3FD5AF46L, 0x7198540DL, 0x83F3D70EL, 0x90A324FAL, 0x62C8A7F9L, 0xB602C312L,
+    0x44694011L, 0x5739B3E5L, 0xA55230E6L, 0xFB410CC2L, 0x092A8FC1L, 0x1A7A7C35L, 0xE811FF36L, 0x3CDB9BDDL, 0xCEB018DEL,
+    0xDDE0EB2AL, 0x2F8B6829L, 0x82F63B78L, 0x709DB87BL, 0x63CD4B8FL, 0x91A6C88CL, 0x456CAC67L, 0xB7072F64L, 0xA457DC90L,
+    0x563C5F93L, 0x082F63B7L, 0xFA44E0B4L, 0xE9141340L, 0x1B7F9043L, 0xCFB5F4A8L, 0x3DDE77ABL, 0x2E8E845FL, 0xDCE5075CL,
+    0x92A8FC17L, 0x60C37F14L, 0x73938CE0L, 0x81F80FE3L, 0x55326B08L, 0xA759E80BL, 0xB4091BFFL, 0x466298FCL, 0x1871A4D8L,
+    0xEA1A27DBL, 0xF94AD42FL, 0x0B21572CL, 0xDFEB33C7L, 0x2D80B0C4L, 0x3ED04330L, 0xCCBBC033L, 0xA24BB5A6L, 0x502036A5L,
+    0x4370C551L, 0xB11B4652L, 0x65D122B9L, 0x97BAA1BAL, 0x84EA524EL, 0x7681D14DL, 0x2892ED69L, 0xDAF96E6AL, 0xC9A99D9EL,
+    0x3BC21E9DL, 0xEF087A76L, 0x1D63F975L, 0x0E330A81L, 0xFC588982L, 0xB21572C9L, 0x407EF1CAL, 0x532E023EL, 0xA145813DL,
+    0x758FE5D6L, 0x87E466D5L, 0x94B49521L, 0x66DF1622L, 0x38CC2A06L, 0xCAA7A905L, 0xD9F75AF1L, 0x2B9CD9F2L, 0xFF56BD19L,
+    0x0D3D3E1AL, 0x1E6DCDEEL, 0xEC064EEDL, 0xC38D26C4L, 0x31E6A5C7L, 0x22B65633L, 0xD0DDD530L, 0x0417B1DBL, 0xF67C32D8L,
+    0xE52CC12CL, 0x1747422FL, 0x49547E0BL, 0xBB3FFD08L, 0xA86F0EFCL, 0x5A048DFFL, 0x8ECEE914L, 0x7CA56A17L, 0x6FF599E3L,
+    0x9D9E1AE0L, 0xD3D3E1ABL, 0x21B862A8L, 0x32E8915CL, 0xC083125FL, 0x144976B4L, 0xE622F5B7L, 0xF5720643L, 0x07198540L,
+    0x590AB964L, 0xAB613A67L, 0xB831C993L, 0x4A5A4A90L, 0x9E902E7BL, 0x6CFBAD78L, 0x7FAB5E8CL, 0x8DC0DD8FL, 0xE330A81AL,
+    0x115B2B19L, 0x020BD8EDL, 0xF0605BEEL, 0x24AA3F05L, 0xD6C1BC06L, 0xC5914FF2L, 0x37FACCF1L, 0x69E9F0D5L, 0x9B8273D6L,
+    0x88D28022L, 0x7AB90321L, 0xAE7367CAL, 0x5C18E4C9L, 0x4F48173DL, 0xBD23943EL, 0xF36E6F75L, 0x0105EC76L, 0x12551F82L,
+    0xE03E9C81L, 0x34F4F86AL, 0xC69F7B69L, 0xD5CF889DL, 0x27A40B9EL, 0x79B737BAL, 0x8BDCB4B9L, 0x988C474DL, 0x6AE7C44EL,
+    0xBE2DA0A5L, 0x4C4623A6L, 0x5F16D052L, 0xAD7D5351L
+};
+
+static u32 crc32sum(u32 crc, u8 * RESTRICT buf, size_t size) {
+    while (size--) crc = crc32Table[((crc >> 24) ^ *(buf++)) & 0xff] ^ (crc << 8);
+    return crc;
+}
+
+/* LZP code. These constants were manually tuned to give the best compression ratio while using relatively
+   little resources. The LZP dictionary is only around 1MiB in size and the minimum match length was chosen
+   so that LZP would not interfere too much with the Burrows-Wheeler transform and the arithmetic coder, and
+   just collapse long redundant data instead (for a major speed-up at a low compression ratio cost - in fact,
+   LZP preprocessing often improves compression in some cases). */
+
+/* A heavily modified version of libbsc's LZP predictor w/ unaligned accesses follows. This one has single thread
+   performance and provides better compression ratio. It is also mostly UB-free and less brittle during
+   AFL fuzzing. */
+
+#define LZP_DICTIONARY 18
+#define LZP_MIN_MATCH 40
+
+#define MATCH 0xf2
+
+static u32 lzp_upcast(const u8 * ptr) {
+    // val = *(u32 *)ptr; - written this way to avoid UB
+    u32 val;
+    memcpy(&val, ptr, sizeof(val));
+    return val;
+}
+
+static s32 lzp_encode_block(const u8 * RESTRICT in, const u8 * in_end, u8 * RESTRICT out, u8 * out_end,
+                            s32 * RESTRICT lut) {
+    const u8 * ins = in;
+    const u8 * outs = out;
+    const u8 * out_eob = out_end - 8;
+    const u8 * heur = in;
+
+    u32 ctx;
+
+    for (s32 i = 0; i < 4; ++i) *out++ = *in++;
+
+    ctx = ((u32)in[-1]) | (((u32)in[-2]) << 8) | (((u32)in[-3]) << 16) | (((u32)in[-4]) << 24);
+
+    while (in < in_end - LZP_MIN_MATCH - 32 && out < out_eob) {
+        u32 idx = (ctx >> 15 ^ ctx ^ ctx >> 3) & ((s32)(1 << LZP_DICTIONARY) - 1);
+        s32 val = lut[idx];
+        lut[idx] = in - ins;
+        if (val > 0) {
+            const u8 * RESTRICT ref = ins + val;
+            if (memcmp(in + LZP_MIN_MATCH - 4, ref + LZP_MIN_MATCH - 4, sizeof(u32)) == 0 &&
+                memcmp(in, ref, sizeof(u32)) == 0) {
+                if (heur > in && lzp_upcast(heur) != lzp_upcast(ref + (heur - in))) goto not_found;
+
+                s32 len = 4;
+                for (; in + len < in_end - LZP_MIN_MATCH - 32; len += sizeof(u32)) {
+                    if (lzp_upcast(in + len) != lzp_upcast(ref + len)) break;
+                }
+
+                if (len < LZP_MIN_MATCH) {
+                    if (heur < in + len) heur = in + len;
+                    goto not_found;
+                }
+
+                len += in[len] == ref[len];
+                len += in[len] == ref[len];
+                len += in[len] == ref[len];
+
+                in += len;
+                ctx = ((u32)in[-1]) | (((u32)in[-2]) << 8) | (((u32)in[-3]) << 16) | (((u32)in[-4]) << 24);
+
+                *out++ = MATCH;
+
+                len -= LZP_MIN_MATCH;
+                while (len >= 254) {
+                    len -= 254;
+                    *out++ = 254;
+                    if (out >= out_eob) break;
+                }
+
+                *out++ = len;
+            } else {
+            not_found:;
+                u8 next = *out++ = *in++;
+                ctx = ctx << 8 | next;
+                if (next == MATCH) *out++ = 255;
+            }
+        } else {
+            ctx = (ctx << 8) | (*out++ = *in++);
+        }
+    }
+
+    ctx = ((u32)in[-1]) | (((u32)in[-2]) << 8) | (((u32)in[-3]) << 16) | (((u32)in[-4]) << 24);
+
+    while (in < in_end && out < out_eob) {
+        u32 idx = (ctx >> 15 ^ ctx ^ ctx >> 3) & ((s32)(1 << LZP_DICTIONARY) - 1);
+        s32 val = lut[idx];
+        lut[idx] = (s32)(in - ins);
+
+        u8 next = *out++ = *in++;
+        ctx = ctx << 8 | next;
+        if (next == MATCH && val > 0) *out++ = 255;
+    }
+
+    return out >= out_eob ? -1 : (s32)(out - outs);
+}
+
+static s32 lzp_decode_block(const u8 * RESTRICT in, const u8 * in_end, s32 * RESTRICT lut, u8 * RESTRICT out,
+                            const u8 * out_end) {
+    const u8 * outs = out;
+
+    for (s32 i = 0; i < 4; ++i) *out++ = *in++;
+
+    u32 ctx = ((u32)out[-1]) | (((u32)out[-2]) << 8) | (((u32)out[-3]) << 16) | (((u32)out[-4]) << 24);
+
+    while (in < in_end && out < out_end) {
+        u32 idx = (ctx >> 15 ^ ctx ^ ctx >> 3) & ((s32)(1 << LZP_DICTIONARY) - 1);
+        s32 val = lut[idx];
+        lut[idx] = (s32)(out - outs);
+        if (*in == MATCH && val > 0) {
+            in++;
+            if (*in != 255) {
+                s32 len = LZP_MIN_MATCH;
+                while (1) {
+                    if (in == in_end) return -1;
+                    len += *in;
+                    if (*in++ != 254) break;
+                }
+
+                const u8 * ref = outs + val;
+                const u8 * oe = out + len;
+                if (oe > out_end) oe = out_end;
+
+                while (out < oe) *out++ = *ref++;
+
+                ctx = ((u32)out[-1]) | (((u32)out[-2]) << 8) | (((u32)out[-3]) << 16) | (((u32)out[-4]) << 24);
+            } else {
+                in++;
+                ctx = (ctx << 8) | (*out++ = MATCH);
+            }
+        } else {
+            ctx = (ctx << 8) | (*out++ = *in++);
+        }
+    }
+
+    return out - outs;
+}
+
+static s32 lzp_compress(const u8 * RESTRICT in, u8 * RESTRICT out, s32 n, s32 * RESTRICT lut) {
+    if (n < LZP_MIN_MATCH + 32) return -1;
+
+    memset(lut, 0, sizeof(s32) * (1 << LZP_DICTIONARY));
+
+    return lzp_encode_block(in, in + n, out, out + n, lut);
+}
+
+static s32 lzp_decompress(const u8 * RESTRICT in, u8 * RESTRICT out, s32 n, s32 max, s32 * RESTRICT lut) {
+    if (n < 4) return -1;
+
+    memset(lut, 0, sizeof(s32) * (1 << LZP_DICTIONARY));
+
+    return lzp_decode_block(in, in + n, lut, out, out + max);
+}
+
+/* RLE code. Unlike RLE in other compressors, we collapse all runs if they yield a net gain
+   for a given character and encode this as a set bit in the RLE metadata. This improves the
+   performance and reduces the amount of collapsing done in normal blocks (so that BWT+AC can
+   be more efficient) while we still filter out all the pathological data. */
+
+static s32 mrlec(u8 * in, s32 inlen, u8 * out) {
+    u8 * ip = in;
+    u8 * in_end = in + inlen;
+    s32 op = 0;
+    s32 c, pc = -1;
+    s32 t[256] = { 0 };
+    s32 run = 0;
+    while ((c = (ip < in_end ? *ip++ : -1)) != -1) {
+        if (c == pc)
+            t[c] += (++run % 255) != 0;
+        else
+            --t[c], run = 0;
+        pc = c;
+    }
+    for (s32 i = 0; i < 32; ++i) {
+        c = 0;
+        for (s32 j = 0; j < 8; ++j) c += (t[i * 8 + j] > 0) << j;
+        out[op++] = c;
+    }
+    ip = in;
+    c = pc = -1;
+    run = 0;
+    do {
+        c = ip < in_end ? *ip++ : -1;
+        if (c == pc)
+            ++run;
+        else if (run > 0 && t[pc] > 0) {
+            out[op++] = pc;
+            for (; run > 255; run -= 255) out[op++] = 255;
+            out[op++] = run - 1;
+            run = 1;
+        } else
+            for (++run; run > 1; --run) out[op++] = pc;
+        pc = c;
+    } while (c != -1);
+
+    return op;
+}
+
+static int mrled(u8 * RESTRICT in, u8 * RESTRICT out, s32 outlen, s32 maxin) {
+    s32 op = 0, ip = 0;
+
+    s32 c, pc = -1;
+    s32 t[256] = { 0 };
+    s32 run = 0;
+
+    if(maxin < 32)
+        return 1;
+
+    for (s32 i = 0; i < 32; ++i) {
+        c = in[ip++];
+        for (s32 j = 0; j < 8; ++j) t[i * 8 + j] = (c >> j) & 1;
+    }
+
+    while (op < outlen && ip < maxin) {
+        c = in[ip++];
+        if (t[c]) {
+            for (run = 0; ip < maxin && (pc = in[ip++]) == 255; run += 255)
+                ;
+            run += pc + 1;
+            for (; run > 0 && op < outlen; --run) out[op++] = c;
+        } else
+            out[op++] = c;
+    }
+
+    return op != outlen;
+}
+
+/* The entropy coder. Uses an arithmetic coder implementation outlined in Matt Mahoney's DCE. */
+
+typedef struct {
+    /* Input/output. */
+    u8 *in_queue, *out_queue;
+    s32 input_ptr, output_ptr, input_max;
+
+    /* C0, C1 - used for making the initial prediction, C2 used for an APM with a slightly low
+       learning rate (6) and 512 contexts. kanzi merges C0 and C1, uses slightly different
+       counter initialisation code and prediction code which from my tests tends to be suboptimal. */
+    u16 C0[256], C1[256][256], C2[512][17];
+} state;
+
+#define write_out(s, c) (s)->out_queue[(s)->output_ptr++] = (c)
+#define read_in(s) ((s)->input_ptr < (s)->input_max ? (s)->in_queue[(s)->input_ptr++] : -1)
+
+#define update0(p, x) (p) = ((p) - ((p) >> x))
+#define update1(p, x) (p) = ((p) + (((p) ^ 65535) >> x))
+
+static void begin(state * s) {
+    prefetch(s);
+    for (int i = 0; i < 256; i++) s->C0[i] = 1 << 15;
+    for (int i = 0; i < 256; i++)
+        for (int j = 0; j < 256; j++) s->C1[i][j] = 1 << 15;
+    for (int i = 0; i < 2; i++)
+        for (int j = 0; j < 256; j++)
+            for (int k = 0; k < 17; k++) s->C2[2 * j + i][k] = (k << 12) - (k == 16);  // Firm difference from stdpack.
+}
+
+static void encode_bytes(state * s, u8 * buf, s32 size) {
+    /* Arithmetic coding, detecting runs of characters in the file */
+    u32 high = 0xFFFFFFFF, low = 0, c1 = 0, c2 = 0, run = 0;
+
+    for (s32 i = 0; i < size; i++) {
+        u8 c = buf[i];
+
+        if (c1 == c2)
+            ++run;
+        else
+            run = 0;
+
+        const int f = run > 2;
+
+        int ctx = 1;
+
+        while (ctx < 256) {
+            const int p0 = s->C0[ctx];
+            const int p1 = s->C1[c1][ctx];
+            const int p2 = s->C1[c2][ctx];
+            const int p = ((p0 + p1) * 7 + p2 + p2) >> 4;
+
+            const int j = p >> 12;
+            const int x1 = s->C2[2 * ctx + f][j];
+            const int x2 = s->C2[2 * ctx + f][j + 1];
+            const int ssep = x1 + (((x2 - x1) * (p & 4095)) >> 12);
+
+            if (c & 128) {
+                high = low + (((u64)(high - low) * (ssep * 3 + p)) >> 18);
+
+                while ((low ^ high) < (1 << 24)) {
+                    write_out(s, low >> 24);
+                    low <<= 8;
+                    high = (high << 8) + 0xFF;
+                }
+
+                update1(s->C0[ctx], 2);
+                update1(s->C1[c1][ctx], 4);
+                update1(s->C2[2 * ctx + f][j], 6);
+                update1(s->C2[2 * ctx + f][j + 1], 6);
+                ctx += ctx + 1;
+            } else {
+                low += (((u64)(high - low) * (ssep * 3 + p)) >> 18) + 1;
+
+                // Write identical bits.
+                while ((low ^ high) < (1 << 24)) {
+                    write_out(s, low >> 24);  // Same as high >> 24
+                    low <<= 8;
+                    high = (high << 8) + 0xFF;
+                }
+
+                update0(s->C0[ctx], 2);
+                update0(s->C1[c1][ctx], 4);
+                update0(s->C2[2 * ctx + f][j], 6);
+                update0(s->C2[2 * ctx + f][j + 1], 6);
+                ctx += ctx;
+            }
+
+            c <<= 1;
+        }
+
+        c2 = c1;
+        c1 = ctx & 255;
+    }
+
+    write_out(s, low >> 24);
+    low <<= 8;
+    write_out(s, low >> 24);
+    low <<= 8;
+    write_out(s, low >> 24);
+    low <<= 8;
+    write_out(s, low >> 24);
+    low <<= 8;
+}
+
+static void decode_bytes(state * s, u8 * c, s32 size) {
+    u32 high = 0xFFFFFFFF, low = 0, c1 = 0, c2 = 0, run = 0, code = 0;
+
+    code = (code << 8) + read_in(s);
+    code = (code << 8) + read_in(s);
+    code = (code << 8) + read_in(s);
+    code = (code << 8) + read_in(s);
+
+    for (s32 i = 0; i < size; i++) {
+        if (c1 == c2)
+            ++run;
+        else
+            run = 0;
+
+        const int f = run > 2;
+
+        int ctx = 1;
+
+        while (ctx < 256) {
+            const int p0 = s->C0[ctx];
+            const int p1 = s->C1[c1][ctx];
+            const int p2 = s->C1[c2][ctx];
+            const int p = ((p0 + p1) * 7 + p2 + p2) >> 4;
+
+            const int j = p >> 12;
+            const int x1 = s->C2[2 * ctx + f][j];
+            const int x2 = s->C2[2 * ctx + f][j + 1];
+            const int ssep = x1 + (((x2 - x1) * (p & 4095)) >> 12);
+
+            const u32 mid = low + (((u64)(high - low) * (ssep * 3 + p)) >> 18);
+            const u8 bit = code <= mid;
+            if (bit)
+                high = mid;
+            else
+                low = mid + 1;
+            while ((low ^ high) < (1 << 24)) {
+                low <<= 8;
+                high = (high << 8) + 255;
+                code = (code << 8) + read_in(s);
+            }
+
+            if (bit) {
+                update1(s->C0[ctx], 2);
+                update1(s->C1[c1][ctx], 4);
+                update1(s->C2[2 * ctx + f][j], 6);
+                update1(s->C2[2 * ctx + f][j + 1], 6);
+                ctx += ctx + 1;
+            } else {
+                update0(s->C0[ctx], 2);
+                update0(s->C1[c1][ctx], 4);
+                update0(s->C2[2 * ctx + f][j], 6);
+                update0(s->C2[2 * ctx + f][j + 1], 6);
+                ctx += ctx;
+            }
+        }
+
+        c2 = c1;
+        c[i] = c1 = ctx & 255;
+    }
+}
+
+/* Public API. */
+
+struct bz3_state {
+    u8 * swap_buffer;
+    s32 block_size;
+    s32 *sais_array, *lzp_lut;
+    state * cm_state;
+    s8 last_error;
+};
+
+BZIP3_API s8 bz3_last_error(struct bz3_state * state) { return state->last_error; }
+
+BZIP3_API const char * bz3_version(void) { return VERSION; }
+
+BZIP3_API size_t bz3_bound(size_t input_size) { return input_size + input_size / 50 + 32; }
+
+BZIP3_API const char * bz3_strerror(struct bz3_state * state) {
+    switch (state->last_error) {
+        case BZ3_OK:
+            return "No error";
+        case BZ3_ERR_OUT_OF_BOUNDS:
+            return "Data index out of bounds";
+        case BZ3_ERR_BWT:
+            return "Burrows-Wheeler transform failed";
+        case BZ3_ERR_CRC:
+            return "CRC32 check failed";
+        case BZ3_ERR_MALFORMED_HEADER:
+            return "Malformed header";
+        case BZ3_ERR_TRUNCATED_DATA:
+            return "Truncated data";
+        case BZ3_ERR_DATA_TOO_BIG:
+            return "Too much data";
+        default:
+            return "Unknown error";
+    }
+}
+
+BZIP3_API struct bz3_state * bz3_new(s32 block_size) {
+    if (block_size < KiB(65) || block_size > MiB(511)) {
+        return NULL;
+    }
+
+    struct bz3_state * bz3_state = malloc(sizeof(struct bz3_state));
+
+    if (!bz3_state) {
+        return NULL;
+    }
+
+    bz3_state->cm_state = malloc(sizeof(state));
+
+    bz3_state->swap_buffer = malloc(bz3_bound(block_size));
+    bz3_state->sais_array = malloc(BWT_BOUND(block_size) * sizeof(s32));
+    memset(bz3_state->sais_array, 0, sizeof(s32) * BWT_BOUND(block_size));
+
+    bz3_state->lzp_lut = calloc(1 << LZP_DICTIONARY, sizeof(s32));
+
+    if (!bz3_state->cm_state || !bz3_state->swap_buffer || !bz3_state->sais_array || !bz3_state->lzp_lut) {
+        if (bz3_state->cm_state) free(bz3_state->cm_state);
+        if (bz3_state->swap_buffer) free(bz3_state->swap_buffer);
+        if (bz3_state->sais_array) free(bz3_state->sais_array);
+        if (bz3_state->lzp_lut) free(bz3_state->lzp_lut);
+        free(bz3_state);
+        return NULL;
+    }
+
+    bz3_state->block_size = block_size;
+
+    bz3_state->last_error = BZ3_OK;
+
+    return bz3_state;
+}
+
+BZIP3_API void bz3_free(struct bz3_state * state) {
+    free(state->swap_buffer);
+    free(state->sais_array);
+    free(state->cm_state);
+    free(state->lzp_lut);
+    free(state);
+}
+
+#define swap(x, y)    \
+    {                 \
+        u8 * tmp = x; \
+        x = y;        \
+        y = tmp;      \
+    }
+
+BZIP3_API s32 bz3_encode_block(struct bz3_state * state, u8 * buffer, s32 data_size) {
+    u8 *b1 = buffer, *b2 = state->swap_buffer;
+
+    if (data_size > state->block_size) {
+        state->last_error = BZ3_ERR_DATA_TOO_BIG;
+        return -1;
+    }
+
+    u32 crc32 = crc32sum(1, b1, data_size);
+
+    // Ignore small blocks. They won't benefit from the entropy coding step.
+    if (data_size < 64) {
+        memmove(b1 + 8, b1, data_size);
+        write_neutral_s32(b1, crc32);
+        write_neutral_s32(b1 + 4, -1);
+        return data_size + 8;
+    }
+
+    // Back to front:
+    // bit 1: lzp | no lzp
+    // bit 2: srt | no srt
+    s8 model = 0;
+    s32 lzp_size, rle_size;
+
+    rle_size = mrlec(b1, data_size, b2);
+    if (rle_size < data_size + 64) {
+        swap(b1, b2);
+        data_size = rle_size;
+        model |= 4;
+    }
+
+    lzp_size = lzp_compress(b1, b2, data_size, state->lzp_lut);
+    if (lzp_size > 0 && lzp_size < data_size + 64) {
+        swap(b1, b2);
+        data_size = lzp_size;
+        model |= 2;
+    }
+
+    s32 bwt_idx = libsais_bwt(b1, b2, state->sais_array, data_size, 0, NULL);
+    if (bwt_idx < 0) {
+        state->last_error = BZ3_ERR_BWT;
+        return -1;
+    }
+
+    // Compute the amount of overhead dwords.
+    s32 overhead = 2;           // CRC32 + BWT index
+    if (model & 2) overhead++;  // LZP
+    if (model & 4) overhead++;  // RLE
+
+    begin(state->cm_state);
+    state->cm_state->out_queue = b1 + overhead * 4 + 1;
+    state->cm_state->output_ptr = 0;
+    encode_bytes(state->cm_state, b2, data_size);
+    data_size = state->cm_state->output_ptr;
+
+    // Write the header. Starting with common entries.
+    write_neutral_s32(b1, crc32);
+    write_neutral_s32(b1 + 4, bwt_idx);
+    b1[8] = model;
+
+    s32 p = 0;
+    if (model & 2) write_neutral_s32(b1 + 9 + 4 * p++, lzp_size);
+    if (model & 4) write_neutral_s32(b1 + 9 + 4 * p++, rle_size);
+
+    state->last_error = BZ3_OK;
+
+    if (b1 != buffer) memcpy(buffer, b1, data_size + overhead * 4 + 1);
+
+    return data_size + overhead * 4 + 1;
+}
+
+BZIP3_API s32 bz3_decode_block(struct bz3_state * state, u8 * buffer, s32 data_size, s32 orig_size) {
+    // Read the header.
+    u32 crc32 = read_neutral_s32(buffer);
+    s32 bwt_idx = read_neutral_s32(buffer + 4);
+
+    if (data_size > bz3_bound(state->block_size) || data_size < 0) {
+        state->last_error = BZ3_ERR_MALFORMED_HEADER;
+        return -1;
+    }
+
+    if (bwt_idx == -1) {
+        if (data_size - 8 > 64 || data_size < 8) {
+            state->last_error = BZ3_ERR_MALFORMED_HEADER;
+            return -1;
+        }
+
+        memmove(buffer, buffer + 8, data_size - 8);
+
+        if (crc32sum(1, buffer, data_size - 8) != crc32) {
+            state->last_error = BZ3_ERR_CRC;
+            return -1;
+        }
+
+        return data_size - 8;
+    }
+
+    s8 model = buffer[8];
+    s32 lzp_size = -1, rle_size = -1, p = 0;
+
+    if (model & 2) lzp_size = read_neutral_s32(buffer + 9 + 4 * p++);
+    if (model & 4) rle_size = read_neutral_s32(buffer + 9 + 4 * p++);
+
+    p += 2;
+
+    data_size -= p * 4 + 1;
+
+    if (((model & 2) && (lzp_size > bz3_bound(state->block_size) || lzp_size < 0)) ||
+        ((model & 4) && (rle_size > bz3_bound(state->block_size) || rle_size < 0))) {
+        state->last_error = BZ3_ERR_MALFORMED_HEADER;
+        return -1;
+    }
+
+    if (orig_size > bz3_bound(state->block_size) || orig_size < 0) {
+        state->last_error = BZ3_ERR_MALFORMED_HEADER;
+        return -1;
+    }
+
+    // Decode the data.
+    u8 *b1 = buffer, *b2 = state->swap_buffer;
+
+    begin(state->cm_state);
+    state->cm_state->in_queue = b1 + p * 4 + 1;
+    state->cm_state->input_ptr = 0;
+    state->cm_state->input_max = data_size;
+
+    s32 size_src;
+
+    if (model & 2)
+        size_src = lzp_size;
+    else if (model & 4)
+        size_src = rle_size;
+    else
+        size_src = orig_size;
+
+    decode_bytes(state->cm_state, b2, size_src);
+    swap(b1, b2);
+
+    if (bwt_idx >= size_src) {
+        state->last_error = BZ3_ERR_MALFORMED_HEADER;
+        return -1;
+    }
+
+    // Undo BWT
+    memset(state->sais_array, 0, sizeof(s32) * BWT_BOUND(state->block_size));
+    memset(b2, 0, size_src);
+    if (libsais_unbwt(b1, b2, state->sais_array, size_src, NULL, bwt_idx) < 0) {
+        state->last_error = BZ3_ERR_BWT;
+        return -1;
+    }
+    swap(b1, b2);
+
+    // Undo LZP
+    if (model & 2) {
+        size_src = lzp_decompress(b1, b2, lzp_size, bz3_bound(state->block_size), state->lzp_lut);
+        if (size_src == -1) {
+            state->last_error = BZ3_ERR_CRC;
+            return -1;
+        }
+        swap(b1, b2);
+    }
+
+    if (model & 4) {
+        int err = mrled(b1, b2, orig_size, size_src);
+        if(err) {
+            state->last_error = BZ3_ERR_CRC;
+            return -1;
+        }
+        size_src = orig_size;
+        swap(b1, b2);
+    }
+
+    state->last_error = BZ3_OK;
+
+    if (size_src > state->block_size || size_src < 0) {
+        state->last_error = BZ3_ERR_MALFORMED_HEADER;
+        return -1;
+    }
+
+    if (b1 != buffer) memcpy(buffer, b1, size_src);
+
+    if (crc32 != crc32sum(1, buffer, size_src)) {
+        state->last_error = BZ3_ERR_CRC;
+        return -1;
+    }
+
+    return size_src;
+}
+
+#undef swap
+
+#ifdef PTHREAD
+
+    #include <pthread.h>
+
+typedef struct {
+    struct bz3_state * state;
+    u8 * buffer;
+    s32 size;
+} encode_thread_msg;
+
+typedef struct {
+    struct bz3_state * state;
+    u8 * buffer;
+    s32 size;
+    s32 orig_size;
+} decode_thread_msg;
+
+static void * bz3_init_encode_thread(void * _msg) {
+    encode_thread_msg * msg = _msg;
+    msg->size = bz3_encode_block(msg->state, msg->buffer, msg->size);
+    pthread_exit(NULL);
+    return NULL;  // unreachable
+}
+
+static void * bz3_init_decode_thread(void * _msg) {
+    decode_thread_msg * msg = _msg;
+    bz3_decode_block(msg->state, msg->buffer, msg->size, msg->orig_size);
+    pthread_exit(NULL);
+    return NULL;  // unreachable
+}
+
+BZIP3_API void bz3_encode_blocks(struct bz3_state * states[], u8 * buffers[], s32 sizes[], s32 n) {
+    encode_thread_msg messages[n];
+    pthread_t threads[n];
+    for (s32 i = 0; i < n; i++) {
+        messages[i].state = states[i];
+        messages[i].buffer = buffers[i];
+        messages[i].size = sizes[i];
+        pthread_create(&threads[i], NULL, bz3_init_encode_thread, &messages[i]);
+    }
+    for (s32 i = 0; i < n; i++) pthread_join(threads[i], NULL);
+    for (s32 i = 0; i < n; i++) sizes[i] = messages[i].size;
+}
+
+BZIP3_API void bz3_decode_blocks(struct bz3_state * states[], u8 * buffers[], s32 sizes[], s32 orig_sizes[], s32 n) {
+    decode_thread_msg messages[n];
+    pthread_t threads[n];
+    for (s32 i = 0; i < n; i++) {
+        messages[i].state = states[i];
+        messages[i].buffer = buffers[i];
+        messages[i].size = sizes[i];
+        messages[i].orig_size = orig_sizes[i];
+        pthread_create(&threads[i], NULL, bz3_init_decode_thread, &messages[i]);
+    }
+    for (s32 i = 0; i < n; i++) pthread_join(threads[i], NULL);
+}
+
+#endif
+
+/* High level API implementations. */
+
+BZIP3_API int bz3_compress(u32 block_size, const u8 * const in, u8 * out, size_t in_size, size_t * out_size) {
+    if (block_size > in_size) block_size = in_size + 16;
+    block_size = block_size <= KiB(65) ? KiB(65) : block_size;
+
+    struct bz3_state * state = bz3_new(block_size);
+    if (!state) return BZ3_ERR_INIT;
+
+    u8 * compression_buf = malloc(block_size);
+    if (!compression_buf) {
+        bz3_free(state);
+        return BZ3_ERR_INIT;
+    }
+
+    size_t buf_max = *out_size;
+    *out_size = 0;
+
+    u32 n_blocks = in_size / block_size;
+    if (in_size % block_size) n_blocks++;
+
+    if (buf_max < 13 || buf_max < bz3_bound(in_size)) {
+        bz3_free(state);
+        free(compression_buf);
+        return BZ3_ERR_DATA_TOO_BIG;
+    }
+
+    out[0] = 'B';
+    out[1] = 'Z';
+    out[2] = '3';
+    out[3] = 'v';
+    out[4] = '1';
+    write_neutral_s32(out + 5, block_size);
+    write_neutral_s32(out + 9, n_blocks);
+    *out_size += 13;
+
+    // Compress and write the blocks.
+    size_t in_offset = 0;
+    for (u32 i = 0; i < n_blocks; i++) {
+        s32 size = block_size;
+        if (i == n_blocks - 1) size = in_size % block_size;
+        memcpy(compression_buf, in + in_offset, size);
+        s32 out_size_block = bz3_encode_block(state, compression_buf, size);
+        if (bz3_last_error(state) != BZ3_OK) {
+            s8 last_error = state->last_error;
+            bz3_free(state);
+            free(compression_buf);
+            return last_error;
+        }
+        memcpy(out + *out_size + 8, compression_buf, out_size_block);
+        write_neutral_s32(out + *out_size, out_size_block);
+        write_neutral_s32(out + *out_size + 4, size);
+        *out_size += out_size_block + 8;
+        in_offset += size;
+    }
+
+    bz3_free(state);
+    free(compression_buf);
+    return BZ3_OK;
+}
+
+BZIP3_API int bz3_decompress(const uint8_t * in, uint8_t * out, size_t in_size, size_t * out_size) {
+    if (in_size < 13) return BZ3_ERR_MALFORMED_HEADER;
+    if (in[0] != 'B' || in[1] != 'Z' || in[2] != '3' || in[3] != 'v' || in[4] != '1') {
+        return BZ3_ERR_MALFORMED_HEADER;
+    }
+    u32 block_size = read_neutral_s32(in + 5);
+    u32 n_blocks = read_neutral_s32(in + 9);
+    in_size -= 13;
+    in += 13;
+
+    struct bz3_state * state = bz3_new(block_size);
+    if (!state) return BZ3_ERR_INIT;
+
+    u8 * compression_buf = malloc(bz3_bound(block_size));
+    if (!compression_buf) {
+        bz3_free(state);
+        return BZ3_ERR_INIT;
+    }
+
+    size_t buf_max = *out_size;
+    *out_size = 0;
+
+    for (u32 i = 0; i < n_blocks; i++) {
+        if (in_size < 8) {
+        malformed_header:
+            bz3_free(state);
+            free(compression_buf);
+            return BZ3_ERR_MALFORMED_HEADER;
+        }
+        s32 size = read_neutral_s32(in);
+        if (size < 0 || size > block_size) goto malformed_header;
+        if (in_size < size + 8) {
+            bz3_free(state);
+            free(compression_buf);
+            return BZ3_ERR_TRUNCATED_DATA;
+        }
+        s32 orig_size = read_neutral_s32(in + 4);
+        if (orig_size < 0) goto malformed_header;
+        if (buf_max < *out_size + orig_size) {
+            bz3_free(state);
+            free(compression_buf);
+            return BZ3_ERR_DATA_TOO_BIG;
+        }
+        memcpy(compression_buf, in + 8, size);
+        bz3_decode_block(state, compression_buf, size, orig_size);
+        if (bz3_last_error(state) != BZ3_OK) {
+            s8 last_error = state->last_error;
+            bz3_free(state);
+            free(compression_buf);
+            return last_error;
+        }
+        memcpy(out + *out_size, compression_buf, orig_size);
+        *out_size += orig_size;
+        in += size + 8;
+        in_size -= size + 8;
+    }
+
+    bz3_free(state);
+    return BZ3_OK;
+}
```

### Comparing `bzip3-0.1.2rc1/dep/src/main.c` & `bzip3-0.1.3rc1/dep/src/main.c`

 * *Files 18% similar despite different names*

```diff
@@ -1,725 +1,791 @@
-
-/*
- * BZip3 - A spiritual successor to BZip2.
- * Copyright (C) 2022 Kamila Szewczyk
- *
- * This program is free software: you can redistribute it and/or modify it
- * under the terms of the GNU Lesser General Public License as published by the Free
- * Software Foundation, either version 3 of the License, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU Lesser General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <ctype.h>
-#include <errno.h>
-#include <inttypes.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <unistd.h>
-
-#ifdef HAVE_GETOPT_LONG
-    #include <getopt.h>
-#else
-    #include "getopt-shim.h"
-#endif
-
-#if defined __MSVCRT__
-    #include <fcntl.h>
-    #include <io.h>
-#endif
-
-#include "common.h"
-#include "libbz3.h"
-
-#define MODE_DECODE 0
-#define MODE_ENCODE 1
-#define MODE_TEST 2
-
-static void version() {
-    fprintf(stdout, "bzip3 " VERSION
-                    "\n"
-                    "Copyright (C) by Kamila Szewczyk, 2022.\n"
-                    "License: GNU Lesser GPL version 3 <https://www.gnu.org/licenses/lgpl-3.0.en.html>\n");
-}
-
-static void help() {
-    fprintf(stdout,
-            "bzip3 - better and stronger spiritual successor to bzip2.\n"
-            "Usage: bzip3 [-e/-z/-d/-t/-c/-h/-V] [-b block_size] [-j jobs] files...\n"
-            "Operations:\n"
-            "  -e/-z, --encode   compress data (default)\n"
-            "  -d, --decode      decompress data\n"
-            "  -t, --test        verify validity of compressed data\n"
-            "  -h, --help        display an usage overview\n"
-            "  -f, --force       force overwriting output if it already exists\n"
-            "  -k, --keep        keep (don't delete) input files (default)\n"
-            "  -v, --verbose     verbose mode (display more information)\n"
-            "  -V, --version     display version information\n"
-            "Extra flags:\n"
-            "  -c, --stdout      force writing to standard output\n"
-            "  -b N, --block=N   set block size in MiB {16}\n"
-            "  -B, --batch       process all files specified as inputs\n"
-#ifdef PTHREAD
-            "  -j N, --jobs=N    set the amount of parallel threads\n"
-#endif
-            "\n"
-            "Report bugs to: https://github.com/kspalaiologos/bzip3\n");
-}
-
-static void xwrite(const void * data, size_t size, size_t len, FILE * des) {
-    if (fwrite(data, size, len, des) != len) {
-        fprintf(stderr, "Write error: %s\n", strerror(errno));
-        exit(1);
-    }
-}
-
-/* Read any amount of items (from 0 to len) as long as there is no error */
-static size_t xread(void * data, size_t size, size_t len, FILE * des) {
-    size_t written = fread(data, size, len, des);
-    if (ferror(des)) {
-        fprintf(stderr, "Read error: %s\n", strerror(errno));
-        exit(1);
-    }
-    return written;
-}
-
-/* Either read 0 (due to eof) items or exactly len items */
-static size_t xread_eofcheck(void * data, size_t size, size_t len, FILE * des) {
-    size_t written = xread(data, size, len, des);
-    /* feof will be true */
-    if (!written) return 0;
-    if (feof(des)) {
-        fprintf(stderr, "Error: Corrupt file\n");
-        exit(1);
-    }
-    return written;
-}
-
-/* Always read len items */
-static void xread_noeof(void * data, size_t size, size_t len, FILE * des) {
-    if (!xread_eofcheck(data, size, len, des)) {
-        fprintf(stderr, "Error: Corrupt file\n");
-        exit(1);
-    }
-}
-
-static void close_out_file(FILE * des) {
-    if (des) {
-        int outfd = fileno(des);
-
-        if (fflush(des)) {
-            fprintf(stderr, "Error: Failed on fflush: %s\n", strerror(errno));
-            exit(1);
-        }
-
-#ifdef __linux__
-        while (1) {
-            int status = fsync(outfd);
-            if (status == -1) {
-                if (errno == EINVAL) break;
-                if (errno == EINTR) continue;
-                fprintf(stderr, "Error: Failed on fsync: %s\n", strerror(errno));
-                exit(1);
-            }
-            break;
-        }
-#endif
-
-        if (des != stdout && fclose(des)) {
-            fprintf(stderr, "Error: Failed on fclose: %s\n", strerror(errno));
-            exit(1);
-        }
-    }
-}
-
-static int process(FILE * input_des, FILE * output_des, int mode, int block_size, int workers, int verbose,
-                   char * file_name) {
-    uint64_t bytes_read = 0, bytes_written = 0;
-
-    if ((mode == MODE_ENCODE && isatty(fileno(output_des))) ||
-        ((mode == MODE_DECODE || mode == MODE_TEST) && isatty(fileno(input_des)))) {
-        fprintf(stderr, "Refusing to read/write binary data from/to the terminal.\n");
-        return 1;
-    }
-
-    // Reset errno after the isatty() call.
-    errno = 0;
-
-    u8 byteswap_buf[4];
-
-    switch (mode) {
-        case MODE_ENCODE:
-            xwrite("BZ3v1", 5, 1, output_des);
-
-            write_neutral_s32(byteswap_buf, block_size);
-            xwrite(byteswap_buf, 4, 1, output_des);
-
-            bytes_written += 9;
-            break;
-        case MODE_DECODE:
-        case MODE_TEST: {
-            char signature[5];
-
-            if (xread(signature, 5, 1, input_des) != 1 || strncmp(signature, "BZ3v1", 5) != 0) {
-                fprintf(stderr, "Invalid signature.\n");
-                return 1;
-            }
-
-            xread_noeof(byteswap_buf, 4, 1, input_des);
-
-            block_size = read_neutral_s32(byteswap_buf);
-
-            if (block_size < KiB(65) || block_size > MiB(511)) {
-                fprintf(stderr,
-                        "The input file is corrupted. Reason: Invalid block "
-                        "size in the header.\n");
-                return 1;
-            }
-
-            bytes_read += 9;
-            break;
-        }
-    }
-
-#ifdef PTHREAD
-    if (workers > 64 || workers < 0) {
-        fprintf(stderr, "Number of workers must be between 0 and 64.\n");
-        return 1;
-    }
-
-    if (workers <= 1) {
-#endif
-        struct bz3_state * state = bz3_new(block_size);
-
-        if (state == NULL) {
-            fprintf(stderr, "Failed to create a block encoder state.\n");
-            return 1;
-        }
-
-        u8 * buffer = malloc(block_size + block_size / 50 + 32);
-
-        if (!buffer) {
-            fprintf(stderr, "Failed to allocate memory.\n");
-            return 1;
-        }
-
-        if (mode == MODE_ENCODE) {
-            s32 read_count;
-            while (!feof(input_des)) {
-                read_count = xread(buffer, 1, block_size, input_des);
-                bytes_read += read_count;
-
-                if (read_count == 0) break;
-
-                s32 new_size = bz3_encode_block(state, buffer, read_count);
-                if (new_size == -1) {
-                    fprintf(stderr, "Failed to encode a block: %s\n", bz3_strerror(state));
-                    return 1;
-                }
-
-                write_neutral_s32(byteswap_buf, new_size);
-                xwrite(byteswap_buf, 4, 1, output_des);
-                write_neutral_s32(byteswap_buf, read_count);
-                xwrite(byteswap_buf, 4, 1, output_des);
-                xwrite(buffer, new_size, 1, output_des);
-                bytes_written += 8 + new_size;
-            }
-            fflush(output_des);
-        } else if (mode == MODE_DECODE) {
-            s32 new_size, old_size;
-            while (!feof(input_des)) {
-                if (!xread_eofcheck(&byteswap_buf, 1, 4, input_des)) continue;
-
-                new_size = read_neutral_s32(byteswap_buf);
-                xread_noeof(&byteswap_buf, 1, 4, input_des);
-                old_size = read_neutral_s32(byteswap_buf);
-                if (old_size > block_size + 31) {
-                    fprintf(stderr, "Failed to decode a block: Inconsistent headers.\n");
-                    return 1;
-                }
-                xread_noeof(buffer, 1, new_size, input_des);
-                bytes_read += 8 + new_size;
-                if (bz3_decode_block(state, buffer, new_size, old_size) == -1) {
-                    fprintf(stderr, "Failed to decode a block: %s\n", bz3_strerror(state));
-                    return 1;
-                }
-                xwrite(buffer, old_size, 1, output_des);
-                bytes_written += old_size;
-            }
-            fflush(output_des);
-        } else if (mode == MODE_TEST) {
-            s32 new_size, old_size;
-            while (!feof(input_des)) {
-                if (!xread_eofcheck(&byteswap_buf, 1, 4, input_des)) continue;
-                new_size = read_neutral_s32(byteswap_buf);
-                xread_noeof(&byteswap_buf, 1, 4, input_des);
-                old_size = read_neutral_s32(byteswap_buf);
-                if (old_size > block_size + 31) {
-                    fprintf(stderr, "Failed to decode a block: Inconsistent headers.\n");
-                    return 1;
-                }
-                xread_noeof(buffer, 1, new_size, input_des);
-                bytes_read += 8 + new_size;
-                if (bz3_decode_block(state, buffer, new_size, old_size) == -1) {
-                    fprintf(stderr, "Failed to decode a block: %s\n", bz3_strerror(state));
-                    return 1;
-                }
-            }
-        }
-
-        if (bz3_last_error(state) != BZ3_OK) {
-            fprintf(stderr, "Failed to read data: %s\n", bz3_strerror(state));
-            return 1;
-        }
-
-        free(buffer);
-
-        bz3_free(state);
-#ifdef PTHREAD
-    } else {
-        struct bz3_state * states[workers];
-        u8 * buffers[workers];
-        s32 sizes[workers];
-        s32 old_sizes[workers];
-        for (s32 i = 0; i < workers; i++) {
-            states[i] = bz3_new(block_size);
-            if (states[i] == NULL) {
-                fprintf(stderr, "Failed to create a block encoder state.\n");
-                return 1;
-            }
-            buffers[i] = malloc(block_size + block_size / 50 + 32);
-            if (!buffers[i]) {
-                fprintf(stderr, "Failed to allocate memory.\n");
-                return 1;
-            }
-        }
-
-        if (mode == MODE_ENCODE) {
-            while (!feof(input_des)) {
-                s32 i = 0;
-                for (; i < workers; i++) {
-                    size_t read_count = xread(buffers[i], 1, block_size, input_des);
-                    bytes_read += read_count;
-                    sizes[i] = old_sizes[i] = read_count;
-                    if (read_count < block_size) {
-                        i++;
-                        break;
-                    }
-                }
-                bz3_encode_blocks(states, buffers, sizes, i);
-                for (s32 j = 0; j < i; j++) {
-                    if (bz3_last_error(states[j]) != BZ3_OK) {
-                        fprintf(stderr, "Failed to encode data: %s\n", bz3_strerror(states[j]));
-                        return 1;
-                    }
-                }
-                for (s32 j = 0; j < i; j++) {
-                    write_neutral_s32(byteswap_buf, sizes[j]);
-                    xwrite(byteswap_buf, 4, 1, output_des);
-                    write_neutral_s32(byteswap_buf, old_sizes[j]);
-                    xwrite(byteswap_buf, 4, 1, output_des);
-                    xwrite(buffers[j], sizes[j], 1, output_des);
-                    bytes_written += 8 + sizes[j];
-                }
-            }
-            fflush(output_des);
-        } else if (mode == MODE_DECODE) {
-            while (!feof(input_des)) {
-                s32 i = 0;
-                for (; i < workers; i++) {
-                    if (!xread_eofcheck(&byteswap_buf, 1, 4, input_des)) break;
-                    sizes[i] = read_neutral_s32(byteswap_buf);
-                    xread_noeof(&byteswap_buf, 1, 4, input_des);
-                    old_sizes[i] = read_neutral_s32(byteswap_buf);
-                    if (old_sizes[i] > block_size + 31) {
-                        fprintf(stderr, "Failed to decode a block: Inconsistent headers.\n");
-                        return 1;
-                    }
-                    xread_noeof(buffers[i], 1, sizes[i], input_des);
-                    bytes_read += 8 + sizes[i];
-                }
-                bz3_decode_blocks(states, buffers, sizes, old_sizes, i);
-                for (s32 j = 0; j < i; j++) {
-                    if (bz3_last_error(states[j]) != BZ3_OK) {
-                        fprintf(stderr, "Failed to decode data: %s\n", bz3_strerror(states[j]));
-                        return 1;
-                    }
-                }
-                for (s32 j = 0; j < i; j++) {
-                    xwrite(buffers[j], old_sizes[j], 1, output_des);
-                    bytes_written += old_sizes[j];
-                }
-            }
-            fflush(output_des);
-        } else if (mode == MODE_TEST) {
-            while (!feof(input_des)) {
-                s32 i = 0;
-                for (; i < workers; i++) {
-                    if (!xread_eofcheck(&byteswap_buf, 1, 4, input_des)) break;
-                    sizes[i] = read_neutral_s32(byteswap_buf);
-                    xread_noeof(&byteswap_buf, 1, 4, input_des);
-                    old_sizes[i] = read_neutral_s32(byteswap_buf);
-                    if (old_sizes[i] > block_size + 31) {
-                        fprintf(stderr, "Failed to decode a block: Inconsistent headers.\n");
-                        return 1;
-                    }
-                    xread_noeof(buffers[i], 1, sizes[i], input_des);
-                    bytes_read += 8 + sizes[i];
-                }
-                bz3_decode_blocks(states, buffers, sizes, old_sizes, i);
-                for (s32 j = 0; j < i; j++) {
-                    if (bz3_last_error(states[j]) != BZ3_OK) {
-                        fprintf(stderr, "Failed to decode data: %s\n", bz3_strerror(states[j]));
-                        return 1;
-                    }
-                }
-            }
-        }
-
-        for (s32 i = 0; i < workers; i++) {
-            free(buffers[i]);
-            bz3_free(states[i]);
-        }
-    }
-#endif
-
-    if (verbose) {
-        if (file_name) fprintf(stderr, " %s:", file_name);
-        if (mode == MODE_ENCODE)
-            fprintf(stderr, "\t%" PRIu64 " -> %" PRIu64 " bytes, %.2f%%, %.2f bpb\n", bytes_read, bytes_written,
-                    (double)bytes_written * 100.0 / bytes_read, (double)bytes_written * 8.0 / bytes_read);
-        else if (mode == MODE_DECODE)
-            fprintf(stderr, "\t%" PRIu64 " -> %" PRIu64 " bytes, %.2f%%, %.2f bpb\n", bytes_read, bytes_written,
-                    (double)bytes_read * 100.0 / bytes_written, (double)bytes_read * 8.0 / bytes_written);
-        else
-            fprintf(stderr, "OK, %" PRIu64 " bytes read.\n", bytes_read);
-    }
-
-    return 0;
-}
-
-static int is_dir(const char * path) {
-    struct stat sb;
-    if (stat(path, &sb) == 0 && S_ISDIR(sb.st_mode)) return 1;
-    return 0;
-}
-
-static int is_numeric(const char * str) {
-    for (; *str; str++)
-        if (!isdigit(*str)) return 0;
-    return 1;
-}
-
-static FILE * open_output(char * output, int force) {
-    FILE * output_des = NULL;
-
-    if (output != NULL) {
-        if (is_dir(output)) {
-            fprintf(stderr, "Error: output file `%s' is a directory.\n", output);
-            exit(1);
-        }
-
-        if (access(output, F_OK) == 0) {
-            if (!force) {
-                fprintf(stderr, "Error: output file `%s' already exists. Use -f to force overwrite.\n", output);
-                exit(1);
-            }
-        }
-
-        output_des = fopen(output, "wb");
-        if (output_des == NULL) {
-            fprintf(stderr, "Error: failed to open output file `%s': %s\n", output, strerror(errno));
-            exit(1);
-        }
-    } else {
-        output_des = stdout;
-    }
-
-    return output_des;
-}
-
-static FILE * open_input(char * input) {
-    FILE * input_des = NULL;
-
-    if (input != NULL) {
-        if (is_dir(input)) {
-            fprintf(stderr, "Error: input `%s' is a directory.\n", input);
-            exit(1);
-        }
-
-        input_des = fopen(input, "rb");
-        if (input_des == NULL) {
-            fprintf(stderr, "Error: failed to open input file `%s': %s\n", input, strerror(errno));
-            exit(1);
-        }
-    } else {
-        input_des = stdin;
-    }
-
-    return input_des;
-}
-
-int main(int argc, char * argv[]) {
-    int mode = MODE_ENCODE;
-
-    // input and output file names
-    char *input = NULL, *output = NULL;
-    char *f1 = NULL, *f2 = NULL;
-    int force = 0;
-
-    // command line arguments
-    int force_stdstreams = 0, workers = 0, batch = 0, verbose = 0;
-
-    // the block size
-    u32 block_size = MiB(16);
-
-#ifdef PTHREAD
-    const char * short_options = "Bb:cdefhj:ktvVz";
-#else
-    const char * short_options = "Bb:cdefhktvVz";
-#endif
-
-    static struct option long_options[] = { { "encode", no_argument, 0, 'e' },
-                                            { "decode", no_argument, 0, 'd' },
-                                            { "test", no_argument, 0, 't' },
-                                            { "stdout", no_argument, 0, 'c' },
-                                            { "force", no_argument, 0, 'f' },
-                                            { "help", no_argument, 0, 'h' },
-                                            { "keep", no_argument, 0, 'k' },
-                                            { "version", no_argument, 0, 'V' },
-                                            { "verbose", no_argument, 0, 'v' },
-                                            { "block", required_argument, 0, 'b' },
-                                            { "batch", no_argument, 0, 'B' },
-#ifdef PTHREAD
-                                            { "jobs", required_argument, 0, 'j' },
-#endif
-                                            { 0, 0, 0, 0 } };
-
-    while (1) {
-        int option_index = 0;
-        int c = getopt_long(argc, argv, short_options, long_options, &option_index);
-        if (c == -1) break;
-
-        switch (c) {
-            case '?':
-                fprintf(stderr, "Try 'bzip3 --help' for more information.\n");
-                return 1;
-            case 'e':
-            case 'z':
-                mode = MODE_ENCODE;
-                break;
-            case 'd':
-                mode = MODE_DECODE;
-                break;
-            case 't':
-                mode = MODE_TEST;
-                break;
-            case 'c':
-                force_stdstreams = 1;
-                break;
-            case 'f':
-                force = 1;
-                break;
-            case 'k':
-                break;
-            case 'h':
-                help();
-                return 0;
-            case 'V':
-                version();
-                return 0;
-            case 'B':
-                batch = 1;
-                break;
-            case 'v':
-                verbose = 1;
-                break;
-            case 'b':
-                if (!is_numeric(optarg)) {
-                    fprintf(stderr, "bzip3: invalid block size: %s\n", optarg);
-                    return 1;
-                }
-                block_size = MiB(atoi(optarg));
-                break;
-#ifdef PTHREAD
-            case 'j':
-                if (!is_numeric(optarg)) {
-                    fprintf(stderr, "bzip3: invalid amount of jobs: %s\n", optarg);
-                    return 1;
-                }
-                workers = atoi(optarg);
-                break;
-#endif
-        }
-    }
-
-#if defined(__MSVCRT__)
-    setmode(STDIN_FILENO, O_BINARY);
-    setmode(STDOUT_FILENO, O_BINARY);
-#endif
-
-    if (block_size < KiB(65) || block_size > MiB(511)) {
-        fprintf(stderr, "Block size must be between 65 KiB and 511 MiB.\n");
-        return 1;
-    }
-
-    if (batch) {
-        switch (mode) {
-            case MODE_ENCODE:
-                /* Encode each of the files. */
-                while (optind < argc) {
-                    char * arg = argv[optind++];
-
-                    FILE * input_des = open_input(arg);
-                    char * output_name;
-                    if (force_stdstreams)
-                        output_name = NULL;
-                    else {
-                        output_name = malloc(strlen(arg) + 5);
-                        strcpy(output_name, arg);
-                        strcat(output_name, ".bz3");
-                    }
-
-                    FILE * output_des = open_output(output_name, force);
-                    process(input_des, output_des, mode, block_size, workers, verbose, arg);
-
-                    fclose(input_des);
-                    close_out_file(output_des);
-                    if (!force_stdstreams) free(output_name);
-                }
-                break;
-            case MODE_DECODE:
-                /* Decode each of the files. */
-                while (optind < argc) {
-                    char * arg = argv[optind++];
-
-                    FILE * input_des = open_input(arg);
-                    char * output_name;
-                    if (force_stdstreams)
-                        output_name = NULL;
-                    else {
-                        output_name = malloc(strlen(arg) + 1);
-                        strcpy(output_name, arg);
-                        if (strlen(output_name) > 4 && !strcmp(output_name + strlen(output_name) - 4, ".bz3"))
-                            output_name[strlen(output_name) - 4] = 0;
-                        else {
-                            fprintf(stderr, "Warning: file %s has an unknown extension, skipping.\n", arg);
-                            return 1;
-                        }
-                    }
-
-                    FILE * output_des = open_output(output_name, force);
-                    process(input_des, output_des, mode, block_size, workers, verbose, arg);
-
-                    fclose(input_des);
-                    close_out_file(output_des);
-                    if (!force_stdstreams) free(output_name);
-                }
-                break;
-            case MODE_TEST:
-                /* Test each of the files. */
-                while (optind < argc) {
-                    char * arg = argv[optind++];
-
-                    FILE * input_des = open_input(arg);
-                    process(input_des, NULL, mode, block_size, workers, verbose, arg);
-                    fclose(input_des);
-                }
-                break;
-        }
-
-        if (fclose(stdout)) {
-            fprintf(stderr, "Error: Failed on fclose(stdout): %s\n", strerror(errno));
-            return 1;
-        }
-
-        return 0;
-    }
-
-    while (optind < argc) {
-        // Positional argument. Likely a file name.
-        char * arg = argv[optind++];
-
-        if (f1 != NULL && f2 != NULL) {
-            fprintf(stderr, "Error: too many files specified.\n");
-            return 1;
-        }
-
-        if (f1 == NULL)
-            f1 = arg;
-        else
-            f2 = arg;
-    }
-
-    if (f1 == NULL && f2 == NULL)
-        input = NULL, output = NULL;
-    else if (mode == MODE_TEST)
-        input = f1;
-    else {
-        if (mode == MODE_ENCODE) {
-            if (f2 == NULL) {
-                // encode from f1?
-                input = f1;
-                if (force_stdstreams)
-                    output = NULL;
-                else {
-                    output = malloc(strlen(f1) + 5);
-                    strcpy(output, f1);
-                    strcat(output, ".bz3");
-                }
-            } else {
-                // encode from f1 to f2.
-                input = f1;
-                output = f2;
-            }
-        } else if (mode == MODE_DECODE) {
-            if (f2 == NULL) {
-                // decode from f1 to stdout.
-                input = f1;
-                if (force_stdstreams)
-                    output = NULL;
-                else {
-                    output = malloc(strlen(f1) + 1);
-                    strcpy(output, f1);
-                    if (strlen(output) > 4 && !strcmp(output + strlen(output) - 4, ".bz3"))
-                        output[strlen(output) - 4] = 0;
-                    else {
-                        fprintf(stderr, "Warning: file %s has an unknown extension, skipping.\n", f1);
-                        return 1;
-                    }
-                }
-            } else {
-                // decode from f1 to f2.
-                input = f1;
-                output = f2;
-            }
-        }
-    }
-
-    FILE *input_des = NULL, *output_des = NULL;
-
-    output_des = mode != MODE_TEST ? open_output(output, force) : NULL;
-    input_des = open_input(input);
-
-    if (output != f2) free(output);
-
-    int r = process(input_des, output_des, mode, block_size, workers, verbose, input);
-
-    fclose(input_des);
-    close_out_file(output_des);
-    if (fclose(stdout)) {
-        fprintf(stderr, "Error: Failed on fclose(stdout): %s\n", strerror(errno));
-        return 1;
-    }
-
-    return r;
-}
+
+/*
+ * BZip3 - A spiritual successor to BZip2.
+ * Copyright (C) 2022-2023 Kamila Szewczyk
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by the Free
+ * Software Foundation, either version 3 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <ctype.h>
+#include <errno.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#ifdef HAVE_GETOPT_LONG
+    #include <getopt.h>
+#else
+    #include "getopt-shim.h"
+#endif
+
+#if defined __MSVCRT__
+    #include <fcntl.h>
+    #include <io.h>
+#endif
+
+#include "common.h"
+#include "libbz3.h"
+
+#define MODE_DECODE 0
+#define MODE_ENCODE 1
+#define MODE_TEST 2
+#define MODE_RECOVER 3
+
+static void version() {
+    fprintf(stdout, "bzip3 " VERSION
+                    "\n"
+                    "Copyright (C) by Kamila Szewczyk, 2022-2023.\n"
+                    "License: GNU Lesser GPL version 3 <https://www.gnu.org/licenses/lgpl-3.0.en.html>\n");
+}
+
+static void help() {
+    fprintf(stdout,
+            "bzip3 - better and stronger spiritual successor to bzip2.\n"
+            "Usage: bzip3 [-e/-z/-d/-t/-c/-h/-V] [-b block_size] [-j jobs] files...\n"
+            "Operations:\n"
+            "  -e/-z, --encode   compress data (default)\n"
+            "  -d, --decode      decompress data\n"
+			"  -r, --recover     attempt at recovering corrupted data\n"
+            "  -t, --test        verify validity of compressed data\n"
+            "  -h, --help        display an usage overview\n"
+            "  -f, --force       force overwriting output if it already exists\n"
+            "  -k, --keep        keep (don't delete) input files (default)\n"
+            "  -v, --verbose     verbose mode (display more information)\n"
+            "  -V, --version     display version information\n"
+            "Extra flags:\n"
+            "  -c, --stdout      force writing to standard output\n"
+            "  -b N, --block=N   set block size in MiB {16}\n"
+            "  -B, --batch       process all files specified as inputs\n"
+#ifdef PTHREAD
+            "  -j N, --jobs=N    set the amount of parallel threads\n"
+#endif
+            "\n"
+            "Report bugs to: https://github.com/kspalaiologos/bzip3\n");
+}
+
+static void xwrite(const void * data, size_t size, size_t len, FILE * des) {
+    if (len == 0 || size == 0)
+        return;
+    if (fwrite(data, size, len, des) != len) {
+        fprintf(stderr, "Write error: %s\n", strerror(errno));
+        exit(1);
+    }
+}
+
+/* Read any amount of items (from 0 to len) as long as there is no error */
+static size_t xread(void * data, size_t size, size_t len, FILE * des) {
+    size_t written = fread(data, size, len, des);
+    if (ferror(des)) {
+        fprintf(stderr, "Read error: %s\n", strerror(errno));
+        exit(1);
+    }
+    return written;
+}
+
+/* Either read 0 (due to eof) items or exactly len items */
+static size_t xread_eofcheck(void * data, size_t size, size_t len, FILE * des) {
+    size_t written = xread(data, size, len, des);
+    /* feof will be true */
+    if (!written) return 0;
+    if (feof(des)) {
+        fprintf(stderr, "Error: Corrupt file\n");
+        exit(1);
+    }
+    return written;
+}
+
+/* Always read len items */
+static void xread_noeof(void * data, size_t size, size_t len, FILE * des) {
+    if (!xread_eofcheck(data, size, len, des)) {
+        fprintf(stderr, "Error: Corrupt file\n");
+        exit(1);
+    }
+}
+
+static void close_out_file(FILE * des) {
+    if (des) {
+        int outfd = fileno(des);
+
+        if (fflush(des)) {
+            fprintf(stderr, "Error: Failed on fflush: %s\n", strerror(errno));
+            exit(1);
+        }
+
+#ifdef __linux__
+        while (1) {
+            int status = fsync(outfd);
+            if (status == -1) {
+                if (errno == EINVAL) break;
+                if (errno == EINTR) continue;
+                fprintf(stderr, "Error: Failed on fsync: %s\n", strerror(errno));
+                exit(1);
+            }
+            break;
+        }
+#endif
+
+        if (des != stdout && fclose(des)) {
+            fprintf(stderr, "Error: Failed on fclose: %s\n", strerror(errno));
+            exit(1);
+        }
+    }
+}
+
+static int process(FILE * input_des, FILE * output_des, int mode, int block_size, int workers, int verbose,
+                   char * file_name) {
+    uint64_t bytes_read = 0, bytes_written = 0;
+
+    if ((mode == MODE_ENCODE && isatty(fileno(output_des))) ||
+        ((mode == MODE_DECODE || mode == MODE_TEST || mode == MODE_RECOVER) && isatty(fileno(input_des)))) {
+        fprintf(stderr, "Refusing to read/write binary data from/to the terminal.\n");
+        return 1;
+    }
+
+    // Reset errno after the isatty() call.
+    errno = 0;
+
+    u8 byteswap_buf[4];
+
+    switch (mode) {
+        case MODE_ENCODE:
+            xwrite("BZ3v1", 5, 1, output_des);
+
+            write_neutral_s32(byteswap_buf, block_size);
+            xwrite(byteswap_buf, 4, 1, output_des);
+
+            bytes_written += 9;
+            break;
+		case MODE_RECOVER:
+        case MODE_DECODE:
+        case MODE_TEST: {
+            char signature[5];
+
+            if (xread(signature, 5, 1, input_des) != 1 || strncmp(signature, "BZ3v1", 5) != 0) {
+                fprintf(stderr, "Invalid signature.\n");
+                return 1;
+            }
+
+            xread_noeof(byteswap_buf, 4, 1, input_des);
+
+            block_size = read_neutral_s32(byteswap_buf);
+
+            if (block_size < KiB(65) || block_size > MiB(511)) {
+                fprintf(stderr,
+                        "The input file is corrupted. Reason: Invalid block "
+                        "size in the header.\n");
+				if(mode == MODE_RECOVER) {
+					fprintf(stderr, "Recovery mode: Proceeding.\n");
+					block_size = MiB(511);
+				} else {
+					return 1;
+				}
+            }
+
+            bytes_read += 9;
+            break;
+        }
+    }
+
+#ifdef PTHREAD
+    if (workers > 64 || workers < 0) {
+        fprintf(stderr, "Number of workers must be between 0 and 64.\n");
+        return 1;
+    }
+
+    if (workers <= 1) {
+#endif
+        struct bz3_state * state = bz3_new(block_size);
+
+        if (state == NULL) {
+            fprintf(stderr, "Failed to create a block encoder state.\n");
+            return 1;
+        }
+
+        u8 * buffer = malloc(bz3_bound(block_size));
+
+        if (!buffer) {
+            fprintf(stderr, "Failed to allocate memory.\n");
+            return 1;
+        }
+
+        if (mode == MODE_ENCODE) {
+            s32 read_count;
+            while (!feof(input_des)) {
+                read_count = xread(buffer, 1, block_size, input_des);
+                bytes_read += read_count;
+
+                if (read_count == 0) break;
+
+                s32 new_size = bz3_encode_block(state, buffer, read_count);
+                if (new_size == -1) {
+                    fprintf(stderr, "Failed to encode a block: %s\n", bz3_strerror(state));
+                    return 1;
+                }
+
+                write_neutral_s32(byteswap_buf, new_size);
+                xwrite(byteswap_buf, 4, 1, output_des);
+                write_neutral_s32(byteswap_buf, read_count);
+                xwrite(byteswap_buf, 4, 1, output_des);
+                xwrite(buffer, new_size, 1, output_des);
+                bytes_written += 8 + new_size;
+            }
+            fflush(output_des);
+        } else if (mode == MODE_DECODE) {
+            s32 new_size, old_size;
+            while (!feof(input_des)) {
+                if (!xread_eofcheck(&byteswap_buf, 1, 4, input_des)) continue;
+
+                new_size = read_neutral_s32(byteswap_buf);
+                xread_noeof(&byteswap_buf, 1, 4, input_des);
+                old_size = read_neutral_s32(byteswap_buf);
+                if (old_size > bz3_bound(block_size) || new_size > bz3_bound(block_size)) {
+                    fprintf(stderr, "Failed to decode a block: Inconsistent headers.\n");
+                    return 1;
+                }
+                xread_noeof(buffer, 1, new_size, input_des);
+                bytes_read += 8 + new_size;
+                if (bz3_decode_block(state, buffer, new_size, old_size) == -1) {
+                    fprintf(stderr, "Failed to decode a block: %s\n", bz3_strerror(state));
+                    return 1;
+                }
+                xwrite(buffer, old_size, 1, output_des);
+                bytes_written += old_size;
+            }
+            fflush(output_des);
+        } else if (mode == MODE_RECOVER) {
+            s32 new_size, old_size;
+            while (!feof(input_des)) {
+                if (!xread_eofcheck(&byteswap_buf, 1, 4, input_des)) continue;
+
+                new_size = read_neutral_s32(byteswap_buf);
+                xread_noeof(&byteswap_buf, 1, 4, input_des);
+                old_size = read_neutral_s32(byteswap_buf);
+                if (old_size > bz3_bound(block_size) || new_size > bz3_bound(block_size)) {
+                    fprintf(stderr, "Failed to decode a block: Inconsistent headers.\n");
+                    return 1;
+                }
+                xread_noeof(buffer, 1, new_size, input_des);
+                bytes_read += 8 + new_size;
+                if (bz3_decode_block(state, buffer, new_size, old_size) == -1) {
+                    fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(state));
+                }
+                xwrite(buffer, old_size, 1, output_des);
+                bytes_written += old_size;
+            }
+            fflush(output_des);
+        } else if (mode == MODE_TEST) {
+            s32 new_size, old_size;
+            while (!feof(input_des)) {
+                if (!xread_eofcheck(&byteswap_buf, 1, 4, input_des)) continue;
+                new_size = read_neutral_s32(byteswap_buf);
+                xread_noeof(&byteswap_buf, 1, 4, input_des);
+                old_size = read_neutral_s32(byteswap_buf);
+                if (old_size > bz3_bound(block_size) || new_size > bz3_bound(block_size)) {
+                    fprintf(stderr, "Failed to decode a block: Inconsistent headers.\n");
+                    return 1;
+                }
+                xread_noeof(buffer, 1, new_size, input_des);
+                bytes_read += 8 + new_size;
+                bytes_written += old_size;
+                if (bz3_decode_block(state, buffer, new_size, old_size) == -1) {
+                    fprintf(stderr, "Failed to decode a block: %s\n", bz3_strerror(state));
+                    return 1;
+                }
+            }
+        }
+
+        if (bz3_last_error(state) != BZ3_OK && mode != MODE_RECOVER) {
+            fprintf(stderr, "Failed to read data: %s\n", bz3_strerror(state));
+            return 1;
+        }
+
+        free(buffer);
+
+        bz3_free(state);
+#ifdef PTHREAD
+    } else {
+        struct bz3_state * states[workers];
+        u8 * buffers[workers];
+        s32 sizes[workers];
+        s32 old_sizes[workers];
+        for (s32 i = 0; i < workers; i++) {
+            states[i] = bz3_new(block_size);
+            if (states[i] == NULL) {
+                fprintf(stderr, "Failed to create a block encoder state.\n");
+                return 1;
+            }
+            buffers[i] = malloc(block_size + block_size / 50 + 32);
+            if (!buffers[i]) {
+                fprintf(stderr, "Failed to allocate memory.\n");
+                return 1;
+            }
+        }
+
+        if (mode == MODE_ENCODE) {
+            while (!feof(input_des)) {
+                s32 i = 0;
+                for (; i < workers; i++) {
+                    size_t read_count = xread(buffers[i], 1, block_size, input_des);
+                    bytes_read += read_count;
+                    sizes[i] = old_sizes[i] = read_count;
+                    if (read_count < block_size) {
+                        i++;
+                        break;
+                    }
+                }
+                bz3_encode_blocks(states, buffers, sizes, i);
+                for (s32 j = 0; j < i; j++) {
+                    if (bz3_last_error(states[j]) != BZ3_OK) {
+                        fprintf(stderr, "Failed to encode data: %s\n", bz3_strerror(states[j]));
+                        return 1;
+                    }
+                }
+                for (s32 j = 0; j < i; j++) {
+                    write_neutral_s32(byteswap_buf, sizes[j]);
+                    xwrite(byteswap_buf, 4, 1, output_des);
+                    write_neutral_s32(byteswap_buf, old_sizes[j]);
+                    xwrite(byteswap_buf, 4, 1, output_des);
+                    xwrite(buffers[j], sizes[j], 1, output_des);
+                    bytes_written += 8 + sizes[j];
+                }
+            }
+            fflush(output_des);
+        } else if (mode == MODE_DECODE) {
+            while (!feof(input_des)) {
+                s32 i = 0;
+                for (; i < workers; i++) {
+                    if (!xread_eofcheck(&byteswap_buf, 1, 4, input_des)) break;
+                    sizes[i] = read_neutral_s32(byteswap_buf);
+                    xread_noeof(&byteswap_buf, 1, 4, input_des);
+                    old_sizes[i] = read_neutral_s32(byteswap_buf);
+                    if (old_sizes[i] > bz3_bound(block_size) || sizes[i] > bz3_bound(block_size)) {
+                        fprintf(stderr, "Failed to decode a block: Inconsistent headers.\n");
+                        return 1;
+                    }
+                    xread_noeof(buffers[i], 1, sizes[i], input_des);
+                    bytes_read += 8 + sizes[i];
+                }
+                bz3_decode_blocks(states, buffers, sizes, old_sizes, i);
+                for (s32 j = 0; j < i; j++) {
+                    if (bz3_last_error(states[j]) != BZ3_OK) {
+                        fprintf(stderr, "Failed to decode data: %s\n", bz3_strerror(states[j]));
+                        return 1;
+                    }
+                }
+                for (s32 j = 0; j < i; j++) {
+                    xwrite(buffers[j], old_sizes[j], 1, output_des);
+                    bytes_written += old_sizes[j];
+                }
+            }
+            fflush(output_des);
+        } else if (mode == MODE_RECOVER) {
+            while (!feof(input_des)) {
+                s32 i = 0;
+                for (; i < workers; i++) {
+                    if (!xread_eofcheck(&byteswap_buf, 1, 4, input_des)) break;
+                    sizes[i] = read_neutral_s32(byteswap_buf);
+                    xread_noeof(&byteswap_buf, 1, 4, input_des);
+                    old_sizes[i] = read_neutral_s32(byteswap_buf);
+                    if (old_sizes[i] > bz3_bound(block_size) || sizes[i] > bz3_bound(block_size)) {
+                        fprintf(stderr, "Failed to decode a block: Inconsistent headers.\n");
+                        return 1;
+                    }
+                    xread_noeof(buffers[i], 1, sizes[i], input_des);
+                    bytes_read += 8 + sizes[i];
+                }
+                bz3_decode_blocks(states, buffers, sizes, old_sizes, i);
+                for (s32 j = 0; j < i; j++) {
+                    if (bz3_last_error(states[j]) != BZ3_OK) {
+                        fprintf(stderr, "Writing invalid block: %s\n", bz3_strerror(states[j]));
+                    }
+                }
+                for (s32 j = 0; j < i; j++) {
+                    xwrite(buffers[j], old_sizes[j], 1, output_des);
+                    bytes_written += old_sizes[j];
+                }
+            }
+            fflush(output_des);
+        } else if (mode == MODE_TEST) {
+            while (!feof(input_des)) {
+                s32 i = 0;
+                for (; i < workers; i++) {
+                    if (!xread_eofcheck(&byteswap_buf, 1, 4, input_des)) break;
+                    sizes[i] = read_neutral_s32(byteswap_buf);
+                    xread_noeof(&byteswap_buf, 1, 4, input_des);
+                    old_sizes[i] = read_neutral_s32(byteswap_buf);
+                    if (old_sizes[i] > bz3_bound(block_size) || sizes[i] > bz3_bound(block_size)) {
+                        fprintf(stderr, "Failed to decode a block: Inconsistent headers.\n");
+                        return 1;
+                    }
+                    xread_noeof(buffers[i], 1, sizes[i], input_des);
+                    bytes_read += 8 + sizes[i];
+                    bytes_written += old_sizes[i];
+                }
+                bz3_decode_blocks(states, buffers, sizes, old_sizes, i);
+                for (s32 j = 0; j < i; j++) {
+                    if (bz3_last_error(states[j]) != BZ3_OK) {
+                        fprintf(stderr, "Failed to decode data: %s\n", bz3_strerror(states[j]));
+                        return 1;
+                    }
+                }
+            }
+        }
+
+        for (s32 i = 0; i < workers; i++) {
+            free(buffers[i]);
+            bz3_free(states[i]);
+        }
+    }
+#endif
+
+    if (verbose) {
+        if (file_name) fprintf(stderr, " %s:", file_name);
+        if (mode == MODE_ENCODE)
+            fprintf(stderr, "\t%" PRIu64 " -> %" PRIu64 " bytes, %.2f%%, %.2f bpb\n", bytes_read, bytes_written,
+                    (double)bytes_written * 100.0 / bytes_read, (double)bytes_written * 8.0 / bytes_read);
+        else if (mode == MODE_DECODE)
+            fprintf(stderr, "\t%" PRIu64 " -> %" PRIu64 " bytes, %.2f%%, %.2f bpb\n", bytes_read, bytes_written,
+                    (double)bytes_read * 100.0 / bytes_written, (double)bytes_read * 8.0 / bytes_written);
+        else
+            fprintf(stderr, "\tOK, %" PRIu64 " -> %" PRIu64 " bytes, %.2f%%, %.2f bpb\n", bytes_read, bytes_written,
+                    (double)bytes_read * 100.0 / bytes_written, (double)bytes_read * 8.0 / bytes_written);
+    }
+
+    return 0;
+}
+
+static int is_dir(const char * path) {
+    struct stat sb;
+    if (stat(path, &sb) == 0 && S_ISDIR(sb.st_mode)) return 1;
+    return 0;
+}
+
+static int is_numeric(const char * str) {
+    for (; *str; str++)
+        if (!isdigit(*str)) return 0;
+    return 1;
+}
+
+static FILE * open_output(char * output, int force) {
+    FILE * output_des = NULL;
+
+    if (output != NULL) {
+        if (is_dir(output)) {
+            fprintf(stderr, "Error: output file `%s' is a directory.\n", output);
+            exit(1);
+        }
+
+        if (access(output, F_OK) == 0) {
+            if (!force) {
+                fprintf(stderr, "Error: output file `%s' already exists. Use -f to force overwrite.\n", output);
+                exit(1);
+            }
+        }
+
+        output_des = fopen(output, "wb");
+        if (output_des == NULL) {
+            fprintf(stderr, "Error: failed to open output file `%s': %s\n", output, strerror(errno));
+            exit(1);
+        }
+    } else {
+        output_des = stdout;
+    }
+
+    return output_des;
+}
+
+static FILE * open_input(char * input) {
+    FILE * input_des = NULL;
+
+    if (input != NULL) {
+        if (is_dir(input)) {
+            fprintf(stderr, "Error: input `%s' is a directory.\n", input);
+            exit(1);
+        }
+
+        input_des = fopen(input, "rb");
+        if (input_des == NULL) {
+            fprintf(stderr, "Error: failed to open input file `%s': %s\n", input, strerror(errno));
+            exit(1);
+        }
+    } else {
+        input_des = stdin;
+    }
+
+    return input_des;
+}
+
+int main(int argc, char * argv[]) {
+    int mode = MODE_ENCODE;
+
+    // input and output file names
+    char *input = NULL, *output = NULL;
+    char *f1 = NULL, *f2 = NULL;
+    int force = 0;
+
+    // command line arguments
+    int force_stdstreams = 0, workers = 0, batch = 0, verbose = 0;
+
+    // the block size
+    u32 block_size = MiB(16);
+
+#ifdef PTHREAD
+    const char * short_options = "Bb:cdefhj:krtvVz";
+#else
+    const char * short_options = "Bb:cdefhkrtvVz";
+#endif
+
+    static struct option long_options[] = { { "encode", no_argument, 0, 'e' },
+                                            { "decode", no_argument, 0, 'd' },
+                                            { "test", no_argument, 0, 't' },
+                                            { "stdout", no_argument, 0, 'c' },
+                                            { "force", no_argument, 0, 'f' },
+											{ "recover", no_argument, 0, 'r' },
+                                            { "help", no_argument, 0, 'h' },
+                                            { "keep", no_argument, 0, 'k' },
+                                            { "version", no_argument, 0, 'V' },
+                                            { "verbose", no_argument, 0, 'v' },
+                                            { "block", required_argument, 0, 'b' },
+                                            { "batch", no_argument, 0, 'B' },
+#ifdef PTHREAD
+                                            { "jobs", required_argument, 0, 'j' },
+#endif
+                                            { 0, 0, 0, 0 } };
+
+    while (1) {
+        int option_index = 0;
+        int c = getopt_long(argc, argv, short_options, long_options, &option_index);
+        if (c == -1) break;
+
+        switch (c) {
+            case '?':
+                fprintf(stderr, "Try 'bzip3 --help' for more information.\n");
+                return 1;
+            case 'e':
+            case 'z':
+                mode = MODE_ENCODE;
+                break;
+            case 'd':
+                mode = MODE_DECODE;
+                break;
+			case 'r':
+                mode = MODE_RECOVER;
+                break;
+            case 't':
+                mode = MODE_TEST;
+                break;
+            case 'c':
+                force_stdstreams = 1;
+                break;
+            case 'f':
+                force = 1;
+                break;
+            case 'k':
+                break;
+            case 'h':
+                help();
+                return 0;
+            case 'V':
+                version();
+                return 0;
+            case 'B':
+                batch = 1;
+                break;
+            case 'v':
+                verbose = 1;
+                break;
+            case 'b':
+                if (!is_numeric(optarg)) {
+                    fprintf(stderr, "bzip3: invalid block size: %s\n", optarg);
+                    return 1;
+                }
+                block_size = MiB(atoi(optarg));
+                break;
+#ifdef PTHREAD
+            case 'j':
+                if (!is_numeric(optarg)) {
+                    fprintf(stderr, "bzip3: invalid amount of jobs: %s\n", optarg);
+                    return 1;
+                }
+                workers = atoi(optarg);
+                break;
+#endif
+        }
+    }
+
+#if defined(__MSVCRT__)
+    setmode(STDIN_FILENO, O_BINARY);
+    setmode(STDOUT_FILENO, O_BINARY);
+#endif
+
+    if (block_size < KiB(65) || block_size > MiB(511)) {
+        fprintf(stderr, "Block size must be between 65 KiB and 511 MiB.\n");
+        return 1;
+    }
+
+    if (batch) {
+        switch (mode) {
+            case MODE_ENCODE:
+                /* Encode each of the files. */
+                while (optind < argc) {
+                    char * arg = argv[optind++];
+
+                    FILE * input_des = open_input(arg);
+                    char * output_name;
+                    if (force_stdstreams)
+                        output_name = NULL;
+                    else {
+                        output_name = malloc(strlen(arg) + 5);
+                        strcpy(output_name, arg);
+                        strcat(output_name, ".bz3");
+                    }
+
+                    FILE * output_des = open_output(output_name, force);
+                    process(input_des, output_des, mode, block_size, workers, verbose, arg);
+
+                    fclose(input_des);
+                    close_out_file(output_des);
+                    if (!force_stdstreams) free(output_name);
+                }
+                break;
+			case MODE_RECOVER:
+            case MODE_DECODE:
+                /* Decode each of the files. */
+                while (optind < argc) {
+                    char * arg = argv[optind++];
+
+                    FILE * input_des = open_input(arg);
+                    char * output_name;
+                    if (force_stdstreams)
+                        output_name = NULL;
+                    else {
+                        output_name = malloc(strlen(arg) + 1);
+                        strcpy(output_name, arg);
+                        if (strlen(output_name) > 4 && !strcmp(output_name + strlen(output_name) - 4, ".bz3"))
+                            output_name[strlen(output_name) - 4] = 0;
+                        else {
+                            fprintf(stderr, "Warning: file %s has an unknown extension, skipping.\n", arg);
+                            return 1;
+                        }
+                    }
+
+                    FILE * output_des = open_output(output_name, force);
+                    process(input_des, output_des, mode, block_size, workers, verbose, arg);
+
+                    fclose(input_des);
+                    close_out_file(output_des);
+                    if (!force_stdstreams) free(output_name);
+                }
+                break;
+            case MODE_TEST:
+                /* Test each of the files. */
+                while (optind < argc) {
+                    char * arg = argv[optind++];
+
+                    FILE * input_des = open_input(arg);
+                    process(input_des, NULL, mode, block_size, workers, verbose, arg);
+                    fclose(input_des);
+                }
+                break;
+        }
+
+        if (fclose(stdout)) {
+            fprintf(stderr, "Error: Failed on fclose(stdout): %s\n", strerror(errno));
+            return 1;
+        }
+
+        return 0;
+    }
+
+    while (optind < argc) {
+        // Positional argument. Likely a file name.
+        char * arg = argv[optind++];
+
+        if (f1 != NULL && f2 != NULL) {
+            fprintf(stderr, "Error: too many files specified.\n");
+            return 1;
+        }
+
+        if (f1 == NULL)
+            f1 = arg;
+        else
+            f2 = arg;
+    }
+
+    if (f1 == NULL && f2 == NULL)
+        input = NULL, output = NULL;
+    else if (mode == MODE_TEST)
+        input = f1;
+    else {
+        if (mode == MODE_ENCODE) {
+            if (f2 == NULL) {
+                // encode from f1?
+                input = f1;
+                if (force_stdstreams)
+                    output = NULL;
+                else {
+                    output = malloc(strlen(f1) + 5);
+                    strcpy(output, f1);
+                    strcat(output, ".bz3");
+                }
+            } else {
+                // encode from f1 to f2.
+                input = f1;
+                output = f2;
+            }
+        } else if (mode == MODE_DECODE || mode == MODE_RECOVER) {
+            if (f2 == NULL) {
+                // decode from f1 to stdout.
+                input = f1;
+                if (force_stdstreams)
+                    output = NULL;
+                else {
+                    output = malloc(strlen(f1) + 1);
+                    strcpy(output, f1);
+                    if (strlen(output) > 4 && !strcmp(output + strlen(output) - 4, ".bz3"))
+                        output[strlen(output) - 4] = 0;
+                    else {
+                        fprintf(stderr, "Warning: file %s has an unknown extension, skipping.\n", f1);
+                        return 1;
+                    }
+                }
+            } else {
+                // decode from f1 to f2.
+                input = f1;
+                output = f2;
+            }
+        }
+    }
+
+    FILE *input_des = NULL, *output_des = NULL;
+
+    output_des = mode != MODE_TEST ? open_output(output, force) : NULL;
+    input_des = open_input(input);
+
+    if (output != f2) free(output);
+
+    int r = process(input_des, output_des, mode, block_size, workers, verbose, input);
+
+    fclose(input_des);
+    close_out_file(output_des);
+    if (fclose(stdout)) {
+        fprintf(stderr, "Error: Failed on fclose(stdout): %s\n", strerror(errno));
+        return 1;
+    }
+
+    return r;
+}
```

### Comparing `bzip3-0.1.2rc1/test/test_compress.py` & `bzip3-0.1.3rc1/test/test_compress.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,57 +1,65 @@
-"""
-Copyright (c) 2008-2021 synodriver <synodriver@gmail.com>
-"""
-import sys
-
-sys.path.append(".")
-import os
-from random import randint
-from unittest import TestCase
-
-from bz3 import (
-    bound,
-    compress_file,
-    compress_into,
-    decompress_file,
-    decompress_into,
-    libversion,
-)
-from bz3 import open as bz3_open
-from bz3 import test_file
-
-# os.environ["BZ3_USE_CFFI"] = "1"
-
-
-class TestCompress(TestCase):
-    def test_compress(self):
-        with open("test_input.tar", "rb") as inp, open("compressed.bz3", "wb") as out:
-            compress_file(inp, out, 1000 * 1000)
-
-    def test_decompress(self):
-        with open("compressed.bz3", "rb") as inp, open("output.tar", "wb") as out:
-            decompress_file(inp, out)
-
-    def test_filelike_write(self):
-        with bz3_open("test.bz3", "wt", encoding="utf-8") as f:
-            f.write("test data")
-        with bz3_open("test.bz3", "rt", encoding="utf-8") as f:
-            self.assertEqual(f.read(), "test data")
-
-    def test_zerocopy(self):
-        outsize = bound(100)
-        out = bytearray(200)
-        out2 = bytearray(200)
-        for i in range(1000):
-            inp = bytes([randint(0, 255) for _ in range(100)])
-            buffer_updated = compress_into(inp, out)
-            buffer_updated = decompress_into(out[:buffer_updated], out2)
-            self.assertEqual(bytes(out2[:buffer_updated]), inp)
-
-    def test_version(self):
-        self.assertTrue(isinstance(libversion(), str))
-
-
-if __name__ == "__main__":
-    import unittest
-
-    unittest.main()
+"""
+Copyright (c) 2008-2023 synodriver <diguohuangjiajinweijun@gmail.com>
+"""
+import sys
+
+sys.path.append(".")
+import os
+from random import randint
+from unittest import TestCase
+
+from bz3 import (
+    bound,
+    compress_file,
+    compress_into,
+    decompress_file,
+    decompress_into,
+    libversion,
+)
+from bz3 import open as bz3_open
+from bz3 import test_file
+
+# os.environ["BZ3_USE_CFFI"] = "1"
+
+
+class TestCompress(TestCase):
+    def test_compress(self):
+        with open("test_input.tar", "rb") as inp, open("compressed.bz3", "wb") as out:
+            compress_file(inp, out, 1000 * 1000)
+
+    def test_decompress(self):
+        with open("compressed.bz3", "rb") as inp, open("output.tar", "wb") as out:
+            decompress_file(inp, out)
+
+    def test_filelike_write(self):
+        with bz3_open("test.bz3", "wt", encoding="utf-8") as f:
+            f.write("test data")
+        with bz3_open("test.bz3", "rt", encoding="utf-8") as f:
+            self.assertEqual(f.read(), "test data")
+
+    def test_filelike_seek(self):
+        with bz3_open("test.bz3", "wt", encoding="utf-8") as f:
+            f.write("test data")
+        with bz3_open("test.bz3", "rb") as f:
+            f.seek(0, 2)
+            f.seek(0, 0)
+            self.assertEqual(f.read(), b"test data")
+
+    def test_zerocopy(self):
+        outsize = bound(100)
+        out = bytearray(200)
+        out2 = bytearray(200)
+        for i in range(1000):
+            inp = bytes([randint(0, 255) for _ in range(100)])
+            buffer_updated = compress_into(inp, out)
+            buffer_updated = decompress_into(out[:buffer_updated], out2)
+            self.assertEqual(bytes(out2[:buffer_updated]), inp)
+
+    def test_version(self):
+        self.assertTrue(isinstance(libversion(), str))
+
+
+if __name__ == "__main__":
+    import unittest
+
+    unittest.main()
```

