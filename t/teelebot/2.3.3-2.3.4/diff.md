# Comparing `tmp/teelebot-2.3.3-py3-none-any.whl.zip` & `tmp/teelebot-2.3.4-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,22 +1,22 @@
-Zip file size: 40622 bytes, number of entries: 20
--rw-rw-rw-  2.0 fat     4241 b- defN 23-May-15 07:38 teelebot/__init__.py
+Zip file size: 40905 bytes, number of entries: 20
+-rw-rw-rw-  2.0 fat     4301 b- defN 23-Jul-12 14:12 teelebot/__init__.py
 -rw-rw-rw-  2.0 fat      165 b- defN 23-May-08 17:02 teelebot/__main__.py
 -rw-rw-rw-  2.0 fat    33199 b- defN 23-May-29 02:04 teelebot/bot.py
--rw-rw-rw-  2.0 fat     7128 b- defN 23-May-14 14:32 teelebot/buffer.py
+-rw-rw-rw-  2.0 fat     7248 b- defN 23-Jul-12 13:37 teelebot/buffer.py
 -rw-rw-rw-  2.0 fat     1581 b- defN 23-May-15 07:43 teelebot/common.py
--rw-rw-rw-  2.0 fat    23008 b- defN 23-May-29 01:43 teelebot/handler.py
+-rw-rw-rw-  2.0 fat    23439 b- defN 23-Jul-12 13:37 teelebot/handler.py
 -rw-rw-rw-  2.0 fat     1807 b- defN 23-May-03 00:00 teelebot/logger.py
--rw-rw-rw-  2.0 fat     7059 b- defN 23-May-14 18:00 teelebot/metadata.py
--rw-rw-rw-  2.0 fat      737 b- defN 23-May-14 14:25 teelebot/polling.py
--rw-rw-rw-  2.0 fat     3824 b- defN 23-May-15 05:04 teelebot/request.py
--rw-rw-rw-  2.0 fat     4075 b- defN 23-May-14 14:30 teelebot/schedule.py
--rw-rw-rw-  2.0 fat      483 b- defN 23-May-29 01:16 teelebot/version.py
--rw-rw-rw-  2.0 fat     2665 b- defN 23-May-03 15:18 teelebot/webhook.py
--rw-rw-rw-  2.0 fat    35823 b- defN 23-May-29 02:26 teelebot-2.3.3.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     9719 b- defN 23-May-29 02:26 teelebot-2.3.3.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-May-29 02:26 teelebot-2.3.3.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       43 b- defN 23-May-29 02:26 teelebot-2.3.3.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat        9 b- defN 23-May-29 02:26 teelebot-2.3.3.dist-info/top_level.txt
--rw-rw-rw-  2.0 fat        2 b- defN 23-May-29 02:26 teelebot-2.3.3.dist-info/zip-safe
--rw-rw-r--  2.0 fat     1558 b- defN 23-May-29 02:26 teelebot-2.3.3.dist-info/RECORD
-20 files, 137218 bytes uncompressed, 38116 bytes compressed:  72.2%
+-rw-rw-rw-  2.0 fat     7235 b- defN 23-Jul-12 13:37 teelebot/metadata.py
+-rw-rw-rw-  2.0 fat      809 b- defN 23-Jul-12 14:13 teelebot/polling.py
+-rw-rw-rw-  2.0 fat     3917 b- defN 23-Jul-12 13:38 teelebot/request.py
+-rw-rw-rw-  2.0 fat     4307 b- defN 23-Jul-12 13:38 teelebot/schedule.py
+-rw-rw-rw-  2.0 fat      483 b- defN 23-Jul-12 13:38 teelebot/version.py
+-rw-rw-rw-  2.0 fat     2744 b- defN 23-Jul-12 14:14 teelebot/webhook.py
+-rw-rw-rw-  2.0 fat    35823 b- defN 23-Jul-12 14:37 teelebot-2.3.4.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     9719 b- defN 23-Jul-12 14:37 teelebot-2.3.4.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Jul-12 14:37 teelebot-2.3.4.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       43 b- defN 23-Jul-12 14:37 teelebot-2.3.4.dist-info/entry_points.txt
+-rw-rw-rw-  2.0 fat        9 b- defN 23-Jul-12 14:37 teelebot-2.3.4.dist-info/top_level.txt
+-rw-rw-rw-  2.0 fat        2 b- defN 23-Jul-12 14:37 teelebot-2.3.4.dist-info/zip-safe
+-rw-rw-r--  2.0 fat     1558 b- defN 23-Jul-12 14:37 teelebot-2.3.4.dist-info/RECORD
+20 files, 138481 bytes uncompressed, 38399 bytes compressed:  72.3%
```

## zipnote {}

```diff
@@ -33,29 +33,29 @@
 
 Filename: teelebot/version.py
 Comment: 
 
 Filename: teelebot/webhook.py
 Comment: 
 
-Filename: teelebot-2.3.3.dist-info/LICENSE
+Filename: teelebot-2.3.4.dist-info/LICENSE
 Comment: 
 
-Filename: teelebot-2.3.3.dist-info/METADATA
+Filename: teelebot-2.3.4.dist-info/METADATA
 Comment: 
 
-Filename: teelebot-2.3.3.dist-info/WHEEL
+Filename: teelebot-2.3.4.dist-info/WHEEL
 Comment: 
 
-Filename: teelebot-2.3.3.dist-info/entry_points.txt
+Filename: teelebot-2.3.4.dist-info/entry_points.txt
 Comment: 
 
-Filename: teelebot-2.3.3.dist-info/top_level.txt
+Filename: teelebot-2.3.4.dist-info/top_level.txt
 Comment: 
 
-Filename: teelebot-2.3.3.dist-info/zip-safe
+Filename: teelebot-2.3.4.dist-info/zip-safe
 Comment: 
 
-Filename: teelebot-2.3.3.dist-info/RECORD
+Filename: teelebot-2.3.4.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## teelebot/__init__.py

```diff
@@ -1,18 +1,19 @@
 # -*- coding:utf-8 -*-
 """
 @creation date: 2019-08-23
-@last modification: 2023-05-15
+@last modification: 2023-07-12
 """
 import os
 import requests
 import urllib3
 
 from .polling import _runUpdates
 from .webhook import _runWebhook
+from .logger import _logger
 from .bot import Bot
 
 urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
 
 
 name = "teelebot"
 __all__ = ['Bot']
@@ -35,17 +36,17 @@
         " \__/\___/\___/_/\___/_.___/\____/\__/   " + "\n"
     )
     print(" * Self-checking...", end="\r")
     req = requests.post(url=f'{bot._url}getWebhookInfo', verify=False, proxies=bot.proxies)
     if not req.json().get("ok"):
         if (req.json().get("error_code") == 401 and \
             req.json().get("description") == "Unauthorized"):
-            print("\nIf you already logout the bot from the cloud Bot API server,please wait at least 10 minutes and try again.")
+            _logger.warn("\nIf you already logout the bot from the cloud Bot API server,please wait at least 10 minutes and try again.")
         else:
-            print("\nFailed to get running mode!")
+            _logger.error("\nFailed to get running mode!")
         os._exit(0)
 
     status = req.json().get("result")
     pending_update_count = status["pending_update_count"]
     allowed_updates = status.get("allowed_updates", [])
 
     if bot._webhook:
@@ -74,30 +75,30 @@
                     max_connections=bot._pool_size,
                     allowed_updates=bot._allowed_updates,
                     drop_pending_updates=bot._drop_pending_updates,
                     secret_token=bot._secret_token
                 )
 
             if not status:
-                print("\nFailed to set Webhook!")
+                _logger.error("\nFailed to set Webhook!")
                 os._exit(0)
 
         print(" * The teelebot starts running",
               "\n * Version : v" + VERSION,
               "\n *    Mode : Webhook",
               "\n *  Thread : " + str(bot._pool_size),
               "\n *  Server : " + api_server + "\n")
         _runWebhook(bot=bot,
             host=bot._local_address,port=int(bot._local_port))
 
     else:
         if status["url"] != "" or status["has_custom_certificate"]:
             status = bot.deleteWebhook()
             if not status:
-                print("\nFailed to set getUpdates!")
+                _logger.error("\nFailed to set getUpdates!")
                 os._exit(0)
 
         print(" * The teelebot starts running",
               "\n * Version : v" + VERSION,
               "\n *    Mode : Polling",
               "\n *  Thread : " + str(bot._pool_size),
               "\n *  Server : " + api_server + "\n")
```

## teelebot/buffer.py

```diff
@@ -1,28 +1,30 @@
 '''
 @creation date: 2021-04-25
-@last modification: 2023-05-14
+@last modification: 2023-07-12
 '''
 from __future__ import print_function
 from sys import getsizeof, stderr
 from itertools import chain
 from collections import deque
 from pathlib import Path
 from typing import Tuple, Union
 try:
     from reprlib import repr
 except ImportError:
     pass
 
 import threading
 import inspect
+import traceback
 import os
 import copy
 
 from .metadata import _Metadata
+from .logger import _logger
 
 class _Buffer(object):
     """
     Buffer Class
     """
     def __init__(self, buffer_size, plugin_names, plugin_dir):
         self.__buffer_size = buffer_size
@@ -53,14 +55,16 @@
             result = {
                 "used": used,
                 "free": free,
                 "size": size
             }
             return True, result
         except Exception as e:
+            _logger.error(e)
+            traceback.print_exc()
             return False, {"exception": e}
 
     def sizeof(self, plugin_name: str = None) -> Tuple[bool, Union[str, int]]:
         """
         Get the memory size occupied by the buffer area of a single plugin,
         measured in bytes
         """
@@ -182,15 +186,15 @@
         def sizeof(o):
             if id(o) in seen:
                 return 0
             seen.add(id(o))
             s = getsizeof(o, default_size)
 
             if verbose:
-                print(s, type(o), repr(o), file=stderr)
+                _logger.error(s, type(o), repr(o), file=stderr)
 
             for typ, handler in all_handlers.items():
                 if isinstance(o, typ):
                     s += sum(map(sizeof, handler(o)))
                     break
             return s
```

## teelebot/handler.py

```diff
@@ -1,23 +1,25 @@
 # -*- coding:utf-8 -*-
 '''
 @creation date: 2019-08-23
-@last modification: 2023-05-29
+@last modification: 2023-07-12
 '''
 import configparser
 import argparse
 import re
 import os
 import sys
 import copy
 import shutil
+import traceback
 import requests
 
 from pathlib import Path
 from .metadata import _Metadata
+from .logger import _logger
 from .version import __author__, __github__, __version__
 from .common import (
     __metadata_templates__,
     __metadata_version_in_use__,
     __cloud_api_server__,
     __common_pkg_prefix__,
     __inline_mode_prefix__,
@@ -70,20 +72,20 @@
         config_dir = os.path.abspath(str(Path(args.config)))
     else:
         config_dir = str(Path(
             f"{os.path.abspath(os.path.expanduser('~'))}/.teelebot/config.cfg"))
     (path, filename) = os.path.split(config_dir)
     (filename_, extension) = os.path.splitext(filename)
     if extension != ".cfg":
-        print("Only support configuration files with .cfg suffix.")
+        _logger.error("Only support configuration files with .cfg suffix.")
         os._exit(0)
     if not os.path.exists(str(Path(path))):
         os.makedirs(str(Path(path)))
     if not os.path.exists(str(Path(config_dir))):
-        print("The configuration file does not exist.")
+        _logger.error("The configuration file does not exist.")
         plugin_dir = ""
         if args.plugin:
             plugin_dir = args.plugin
         key = ""
         if args.key:
             key = args.key
         root = ""
@@ -107,18 +109,18 @@
                     config_list.append(f"{key} = {value}\n")
             config_list[-1] = config_list[-1].strip()
             if config_list[-1].split("=")[1].strip() in [None, ""]:
                     config_list[-1] += " "
 
             conf_file.writelines(config_list)
             os.system("")
-            print("The configuration file has been created automatically.")
-            print(f"Configuration file path: \033[1;32m{str(config_dir)}\033[0m") # Green
+            _logger.info("The configuration file has been created automatically.")
+            _logger.info(f"Configuration file path: \033[1;32m{str(config_dir)}\033[0m") # Green
         if not args.key or not args.root:
-            print("Please modify the relevant parameters and restart the teelebot.")
+            _logger.warn("Please modify the relevant parameters and restart the teelebot.")
             os._exit(0)
         # else:
         #     print("\n")
 
     conf = configparser.ConfigParser()
     conf.read(config_dir)
     options = conf.options("config")
@@ -137,62 +139,62 @@
 
     if args.debug:
         default_args = ["plugin_dir", "key", "webhook", "root_id", "debug"]
     else:
         default_args = ["plugin_dir", "key", "webhook", "root_id"]
     for default_arg in default_args:
         if default_arg not in options:
-            print("The configuration file is missing necessary parameters.",
+            _logger.error("The configuration file is missing necessary parameters.",
                 "\nnecessary parameters:", default_args)
             os._exit(0)
 
     for option in options:
         config[str(option)] = conf.get("config", option)
 
     none_count = 0
     for default_arg in default_args:
         if config[default_arg] == "" or\
             config[default_arg] == None:
             none_count += 1
-            print(f"Field {default_arg} is not set in configuration file.")
+            _logger.error(f"Field {default_arg} is not set in configuration file.")
     if none_count != 0:
         os._exit(0)
 
     if any(["version" in config.keys(), "author" in config.keys()]):
-        print("Error in configuration file.")
+        _logger.error("Error in configuration file.")
         os._exit(0)
 
     if config["webhook"] == "True":
         webhook_args = ["self_signed",
                         "server_address", "server_port",
                         "local_address", "local_port",
                         "cert_pub", "cert_key"] # Optional: secret_token
         for w in webhook_args:
             if w not in config.keys():
-                print("Please check if the following fields exist in the configuration file: \n" +
+                _logger.error("Please check if the following fields exist in the configuration file: \n" +
                     "cert_pub cert_key self_signed server_address server_port local_address local_port")
                 os._exit(0)
         if "secret_token" in config.keys():
             if config["secret_token"] not in [None, "", " "]:
                 pattern = r"^[A-Za-z0-9_-]{1,256}$"
                 if not re.match(pattern, config["secret_token"]):
-                    print("The format of secret_token is wrong (1-256 characters, only characters A-Z, a-z, 0-9, _ and - are allowed).")
+                    _logger.error("The format of secret_token is wrong (1-256 characters, only characters A-Z, a-z, 0-9, _ and - are allowed).")
                     os._exit(0)
             
 
     plugin_dir_in_config = False
     if "plugin_dir" in config.keys():
         if config["plugin_dir"] == "" or config["plugin_dir"] == None:
-            print("Field plugin_dir is not set in configuration file.")
+            _logger.error("Field plugin_dir is not set in configuration file.")
             os._exit(0)
         else:
             plugin_dir = f'{str(Path(os.path.abspath(config["plugin_dir"])))}{os.sep}'
             plugin_dir_in_config = True
     else:
-        print("Field plugin_dir does not exist in configuration file.")
+        _logger.error("Field plugin_dir does not exist in configuration file.")
         os._exit(0)
 
     pycache_path = f'{os.path.dirname(os.path.abspath(__file__))}/__pycache__'
     if os.path.exists(str(Path(pycache_path))):
         shutil.rmtree(str(Path(pycache_path)))
 
     if not os.path.isdir(plugin_dir):  # Plugin directory detection
@@ -261,106 +263,106 @@
                         metadata_list.append(f"{key}: {value}\n")
                     metadata_list[-1] = metadata_list[-1].strip()
                     if metadata_list[-1].split(":")[1].strip() in [None, ""]:
                             metadata_list[-1] += " "
 
                     meta.writelines(metadata_list)
 
-            print(f"Plugin {plugin_name} was created successfully.")
+            _logger.info(f"Plugin {plugin_name} was created successfully.")
         else:
-            print(f"Plugin {plugin_name} already exists.")
+            _logger.warn(f"Plugin {plugin_name} already exists.")
         os._exit(0)
     elif args.make_plugin and not plugin_dir_in_config:
-        print("The plugin_dir is not set in the configuration file.")
+        _logger.error("The plugin_dir is not set in the configuration file.")
         os._exit(0)
 
     if "pool_size" in config.keys():
         if int(config["pool_size"]) < 1 or int(config["pool_size"]) > 100:
-            print("Thread pool size is out of range (1-100).")
+            _logger.error("Thread pool size is out of range (1-100).")
             os._exit(0)
     else:
         config["pool_size"] = "40"
 
     if "buffer_size" in config.keys():
         if int(config["buffer_size"]) <= 0:
-            print("Data buffer_size is out of range (> 0 MiB).")
+            _logger.error("Data buffer_size is out of range (> 0 MiB).")
             os._exit(0)
     else:
         config["buffer_size"] = "16"
 
     if "local_api_server" in config.keys():
         local_api_server = config["local_api_server"]
         if (local_api_server == None or
             local_api_server == "" or
             local_api_server == "False" or
             len(local_api_server) < 7):
             config["local_api_server"] = "False"
         else:
             if "https://" in local_api_server:
-                print("Local api server address not support https.")
+                _logger.error("Local api server address not support https.")
                 os._exit(0)
             if "http://" not in local_api_server:
-                print("Local api server address incorrect.")
+                _logger.error("Local api server address incorrect.")
                 os._exit(0)
             if "telegram.org" in local_api_server:
-                print("Local api server address incorrect.")
+                _logger.error("Local api server address incorrect.")
                 os._exit(0)
             if local_api_server[len(local_api_server)-1] != "/":
                 local_api_server += "/"
             config["local_api_server"] = local_api_server
     else:
         config["local_api_server"] = "False"
 
     if "self_signed" in config.keys():
         if config["self_signed"] == "True":
             config["self_signed"] = True
         elif config["self_signed"] == "False":
             config["self_signed"] = False
         else:
-            print("The self_signed field value in the configuration file is wrong.")
+            _logger.error("The self_signed field value in the configuration file is wrong.")
             os._exit(0)
     else:
         config["self_signed"] = False
 
     if "drop_pending_updates" in config.keys():
         if config["drop_pending_updates"] == "True":
             config["drop_pending_updates"] = True
         elif config["drop_pending_updates"] == "False":
             config["drop_pending_updates"] = False
         else:
-            print("The drop_pending_updates field value in the configuration file is wrong.")
+            _logger.error("The drop_pending_updates field value in the configuration file is wrong.")
             os._exit(0)
     else:
         config["drop_pending_updates"] = False
 
     if "updates_chat_member" in config.keys():
         if config["updates_chat_member"] == "True":
             config["updates_chat_member"] = True
         elif config["updates_chat_member"] == "False":
             config["updates_chat_member"] = False
         else:
-            print("The updates_chat_member field value in the configuration file is wrong.")
+            _logger.error("The updates_chat_member field value in the configuration file is wrong.")
             os._exit(0)
     else:
         config["updates_chat_member"] = False
 
     if config["debug"] == "True":
         config["debug"] = True
     elif config["debug"] == "False":
         config["debug"] = False
     else:
-        print("The debug field value in the configuration file is wrong.")
+        _logger.error("The debug field value in the configuration file is wrong.")
         os._exit(0)
 
     if config["webhook"] == "True":
         config["webhook"] = True
     elif config["webhook"] == "False":
         config["webhook"] = False
     else:
-        print("The webhook field value in the configuration file is wrong.")
+        _logger.error("The webhook field value in the configuration file is wrong.")
         os._exit(0)
 
     if "proxy" in config.keys():
         if str(config["proxy"]).strip() == "" or str(config["proxy"]).strip() == None:
             config["proxies"] = {"all": None}
         else:
             config["proxies"] = {"all": str(config["proxy"]).strip()}
@@ -410,28 +412,29 @@
                     if entrance_exist:
                         entrance_count += content.count(f"def {plugi}(bot, message):")
                         entrance_count += content.count(f"def {plugi}(message, bot):")
                         entrance_count += content.count(f"def {plugi}(bot,message):")
                         entrance_count += content.count(f"def {plugi}(message,bot):")
             except Exception as e:
                 os.system("")
-                print("\033[1;31mThe " + plugi + " plugin is corrupted: " + "\033[0m" + str(e))
-
+                _logger.error("\033[1;31mThe " + plugi + " plugin is corrupted: " + "\033[0m" + str(e))
+                traceback.print_exc()
+                
             metadata_ok = False
             metadata = _Metadata(plugin_dir=plugin_dir)
             ok, metadata_data = metadata.read(plugin_name=plugi)
             if ok:
                 if list(metadata_data.keys()) == list(metadata_template.keys()):
                     metadata_ok = True
 
                     if metadata_data["Command"] == common_pkg_prefix: # Skip plugin integrity checks
                         continue
             else:
                 os.system("")
-                print(f"\033[1;31mThe {plugi} plugin is corrupted: \033[0m{str(metadata_data)}")
+                _logger.error(f"\033[1;31mThe {plugi} plugin is corrupted: \033[0m{str(metadata_data)}")
 
             package_file_list = os.listdir(str(Path(f'{plugin_dir}{plugi}')))
             if plugi + ".py" in package_file_list and \
                 "METADATA" in package_file_list and \
                 entrance_exist and entrance_count == 1 and metadata_ok:
                 plugin_list.append(plugi)
             else:
@@ -443,40 +446,40 @@
                     error += f"'{plugi}.py' "
                     missing_files_count += 1
                 if "METADATA" not in package_file_list:
                     error += "'METADATA' "
                     missing_files_count += 1
                 if missing_files_count != 0:
                     os.system("")
-                    print(f"\033[1;31mThe {plugi} plugin is corrupted: \033[0m{error}")
+                    _logger.error(f"\033[1;31mThe {plugi} plugin is corrupted: \033[0m{error}")
                 
                 if not entrance_exist:
                     error = f"plugin not found entrance function '{plugi}'"
                     os.system("")
-                    print(f"\033[1;31mThe {plugi} plugin is corrupted: \033[0m{error}")
+                    _logger.error(f"\033[1;31mThe {plugi} plugin is corrupted: \033[0m{error}")
                 elif entrance_exist and entrance_count != 1:
                     error = f"multiple entrance functions exist in plugin"
                     os.system("")
-                    print(f"\033[1;31mThe {plugi} plugin is corrupted: \033[0m{error}")
+                    _logger.error(f"\033[1;31mThe {plugi} plugin is corrupted: \033[0m{error}")
 
                 if not metadata_ok:
                     error = f"metadata format error"
                     os.system("")
-                    print(f"\033[1;31mThe {plugi} plugin is corrupted: \033[0m{error}")
+                    _logger.error(f"\033[1;31mThe {plugi} plugin is corrupted: \033[0m{error}")
 
     for plugin in plugin_list:
         metadata_data = {}
         metadata = _Metadata(plugin_dir=plugin_dir)
         ok, data = metadata.read(plugin_name=plugin)
         if ok:
             if list(data.keys()) == list(metadata_template.keys()):
                 metadata_data = data
         else:
             os.system("")
-            print(f"\033[1;31mThe {plugi} plugin is corrupted: \033[0m{data}")
+            _logger.error(f"\033[1;31mThe {plugi} plugin is corrupted: \033[0m{data}")
             continue
         
         if metadata_data["Command"] != common_pkg_prefix:  # Hidden plugin
             plugin_bridge[plugin] = metadata_data["Command"]
         else:
             if plugin in corrupted_plugin_list:
                 if (f'{plugin_dir}{plugin}') in sys.path:
@@ -501,48 +504,48 @@
         mtime = os.stat(str(Path(f"{plugin_dir}{plugin}{os.sep}{plugin}.py"))).st_mtime
         plugin_info[plugin] = mtime
 
     return plugin_info
 
 
 if args.close and args.logout:
-    print("Only one of logout and close can be used at the same time.")
+    _logger.error("Only one of logout and close can be used at the same time.")
     os._exit(0)
 
 elif args.logout and not args.close:
     config = _config()
     logout_url = f'{cloud_api_server}bot{config["key"]}/logOut'
     try:
         req = requests.post(url=logout_url, verify=False)
     except:
-        print("Error request the cloud Bot API server.")
+        _logger.error("Error request the cloud Bot API server.")
         os._exit(0)
     if req.json().get("ok"):
-        print("Successfully logout from the cloud Bot API server.")
+        _logger.info("Successfully logout from the cloud Bot API server.")
     elif not req.json().get("ok"):
-        print("Error logout from the cloud Bot API server.")
+        _logger.error("Error logout from the cloud Bot API server.")
         if (req.json().get("error_code") == 401 and
             req.json().get("description") == "Unauthorized"):
-            print("If you already logout the bot from the cloud Bot API server,please wait at least 10 minutes and try again.")
+            _logger.error("If you already logout the bot from the cloud Bot API server,please wait at least 10 minutes and try again.")
     os._exit(0)
 
 elif args.close and not args.logout:
     config = _config()
     if config["local_api_server"] == "False":
-        print("The close can only be used when local_api_server is configured.")
+        _logger.error("The close can only be used when local_api_server is configured.")
         os._exit(0)
 
     close_url = f'{config["local_api_server"]}bot{config["key"]}/close'
     try:
         req = requests.post(url=close_url, verify=False)
     except:
-        print("Error request the the local API server.")
+        _logger.error("Error request the the local API server.")
         os._exit(0)
     if req.json().get("ok"):
-        print("Successfully close from the local API server.")
+        _logger.info("Successfully close from the local API server.")
     elif not req.json().get("ok"):
-        print("Error close from the local API server.")
+        _logger.error("Error close from the local API server.")
         if req.json().get("error_code") == 429:
-            print(f'Too many requests, please retry after {str(req.json().get("parameters")["retry_after"])} seconds.')
+            _logger.error(f'Too many requests, please retry after {str(req.json().get("parameters")["retry_after"])} seconds.')
     os._exit(0)
```

## teelebot/metadata.py

```diff
@@ -1,19 +1,21 @@
 '''
 @creation date: 2023-05-12
-@last modification: 2023-05-15
+@last modification: 2023-07-12
 '''
 import os
 import copy
 import inspect
+import traceback
 import threading
 
 from pathlib import Path
 from typing import Tuple, Union
 
+from .logger import _logger
 from .common import __metadata_templates__, __metadata_version_in_use__
 
 class _Metadata(object):
     """
     METADATA Class
     """
     def __init__(self, plugin_dir):
@@ -78,15 +80,16 @@
 
                     if not (list(metadata.keys()) == list(self.__metadata_template.keys())):
                         return False, "MetadataFormatError"
                     else:
                         return True, metadata
         except Exception as e:
             os.system("")
-            print(f"\033[1;31mError to read metadata of {plugin_name} plugin:\033[0m {str(e)}")
+            _logger.error(f"\033[1;31mError to read metadata of {plugin_name} plugin:\033[0m {str(e)}")
+            traceback.print_exc()
             return False, "ReadMetadataError"
                 
     def write(self, metadata: dict,
             plugin_name: str = None, plugin_dir: str = None) -> Tuple[bool, Union[dict, str]]:
         """
         Write the METADATA data
         """
@@ -143,24 +146,26 @@
         try:
             with self.__metadata_mutex:
                 with open(Path(f"{plugin_dir}{plugin_name}{os.sep}METADATA"), "w", encoding="utf-8") as meta:
                     meta.writelines(metadata_list)
             return True, ""
         except Exception as e:
             os.system("")
-            print(f"\033[1;31mError to write metadata of {plugin_name} plugin:\033[0m {str(e)}")
+            _logger.error(f"\033[1;31mError to write metadata of {plugin_name} plugin:\033[0m {str(e)}")
+            traceback.print_exc()
             return False, "WriteMetadataError"
         
     def template(self, version: str = None) -> Tuple[bool, Union[dict, str]]:
         """
         Get METADATA data template
         """
         try:
             if version in [None, "", " "]:
                 version = __metadata_version_in_use__
             return True, copy.deepcopy(__metadata_templates__[__metadata_version_in_use__])
         except Exception as e:
             os.system("")
-            print(f"\033[1;31mError to get metadata template:\033[0m {str(e)}")
+            _logger.error(f"\033[1;31mError to get metadata template:\033[0m {str(e)}")
+            traceback.print_exc()
             return False, "GetMetadataTemplateError"
```

## teelebot/polling.py

```diff
@@ -1,18 +1,22 @@
 # -*- coding:utf-8 -*-
 '''
 @creation date: 2020-06-23
-@last modification: 2023-05-14
+@last modification: 2023-07-12
 '''
 import os
 import signal
 
+from .logger import _logger
+
 
 def _runUpdates(bot):
 
+    _logger.info("Bot Start.")
+
     signal.signal(signal.SIGINT, __exit)
     while True:
         results = bot.getUpdates(
             offset=bot._offset,
             limit=100,
             timeout=bot._timeout,
             allowed_updates=bot._allowed_updates
@@ -21,11 +25,11 @@
         if messages is None or not messages:
             continue
         for message in messages:  # Retrieve a single message 'message'
             bot._pluginRun(bot, message)
 
 
 def __exit(signum, frame):
-    print("Bot Exit.")
+    _logger.info("Bot Exit.")
     os._exit(0)
```

## teelebot/request.py

```diff
@@ -1,14 +1,15 @@
 # -*- coding:utf-8 -*-
 '''
 @creation date: 2019-11-15
-@last modification: 2023-05-15
+@last modification: 2023-07-12
 '''
 import io
 import json
+import traceback
 import requests
 
 from .logger import _logger
 from traceback import extract_stack
 
 
 class _Request(object):
@@ -98,11 +99,12 @@
             with self.__session.post(url=f'{self.__url}{method_name}', data=data, files=files) as req:
                 self.__debug_info(method_name, req.json())
                 if req.json().get("ok", False):
                     return req.json().get("result")
                 else:
                     return req.json().get("ok")
         except Exception as e:
-            print("Error:", str(e))
+            _logger.error(f"Error executing method {method_name}:", str(e))
+            traceback.print_exc()
             return False
```

## teelebot/schedule.py

```diff
@@ -1,16 +1,20 @@
 # -*- coding:utf-8 -*-
 '''
 @creation date: 2019-11-15
-@last modification: 2023-05-14
+@last modification: 2023-07-12
 '''
 import threading
+import traceback
+
 from uuid import uuid4
 from typing import Tuple, Callable
 
+from .logger import _logger
+
 class _Schedule(object):
     """
     Schedule Class
     """
     def __init__(self, queue_size):
         self.__queue_size = queue_size
         self.__queue_mutex = threading.Lock()
@@ -26,15 +30,16 @@
                     self.function(*self.args, **self.kwargs)
                     self.finished.wait(self.interval)
         try:
             t = RepeatingTimer(gap, func, args)
             t.setDaemon(True)
             return True, t
         except Exception as e:
-            print("Error:", str(e))
+            _logger.error(str(e))
+            traceback.print_exc()
             return False, str(e)
 
     def add(self, gap: int, func: Callable[..., None], args: tuple) -> Tuple[bool, str]:
         """
         Add schedule task
         """
         def __short_uuid():
@@ -79,14 +84,16 @@
             result = {
                 "used": used,
                 "free": free,
                 "size": size
             }
             return True, result
         except Exception as e:
+            _logger.error(str(e))
+            traceback.print_exc()
             return False, {"exception": e}
 
     def find(self, uid: str) -> Tuple[bool, str]:
         """
         Find schedule tasks
         """
         with self.__queue_mutex:
@@ -126,10 +133,12 @@
                     self.__queue[str(uid)].cancel()
 
                 with self.__queue_mutex:
                     self.__queue.clear()
 
                 return True, "Cleared"
             except Exception as e:
+                _logger.error(str(e))
+                traceback.print_exc()
                 return False, str(e)
```

## teelebot/version.py

```diff
@@ -1,16 +1,16 @@
 # -*- coding:utf-8 -*-
 """
 @description: A Python-based Telegram Bot framework
 @creation date: 2019-11-15
-@last modification: 2023-05-29
+@last modification: 2023-07-12
 @author: Pluto (github:plutobell)
 """
 
-__version__ = "2.3.3"
+__version__ = "2.3.4"
 
 __author__ = "Pluto"
 __email__ = "hi@ojoll.com"
 __blog__ = "https://ojoll.com"
 __github__ = "https://github.com/plutobell/teelebot"
 __description__ = "teelebot is a Python-based Telegram Bot framework with a plugin system that supports hot reload and hot loading."
```

## teelebot/webhook.py

```diff
@@ -1,18 +1,20 @@
 # -*- coding:utf-8 -*-
 '''
 @creation date: 2020-6-12
-@last modification: 2023-05-03
+@last modification: 2023-07-12
 '''
 #from socketserver import ThreadingMixIn
 from http.server import HTTPServer, BaseHTTPRequestHandler
 import ssl
 import os
 import json
 
+from .logger import _logger
+
 
 def __MakeRequestHandler(bot):
     class RequestHandler(BaseHTTPRequestHandler):
         def __init__(self, *args, **kwargs):
             super(RequestHandler, self).__init__(*args, **kwargs)
 
         def do_POST(self):
@@ -50,28 +52,30 @@
 
 
 # class ThreadedHTTPServer(ThreadingMixIn, HTTPServer):
 #     pass
 
 
 def _runWebhook(bot, host, port):
+    _logger.info("Bot Start.")
+
     RequestHandler = __MakeRequestHandler(bot)
     if bot._local_address == "0.0.0.0":
         try:
             context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
             context.load_cert_chain(bot._cert_pub, bot._cert_key)
 
             server = HTTPServer((host, port), RequestHandler)
             server.socket = context.wrap_socket(server.socket, server_side=True)
             server.serve_forever()
         except KeyboardInterrupt:
             server.server_close()
-            print("Bot Exit.")
+            _logger.info("Bot Exit.")
             os._exit(0)
     else:
         try:
             server = HTTPServer((host, port), RequestHandler)
             server.serve_forever()
         except KeyboardInterrupt:
             server.server_close()
-            print("Bot Exit.")
+            _logger.info("Bot Exit.")
             os._exit(0)
```

## Comparing `teelebot-2.3.3.dist-info/LICENSE` & `teelebot-2.3.4.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `teelebot-2.3.3.dist-info/METADATA` & `teelebot-2.3.4.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: teelebot
-Version: 2.3.3
+Version: 2.3.4
 Summary: teelebot is a Python-based Telegram Bot framework with a plugin system that supports hot reload and hot loading.
 Home-page: https://ojoll.com
 Author: Pluto
 Author-email: hi@ojoll.com
 License: GPLv3
 Keywords: teelebot telegram bot telegram bot api telegram
 Classifier: Programming Language :: Python :: 3
```

### html2text {}

```diff
@@ -1,8 +1,8 @@
-Metadata-Version: 2.1 Name: teelebot Version: 2.3.3 Summary: teelebot is a
+Metadata-Version: 2.1 Name: teelebot Version: 2.3.4 Summary: teelebot is a
 Python-based Telegram Bot framework with a plugin system that supports hot
 reload and hot loading. Home-page: https://ojoll.com Author: Pluto Author-
 email: hi@ojoll.com License: GPLv3 Keywords: teelebot telegram bot telegram bot
 api telegram Classifier: Programming Language :: Python :: 3 Classifier:
 Operating System :: OS Independent Classifier: License :: OSI Approved :: GNU
 General Public License v3 (GPLv3) Requires-Python: >=3.6 Description-Content-
 Type: text/markdown License-File: LICENSE Requires-Dist: requests
```

## Comparing `teelebot-2.3.3.dist-info/RECORD` & `teelebot-2.3.4.dist-info/RECORD`

 * *Files 27% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-teelebot/__init__.py,sha256=R5rmHjYrTnILTkFbBRCxrc6GgnrpP2BiQ-GpBWXFE3I,4241
+teelebot/__init__.py,sha256=izTaxR9BNZlwoIXdHhP_3pwMipIsEOVhXwYJs5llJXE,4301
 teelebot/__main__.py,sha256=_j6f3hj0VtlcCsabcIvuS0uBI0NVbCVwmH138tqYGFo,165
 teelebot/bot.py,sha256=79U_AoWjkSfAa1hetAK_pCtUh_rBObYcWoxLthyt9Xw,33199
-teelebot/buffer.py,sha256=DkGfV_cfjYI7_FK-W34Wvcwox68I4w2Opqwe2-iDY-A,7128
+teelebot/buffer.py,sha256=dKlomQ9aJP4v0TNukChxyGM-oAUBcOv803oW5POeils,7248
 teelebot/common.py,sha256=RHSqpXXmAJ3jFrWOTubgTavfSu0FprHNQyX0llvJ680,1581
-teelebot/handler.py,sha256=L8ayQG4zW_uvdBI13pj4sXGYpYFKuY043Ho7oQbJAIA,23008
+teelebot/handler.py,sha256=qfmlrPZlA7_LtguM3ItnLPMyQ_-0qS3x-WAI3DHcpow,23439
 teelebot/logger.py,sha256=_QWA2Kbj-JWNYDtgeK6IE7q34Brxrq6cUgHEH4YTu2M,1807
-teelebot/metadata.py,sha256=Vk0bSwey0kd4rUS-NQoSC5ORCCmZ48bXJ2kl4d7an20,7059
-teelebot/polling.py,sha256=yZPVAN3TxjGskf2jngdIpaA0Pi1SFzQSUt3WVJb6TuA,737
-teelebot/request.py,sha256=B-dUZMc1FJnxlo2K7B7Q4_2gVwcxKlxYZ8iAYZCrW3k,3824
-teelebot/schedule.py,sha256=egn4EsUNPrtSkgOj1hxjNf1MQwJb95m5454rGatTpU8,4075
-teelebot/version.py,sha256=ntKgOtlwO9-Ly0nG3c6KTFEaBM4_ILOaLQ1ZEZgfkWQ,483
-teelebot/webhook.py,sha256=IomyaLxak_caDNYKNnLaTLtqkFToYq4sHWsD7kahV4Y,2665
-teelebot-2.3.3.dist-info/LICENSE,sha256=IwGE9guuL-ryRPEKi6wFPI_zOhg7zDZbTYuHbSt_SAk,35823
-teelebot-2.3.3.dist-info/METADATA,sha256=RYBt8_ScOFq3fEam9-UJnALMndSXhYlridkceaezG80,9719
-teelebot-2.3.3.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-teelebot-2.3.3.dist-info/entry_points.txt,sha256=IZHSiwFVJ6BPPTW3j7I1i34AESCOPaTYiC1qoWfpj6k,43
-teelebot-2.3.3.dist-info/top_level.txt,sha256=vMgTMVZJd4P3KjMwVpgWfIUvNLYKqfyHO4Cul-YwuyQ,9
-teelebot-2.3.3.dist-info/zip-safe,sha256=frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN_XKdLCPjaYaY,2
-teelebot-2.3.3.dist-info/RECORD,,
+teelebot/metadata.py,sha256=pxezwNWaSmBpEACdij-ubvsFtUYwpbJd1GMS9x2SMfM,7235
+teelebot/polling.py,sha256=YAXUqN_XngnykSE0TmpF8O2twQ6wqF1n6lZ6JowmO8A,809
+teelebot/request.py,sha256=PuYRtKYdzGkpxXNO6M_xhfs26o1Lh2W4w5EFPJPjVKM,3917
+teelebot/schedule.py,sha256=7ANts-y4OUW1_5yedpSk3FNRJ5aVAwYVkC-umQohzlQ,4307
+teelebot/version.py,sha256=Pg94QGm-B-6Ozw6cCXtwJe_WR5TgNo9a3VQoXVxmXKc,483
+teelebot/webhook.py,sha256=YT0SAuCImdxrYx2_-sB0IQ3vSkG8RZbwxPs7h5QG0cI,2744
+teelebot-2.3.4.dist-info/LICENSE,sha256=IwGE9guuL-ryRPEKi6wFPI_zOhg7zDZbTYuHbSt_SAk,35823
+teelebot-2.3.4.dist-info/METADATA,sha256=vPqaBLHRuNxjp8ic7FlJlyKaxEg1Mw3qd37fw8ySveo,9719
+teelebot-2.3.4.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+teelebot-2.3.4.dist-info/entry_points.txt,sha256=IZHSiwFVJ6BPPTW3j7I1i34AESCOPaTYiC1qoWfpj6k,43
+teelebot-2.3.4.dist-info/top_level.txt,sha256=vMgTMVZJd4P3KjMwVpgWfIUvNLYKqfyHO4Cul-YwuyQ,9
+teelebot-2.3.4.dist-info/zip-safe,sha256=frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN_XKdLCPjaYaY,2
+teelebot-2.3.4.dist-info/RECORD,,
```

