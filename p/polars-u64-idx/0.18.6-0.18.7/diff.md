# Comparing `tmp/polars_u64_idx-0.18.6.tar.gz` & `tmp/polars_u64_idx-0.18.7.tar.gz`

## Comparing `polars_u64_idx-0.18.6.tar` & `polars_u64_idx-0.18.7.tar`

### file list

```diff
@@ -1,1270 +1,1283 @@
--rw-r--r--   0        0        0     2037 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/LICENSE
--rw-r--r--   0     1001      123      143 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/README.md
--rw-r--r--   0     1001      123     1018 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/base_utc_offset.rs
--rw-r--r--   0     1001      123     3569 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/date.rs
--rw-r--r--   0     1001      123     6465 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/datetime.rs
--rw-r--r--   0     1001      123     3305 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/duration.rs
--rw-r--r--   0     1001      123     5607 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/kernels.rs
--rw-r--r--   0     1001      123     1062 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/mod.rs
--rw-r--r--   0     1001      123     6759 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/rolling_window/floats.rs
--rw-r--r--   0     1001      123     2582 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/rolling_window/ints.rs
--rw-r--r--   0     1001      123    11122 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/rolling_window/mod.rs
--rw-r--r--   0     1001      123      413 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/rolling_window/rolling_kernels/mod.rs
--rw-r--r--   0     1001      123     4810 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/rolling_window/rolling_kernels/no_nulls.rs
--rw-r--r--   0     1001      123     2372 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/time.rs
--rw-r--r--   0     1001      123    21334 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/utf8/infer.rs
--rw-r--r--   0     1001      123    18997 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/utf8/mod.rs
--rw-r--r--   0     1001      123     3975 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/utf8/patterns.rs
--rw-r--r--   0     1001      123    11229 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/utf8/strptime.rs
--rw-r--r--   0     1001      123     3340 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/date_range.rs
--rw-r--r--   0     1001      123      994 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/dst_offset.rs
--rw-r--r--   0     1001      123    34703 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/groupby/dynamic.rs
--rw-r--r--   0     1001      123       88 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/groupby/mod.rs
--rw-r--r--   0     1001      123      769 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/lib.rs
--rw-r--r--   0     1001      123     2976 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/month_end.rs
--rw-r--r--   0     1001      123     3365 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/month_start.rs
--rw-r--r--   0     1001      123      274 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/prelude.rs
--rw-r--r--   0     1001      123     1381 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/round.rs
--rw-r--r--   0     1001      123     3992 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/series/_trait.rs
--rw-r--r--   0     1001      123      136 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/series/implementations/boolean.rs
--rw-r--r--   0     1001      123      140 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/series/implementations/categoricals.rs
--rw-r--r--   0     1001      123      133 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/series/implementations/date.rs
--rw-r--r--   0     1001      123      137 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/series/implementations/datetime.rs
--rw-r--r--   0     1001      123      137 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/series/implementations/duration.rs
--rw-r--r--   0     1001      123     1863 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/series/implementations/floats.rs
--rw-r--r--   0     1001      123     1792 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/series/implementations/integers.rs
--rw-r--r--   0     1001      123      133 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/series/implementations/list.rs
--rw-r--r--   0     1001      123      486 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/series/implementations/mod.rs
--rw-r--r--   0     1001      123      155 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/series/implementations/object.rs
--rw-r--r--   0     1001      123      135 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/series/implementations/struct_.rs
--rw-r--r--   0     1001      123      133 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/series/implementations/time.rs
--rw-r--r--   0     1001      123      133 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/series/implementations/utf8.rs
--rw-r--r--   0     1001      123    12791 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/series/mod.rs
--rw-r--r--   0     1001      123     1443 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/truncate.rs
--rw-r--r--   0     1001      123     7619 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/upsample.rs
--rw-r--r--   0     1001      123     2511 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/utils.rs
--rw-r--r--   0     1001      123     1524 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/windows/bounds.rs
--rw-r--r--   0     1001      123     2672 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/windows/calendar.rs
--rw-r--r--   0     1001      123    25303 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/windows/duration.rs
--rw-r--r--   0     1001      123    20201 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/windows/groupby.rs
--rw-r--r--   0     1001      123      503 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/windows/mod.rs
--rw-r--r--   0     1001      123    23627 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/windows/test.rs
--rw-r--r--   0     1001      123    10657 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-time/src/windows/window.rs
--rw-r--r--   0        0        0     1106 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/LICENSE
--rw-r--r--   0     1001      123      466 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/README.md
--rw-r--r--   0     1001      123    23373 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/src/context.rs
--rw-r--r--   0     1001      123    23921 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/src/functions.rs
--rw-r--r--   0     1001      123     2122 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/src/keywords.rs
--rw-r--r--   0     1001      123      239 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/src/lib.rs
--rw-r--r--   0     1001      123    20933 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/src/sql_expr.rs
--rw-r--r--   0     1001      123     4572 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/src/table_functions.rs
--rw-r--r--   0     1001      123     1682 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/functions_cumulative.rs
--rw-r--r--   0     1001      123     3063 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/functions_io.rs
--rw-r--r--   0     1001      123     1539 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/functions_math.rs
--rw-r--r--   0     1001      123      860 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/functions_meta.rs
--rw-r--r--   0     1001      123     2982 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/functions_string.rs
--rw-r--r--   0     1001      123     1056 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/iss_7436.rs
--rw-r--r--   0     1001      123      888 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/iss_7437.rs
--rw-r--r--   0     1001      123      652 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/iss_7440.rs
--rw-r--r--   0     1001      123      700 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/iss_8395.rs
--rw-r--r--   0     1001      123     1062 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/iss_8419.rs
--rw-r--r--   0     1001      123      982 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/ops_distinct_on.rs
--rw-r--r--   0     1001      123    15811 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/simple_exprs.rs
--rw-r--r--   0     1001      123     3976 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/statements.rs
--rw-r--r--   0        0        0      827 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.6/local_dependencies/polars-algo/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-algo/LICENSE
--rw-r--r--   0     1001      123      142 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-algo/README.md
--rw-r--r--   0     1001      123     7548 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-algo/src/algo.rs
--rw-r--r--   0     1001      123       88 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-algo/src/lib.rs
--rw-r--r--   0     1001      123       28 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-algo/src/prelude.rs
--rw-r--r--   0        0        0     3552 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/LICENSE
--rw-r--r--   0     1001      123      132 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/README.md
--rw-r--r--   0     1001      123     2382 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/array/min_max.rs
--rw-r--r--   0     1001      123      267 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/array/mod.rs
--rw-r--r--   0     1001      123     1512 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/array/namespace.rs
--rw-r--r--   0     1001      123     4108 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/array/sum_mean.rs
--rw-r--r--   0     1001      123      234 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/binary/mod.rs
--rw-r--r--   0     1001      123     3549 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/binary/namespace.rs
--rw-r--r--   0     1001      123    11023 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/interpolate.rs
--rw-r--r--   0     1001      123     1930 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/list/any_all.rs
--rw-r--r--   0     1001      123     1687 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/list/count.rs
--rw-r--r--   0     1001      123     2419 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/list/hash.rs
--rw-r--r--   0     1001      123     7861 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/list/min_max.rs
--rw-r--r--   0     1001      123      644 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/list/mod.rs
--rw-r--r--   0     1001      123    19916 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/list/namespace.rs
--rw-r--r--   0     1001      123     9376 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/list/sets.rs
--rw-r--r--   0     1001      123     7633 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/list/sum_mean.rs
--rw-r--r--   0     1001      123     2435 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/list/to_struct.rs
--rw-r--r--   0     1001      123      545 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/mod.rs
--rw-r--r--   0     1001      123     9452 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/nan_propagating_aggregate.rs
--rw-r--r--   0     1001      123     6795 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/set.rs
--rw-r--r--   0     1001      123     8781 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/strings/case.rs
--rw-r--r--   0     1001      123     8593 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/strings/json_path.rs
--rw-r--r--   0     1001      123     2345 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/strings/justify.rs
--rw-r--r--   0     1001      123      514 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/strings/mod.rs
--rw-r--r--   0     1001      123    14951 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/strings/namespace.rs
--rw-r--r--   0     1001      123     4053 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/strings/replace.rs
--rw-r--r--   0     1001      123      439 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/sum.rs
--rw-r--r--   0     1001      123     2486 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/top_k.rs
--rw-r--r--   0     1001      123     7727 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/frame/join/merge_sorted.rs
--rw-r--r--   0     1001      123    18232 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/frame/join/mod.rs
--rw-r--r--   0     1001      123     4291 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/frame/mod.rs
--rw-r--r--   0     1001      123    10257 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/frame/pivot/mod.rs
--rw-r--r--   0     1001      123    13486 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/frame/pivot/positioning.rs
--rw-r--r--   0     1001      123      237 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/lib.rs
--rw-r--r--   0     1001      123      290 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/prelude.rs
--rw-r--r--   0     1001      123       25 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/mod.rs
--rw-r--r--   0     1001      123     9623 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/approx_algo/hyperloglogplus.rs
--rw-r--r--   0     1001      123      118 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/approx_algo/mod.rs
--rw-r--r--   0     1001      123     2016 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/approx_unique.rs
--rw-r--r--   0     1001      123    11866 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/arg_min_max.rs
--rw-r--r--   0     1001      123     3669 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/cut.rs
--rw-r--r--   0     1001      123     3688 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/floor_divide.rs
--rw-r--r--   0     1001      123     5245 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/fused.rs
--rw-r--r--   0     1001      123     3423 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/is_first.rs
--rw-r--r--   0     1001      123     2975 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/is_unique.rs
--rw-r--r--   0     1001      123     3626 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/log.rs
--rw-r--r--   0     1001      123     1268 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/mod.rs
--rw-r--r--   0     1001      123     1769 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/rolling.rs
--rw-r--r--   0     1001      123     7642 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/search_sorted.rs
--rw-r--r--   0     1001      123     2603 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/to_dummies.rs
--rw-r--r--   0     1001      123     2067 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/various.rs
--rw-r--r--   0        0        0      954 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.6/local_dependencies/polars-row/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-row/LICENSE
--rw-r--r--   0     1001      123      137 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-row/README.md
--rw-r--r--   0     1001      123     2377 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-row/src/decode.rs
--rw-r--r--   0     1001      123    13364 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-row/src/encode.rs
--rw-r--r--   0     1001      123     7767 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-row/src/fixed.rs
--rw-r--r--   0     1001      123    13846 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-row/src/lib.rs
--rw-r--r--   0     1001      123     3019 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-row/src/row.rs
--rw-r--r--   0     1001      123      682 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-row/src/utils.rs
--rw-r--r--   0     1001      123     8679 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-row/src/variable.rs
--rw-r--r--   0        0        0     6286 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/LICENSE
--rw-r--r--   0     1001      123      358 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/README.md
--rw-r--r--   0     1001      123     1796 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/dot.rs
--rw-r--r--   0     1001      123     4479 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/dsl/eval.rs
--rw-r--r--   0     1001      123     7115 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/dsl/functions.rs
--rw-r--r--   0     1001      123      164 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/dsl/into.rs
--rw-r--r--   0     1001      123     6754 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/dsl/list.rs
--rw-r--r--   0     1001      123     2899 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/dsl/mod.rs
--rw-r--r--   0     1001      123     1182 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/frame/anonymous_scan.rs
--rw-r--r--   0     1001      123     9285 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/frame/csv.rs
--rw-r--r--   0     1001      123     4368 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/frame/file_list_reader.rs
--rw-r--r--   0     1001      123     2261 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/frame/ipc.rs
--rw-r--r--   0     1001      123    49541 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/frame/mod.rs
--rw-r--r--   0     1001      123     3382 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/frame/ndjson.rs
--rw-r--r--   0     1001      123     2734 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/frame/parquet.rs
--rw-r--r--   0     1001      123     2892 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/frame/pivot.rs
--rw-r--r--   0     1001      123      459 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/frame/python.rs
--rw-r--r--   0     1001      123     6374 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/lib.rs
--rw-r--r--   0     1001      123     1049 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/cache.rs
--rw-r--r--   0     1001      123      776 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/executor.rs
--rw-r--r--   0     1001      123      670 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/ext_context.rs
--rw-r--r--   0     1001      123     1555 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/filter.rs
--rw-r--r--   0     1001      123     3986 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/groupby.rs
--rw-r--r--   0     1001      123     4125 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_dynamic.rs
--rw-r--r--   0     1001      123    13599 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_partitioned.rs
--rw-r--r--   0     1001      123     4883 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_rolling.rs
--rw-r--r--   0     1001      123     5859 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/join.rs
--rw-r--r--   0     1001      123     6753 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/mod.rs
--rw-r--r--   0     1001      123     2045 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/projection.rs
--rw-r--r--   0     1001      123     1761 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/python_scan.rs
--rw-r--r--   0     1001      123     2854 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/scan/csv.rs
--rw-r--r--   0     1001      123     1963 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/scan/ipc.rs
--rw-r--r--   0     1001      123     4303 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/scan/mod.rs
--rw-r--r--   0     1001      123     1209 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/scan/ndjson.rs
--rw-r--r--   0     1001      123     2421 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/scan/parquet.rs
--rw-r--r--   0     1001      123      548 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/slice.rs
--rw-r--r--   0     1001      123     2197 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/sort.rs
--rw-r--r--   0     1001      123     2015 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/stack.rs
--rw-r--r--   0     1001      123      663 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/udf.rs
--rw-r--r--   0     1001      123     4041 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/union.rs
--rw-r--r--   0     1001      123      838 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/unique.rs
--rw-r--r--   0     1001      123     1335 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/exotic.rs
--rw-r--r--   0     1001      123    21959 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/aggregation.rs
--rw-r--r--   0     1001      123     2689 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/alias.rs
--rw-r--r--   0     1001      123    18581 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/apply.rs
--rw-r--r--   0     1001      123    17674 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/binary.rs
--rw-r--r--   0     1001      123     2583 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/cache.rs
--rw-r--r--   0     1001      123     3153 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/cast.rs
--rw-r--r--   0     1001      123     6326 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/column.rs
--rw-r--r--   0     1001      123     1996 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/count.rs
--rw-r--r--   0     1001      123     5809 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/filter.rs
--rw-r--r--   0     1001      123     4131 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/group_iter.rs
--rw-r--r--   0     1001      123     5304 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/literal.rs
--rw-r--r--   0     1001      123    23566 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/mod.rs
--rw-r--r--   0     1001      123    10091 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/slice.rs
--rw-r--r--   0     1001      123     4332 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/sort.rs
--rw-r--r--   0     1001      123    13549 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/sortby.rs
--rw-r--r--   0     1001      123     8331 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/take.rs
--rw-r--r--   0     1001      123    14360 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/ternary.rs
--rw-r--r--   0     1001      123    31970 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/window.rs
--rw-r--r--   0     1001      123     2039 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/file_cache.rs
--rw-r--r--   0     1001      123      414 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/mod.rs
--rw-r--r--   0     1001      123     2005 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/node_timer.rs
--rw-r--r--   0     1001      123    24174 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/planner/expr.rs
--rw-r--r--   0     1001      123    20552 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/planner/lp.rs
--rw-r--r--   0     1001      123       87 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/planner/mod.rs
--rw-r--r--   0     1001      123    10203 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/state.rs
--rw-r--r--   0     1001      123     2583 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/streaming/checks.rs
--rw-r--r--   0     1001      123     9280 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/streaming/construct_pipeline.rs
--rw-r--r--   0     1001      123    16847 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/streaming/convert_alp.rs
--rw-r--r--   0     1001      123      116 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/streaming/mod.rs
--rw-r--r--   0     1001      123     5827 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/streaming/tree.rs
--rw-r--r--   0     1001      123      722 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/prelude.rs
--rw-r--r--   0     1001      123    15000 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/aggregations.rs
--rw-r--r--   0     1001      123     2339 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/arity.rs
--rw-r--r--   0     1001      123     7276 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/cse.rs
--rw-r--r--   0     1001      123    12752 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/io.rs
--rw-r--r--   0     1001      123     4166 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/logical.rs
--rw-r--r--   0     1001      123     4273 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/mod.rs
--rw-r--r--   0     1001      123    15770 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/optimization_checks.rs
--rw-r--r--   0     1001      123     6772 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/predicate_queries.rs
--rw-r--r--   0     1001      123     3165 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/projection_queries.rs
--rw-r--r--   0     1001      123    47685 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/queries.rs
--rw-r--r--   0     1001      123     9519 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/streaming.rs
--rw-r--r--   0     1001      123     2893 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/tpch.rs
--rw-r--r--   0     1001      123     1028 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/utils.rs
--rw-r--r--   0        0        0     5484 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/LICENSE
--rw-r--r--   0     1001      123      144 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/README.md
--rw-r--r--   0     1001      123     5158 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/arithmetic/decimal.rs
--rw-r--r--   0     1001      123     8275 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/arithmetic/mod.rs
--rw-r--r--   0     1001      123     9417 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/arithmetic/numeric.rs
--rw-r--r--   0     1001      123     3588 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/array/iterator.rs
--rw-r--r--   0     1001      123     2551 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/array/mod.rs
--rw-r--r--   0     1001      123     6448 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/bitwise.rs
--rw-r--r--   0     1001      123     2298 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/binary.rs
--rw-r--r--   0     1001      123     1207 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/boolean.rs
--rw-r--r--   0     1001      123     4311 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/fixed_size_list.rs
--rw-r--r--   0     1001      123     1556 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/from.rs
--rw-r--r--   0     1001      123     5762 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/list/anonymous.rs
--rw-r--r--   0     1001      123     4418 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/list/binary.rs
--rw-r--r--   0     1001      123     2374 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/list/boolean.rs
--rw-r--r--   0     1001      123     1392 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/list/categorical.rs
--rw-r--r--   0     1001      123     1575 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/list/dtypes.rs
--rw-r--r--   0     1001      123     4953 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/list/mod.rs
--rw-r--r--   0     1001      123     3506 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/list/primitive.rs
--rw-r--r--   0     1001      123     8969 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/mod.rs
--rw-r--r--   0     1001      123     1410 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/primitive.rs
--rw-r--r--   0     1001      123     2291 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/utf8.rs
--rw-r--r--   0     1001      123    17014 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/cast.rs
--rw-r--r--   0     1001      123    50501 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/comparison/mod.rs
--rw-r--r--   0     1001      123    10060 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/comparison/scalar.rs
--rw-r--r--   0     1001      123      551 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/drop.rs
--rw-r--r--   0     1001      123      963 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/float.rs
--rw-r--r--   0     1001      123     7945 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/from.rs
--rw-r--r--   0     1001      123    42339 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/iterator/mod.rs
--rw-r--r--   0     1001      123     1453 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/iterator/par/list.rs
--rw-r--r--   0     1001      123       28 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/iterator/par/mod.rs
--rw-r--r--   0     1001      123     1129 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/iterator/par/utf8.rs
--rw-r--r--   0     1001      123       21 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/kernels/mod.rs
--rw-r--r--   0     1001      123     2347 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/kernels/take.rs
--rw-r--r--   0     1001      123     7963 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/list/iterator.rs
--rw-r--r--   0     1001      123     3242 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/list/mod.rs
--rw-r--r--   0     1001      123    19831 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/categorical/builder.rs
--rw-r--r--   0     1001      123     3688 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/categorical/from.rs
--rw-r--r--   0     1001      123     5693 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/categorical/merge.rs
--rw-r--r--   0     1001      123    10219 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/categorical/mod.rs
--rw-r--r--   0     1001      123     1263 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/append.rs
--rw-r--r--   0     1001      123      358 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/full.rs
--rw-r--r--   0     1001      123      192 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/mod.rs
--rw-r--r--   0     1001      123     2731 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/take_random.rs
--rw-r--r--   0     1001      123     2172 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/unique.rs
--rw-r--r--   0     1001      123      925 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/zip.rs
--rw-r--r--   0     1001      123     6805 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/categorical/stringcache.rs
--rw-r--r--   0     1001      123     1604 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/date.rs
--rw-r--r--   0     1001      123     4105 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/datetime.rs
--rw-r--r--   0     1001      123     4443 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/decimal.rs
--rw-r--r--   0     1001      123     2434 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/duration.rs
--rw-r--r--   0     1001      123     2556 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/mod.rs
--rw-r--r--   0     1001      123      476 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/struct_/from.rs
--rw-r--r--   0     1001      123    15983 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/struct_/mod.rs
--rw-r--r--   0     1001      123     1182 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/time.rs
--rw-r--r--   0     1001      123    23309 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/mod.rs
--rw-r--r--   0     1001      123     9064 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ndarray.rs
--rw-r--r--   0     1001      123     4484 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/object/builder.rs
--rw-r--r--   0     1001      123     1547 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/object/extension/drop.rs
--rw-r--r--   0     1001      123     3097 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/object/extension/list.rs
--rw-r--r--   0     1001      123     7054 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/object/extension/mod.rs
--rw-r--r--   0     1001      123     3410 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/object/extension/polars_extension.rs
--rw-r--r--   0     1001      123      137 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/object/is_valid.rs
--rw-r--r--   0     1001      123     4419 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/object/iterator.rs
--rw-r--r--   0     1001      123     4806 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/object/mod.rs
--rw-r--r--   0     1001      123     2956 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/object/registry.rs
--rw-r--r--   0     1001      123      272 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/abs.rs
--rw-r--r--   0     1001      123    32662 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/aggregate/mod.rs
--rw-r--r--   0     1001      123    10025 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/aggregate/quantile.rs
--rw-r--r--   0     1001      123     2880 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/aggregate/var.rs
--rw-r--r--   0     1001      123    10551 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/any_value.rs
--rw-r--r--   0     1001      123     4526 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/append.rs
--rw-r--r--   0     1001      123    28257 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/apply.rs
--rw-r--r--   0     1001      123    12799 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/bit_repr.rs
--rw-r--r--   0     1001      123     6236 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/chunkops.rs
--rw-r--r--   0     1001      123    11537 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/compare_inner.rs
--rw-r--r--   0     1001      123     1737 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/concat_str.rs
--rw-r--r--   0     1001      123     4801 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/cum_agg.rs
--rw-r--r--   0     1001      123      908 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/decimal.rs
--rw-r--r--   0     1001      123     7056 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/downcast.rs
--rw-r--r--   0     1001      123    19462 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/explode.rs
--rw-r--r--   0     1001      123     8691 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/explode_and_offsets.rs
--rw-r--r--   0     1001      123     9103 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/extend.rs
--rw-r--r--   0     1001      123    13777 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/fill_null.rs
--rw-r--r--   0     1001      123     6356 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/filter.rs
--rw-r--r--   0     1001      123     5886 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/full.rs
--rw-r--r--   0     1001      123        1 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/interpolate.rs
--rw-r--r--   0     1001      123    16797 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/is_in.rs
--rw-r--r--   0     1001      123        1 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/len.rs
--rw-r--r--   0     1001      123     2658 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/min_max_binary.rs
--rw-r--r--   0     1001      123    23299 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/mod.rs
--rw-r--r--   0     1001      123     2414 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/nulls.rs
--rw-r--r--   0     1001      123      593 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/peaks.rs
--rw-r--r--   0     1001      123     4375 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/repeat_by.rs
--rw-r--r--   0     1001      123     2771 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/reverse.rs
--rw-r--r--   0     1001      123    10267 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/rolling_window.rs
--rw-r--r--   0     1001      123    12518 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/set.rs
--rw-r--r--   0     1001      123     7391 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/shift.rs
--rw-r--r--   0     1001      123     2299 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/sort/arg_sort.rs
--rw-r--r--   0     1001      123     5522 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/sort/arg_sort_multiple.rs
--rw-r--r--   0     1001      123     7543 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/sort/categorical.rs
--rw-r--r--   0     1001      123    28138 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/sort/mod.rs
--rw-r--r--   0     1001      123      380 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/sort/slice.rs
--rw-r--r--   0     1001      123    22089 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/take/mod.rs
--rw-r--r--   0     1001      123     7848 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/take/take_chunked.rs
--rw-r--r--   0     1001      123      301 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/take/take_every.rs
--rw-r--r--   0     1001      123    16256 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/take/take_random.rs
--rw-r--r--   0     1001      123     6275 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/take/take_single.rs
--rw-r--r--   0     1001      123     6072 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/take/traits.rs
--rw-r--r--   0     1001      123      459 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/tile.rs
--rw-r--r--   0     1001      123    12251 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/unique/mod.rs
--rw-r--r--   0     1001      123    14620 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/unique/rank.rs
--rw-r--r--   0     1001      123     5846 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/zip.rs
--rw-r--r--   0     1001      123     9093 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/random.rs
--rw-r--r--   0     1001      123     1875 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/temporal/conversion.rs
--rw-r--r--   0     1001      123     2826 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/temporal/date.rs
--rw-r--r--   0     1001      123    10336 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/temporal/datetime.rs
--rw-r--r--   0     1001      123     3201 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/temporal/duration.rs
--rw-r--r--   0     1001      123     1061 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/temporal/mod.rs
--rw-r--r--   0     1001      123     3042 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/temporal/time.rs
--rw-r--r--   0     1001      123      872 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/to_vec.rs
--rw-r--r--   0     1001      123     8114 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/trusted_len.rs
--rw-r--r--   0     1001      123    26020 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/upstream_traits.rs
--rw-r--r--   0     1001      123     7944 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/cloud.rs
--rw-r--r--   0     1001      123     1549 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/config.rs
--rw-r--r--   0     1001      123     4469 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/datatypes/_serde.rs
--rw-r--r--   0     1001      123     2509 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/datatypes/aliases.rs
--rw-r--r--   0     1001      123    42659 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/datatypes/any_value.rs
--rw-r--r--   0     1001      123    13381 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/datatypes/dtype.rs
--rw-r--r--   0     1001      123     5609 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/datatypes/field.rs
--rw-r--r--   0     1001      123     8059 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/datatypes/mod.rs
--rw-r--r--   0     1001      123     2016 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/datatypes/time_unit.rs
--rw-r--r--   0     1001      123      118 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/doc/changelog/mod.rs
--rw-r--r--   0     1001      123      898 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/doc/changelog/v0_10_0_11.rs
--rw-r--r--   0     1001      123      481 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/doc/changelog/v0_3.rs
--rw-r--r--   0     1001      123      293 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/doc/changelog/v0_4.rs
--rw-r--r--   0     1001      123      499 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/doc/changelog/v0_5.rs
--rw-r--r--   0     1001      123      288 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/doc/changelog/v0_6.rs
--rw-r--r--   0     1001      123     1071 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/doc/changelog/v0_7.rs
--rw-r--r--   0     1001      123      819 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/doc/changelog/v0_8.rs
--rw-r--r--   0     1001      123      596 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/doc/changelog/v0_9.rs
--rw-r--r--   0     1001      123       43 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/doc/mod.rs
--rw-r--r--   0     1001      123       25 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/error.rs
--rw-r--r--   0     1001      123      263 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/export.rs
--rw-r--r--   0     1001      123    36573 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/fmt.rs
--rw-r--r--   0     1001      123     5177 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/arithmetic.rs
--rw-r--r--   0     1001      123     9916 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/asof_join/asof.rs
--rw-r--r--   0     1001      123    35743 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/asof_join/groups.rs
--rw-r--r--   0     1001      123     7168 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/asof_join/mod.rs
--rw-r--r--   0     1001      123      559 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/chunks.rs
--rw-r--r--   0     1001      123     5181 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/cross_join.rs
--rw-r--r--   0     1001      123    16760 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/explode.rs
--rw-r--r--   0     1001      123     1019 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/from.rs
--rw-r--r--   0     1001      123    19239 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/groupby/aggregations/agg_list.rs
--rw-r--r--   0     1001      123     4113 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/groupby/aggregations/boolean.rs
--rw-r--r--   0     1001      123     7749 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/groupby/aggregations/dispatch.rs
--rw-r--r--   0     1001      123    40479 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/groupby/aggregations/mod.rs
--rw-r--r--   0     1001      123     5634 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/groupby/aggregations/utf8.rs
--rw-r--r--   0     1001      123      218 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/groupby/expr.rs
--rw-r--r--   0     1001      123    22901 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/groupby/hashing.rs
--rw-r--r--   0     1001      123    14380 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/groupby/into_groups.rs
--rw-r--r--   0     1001      123    39623 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/groupby/mod.rs
--rw-r--r--   0     1001      123    10637 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/groupby/perfect.rs
--rw-r--r--   0     1001      123    19780 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/groupby/proxy.rs
--rw-r--r--   0     1001      123     5416 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/args.rs
--rw-r--r--   0     1001      123    13172 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/mod.rs
--rw-r--r--   0     1001      123    22364 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/multiple_keys.rs
--rw-r--r--   0     1001      123     2400 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/single_keys.rs
--rw-r--r--   0     1001      123    17372 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/single_keys_dispatch.rs
--rw-r--r--   0     1001      123     4677 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/single_keys_inner.rs
--rw-r--r--   0     1001      123     6502 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/single_keys_left.rs
--rw-r--r--   0     1001      123     4665 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/single_keys_outer.rs
--rw-r--r--   0     1001      123     3913 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/single_keys_semi_anti.rs
--rw-r--r--   0     1001      123    12313 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/sort_merge.rs
--rw-r--r--   0     1001      123     3865 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/zip_outer.rs
--rw-r--r--   0     1001      123   126294 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/mod.rs
--rw-r--r--   0     1001      123    27652 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/row/av_buffer.rs
--rw-r--r--   0     1001      123     5183 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/row/dataframe.rs
--rw-r--r--   0     1001      123     5976 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/row/mod.rs
--rw-r--r--   0     1001      123     9875 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/row/transpose.rs
--rw-r--r--   0     1001      123     2811 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/top_k.rs
--rw-r--r--   0     1001      123     1388 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/upstream_traits.rs
--rw-r--r--   0     1001      123    10198 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/functions.rs
--rw-r--r--   0     1001      123     2149 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/hashing/fx.rs
--rw-r--r--   0     1001      123     1503 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/hashing/identity.rs
--rw-r--r--   0     1001      123      457 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/hashing/mod.rs
--rw-r--r--   0     1001      123     2684 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/hashing/partition.rs
--rw-r--r--   0     1001      123    17704 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/hashing/vector_hasher.rs
--rw-r--r--   0     1001      123     1896 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/lib.rs
--rw-r--r--   0     1001      123    15763 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/named_from.rs
--rw-r--r--   0     1001      123     2502 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/prelude.rs
--rw-r--r--   0     1001      123    18242 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/schema.rs
--rw-r--r--   0     1001      123     3995 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/serde/chunked_array.rs
--rw-r--r--   0     1001      123     1094 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/serde/df.rs
--rw-r--r--   0     1001      123     4734 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/serde/mod.rs
--rw-r--r--   0     1001      123     9938 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/serde/series.rs
--rw-r--r--   0     1001      123    18543 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/any_value.rs
--rw-r--r--   0     1001      123    28755 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/arithmetic/borrowed.rs
--rw-r--r--   0     1001      123      222 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/arithmetic/mod.rs
--rw-r--r--   0     1001      123     3546 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/arithmetic/owned.rs
--rw-r--r--   0     1001      123    19293 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/comparison.rs
--rw-r--r--   0     1001      123    29766 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/from.rs
--rw-r--r--   0     1001      123     6080 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/array.rs
--rw-r--r--   0     1001      123     9089 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/binary.rs
--rw-r--r--   0     1001      123    10835 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/boolean.rs
--rw-r--r--   0     1001      123    12800 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/categorical.rs
--rw-r--r--   0     1001      123    18214 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/dates_time.rs
--rw-r--r--   0     1001      123    15034 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/datetime.rs
--rw-r--r--   0     1001      123     7981 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/decimal.rs
--rw-r--r--   0     1001      123    14734 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/duration.rs
--rw-r--r--   0     1001      123    14063 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/floats.rs
--rw-r--r--   0     1001      123     6078 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/list.rs
--rw-r--r--   0     1001      123    18396 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/mod.rs
--rw-r--r--   0     1001      123     5522 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/null.rs
--rw-r--r--   0     1001      123     7939 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/object.rs
--rw-r--r--   0     1001      123    11788 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/struct_.rs
--rw-r--r--   0     1001      123     9607 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/utf8.rs
--rw-r--r--   0     1001      123     4471 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/into.rs
--rw-r--r--   0     1001      123     6241 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/iterator.rs
--rw-r--r--   0     1001      123    39074 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/mod.rs
--rw-r--r--   0     1001      123      853 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/ops/diff.rs
--rw-r--r--   0     1001      123     5814 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/ops/downcast.rs
--rw-r--r--   0     1001      123     3601 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/ops/ewm.rs
--rw-r--r--   0     1001      123      413 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/ops/extend.rs
--rw-r--r--   0     1001      123      562 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/ops/mod.rs
--rw-r--r--   0     1001      123     5974 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/ops/moment.rs
--rw-r--r--   0     1001      123     3181 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/ops/null.rs
--rw-r--r--   0     1001      123     1347 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/ops/pct_change.rs
--rw-r--r--   0     1001      123     4620 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/ops/round.rs
--rw-r--r--   0     1001      123     5082 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/ops/to_list.rs
--rw-r--r--   0     1001      123     1476 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/ops/unique.rs
--rw-r--r--   0     1001      123    18408 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/series_trait.rs
--rw-r--r--   0     1001      123     2912 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/unstable.rs
--rw-r--r--   0     1001      123     7077 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/testing.rs
--rw-r--r--   0     1001      123      508 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/tests.rs
--rw-r--r--   0     1001      123     2492 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/utils/flatten.rs
--rw-r--r--   0     1001      123    31194 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/utils/mod.rs
--rw-r--r--   0     1001      123     1600 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/utils/series.rs
--rw-r--r--   0     1001      123    13201 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-core/src/utils/supertype.rs
--rw-r--r--   0        0        0     5424 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/LICENSE
--rw-r--r--   0     1001      123       45 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/constants.rs
--rw-r--r--   0     1001      123    17253 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dot.rs
--rw-r--r--   0     1001      123     4789 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/arithmetic.rs
--rw-r--r--   0     1001      123     3992 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/arity.rs
--rw-r--r--   0     1001      123     1278 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/array.rs
--rw-r--r--   0     1001      123      935 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/binary.rs
--rw-r--r--   0     1001      123      650 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/cat.rs
--rw-r--r--   0     1001      123    10729 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/dt.rs
--rw-r--r--   0     1001      123     9542 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/expr.rs
--rw-r--r--   0     1001      123     8359 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/expr_dyn_fn.rs
--rw-r--r--   0     1001      123      753 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/from.rs
--rw-r--r--   0     1001      123       85 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/abs.rs
--rw-r--r--   0     1001      123     1431 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/arg_where.rs
--rw-r--r--   0     1001      123     1074 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/array.rs
--rw-r--r--   0     1001      123     1327 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/binary.rs
--rw-r--r--   0     1001      123     4221 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/boolean.rs
--rw-r--r--   0     1001      123     1910 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/bounds.rs
--rw-r--r--   0     1001      123     1216 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/cat.rs
--rw-r--r--   0     1001      123      344 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/clip.rs
--rw-r--r--   0     1001      123      257 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/concat.rs
--rw-r--r--   0     1001      123     6125 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/correlation.rs
--rw-r--r--   0     1001      123     1593 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/cum.rs
--rw-r--r--   0     1001      123    11615 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/datetime.rs
--rw-r--r--   0     1001      123      782 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/dispatch.rs
--rw-r--r--   0     1001      123     2567 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/fill_null.rs
--rw-r--r--   0     1001      123      992 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/fused.rs
--rw-r--r--   0     1001      123     8997 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/list.rs
--rw-r--r--   0     1001      123      581 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/log.rs
--rw-r--r--   0     1001      123    24898 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/mod.rs
--rw-r--r--   0     1001      123      462 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/nan.rs
--rw-r--r--   0     1001      123     3132 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/pow.rs
--rw-r--r--   0     1001      123     1410 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/random.rs
--rw-r--r--   0     1001      123     5146 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/range.rs
--rw-r--r--   0     1001      123      152 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/rolling.rs
--rw-r--r--   0     1001      123      260 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/round.rs
--rw-r--r--   0     1001      123      200 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/row_hash.rs
--rw-r--r--   0     1001      123    19251 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/schema.rs
--rw-r--r--   0     1001      123      306 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/search_sorted.rs
--rw-r--r--   0     1001      123     3812 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/shift_and_fill.rs
--rw-r--r--   0     1001      123     1238 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/shrink_type.rs
--rw-r--r--   0     1001      123      972 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/sign.rs
--rw-r--r--   0     1001      123    22249 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/strings.rs
--rw-r--r--   0     1001      123     1017 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/struct_.rs
--rw-r--r--   0     1001      123     8438 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/temporal.rs
--rw-r--r--   0     1001      123     6112 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/trigonometry.rs
--rw-r--r--   0     1001      123      170 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/unique.rs
--rw-r--r--   0     1001      123     1155 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/arity.rs
--rw-r--r--   0     1001      123      611 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/coerce.rs
--rw-r--r--   0     1001      123     2717 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/concat.rs
--rw-r--r--   0     1001      123     4525 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/correlation.rs
--rw-r--r--   0     1001      123     8736 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/horizontal.rs
--rw-r--r--   0     1001      123     1042 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/index.rs
--rw-r--r--   0     1001      123      968 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/mod.rs
--rw-r--r--   0     1001      123     4129 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/range.rs
--rw-r--r--   0     1001      123     1308 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/selectors.rs
--rw-r--r--   0     1001      123     1973 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/syntactic_sugar.rs
--rw-r--r--   0     1001      123    11328 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/temporal.rs
--rw-r--r--   0     1001      123    12282 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/list.rs
--rw-r--r--   0     1001      123     4501 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/meta.rs
--rw-r--r--   0     1001      123    61162 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/mod.rs
--rw-r--r--   0     1001      123       40 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/names.rs
--rw-r--r--   0     1001      123     2658 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/options.rs
--rw-r--r--   0     1001      123     7017 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/python_udf.rs
--rw-r--r--   0     1001      123     1432 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/random.rs
--rw-r--r--   0     1001      123     1068 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/selector.rs
--rw-r--r--   0     1001      123    17626 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/string.rs
--rw-r--r--   0     1001      123     2715 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/struct_.rs
--rw-r--r--   0     1001      123       38 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/frame/mod.rs
--rw-r--r--   0     1001      123      933 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/frame/opt_state.rs
--rw-r--r--   0     1001      123      466 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/global.rs
--rw-r--r--   0     1001      123      175 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/lib.rs
--rw-r--r--   0     1001      123    10651 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/aexpr/mod.rs
--rw-r--r--   0     1001      123    11920 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/aexpr/schema.rs
--rw-r--r--   0     1001      123    25683 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/alp.rs
--rw-r--r--   0     1001      123     1622 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/anonymous_scan.rs
--rw-r--r--   0     1001      123     1428 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/apply.rs
--rw-r--r--   0     1001      123    25639 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/builder.rs
--rw-r--r--   0     1001      123    29993 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/conversion.rs
--rw-r--r--   0     1001      123      301 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/debug.rs
--rw-r--r--   0     1001      123    15713 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/format.rs
--rw-r--r--   0     1001      123      895 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/functions/drop.rs
--rw-r--r--   0     1001      123      137 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/functions/explode.rs
--rw-r--r--   0     1001      123     1169 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/functions/merge_sorted.rs
--rw-r--r--   0     1001      123    13288 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/functions/mod.rs
--rw-r--r--   0     1001      123     1031 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/functions/python_udf.rs
--rw-r--r--   0     1001      123     1330 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/functions/rename.rs
--rw-r--r--   0     1001      123    10157 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/iterator.rs
--rw-r--r--   0     1001      123    10559 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/lit.rs
--rw-r--r--   0     1001      123     8142 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/mod.rs
--rw-r--r--   0     1001      123     7416 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/cache_states.rs
--rw-r--r--   0     1001      123    15277 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/cse.rs
--rw-r--r--   0     1001      123     2889 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/delay_rechunk.rs
--rw-r--r--   0     1001      123     3236 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/drop_nulls.rs
--rw-r--r--   0     1001      123     4663 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/fast_projection.rs
--rw-r--r--   0     1001      123    14479 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/file_caching.rs
--rw-r--r--   0     1001      123     1556 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/flatten_union.rs
--rw-r--r--   0     1001      123     6017 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/fused.rs
--rw-r--r--   0     1001      123     6778 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/mod.rs
--rw-r--r--   0     1001      123     1222 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/keys.rs
--rw-r--r--   0     1001      123    28901 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/mod.rs
--rw-r--r--   0     1001      123     2571 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/rename.rs
--rw-r--r--   0     1001      123    16171 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/utils.rs
--rw-r--r--   0     1001      123     1755 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/functions/melt.rs
--rw-r--r--   0     1001      123     3930 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/functions/mod.rs
--rw-r--r--   0     1001      123     1799 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/generic.rs
--rw-r--r--   0     1001      123     3269 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/groupby.rs
--rw-r--r--   0     1001      123     2638 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/hstack.rs
--rw-r--r--   0     1001      123    15874 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/joins.rs
--rw-r--r--   0     1001      123    26739 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/mod.rs
--rw-r--r--   0     1001      123     3707 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/projection.rs
--rw-r--r--   0     1001      123     2639 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/rename.rs
--rw-r--r--   0     1001      123     3509 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/semi_anti_join.rs
--rw-r--r--   0     1001      123    27269 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/simplify_expr.rs
--rw-r--r--   0     1001      123     3496 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/slice_pushdown_expr.rs
--rw-r--r--   0     1001      123    13232 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/slice_pushdown_lp.rs
--rw-r--r--   0     1001      123     4181 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/stack_opt.rs
--rw-r--r--   0     1001      123     9796 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/type_coercion/binary.rs
--rw-r--r--   0     1001      123    20215 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/type_coercion/mod.rs
--rw-r--r--   0     1001      123    10653 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/options.rs
--rw-r--r--   0     1001      123    19151 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/projection.rs
--rw-r--r--   0     1001      123     6144 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/pyarrow.rs
--rw-r--r--   0     1001      123    13026 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/schema.rs
--rw-r--r--   0     1001      123     6699 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/tree_format.rs
--rw-r--r--   0     1001      123     3544 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/visitor/expr.rs
--rw-r--r--   0     1001      123      930 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/visitor/mod.rs
--rw-r--r--   0     1001      123     4408 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/visitor/visitors.rs
--rw-r--r--   0     1001      123      832 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/prelude.rs
--rw-r--r--   0     1001      123    12428 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/utils.rs
--rw-r--r--   0        0        0     4397 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/LICENSE
--rw-r--r--   0     1001      123      138 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/README.md
--rw-r--r--   0     1001      123     2383 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/avro/mod.rs
--rw-r--r--   0     1001      123     3608 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/avro/read.rs
--rw-r--r--   0     1001      123     2622 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/avro/write.rs
--rw-r--r--   0     1001      123     4505 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/cloud/adaptors.rs
--rw-r--r--   0     1001      123     9506 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/cloud/glob.rs
--rw-r--r--   0     1001      123     3089 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/cloud/mod.rs
--rw-r--r--   0     1001      123    28829 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/buffer.rs
--rw-r--r--   0     1001      123     1815 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/mod.rs
--rw-r--r--   0     1001      123    19446 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/parser.rs
--rw-r--r--   0     1001      123    22228 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/read.rs
--rw-r--r--   0     1001      123    10847 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/read_impl/batched_mmap.rs
--rw-r--r--   0     1001      123    13939 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/read_impl/batched_read.rs
--rw-r--r--   0     1001      123    30724 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/read_impl/mod.rs
--rw-r--r--   0     1001      123    11466 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/splitfields.rs
--rw-r--r--   0     1001      123    24531 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/utils.rs
--rw-r--r--   0     1001      123     2796 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/write.rs
--rw-r--r--   0     1001      123    14759 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/write_impl.rs
--rw-r--r--   0     1001      123      184 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/export.rs
--rw-r--r--   0     1001      123     7586 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/ipc/ipc_file.rs
--rw-r--r--   0     1001      123     9227 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/ipc/ipc_stream.rs
--rw-r--r--   0     1001      123     3253 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/ipc/mmap.rs
--rw-r--r--   0     1001      123      401 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/ipc/mod.rs
--rw-r--r--   0     1001      123     8287 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/ipc/write.rs
--rw-r--r--   0     1001      123     1471 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/ipc/write_async.rs
--rw-r--r--   0     1001      123    11044 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/json/mod.rs
--rw-r--r--   0     1001      123     4771 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/lib.rs
--rw-r--r--   0     1001      123     1969 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/mmap.rs
--rw-r--r--   0     1001      123     7228 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/ndjson/buffer.rs
--rw-r--r--   0     1001      123    11979 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/ndjson/core.rs
--rw-r--r--   0     1001      123       37 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/ndjson/mod.rs
--rw-r--r--   0     1001      123      273 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/options.rs
--rw-r--r--   0     1001      123     7360 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/parquet/async_impl.rs
--rw-r--r--   0     1001      123     3093 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/parquet/mmap.rs
--rw-r--r--   0     1001      123     3132 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/parquet/mod.rs
--rw-r--r--   0     1001      123     4784 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/parquet/predicates.rs
--rw-r--r--   0     1001      123     9623 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/parquet/read.rs
--rw-r--r--   0     1001      123    17321 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/parquet/read_impl.rs
--rw-r--r--   0     1001      123    10129 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/parquet/write.rs
--rw-r--r--   0     1001      123     5334 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/partition.rs
--rw-r--r--   0     1001      123     1455 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/predicates.rs
--rw-r--r--   0     1001      123      621 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/prelude.rs
--rw-r--r--   0     1001      123      417 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/tests.rs
--rw-r--r--   0     1001      123     4374 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-io/src/utils.rs
--rw-r--r--   0        0        0      587 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/LICENSE
--rw-r--r--   0     1001      123      141 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/README.md
--rw-r--r--   0     1001      123      151 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/aliases.rs
--rw-r--r--   0     1001      123     2879 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/arena.rs
--rw-r--r--   0     1001      123     1379 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/atomic.rs
--rw-r--r--   0     1001      123     2659 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/cell.rs
--rw-r--r--   0     1001      123     1015 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/contention_pool.rs
--rw-r--r--   0     1001      123      509 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/error.rs
--rw-r--r--   0     1001      123      271 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/fmt.rs
--rw-r--r--   0     1001      123      763 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/functions.rs
--rw-r--r--   0     1001      123     2709 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/iter/enumerate_idx.rs
--rw-r--r--   0     1001      123       61 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/iter/mod.rs
--rw-r--r--   0     1001      123      503 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/lib.rs
--rw-r--r--   0     1001      123      573 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/macros.rs
--rw-r--r--   0     1001      123      282 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/mem.rs
--rw-r--r--   0     1001      123     2642 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/slice.rs
--rw-r--r--   0     1001      123     2467 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/sort.rs
--rw-r--r--   0     1001      123     1115 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/sync.rs
--rw-r--r--   0     1001      123      504 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/sys.rs
--rw-r--r--   0     1001      123      697 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/unwrap.rs
--rw-r--r--   0     1001      123     2024 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/vec.rs
--rw-r--r--   0     1001      123      616 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/wasm.rs
--rw-r--r--   0        0        0     1353 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.6/local_dependencies/polars-json/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-json/LICENSE
--rw-r--r--   0     1001      123    16461 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-json/src/json/deserialize.rs
--rw-r--r--   0     1001      123     6564 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-json/src/json/infer_schema.rs
--rw-r--r--   0     1001      123      189 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-json/src/json/mod.rs
--rw-r--r--   0     1001      123       30 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-json/src/lib.rs
--rw-r--r--   0     1001      123     1198 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-json/src/ndjson/deserialize.rs
--rw-r--r--   0     1001      123     4808 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-json/src/ndjson/file.rs
--rw-r--r--   0     1001      123      143 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-json/src/ndjson/mod.rs
--rw-r--r--   0        0        0    10755 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.6/local_dependencies/polars/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/LICENSE
--rw-r--r--   0     1001      123     3472 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/Makefile
--rw-r--r--   0     1001      123      215 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/build.rs
--rw-r--r--   0     1001      123       78 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/clippy.toml
--rw-r--r--   0     1001      123    17614 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/src/docs/eager.rs
--rw-r--r--   0     1001      123     8815 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/src/docs/lazy.rs
--rw-r--r--   0     1001      123       50 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/src/docs/mod.rs
--rw-r--r--   0     1001      123     3806 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/src/docs/performance.rs
--rw-r--r--   0     1001      123       59 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/src/export.rs
--rw-r--r--   0     1001      123    19848 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/src/lib.rs
--rw-r--r--   0     1001      123      387 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/src/prelude.rs
--rw-r--r--   0     1001      123       54 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/src/sql.rs
--rw-r--r--   0     1001      123     4272 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/core/date_like.rs
--rw-r--r--   0     1001      123     2401 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/core/groupby.rs
--rw-r--r--   0     1001      123    17838 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/core/joins.rs
--rw-r--r--   0     1001      123      545 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/core/list.rs
--rw-r--r--   0     1001      123      198 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/core/mod.rs
--rw-r--r--   0     1001      123       24 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/core/ops/mod.rs
--rw-r--r--   0     1001      123      457 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/core/ops/take.rs
--rw-r--r--   0     1001      123     6259 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/core/pivot.rs
--rw-r--r--   0     1001      123     1102 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/core/random.rs
--rw-r--r--   0     1001      123    11096 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/core/rolling_window.rs
--rw-r--r--   0     1001      123     1093 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/core/series.rs
--rw-r--r--   0     1001      123      370 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/core/utils.rs
--rw-r--r--   0     1001      123    30423 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/io/csv.rs
--rw-r--r--   0     1001      123     4490 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/io/ipc_stream.rs
--rw-r--r--   0     1001      123     7043 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/io/json.rs
--rw-r--r--   0     1001      123      378 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/io/mod.rs
--rw-r--r--   0     1001      123      531 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/io/parquet.rs
--rw-r--r--   0     1001      123     1530 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/joins.rs
--rw-r--r--   0     1001      123     2452 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/aggregation.rs
--rw-r--r--   0     1001      123      821 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/cse.rs
--rw-r--r--   0     1001      123      500 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/explodes.rs
--rw-r--r--   0     1001      123     2278 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/expressions/apply.rs
--rw-r--r--   0     1001      123    10285 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/expressions/arity.rs
--rw-r--r--   0     1001      123     1065 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/expressions/expand.rs
--rw-r--r--   0     1001      123     1008 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/expressions/filter.rs
--rw-r--r--   0     1001      123      428 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/expressions/is_in.rs
--rw-r--r--   0     1001      123      121 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/expressions/mod.rs
--rw-r--r--   0     1001      123      659 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/expressions/slice.rs
--rw-r--r--   0     1001      123    10657 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/expressions/window.rs
--rw-r--r--   0     1001      123      579 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/folds.rs
--rw-r--r--   0     1001      123      557 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/functions.rs
--rw-r--r--   0     1001      123     4482 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/groupby.rs
--rw-r--r--   0     1001      123     1681 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/groupby_dynamic.rs
--rw-r--r--   0     1001      123      691 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/mod.rs
--rw-r--r--   0     1001      123     5747 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/predicate_queries.rs
--rw-r--r--   0     1001      123     4483 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/projection_queries.rs
--rw-r--r--   0     1001      123     6584 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/queries.rs
--rw-r--r--   0     1001      123      151 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/main.rs
--rw-r--r--   0     1001      123    12591 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/schema.rs
--rw-r--r--   0     1001      123     1899 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/time/date_range.rs
--rw-r--r--   0     1001      123       16 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/time/mod.rs
--rw-r--r--   0        0        0     1592 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/LICENSE
--rw-r--r--   0     1001      123      144 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/README.md
--rw-r--r--   0     1001      123     1975 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/array/default_arrays.rs
--rw-r--r--   0     1001      123     1791 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/array/fixed_size_list.rs
--rw-r--r--   0     1001      123     3773 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/array/get.rs
--rw-r--r--   0     1001      123     6664 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/array/list.rs
--rw-r--r--   0     1001      123     8165 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/array/mod.rs
--rw-r--r--   0     1001      123      878 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/array/null.rs
--rw-r--r--   0     1001      123     1125 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/array/slice.rs
--rw-r--r--   0     1001      123     2253 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/array/utf8.rs
--rw-r--r--   0     1001      123     2294 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/bit_util.rs
--rw-r--r--   0     1001      123       17 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/bitmap/mod.rs
--rw-r--r--   0     1001      123      819 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/bitmap/mutable.rs
--rw-r--r--   0     1001      123      370 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/add.rs
--rw-r--r--   0     1001      123     2181 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/commutative.rs
--rw-r--r--   0     1001      123     1482 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/div.rs
--rw-r--r--   0     1001      123     1028 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/mod.rs
--rw-r--r--   0     1001      123     1177 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/mul.rs
--rw-r--r--   0     1001      123      508 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/sub.rs
--rw-r--r--   0     1001      123       51 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/arithmetics/mod.rs
--rw-r--r--   0     1001      123        1 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/arity.rs
--rw-r--r--   0     1001      123      727 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/bitwise.rs
--rw-r--r--   0     1001      123     1206 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/cast.rs
--rw-r--r--   0     1001      123     3964 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/decimal.rs
--rw-r--r--   0     1001      123     1250 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/mod.rs
--rw-r--r--   0     1001      123      391 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/take/bitmap.rs
--rw-r--r--   0     1001      123     2767 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/take/boolean.rs
--rw-r--r--   0     1001      123     3489 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/take/fixed_size_list.rs
--rw-r--r--   0     1001      123    25290 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/take/mod.rs
--rw-r--r--   0     1001      123      797 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/tile.rs
--rw-r--r--   0     1001      123     1102 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/conversion.rs
--rw-r--r--   0     1001      123     1609 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/data_types.rs
--rw-r--r--   0     1001      123       25 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/error.rs
--rw-r--r--   0     1001      123       28 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/export.rs
--rw-r--r--   0     1001      123       26 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/floats/mod.rs
--rw-r--r--   0     1001      123     2066 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/floats/ord.rs
--rw-r--r--   0     1001      123     1273 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/index.rs
--rw-r--r--   0     1001      123      984 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/is_valid.rs
--rw-r--r--   0     1001      123     4783 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/agg_mean.rs
--rw-r--r--   0     1001      123     1074 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/comparison.rs
--rw-r--r--   0     1001      123     1068 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/concatenate.rs
--rw-r--r--   0     1001      123     5161 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/ewm/average.rs
--rw-r--r--   0     1001      123     1808 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/ewm/mod.rs
--rw-r--r--   0     1001      123    25065 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/ewm/variance.rs
--rw-r--r--   0     1001      123     1406 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/float.rs
--rw-r--r--   0     1001      123     4908 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/list.rs
--rw-r--r--   0     1001      123     1885 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/list_bytes_iter.rs
--rw-r--r--   0     1001      123     9783 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/mod.rs
--rw-r--r--   0     1001      123     3923 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/mod.rs
--rw-r--r--   0     1001      123     2019 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/mean.rs
--rw-r--r--   0     1001      123    16187 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/min_max.rs
--rw-r--r--   0     1001      123     3848 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/mod.rs
--rw-r--r--   0     1001      123    13521 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/quantile.rs
--rw-r--r--   0     1001      123     5684 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/sum.rs
--rw-r--r--   0     1001      123     7807 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/variance.rs
--rw-r--r--   0     1001      123     1879 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/nulls/mean.rs
--rw-r--r--   0     1001      123    14722 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/nulls/min_max.rs
--rw-r--r--   0     1001      123    10055 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/nulls/mod.rs
--rw-r--r--   0     1001      123    11643 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/nulls/quantile.rs
--rw-r--r--   0     1001      123     4821 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/nulls/sum.rs
--rw-r--r--   0     1001      123     6856 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/nulls/variance.rs
--rw-r--r--   0     1001      123     8109 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/window.rs
--rw-r--r--   0     1001      123     4753 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/set.rs
--rw-r--r--   0     1001      123     4529 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/sort_partition.rs
--rw-r--r--   0     1001      123     2948 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/sorted_join/inner.rs
--rw-r--r--   0     1001      123     5974 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/sorted_join/left.rs
--rw-r--r--   0     1001      123      231 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/sorted_join/mod.rs
--rw-r--r--   0     1001      123      842 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/string.rs
--rw-r--r--   0     1001      123     2310 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/take_agg/boolean.rs
--rw-r--r--   0     1001      123     4315 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/take_agg/mod.rs
--rw-r--r--   0     1001      123     2606 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/take_agg/var.rs
--rw-r--r--   0     1001      123     3672 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/time.rs
--rw-r--r--   0     1001      123      341 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/lib.rs
--rw-r--r--   0     1001      123      496 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/prelude.rs
--rw-r--r--   0     1001      123      534 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/slice.rs
--rw-r--r--   0     1001      123      183 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/time_zone.rs
--rw-r--r--   0     1001      123      998 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/trusted_len/boolean.rs
--rw-r--r--   0     1001      123     2821 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/trusted_len/mod.rs
--rw-r--r--   0     1001      123     2054 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/trusted_len/push_unchecked.rs
--rw-r--r--   0     1001      123      158 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/trusted_len/rev.rs
--rw-r--r--   0     1001      123     5233 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/utils.rs
--rw-r--r--   0        0        0     1998 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/LICENSE
--rw-r--r--   0     1001      123      165 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/README.md
--rw-r--r--   0     1001      123       98 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/mod.rs
--rw-r--r--   0     1001      123     1219 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/operators/filter.rs
--rw-r--r--   0     1001      123     4103 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/operators/function.rs
--rw-r--r--   0     1001      123      266 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/operators/mod.rs
--rw-r--r--   0     1001      123      682 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/operators/pass.rs
--rw-r--r--   0     1001      123      548 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/operators/placeholder.rs
--rw-r--r--   0     1001      123     3553 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/operators/projection.rs
--rw-r--r--   0     1001      123     3559 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/operators/reproject.rs
--rw-r--r--   0     1001      123     6479 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/file_sink.rs
--rw-r--r--   0     1001      123    11288 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/convert.rs
--rw-r--r--   0     1001      123     1207 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/count.rs
--rw-r--r--   0     1001      123     1888 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/first.rs
--rw-r--r--   0     1001      123     4554 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/interface.rs
--rw-r--r--   0     1001      123     1746 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/last.rs
--rw-r--r--   0     1001      123     5413 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/mean.rs
--rw-r--r--   0     1001      123     4951 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/min_max.rs
--rw-r--r--   0     1001      123      211 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/mod.rs
--rw-r--r--   0     1001      123      856 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/null.rs
--rw-r--r--   0     1001      123     4294 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/sum.rs
--rw-r--r--   0     1001      123     4109 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/eval.rs
--rw-r--r--   0     1001      123     7404 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/global.rs
--rw-r--r--   0     1001      123    10554 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/hash_table.rs
--rw-r--r--   0     1001      123     3589 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/mod.rs
--rw-r--r--   0     1001      123     2767 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/ooc_state.rs
--rw-r--r--   0     1001      123     6326 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/sink.rs
--rw-r--r--   0     1001      123     3116 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/source.rs
--rw-r--r--   0     1001      123    10194 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/thread_local.rs
--rw-r--r--   0     1001      123     2119 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/mod.rs
--rw-r--r--   0     1001      123     4695 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/ooc.rs
--rw-r--r--   0     1001      123     1887 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/ooc_state.rs
--rw-r--r--   0     1001      123    20783 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/primitive/mod.rs
--rw-r--r--   0     1001      123    23825 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/string.rs
--rw-r--r--   0     1001      123     2457 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/utils.rs
--rw-r--r--   0     1001      123     9239 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/io.rs
--rw-r--r--   0     1001      123     5451 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/joins/cross.rs
--rw-r--r--   0     1001      123    12056 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/joins/generic_build.rs
--rw-r--r--   0     1001      123    11658 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/joins/inner_left.rs
--rw-r--r--   0     1001      123      178 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/joins/mod.rs
--rw-r--r--   0     1001      123     2241 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/memory.rs
--rw-r--r--   0     1001      123      589 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/mod.rs
--rw-r--r--   0     1001      123     1492 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/ordered.rs
--rw-r--r--   0     1001      123     1824 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/reproject.rs
--rw-r--r--   0     1001      123     3108 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/slice.rs
--rw-r--r--   0     1001      123      130 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/sort/mod.rs
--rw-r--r--   0     1001      123     6774 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/sort/ooc.rs
--rw-r--r--   0     1001      123     7279 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/sort/sink.rs
--rw-r--r--   0     1001      123    11679 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/sort/sink_multiple.rs
--rw-r--r--   0     1001      123     3908 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/sort/source.rs
--rw-r--r--   0     1001      123      526 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/utils.rs
--rw-r--r--   0     1001      123     5984 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sources/csv.rs
--rw-r--r--   0     1001      123     1231 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sources/frame.rs
--rw-r--r--   0     1001      123      987 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sources/ipc_one_shot.rs
--rw-r--r--   0     1001      123      366 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sources/mod.rs
--rw-r--r--   0     1001      123     4335 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sources/parquet.rs
--rw-r--r--   0     1001      123     1146 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sources/reproject.rs
--rw-r--r--   0     1001      123     1022 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sources/union.rs
--rw-r--r--   0     1001      123      448 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/expressions.rs
--rw-r--r--   0     1001      123      272 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/lib.rs
--rw-r--r--   0     1001      123      719 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/operators/chunks.rs
--rw-r--r--   0     1001      123      474 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/operators/context.rs
--rw-r--r--   0     1001      123      223 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/operators/mod.rs
--rw-r--r--   0     1001      123      514 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/operators/operator.rs
--rw-r--r--   0     1001      123      626 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/operators/sink.rs
--rw-r--r--   0     1001      123      241 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/operators/source.rs
--rw-r--r--   0     1001      123        1 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/pipeline/config.rs
--rw-r--r--   0     1001      123    21320 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/pipeline/convert.rs
--rw-r--r--   0     1001      123    20362 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/pipeline/dispatcher.rs
--rw-r--r--   0     1001      123     1155 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/pipeline/mod.rs
--rw-r--r--   0        0        0      894 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.6/local_dependencies/polars-error/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-error/LICENSE
--rw-r--r--   0     1001      123      145 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-error/README.md
--rw-r--r--   0     1001      123     7567 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/local_dependencies/polars-error/src/lib.rs
--rw-r--r--   0        0        0     4554 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.6/Cargo.toml
--rw-r--r--   0     1001      123       76 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/.gitignore
--rw-r--r--   0     1001      123     1055 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/LICENSE
--rw-r--r--   0     1001      123     2414 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/Makefile
--rw-r--r--   0     1001      123    11696 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/README.md
--rw-r--r--   0     1001      123      651 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/build.rs
--rw-r--r--   0     1001      123       32 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/.gitignore
--rw-r--r--   0     1001      123      682 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/Makefile
--rw-r--r--   0     1001      123      318 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/_templates/api_redirect.html
--rw-r--r--   0     1001      123      151 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/_templates/autosummary/accessor.rst
--rw-r--r--   0     1001      123      160 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/_templates/autosummary/accessor_attribute.rst
--rw-r--r--   0     1001      123      168 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/_templates/autosummary/accessor_callable.rst
--rw-r--r--   0     1001      123      157 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/_templates/autosummary/accessor_method.rst
--rw-r--r--   0     1001      123      836 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/_templates/autosummary/class.rst
--rw-r--r--   0     1001      123       94 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/_templates/autosummary/class_without_autosummary.rst
--rw-r--r--   0     1001      123      406 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/_templates/sidebar-nav-bs.html
--rw-r--r--   0     1001      123      559 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/requirements-docs.txt
--rw-r--r--   0     1001      123     1164 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/run_live_docs_server.py
--rw-r--r--   0     1001      123     1567 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/_static/css/custom.css
--rw-r--r--   0     1001      123     7297 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/conf.py
--rw-r--r--   0     1001      123       51 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/index.rst
--rw-r--r--   0     1001      123     6767 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/api.rst
--rw-r--r--   0     1001      123     2069 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/config.rst
--rw-r--r--   0     1001      123      274 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/dataframe/aggregation.rst
--rw-r--r--   0     1001      123      221 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/dataframe/attributes.rst
--rw-r--r--   0     1001      123      142 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/dataframe/computation.rst
--rw-r--r--   0     1001      123      319 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/dataframe/descriptive.rst
--rw-r--r--   0     1001      123      319 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/dataframe/export.rst
--rw-r--r--   0     1001      123      464 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/dataframe/groupby.rst
--rw-r--r--   0     1001      123      379 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/dataframe/index.rst
--rw-r--r--   0     1001      123      189 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/dataframe/miscellaneous.rst
--rw-r--r--   0     1001      123     1538 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/dataframe/modify_select.rst
--rw-r--r--   0     1001      123      673 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/datatypes.rst
--rw-r--r--   0     1001      123      421 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/exceptions.rst
--rw-r--r--   0     1001      123      391 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/expressions/aggregation.rst
--rw-r--r--   0     1001      123      267 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/expressions/array.rst
--rw-r--r--   0     1001      123      309 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/expressions/binary.rst
--rw-r--r--   0     1001      123      338 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/expressions/boolean.rst
--rw-r--r--   0     1001      123      237 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/expressions/categories.rst
--rw-r--r--   0     1001      123      221 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/expressions/columns.rst
--rw-r--r--   0     1001      123     1095 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/expressions/computation.rst
--rw-r--r--   0     1001      123     1215 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/expressions/functions.rst
--rw-r--r--   0     1001      123      470 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/expressions/index.rst
--rw-r--r--   0     1001      123      830 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/expressions/list.rst
--rw-r--r--   0     1001      123      458 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/expressions/meta.rst
--rw-r--r--   0     1001      123      159 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/expressions/miscellaneous.rst
--rw-r--r--   0     1001      123      977 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/expressions/modify_select.rst
--rw-r--r--   0     1001      123      679 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/expressions/operators.rst
--rw-r--r--   0     1001      123      977 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/expressions/string.rst
--rw-r--r--   0     1001      123      254 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/expressions/struct.rst
--rw-r--r--   0     1001      123     1087 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/expressions/temporal.rst
--rw-r--r--   0     1001      123       98 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/expressions/window.rst
--rw-r--r--   0     1001      123      694 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/functions.rst
--rw-r--r--   0     1001      123      405 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/index.rst
--rw-r--r--   0     1001      123     1294 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/io.rst
--rw-r--r--   0     1001      123      277 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/lazyframe/aggregation.rst
--rw-r--r--   0     1001      123      179 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/lazyframe/attributes.rst
--rw-r--r--   0     1001      123      146 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/lazyframe/descriptive.rst
--rw-r--r--   0     1001      123      497 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/lazyframe/groupby.rst
--rw-r--r--   0     1001      123      354 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/lazyframe/index.rst
--rw-r--r--   0     1001      123      455 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/lazyframe/miscellaneous.rst
--rw-r--r--   0     1001      123     1013 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/lazyframe/modify_select.rst
--rw-r--r--   0     1001      123     3279 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/selectors.rst
--rw-r--r--   0     1001      123      358 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/series/aggregation.rst
--rw-r--r--   0     1001      123      277 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/series/array.rst
--rw-r--r--   0     1001      123      257 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/series/attributes.rst
--rw-r--r--   0     1001      123      321 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/series/binary.rst
--rw-r--r--   0     1001      123      117 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/series/boolean.rst
--rw-r--r--   0     1001      123      241 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/series/categories.rst
--rw-r--r--   0     1001      123     1103 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/series/computation.rst
--rw-r--r--   0     1001      123      744 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/series/descriptive.rst
--rw-r--r--   0     1001      123      240 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/series/export.rst
--rw-r--r--   0     1001      123      437 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/series/index.rst
--rw-r--r--   0     1001      123      894 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/series/list.rst
--rw-r--r--   0     1001      123      236 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/series/miscellaneous.rst
--rw-r--r--   0     1001      123     1077 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/series/modify_select.rst
--rw-r--r--   0     1001      123     1049 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/series/string.rst
--rw-r--r--   0     1001      123      421 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/series/struct.rst
--rw-r--r--   0     1001      123     1247 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/series/temporal.rst
--rw-r--r--   0     1001      123      503 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/sql.rst
--rw-r--r--   0     1001      123     8067 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/testing.rst
--rw-r--r--   0     1001      123      168 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/docs/source/reference/utils.rst
--rw-r--r--   0     1001      123     6370 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/__init__.py
--rw-r--r--   0     1001      123      280 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/_reexport.py
--rw-r--r--   0     1001      123    13229 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/api.py
--rw-r--r--   0     1001      123    29652 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/config.py
--rw-r--r--   0     1001      123    28090 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/convert.py
--rw-r--r--   0     1001      123       77 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/dataframe/__init__.py
--rw-r--r--   0     1001      123     5227 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/dataframe/_html.py
--rw-r--r--   0     1001      123   323980 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/dataframe/frame.py
--rw-r--r--   0     1001      123    41618 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/dataframe/groupby.py
--rw-r--r--   0     1001      123     2692 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/datatypes/__init__.py
--rw-r--r--   0     1001      123    17874 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/datatypes/classes.py
--rw-r--r--   0     1001      123     1690 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/datatypes/constants.py
--rw-r--r--   0     1001      123     4701 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/datatypes/constructor.py
--rw-r--r--   0     1001      123    15446 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/datatypes/convert.py
--rw-r--r--   0     1001      123     7358 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/dependencies.py
--rw-r--r--   0     1001      123     3792 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/exceptions.py
--rw-r--r--   0     1001      123       61 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/expr/__init__.py
--rw-r--r--   0     1001      123     3020 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/expr/array.py
--rw-r--r--   0     1001      123    10330 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/expr/binary.py
--rw-r--r--   0     1001      123     1698 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/expr/categorical.py
--rw-r--r--   0     1001      123    80633 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/expr/datetime.py
--rw-r--r--   0     1001      123   319136 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/expr/expr.py
--rw-r--r--   0     1001      123    31956 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/expr/list.py
--rw-r--r--   0     1001      123     4683 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/expr/meta.py
--rw-r--r--   0     1001      123    60086 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/expr/string.py
--rw-r--r--   0     1001      123     5426 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/expr/struct.py
--rw-r--r--   0     1001      123     2126 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/functions/__init__.py
--rw-r--r--   0     1001      123    16430 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/functions/as_datatype.py
--rw-r--r--   0     1001      123    18732 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/functions/eager.py
--rw-r--r--   0     1001      123    72418 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/functions/lazy.py
--rw-r--r--   0     1001      123    20012 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/functions/range.py
--rw-r--r--   0     1001      123     6043 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/functions/repeat.py
--rw-r--r--   0     1001      123     6051 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/functions/whenthen.py
--rw-r--r--   0     1001      123      952 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/__init__.py
--rw-r--r--   0     1001      123     6364 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/_utils.py
--rw-r--r--   0     1001      123      861 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/avro.py
--rw-r--r--   0     1001      123      144 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/csv/__init__.py
--rw-r--r--   0     1001      123     1072 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/csv/_utils.py
--rw-r--r--   0     1001      123     4681 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/csv/batched_reader.py
--rw-r--r--   0     1001      123    35482 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/csv/functions.py
--rw-r--r--   0     1001      123     6428 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/database.py
--rw-r--r--   0     1001      123    11047 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/delta.py
--rw-r--r--   0     1001      123       75 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/excel/__init__.py
--rw-r--r--   0     1001      123    18338 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/excel/_write_utils.py
--rw-r--r--   0     1001      123     6355 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/excel/functions.py
--rw-r--r--   0     1001      123      142 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/ipc/__init__.py
--rw-r--r--   0     1001      123     1227 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/ipc/anonymous_scan.py
--rw-r--r--   0     1001      123     5804 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/ipc/functions.py
--rw-r--r--   0     1001      123      510 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/json.py
--rw-r--r--   0     1001      123     2215 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/ndjson.py
--rw-r--r--   0     1001      123      170 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/parquet/__init__.py
--rw-r--r--   0     1001      123     1259 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/parquet/anonymous_scan.py
--rw-r--r--   0     1001      123     7177 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/parquet/functions.py
--rw-r--r--   0     1001      123      136 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/pyarrow_dataset/__init__.py
--rw-r--r--   0     1001      123     2186 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/pyarrow_dataset/anonymous_scan.py
--rw-r--r--   0     1001      123     3601 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/io/pyarrow_dataset/functions.py
--rw-r--r--   0     1001      123       77 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/lazyframe/__init__.py
--rw-r--r--   0     1001      123   172003 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/lazyframe/frame.py
--rw-r--r--   0     1001      123    25094 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/lazyframe/groupby.py
--rw-r--r--   0     1001      123        0 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/py.typed
--rw-r--r--   0     1001      123    38494 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/selectors.py
--rw-r--r--   0     1001      123       69 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/series/__init__.py
--rw-r--r--   0     1001      123     1572 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/series/_numpy.py
--rw-r--r--   0     1001      123     2515 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/series/array.py
--rw-r--r--   0     1001      123     1913 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/series/binary.py
--rw-r--r--   0     1001      123     1692 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/series/categorical.py
--rw-r--r--   0     1001      123    54653 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/series/datetime.py
--rw-r--r--   0     1001      123    16940 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/series/list.py
--rw-r--r--   0     1001      123   170756 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/series/series.py
--rw-r--r--   0     1001      123    38879 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/series/string.py
--rw-r--r--   0     1001      123     2542 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/series/struct.py
--rw-r--r--   0     1001      123     5361 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/series/utils.py
--rw-r--r--   0     1001      123     7559 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/slice.py
--rw-r--r--   0     1001      123       75 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/sql/__init__.py
--rw-r--r--   0     1001      123    17286 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/sql/context.py
--rw-r--r--   0     1001      123     4793 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/string_cache.py
--rw-r--r--   0     1001      123      362 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/testing/__init__.py
--rw-r--r--   0     1001      123     1060 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/testing/_private.py
--rw-r--r--   0     1001      123    16964 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/testing/asserts.py
--rw-r--r--   0     1001      123      898 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/testing/parametric/__init__.py
--rw-r--r--   0     1001      123    28187 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/testing/parametric/primitives.py
--rw-r--r--   0     1001      123     3371 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/testing/parametric/profiles.py
--rw-r--r--   0     1001      123    13165 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/testing/parametric/strategies.py
--rw-r--r--   0     1001      123     6460 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/type_aliases.py
--rw-r--r--   0     1001      123     1157 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/utils/__init__.py
--rw-r--r--   0     1001      123    56946 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/utils/_construction.py
--rw-r--r--   0     1001      123     4937 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/utils/_parse_expr_input.py
--rw-r--r--   0     1001      123      647 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/utils/_scan.py
--rw-r--r--   0     1001      123      579 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/utils/_wrap.py
--rw-r--r--   0     1001      123      683 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/utils/build_info.py
--rw-r--r--   0     1001      123     8702 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/utils/convert.py
--rw-r--r--   0     1001      123     7199 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/utils/decorators.py
--rw-r--r--   0     1001      123     1660 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/utils/meta.py
--rw-r--r--   0     1001      123      514 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/utils/polars_version.py
--rw-r--r--   0     1001      123     2509 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/utils/show_versions.py
--rw-r--r--   0     1001      123    13340 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/polars/utils/various.py
--rw-r--r--   0     1001      123     5370 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/pyproject.toml
--rw-r--r--   0     1001      123      756 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/requirements-dev.txt
--rw-r--r--   0     1001      123       70 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/requirements-lint.txt
--rw-r--r--   0     1001      123     1610 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/scripts/check_stacklevels.py
--rw-r--r--   0     1001      123    10980 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/apply/dataframe.rs
--rw-r--r--   0     1001      123     6428 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/apply/lazy.rs
--rw-r--r--   0     1001      123     8535 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/apply/mod.rs
--rw-r--r--   0     1001      123    90654 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/apply/series.rs
--rw-r--r--   0     1001      123       32 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/arrow_interop/mod.rs
--rw-r--r--   0     1001      123     1306 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/arrow_interop/to_py.rs
--rw-r--r--   0     1001      123     3902 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/arrow_interop/to_rust.rs
--rw-r--r--   0     1001      123     5250 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/batched_csv.rs
--rw-r--r--   0     1001      123    49813 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/conversion.rs
--rw-r--r--   0     1001      123    46152 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/dataframe.rs
--rw-r--r--   0     1001      123     3950 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/datatypes.rs
--rw-r--r--   0     1001      123     3506 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/error.rs
--rw-r--r--   0     1001      123      570 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/expr/array.rs
--rw-r--r--   0     1001      123     2080 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/expr/binary.rs
--rw-r--r--   0     1001      123      274 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/expr/categorical.rs
--rw-r--r--   0     1001      123     6206 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/expr/datetime.rs
--rw-r--r--   0     1001      123    35096 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/expr/general.rs
--rw-r--r--   0     1001      123     4693 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/expr/list.rs
--rw-r--r--   0     1001      123     3152 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/expr/meta.rs
--rw-r--r--   0     1001      123      870 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/expr/mod.rs
--rw-r--r--   0     1001      123     8366 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/expr/string.rs
--rw-r--r--   0     1001      123      467 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/expr/struct.rs
--rw-r--r--   0     1001      123     9482 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/file.rs
--rw-r--r--   0     1001      123     2777 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/functions/eager.rs
--rw-r--r--   0     1001      123     1657 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/functions/io.rs
--rw-r--r--   0     1001      123    11595 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/functions/lazy.rs
--rw-r--r--   0     1001      123     1312 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/functions/meta.rs
--rw-r--r--   0     1001      123      217 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/functions/misc.rs
--rw-r--r--   0     1001      123      102 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/functions/mod.rs
--rw-r--r--   0     1001      123      689 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/functions/range.rs
--rw-r--r--   0     1001      123     1474 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/functions/whenthen.rs
--rw-r--r--   0     1001      123    28073 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/lazyframe.rs
--rw-r--r--   0     1001      123     2670 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/lazygroupby.rs
--rw-r--r--   0     1001      123     8553 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/lib.rs
--rw-r--r--   0     1001      123       47 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/object.rs
--rw-r--r--   0     1001      123     2989 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/on_startup.rs
--rw-r--r--   0     1001      123      122 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/prelude.rs
--rw-r--r--   0     1001      123      435 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/py_modules.rs
--rw-r--r--   0     1001      123     1964 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/series/aggregation.rs
--rw-r--r--   0     1001      123     5406 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/series/arithmetic.rs
--rw-r--r--   0     1001      123     5138 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/series/comparison.rs
--rw-r--r--   0     1001      123     9077 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/series/construction.rs
--rw-r--r--   0     1001      123     8971 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/series/export.rs
--rw-r--r--   0     1001      123    26606 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/series/mod.rs
--rw-r--r--   0     1001      123     4569 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/series/numpy_ufunc.rs
--rw-r--r--   0     1001      123     4046 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/series/set_at_idx.rs
--rw-r--r--   0     1001      123     1036 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/sql.rs
--rw-r--r--   0     1001      123     2335 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/src/utils.rs
--rw-r--r--   0     1001      123     6165 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/README.md
--rw-r--r--   0     1001      123     2189 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/benchmark/groupby-datagen.R
--rw-r--r--   0     1001      123     7963 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/benchmark/run_h2oai_benchmark.py
--rw-r--r--   0     1001      123     6530 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/benchmark/test_release.py
--rw-r--r--   0     1001      123     4589 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/docs/run_doctest.py
--rw-r--r--   0     1001      123        0 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/parametric/__init__.py
--rw-r--r--   0     1001      123      179 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/parametric/conftest.py
--rw-r--r--   0     1001      123     3856 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/parametric/test_dataframe.py
--rw-r--r--   0     1001      123     2398 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/parametric/test_groupby_rolling.py
--rw-r--r--   0     1001      123     1692 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/parametric/test_lazyframe.py
--rw-r--r--   0     1001      123      976 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/parametric/test_lit.py
--rw-r--r--   0     1001      123     6853 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/parametric/test_series.py
--rw-r--r--   0     1001      123     8467 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/parametric/test_testing.py
--rw-r--r--   0     1001      123     1554 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/parametric/time_series/test_to_datetime.py
--rw-r--r--   0     1001      123        0 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/__init__.py
--rw-r--r--   0     1001      123     3382 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/conftest.py
--rw-r--r--   0     1001      123       86 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/datatypes/__init__.py
--rw-r--r--   0     1001      123     1285 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/datatypes/test_array.py
--rw-r--r--   0     1001      123      847 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/datatypes/test_binary.py
--rw-r--r--   0     1001      123     1420 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/datatypes/test_bool.py
--rw-r--r--   0     1001      123    13982 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/datatypes/test_categorical.py
--rw-r--r--   0     1001      123     5222 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/datatypes/test_decimal.py
--rw-r--r--   0     1001      123      549 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/datatypes/test_duration.py
--rw-r--r--   0     1001      123      423 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/datatypes/test_integer.py
--rw-r--r--   0     1001      123    14052 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/datatypes/test_list.py
--rw-r--r--   0     1001      123      284 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/datatypes/test_null.py
--rw-r--r--   0     1001      123     3028 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/datatypes/test_object.py
--rw-r--r--   0     1001      123    27697 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/datatypes/test_struct.py
--rw-r--r--   0     1001      123    87698 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/datatypes/test_temporal.py
--rw-r--r--   0     1001      123      418 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/datatypes/test_time.py
--rw-r--r--   0     1001      123        0 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/functions/__init__.py
--rw-r--r--   0     1001      123    13970 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/functions/test_as_datatype.py
--rw-r--r--   0     1001      123      480 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/functions/test_concat.py
--rw-r--r--   0     1001      123    15574 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/functions/test_functions.py
--rw-r--r--   0     1001      123    30418 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/functions/test_range.py
--rw-r--r--   0     1001      123     3847 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/functions/test_repeat.py
--rw-r--r--   0     1001      123      218 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/conftest.py
--rw-r--r--   0     1001      123       16 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/delta-table/.part-00000-e42312d7-60e5-454d-acbc-db192d220e73-c000.snappy.parquet.crc
--rw-r--r--   0     1001      123       16 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/delta-table/.part-00000-e4a999da-df45-4fb0-bdc4-d999fc0f58aa-c000.snappy.parquet.crc
--rw-r--r--   0     1001      123       16 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/delta-table/_delta_log/.00000000000000000000.json.crc
--rw-r--r--   0     1001      123       16 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/delta-table/_delta_log/.00000000000000000001.json.crc
--rw-r--r--   0     1001      123      905 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/delta-table/_delta_log/00000000000000000000.json
--rw-r--r--   0     1001      123      936 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/delta-table/_delta_log/00000000000000000001.json
--rw-r--r--   0     1001      123      972 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/delta-table/part-00000-e42312d7-60e5-454d-acbc-db192d220e73-c000.snappy.parquet
--rw-r--r--   0     1001      123      690 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/delta-table/part-00000-e4a999da-df45-4fb0-bdc4-d999fc0f58aa-c000.snappy.parquet
--rw-r--r--   0     1001      123        0 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/empty.csv
--rw-r--r--   0     1001      123     5959 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/example.xlsx
--rw-r--r--   0     1001      123      457 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/foods1.csv
--rw-r--r--   0     1001      123     2351 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/foods1.ipc
--rw-r--r--   0     1001      123     1713 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/foods1.ndjson
--rw-r--r--   0     1001      123     1427 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/foods1.parquet
--rw-r--r--   0     1001      123      455 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/foods2.csv
--rw-r--r--   0     1001      123     2351 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/foods2.ipc
--rw-r--r--   0     1001      123     1711 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/foods2.ndjson
--rw-r--r--   0     1001      123     1916 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/foods2.parquet
--rw-r--r--   0     1001      123      455 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/foods3.csv
--rw-r--r--   0     1001      123      457 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/foods4.csv
--rw-r--r--   0     1001      123      452 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/foods5.csv
--rw-r--r--   0     1001      123       49 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/gzipped.csv
--rw-r--r--   0     1001      123       57 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/small.csv
--rw-r--r--   0     1001      123      756 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/files/small.parquet
--rw-r--r--   0     1001      123     1884 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/test_avro.py
--rw-r--r--   0     1001      123    41164 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/test_csv.py
--rw-r--r--   0     1001      123     6271 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/test_database.py
--rw-r--r--   0     1001      123     6172 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/test_delta.py
--rw-r--r--   0     1001      123    11169 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/test_excel.py
--rw-r--r--   0     1001      123     5483 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/test_ipc.py
--rw-r--r--   0     1001      123     4389 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/test_json.py
--rw-r--r--   0     1001      123     7379 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/test_lazy_csv.py
--rw-r--r--   0     1001      123     2060 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/test_lazy_ipc.py
--rw-r--r--   0     1001      123     2867 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/test_lazy_json.py
--rw-r--r--   0     1001      123    11145 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/test_lazy_parquet.py
--rw-r--r--   0     1001      123     2012 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/test_other.py
--rw-r--r--   0     1001      123    14157 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/test_parquet.py
--rw-r--r--   0     1001      123      612 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/test_pickle.py
--rw-r--r--   0     1001      123     3706 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/io/test_pyarrow_dataset.py
--rw-r--r--   0     1001      123      509 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/namespaces/__init__.py
--rw-r--r--   0     1001      123      589 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/namespaces/test_array.py
--rw-r--r--   0     1001      123     3218 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/namespaces/test_binary.py
--rw-r--r--   0     1001      123     2489 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/namespaces/test_categorical.py
--rw-r--r--   0     1001      123    23231 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/namespaces/test_datetime.py
--rw-r--r--   0     1001      123    15528 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/namespaces/test_list.py
--rw-r--r--   0     1001      123     2472 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/namespaces/test_meta.py
--rw-r--r--   0     1001      123    24050 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/namespaces/test_string.py
--rw-r--r--   0     1001      123    20819 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/namespaces/test_strptime.py
--rw-r--r--   0     1001      123      982 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/namespaces/test_struct.py
--rw-r--r--   0     1001      123       85 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/__init__.py
--rw-r--r--   0     1001      123     8008 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_aggregations.py
--rw-r--r--   0     1001      123    10613 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_apply.py
--rw-r--r--   0     1001      123     6896 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_arithmetic.py
--rw-r--r--   0     1001      123     4940 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_comparison.py
--rw-r--r--   0     1001      123     3275 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_drop.py
--rw-r--r--   0     1001      123     8813 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_explode.py
--rw-r--r--   0     1001      123     3664 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_filter.py
--rw-r--r--   0     1001      123     1801 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_folds.py
--rw-r--r--   0     1001      123    25037 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_groupby.py
--rw-r--r--   0     1001      123     7649 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_groupby_rolling.py
--rw-r--r--   0     1001      123     2983 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_is_in.py
--rw-r--r--   0     1001      123    18993 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_join.py
--rw-r--r--   0     1001      123    14952 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_join_asof.py
--rw-r--r--   0     1001      123      643 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_melt.py
--rw-r--r--   0     1001      123    10253 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_pivot.py
--rw-r--r--   0     1001      123     3187 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_random.py
--rw-r--r--   0     1001      123    24274 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_rolling.py
--rw-r--r--   0     1001      123     2389 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_select.py
--rw-r--r--   0     1001      123    20770 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_sort.py
--rw-r--r--   0     1001      123     7395 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_statistics.py
--rw-r--r--   0     1001      123     4130 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_transpose.py
--rw-r--r--   0     1001      123      771 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_unique.py
--rw-r--r--   0     1001      123    11644 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_window.py
--rw-r--r--   0     1001      123     5480 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/operations/test_with_columns.py
--rw-r--r--   0     1001      123        0 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/streaming/__init__.py
--rw-r--r--   0     1001      123      196 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/streaming/conftest.py
--rw-r--r--   0     1001      123      908 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/streaming/test_ooc.py
--rw-r--r--   0     1001      123    19789 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/streaming/test_streaming.py
--rw-r--r--   0     1001      123     4831 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_api.py
--rw-r--r--   0     1001      123     1969 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_arity.py
--rw-r--r--   0     1001      123    20397 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_cfg.py
--rw-r--r--   0     1001      123    43560 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_constructors.py
--rw-r--r--   0     1001      123      454 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_context.py
--rw-r--r--   0     1001      123     2626 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_cse.py
--rw-r--r--   0     1001      123     5191 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_datatypes.py
--rw-r--r--   0     1001      123   120452 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_df.py
--rw-r--r--   0     1001      123     2741 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_empty.py
--rw-r--r--   0     1001      123    19301 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_errors.py
--rw-r--r--   0     1001      123     2741 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_expr_multi_cols.py
--rw-r--r--   0     1001      123    33619 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_exprs.py
--rw-r--r--   0     1001      123     3516 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_fmt.py
--rw-r--r--   0     1001      123     3512 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_interchange.py
--rw-r--r--   0     1001      123    38530 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_interop.py
--rw-r--r--   0     1001      123    49654 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_lazy.py
--rw-r--r--   0     1001      123     2463 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_polars_import.py
--rw-r--r--   0     1001      123     4883 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_predicates.py
--rw-r--r--   0     1001      123     7572 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_projections.py
--rw-r--r--   0     1001      123    11551 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_queries.py
--rw-r--r--   0     1001      123     8100 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_rows.py
--rw-r--r--   0     1001      123    13961 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_schema.py
--rw-r--r--   0     1001      123    12341 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_selectors.py
--rw-r--r--   0     1001      123     4107 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_serde.py
--rw-r--r--   0     1001      123    82889 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_series.py
--rw-r--r--   0     1001      123      657 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_single.py
--rw-r--r--   0     1001      123    16616 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_sql.py
--rw-r--r--   0     1001      123    35314 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/test_testing.py
--rw-r--r--   0     1001      123       41 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/utils/__init__.py
--rw-r--r--   0     1001      123      306 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/utils/test_build_info.py
--rw-r--r--   0     1001      123     2855 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/utils/test_parse_expr_input.py
--rw-r--r--   0     1001      123      247 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/utils/test_show_versions.py
--rw-r--r--   0     1001      123     5026 2023-07-06 16:19:17.000000 polars_u64_idx-0.18.6/tests/unit/utils/test_utils.py
--rw-r--r--   0     1001      123    65129 2023-07-06 16:20:20.000000 polars_u64_idx-0.18.6/Cargo.lock
--rw-r--r--   0        0        0    14286 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.6/PKG-INFO
+-rw-r--r--   0        0        0     4397 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/LICENSE
+-rw-r--r--   0     1001      123      138 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/README.md
+-rw-r--r--   0     1001      123     2383 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/avro/mod.rs
+-rw-r--r--   0     1001      123     3608 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/avro/read.rs
+-rw-r--r--   0     1001      123     2622 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/avro/write.rs
+-rw-r--r--   0     1001      123     4505 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/cloud/adaptors.rs
+-rw-r--r--   0     1001      123     9506 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/cloud/glob.rs
+-rw-r--r--   0     1001      123     3089 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/cloud/mod.rs
+-rw-r--r--   0     1001      123    28829 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/buffer.rs
+-rw-r--r--   0     1001      123     1815 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/mod.rs
+-rw-r--r--   0     1001      123    19446 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/parser.rs
+-rw-r--r--   0     1001      123    22228 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/read.rs
+-rw-r--r--   0     1001      123    10847 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/read_impl/batched_mmap.rs
+-rw-r--r--   0     1001      123    13939 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/read_impl/batched_read.rs
+-rw-r--r--   0     1001      123    30724 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/read_impl/mod.rs
+-rw-r--r--   0     1001      123    11466 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/splitfields.rs
+-rw-r--r--   0     1001      123    24531 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/utils.rs
+-rw-r--r--   0     1001      123     2796 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/write.rs
+-rw-r--r--   0     1001      123    14759 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/write_impl.rs
+-rw-r--r--   0     1001      123      184 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/export.rs
+-rw-r--r--   0     1001      123     7586 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/ipc/ipc_file.rs
+-rw-r--r--   0     1001      123     9227 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/ipc/ipc_stream.rs
+-rw-r--r--   0     1001      123     3253 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/ipc/mmap.rs
+-rw-r--r--   0     1001      123      401 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/ipc/mod.rs
+-rw-r--r--   0     1001      123     8287 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/ipc/write.rs
+-rw-r--r--   0     1001      123     1471 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/ipc/write_async.rs
+-rw-r--r--   0     1001      123    11044 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/json/mod.rs
+-rw-r--r--   0     1001      123     4771 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/lib.rs
+-rw-r--r--   0     1001      123     1969 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/mmap.rs
+-rw-r--r--   0     1001      123     7228 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/ndjson/buffer.rs
+-rw-r--r--   0     1001      123    11979 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/ndjson/core.rs
+-rw-r--r--   0     1001      123       37 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/ndjson/mod.rs
+-rw-r--r--   0     1001      123      273 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/options.rs
+-rw-r--r--   0     1001      123     7360 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/parquet/async_impl.rs
+-rw-r--r--   0     1001      123     3093 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/parquet/mmap.rs
+-rw-r--r--   0     1001      123     3132 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/parquet/mod.rs
+-rw-r--r--   0     1001      123     4784 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/parquet/predicates.rs
+-rw-r--r--   0     1001      123     9623 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/parquet/read.rs
+-rw-r--r--   0     1001      123    17321 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/parquet/read_impl.rs
+-rw-r--r--   0     1001      123    10129 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/parquet/write.rs
+-rw-r--r--   0     1001      123     5334 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/partition.rs
+-rw-r--r--   0     1001      123     1455 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/predicates.rs
+-rw-r--r--   0     1001      123      621 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/prelude.rs
+-rw-r--r--   0     1001      123      417 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/tests.rs
+-rw-r--r--   0     1001      123     4374 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-io/src/utils.rs
+-rw-r--r--   0        0        0     1592 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/LICENSE
+-rw-r--r--   0     1001      123      144 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/README.md
+-rw-r--r--   0     1001      123     1975 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/array/default_arrays.rs
+-rw-r--r--   0     1001      123     1791 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/array/fixed_size_list.rs
+-rw-r--r--   0     1001      123     3773 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/array/get.rs
+-rw-r--r--   0     1001      123     6664 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/array/list.rs
+-rw-r--r--   0     1001      123     8165 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/array/mod.rs
+-rw-r--r--   0     1001      123      878 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/array/null.rs
+-rw-r--r--   0     1001      123     1125 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/array/slice.rs
+-rw-r--r--   0     1001      123     2253 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/array/utf8.rs
+-rw-r--r--   0     1001      123     2294 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/bit_util.rs
+-rw-r--r--   0     1001      123       17 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/bitmap/mod.rs
+-rw-r--r--   0     1001      123      819 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/bitmap/mutable.rs
+-rw-r--r--   0     1001      123      370 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/add.rs
+-rw-r--r--   0     1001      123     2181 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/commutative.rs
+-rw-r--r--   0     1001      123     1482 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/div.rs
+-rw-r--r--   0     1001      123     1028 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/mod.rs
+-rw-r--r--   0     1001      123     1177 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/mul.rs
+-rw-r--r--   0     1001      123      508 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/sub.rs
+-rw-r--r--   0     1001      123       51 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/arithmetics/mod.rs
+-rw-r--r--   0     1001      123        1 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/arity.rs
+-rw-r--r--   0     1001      123      727 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/bitwise.rs
+-rw-r--r--   0     1001      123     1206 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/cast.rs
+-rw-r--r--   0     1001      123     3964 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/decimal.rs
+-rw-r--r--   0     1001      123     1250 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/mod.rs
+-rw-r--r--   0     1001      123      391 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/take/bitmap.rs
+-rw-r--r--   0     1001      123     2767 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/take/boolean.rs
+-rw-r--r--   0     1001      123     3489 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/take/fixed_size_list.rs
+-rw-r--r--   0     1001      123    25290 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/take/mod.rs
+-rw-r--r--   0     1001      123      797 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/tile.rs
+-rw-r--r--   0     1001      123     1102 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/conversion.rs
+-rw-r--r--   0     1001      123     1609 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/data_types.rs
+-rw-r--r--   0     1001      123       25 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/error.rs
+-rw-r--r--   0     1001      123       28 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/export.rs
+-rw-r--r--   0     1001      123       26 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/floats/mod.rs
+-rw-r--r--   0     1001      123     2066 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/floats/ord.rs
+-rw-r--r--   0     1001      123     1273 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/index.rs
+-rw-r--r--   0     1001      123      984 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/is_valid.rs
+-rw-r--r--   0     1001      123     4783 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/agg_mean.rs
+-rw-r--r--   0     1001      123     1074 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/comparison.rs
+-rw-r--r--   0     1001      123     1068 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/concatenate.rs
+-rw-r--r--   0     1001      123     5153 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/ewm/average.rs
+-rw-r--r--   0     1001      123     1808 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/ewm/mod.rs
+-rw-r--r--   0     1001      123    25065 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/ewm/variance.rs
+-rw-r--r--   0     1001      123     1406 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/float.rs
+-rw-r--r--   0     1001      123     4908 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/list.rs
+-rw-r--r--   0     1001      123     1885 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/list_bytes_iter.rs
+-rw-r--r--   0     1001      123     9783 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/mod.rs
+-rw-r--r--   0     1001      123     3923 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/mod.rs
+-rw-r--r--   0     1001      123     2019 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/mean.rs
+-rw-r--r--   0     1001      123    16187 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/min_max.rs
+-rw-r--r--   0     1001      123     3848 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/mod.rs
+-rw-r--r--   0     1001      123    13521 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/quantile.rs
+-rw-r--r--   0     1001      123     5684 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/sum.rs
+-rw-r--r--   0     1001      123     7807 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/variance.rs
+-rw-r--r--   0     1001      123     1879 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/nulls/mean.rs
+-rw-r--r--   0     1001      123    14722 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/nulls/min_max.rs
+-rw-r--r--   0     1001      123    10055 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/nulls/mod.rs
+-rw-r--r--   0     1001      123    11643 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/nulls/quantile.rs
+-rw-r--r--   0     1001      123     4821 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/nulls/sum.rs
+-rw-r--r--   0     1001      123     6856 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/nulls/variance.rs
+-rw-r--r--   0     1001      123     8109 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/window.rs
+-rw-r--r--   0     1001      123     4753 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/set.rs
+-rw-r--r--   0     1001      123     4529 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/sort_partition.rs
+-rw-r--r--   0     1001      123     2948 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/sorted_join/inner.rs
+-rw-r--r--   0     1001      123     5974 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/sorted_join/left.rs
+-rw-r--r--   0     1001      123      231 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/sorted_join/mod.rs
+-rw-r--r--   0     1001      123      842 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/string.rs
+-rw-r--r--   0     1001      123     2310 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/take_agg/boolean.rs
+-rw-r--r--   0     1001      123     4315 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/take_agg/mod.rs
+-rw-r--r--   0     1001      123     2606 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/take_agg/var.rs
+-rw-r--r--   0     1001      123     3658 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/time.rs
+-rw-r--r--   0     1001      123      341 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/lib.rs
+-rw-r--r--   0     1001      123      496 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/prelude.rs
+-rw-r--r--   0     1001      123      534 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/slice.rs
+-rw-r--r--   0     1001      123      183 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/time_zone.rs
+-rw-r--r--   0     1001      123      998 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/trusted_len/boolean.rs
+-rw-r--r--   0     1001      123     2821 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/trusted_len/mod.rs
+-rw-r--r--   0     1001      123     2054 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/trusted_len/push_unchecked.rs
+-rw-r--r--   0     1001      123      158 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/trusted_len/rev.rs
+-rw-r--r--   0     1001      123     5233 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/utils.rs
+-rw-r--r--   0        0        0      827 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.7/local_dependencies/polars-algo/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-algo/LICENSE
+-rw-r--r--   0     1001      123      142 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-algo/README.md
+-rw-r--r--   0     1001      123     3503 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-algo/src/algo.rs
+-rw-r--r--   0     1001      123       88 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-algo/src/lib.rs
+-rw-r--r--   0     1001      123       21 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-algo/src/prelude.rs
+-rw-r--r--   0        0        0    10781 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.7/local_dependencies/polars/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/LICENSE
+-rw-r--r--   0     1001      123     3124 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/Makefile
+-rw-r--r--   0     1001      123      215 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/build.rs
+-rw-r--r--   0     1001      123       78 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/clippy.toml
+-rw-r--r--   0     1001      123    17620 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/src/docs/eager.rs
+-rw-r--r--   0     1001      123     8822 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/src/docs/lazy.rs
+-rw-r--r--   0     1001      123       50 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/src/docs/mod.rs
+-rw-r--r--   0     1001      123     3806 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/src/docs/performance.rs
+-rw-r--r--   0     1001      123       59 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/src/export.rs
+-rw-r--r--   0     1001      123    19848 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/src/lib.rs
+-rw-r--r--   0     1001      123      387 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/src/prelude.rs
+-rw-r--r--   0     1001      123       54 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/src/sql.rs
+-rw-r--r--   0     1001      123     4243 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/core/date_like.rs
+-rw-r--r--   0     1001      123     2401 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/core/groupby.rs
+-rw-r--r--   0     1001      123    17838 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/core/joins.rs
+-rw-r--r--   0     1001      123      545 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/core/list.rs
+-rw-r--r--   0     1001      123      198 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/core/mod.rs
+-rw-r--r--   0     1001      123       24 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/core/ops/mod.rs
+-rw-r--r--   0     1001      123      449 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/core/ops/take.rs
+-rw-r--r--   0     1001      123     6259 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/core/pivot.rs
+-rw-r--r--   0     1001      123     1102 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/core/random.rs
+-rw-r--r--   0     1001      123    11096 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/core/rolling_window.rs
+-rw-r--r--   0     1001      123     1093 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/core/series.rs
+-rw-r--r--   0     1001      123      370 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/core/utils.rs
+-rw-r--r--   0     1001      123    30377 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/io/csv.rs
+-rw-r--r--   0     1001      123     4500 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/io/ipc_stream.rs
+-rw-r--r--   0     1001      123     6972 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/io/json.rs
+-rw-r--r--   0     1001      123      378 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/io/mod.rs
+-rw-r--r--   0     1001      123      531 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/io/parquet.rs
+-rw-r--r--   0     1001      123     1530 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/joins.rs
+-rw-r--r--   0     1001      123     2452 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/aggregation.rs
+-rw-r--r--   0     1001      123      839 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/cse.rs
+-rw-r--r--   0     1001      123      500 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/explodes.rs
+-rw-r--r--   0     1001      123     2281 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/expressions/apply.rs
+-rw-r--r--   0     1001      123    10351 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/expressions/arity.rs
+-rw-r--r--   0     1001      123     1065 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/expressions/expand.rs
+-rw-r--r--   0     1001      123     1008 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/expressions/filter.rs
+-rw-r--r--   0     1001      123      428 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/expressions/is_in.rs
+-rw-r--r--   0     1001      123      121 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/expressions/mod.rs
+-rw-r--r--   0     1001      123      659 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/expressions/slice.rs
+-rw-r--r--   0     1001      123    10647 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/expressions/window.rs
+-rw-r--r--   0     1001      123      584 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/folds.rs
+-rw-r--r--   0     1001      123      557 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/functions.rs
+-rw-r--r--   0     1001      123     4482 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/groupby.rs
+-rw-r--r--   0     1001      123     1681 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/groupby_dynamic.rs
+-rw-r--r--   0     1001      123      691 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/mod.rs
+-rw-r--r--   0     1001      123     5710 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/predicate_queries.rs
+-rw-r--r--   0     1001      123     4482 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/projection_queries.rs
+-rw-r--r--   0     1001      123     6585 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/queries.rs
+-rw-r--r--   0     1001      123      151 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/main.rs
+-rw-r--r--   0     1001      123    12591 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/schema.rs
+-rw-r--r--   0     1001      123     1899 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/time/date_range.rs
+-rw-r--r--   0     1001      123       16 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/time/mod.rs
+-rw-r--r--   0        0        0     6330 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/LICENSE
+-rw-r--r--   0     1001      123      358 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/README.md
+-rw-r--r--   0     1001      123     1796 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/dot.rs
+-rw-r--r--   0     1001      123     4479 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/dsl/eval.rs
+-rw-r--r--   0     1001      123     7115 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/dsl/functions.rs
+-rw-r--r--   0     1001      123      164 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/dsl/into.rs
+-rw-r--r--   0     1001      123     6756 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/dsl/list.rs
+-rw-r--r--   0     1001      123     2899 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/dsl/mod.rs
+-rw-r--r--   0     1001      123     1182 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/frame/anonymous_scan.rs
+-rw-r--r--   0     1001      123     9285 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/frame/csv.rs
+-rw-r--r--   0     1001      123      476 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/frame/err.rs
+-rw-r--r--   0     1001      123     4368 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/frame/file_list_reader.rs
+-rw-r--r--   0     1001      123     2231 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/frame/ipc.rs
+-rw-r--r--   0     1001      123    48879 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/frame/mod.rs
+-rw-r--r--   0     1001      123     3382 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/frame/ndjson.rs
+-rw-r--r--   0     1001      123     2734 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/frame/parquet.rs
+-rw-r--r--   0     1001      123     2892 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/frame/pivot.rs
+-rw-r--r--   0     1001      123      459 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/frame/python.rs
+-rw-r--r--   0     1001      123     6374 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/lib.rs
+-rw-r--r--   0     1001      123     1049 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/cache.rs
+-rw-r--r--   0     1001      123      776 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/executor.rs
+-rw-r--r--   0     1001      123      670 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/ext_context.rs
+-rw-r--r--   0     1001      123     1555 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/filter.rs
+-rw-r--r--   0     1001      123     3986 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/groupby.rs
+-rw-r--r--   0     1001      123     4125 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_dynamic.rs
+-rw-r--r--   0     1001      123    13599 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_partitioned.rs
+-rw-r--r--   0     1001      123     4883 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_rolling.rs
+-rw-r--r--   0     1001      123     5859 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/join.rs
+-rw-r--r--   0     1001      123     6753 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/mod.rs
+-rw-r--r--   0     1001      123     2050 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/projection.rs
+-rw-r--r--   0     1001      123     1761 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/python_scan.rs
+-rw-r--r--   0     1001      123     2971 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/scan/csv.rs
+-rw-r--r--   0     1001      123     2085 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/scan/ipc.rs
+-rw-r--r--   0     1001      123     4353 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/scan/mod.rs
+-rw-r--r--   0     1001      123     1209 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/scan/ndjson.rs
+-rw-r--r--   0     1001      123     2650 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/scan/parquet.rs
+-rw-r--r--   0     1001      123      548 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/slice.rs
+-rw-r--r--   0     1001      123     2235 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/sort.rs
+-rw-r--r--   0     1001      123     2015 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/stack.rs
+-rw-r--r--   0     1001      123      663 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/udf.rs
+-rw-r--r--   0     1001      123     4041 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/union.rs
+-rw-r--r--   0     1001      123      838 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/unique.rs
+-rw-r--r--   0     1001      123     1335 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/exotic.rs
+-rw-r--r--   0     1001      123    21959 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/aggregation.rs
+-rw-r--r--   0     1001      123     2689 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/alias.rs
+-rw-r--r--   0     1001      123    18581 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/apply.rs
+-rw-r--r--   0     1001      123    17674 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/binary.rs
+-rw-r--r--   0     1001      123     2583 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/cache.rs
+-rw-r--r--   0     1001      123     3153 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/cast.rs
+-rw-r--r--   0     1001      123     6326 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/column.rs
+-rw-r--r--   0     1001      123     1996 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/count.rs
+-rw-r--r--   0     1001      123     5809 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/filter.rs
+-rw-r--r--   0     1001      123     4131 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/group_iter.rs
+-rw-r--r--   0     1001      123     5304 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/literal.rs
+-rw-r--r--   0     1001      123    23566 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/mod.rs
+-rw-r--r--   0     1001      123    10091 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/slice.rs
+-rw-r--r--   0     1001      123     4332 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/sort.rs
+-rw-r--r--   0     1001      123    13549 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/sortby.rs
+-rw-r--r--   0     1001      123     8331 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/take.rs
+-rw-r--r--   0     1001      123    14360 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/ternary.rs
+-rw-r--r--   0     1001      123    31970 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/window.rs
+-rw-r--r--   0     1001      123     2039 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/file_cache.rs
+-rw-r--r--   0     1001      123      414 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/mod.rs
+-rw-r--r--   0     1001      123     2046 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/node_timer.rs
+-rw-r--r--   0     1001      123    24174 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/planner/expr.rs
+-rw-r--r--   0     1001      123    19892 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/planner/lp.rs
+-rw-r--r--   0     1001      123       87 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/planner/mod.rs
+-rw-r--r--   0     1001      123    10203 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/state.rs
+-rw-r--r--   0     1001      123     2787 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/streaming/checks.rs
+-rw-r--r--   0     1001      123     9280 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/streaming/construct_pipeline.rs
+-rw-r--r--   0     1001      123    17011 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/streaming/convert_alp.rs
+-rw-r--r--   0     1001      123      116 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/streaming/mod.rs
+-rw-r--r--   0     1001      123     5827 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/streaming/tree.rs
+-rw-r--r--   0     1001      123      722 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/prelude.rs
+-rw-r--r--   0     1001      123    15189 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/aggregations.rs
+-rw-r--r--   0     1001      123     2339 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/arity.rs
+-rw-r--r--   0     1001      123     7224 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/cse.rs
+-rw-r--r--   0     1001      123    12736 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/io.rs
+-rw-r--r--   0     1001      123     4166 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/logical.rs
+-rw-r--r--   0     1001      123     4273 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/mod.rs
+-rw-r--r--   0     1001      123    15027 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/optimization_checks.rs
+-rw-r--r--   0     1001      123     6739 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/predicate_queries.rs
+-rw-r--r--   0     1001      123     3153 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/projection_queries.rs
+-rw-r--r--   0     1001      123    48161 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/queries.rs
+-rw-r--r--   0     1001      123     9970 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/streaming.rs
+-rw-r--r--   0     1001      123     2904 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/tpch.rs
+-rw-r--r--   0     1001      123      717 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/utils.rs
+-rw-r--r--   0        0        0     3591 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/LICENSE
+-rw-r--r--   0     1001      123      132 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/README.md
+-rw-r--r--   0     1001      123     2382 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/array/min_max.rs
+-rw-r--r--   0     1001      123      267 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/array/mod.rs
+-rw-r--r--   0     1001      123     1512 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/array/namespace.rs
+-rw-r--r--   0     1001      123     4108 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/array/sum_mean.rs
+-rw-r--r--   0     1001      123      234 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/binary/mod.rs
+-rw-r--r--   0     1001      123     3549 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/binary/namespace.rs
+-rw-r--r--   0     1001      123    11023 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/interpolate.rs
+-rw-r--r--   0     1001      123     1930 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/list/any_all.rs
+-rw-r--r--   0     1001      123     1687 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/list/count.rs
+-rw-r--r--   0     1001      123     2419 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/list/hash.rs
+-rw-r--r--   0     1001      123     7861 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/list/min_max.rs
+-rw-r--r--   0     1001      123      644 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/list/mod.rs
+-rw-r--r--   0     1001      123    19916 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/list/namespace.rs
+-rw-r--r--   0     1001      123     9376 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/list/sets.rs
+-rw-r--r--   0     1001      123     7633 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/list/sum_mean.rs
+-rw-r--r--   0     1001      123     2435 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/list/to_struct.rs
+-rw-r--r--   0     1001      123      545 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/mod.rs
+-rw-r--r--   0     1001      123     9452 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/nan_propagating_aggregate.rs
+-rw-r--r--   0     1001      123     6795 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/set.rs
+-rw-r--r--   0     1001      123     8781 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/strings/case.rs
+-rw-r--r--   0     1001      123     8593 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/strings/json_path.rs
+-rw-r--r--   0     1001      123     2345 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/strings/justify.rs
+-rw-r--r--   0     1001      123      514 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/strings/mod.rs
+-rw-r--r--   0     1001      123    14951 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/strings/namespace.rs
+-rw-r--r--   0     1001      123     4053 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/strings/replace.rs
+-rw-r--r--   0     1001      123      439 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/sum.rs
+-rw-r--r--   0     1001      123     2486 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/top_k.rs
+-rw-r--r--   0     1001      123     7727 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/frame/join/merge_sorted.rs
+-rw-r--r--   0     1001      123    18232 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/frame/join/mod.rs
+-rw-r--r--   0     1001      123     4291 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/frame/mod.rs
+-rw-r--r--   0     1001      123    10257 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/frame/pivot/mod.rs
+-rw-r--r--   0     1001      123    13486 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/frame/pivot/positioning.rs
+-rw-r--r--   0     1001      123      237 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/lib.rs
+-rw-r--r--   0     1001      123      290 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/prelude.rs
+-rw-r--r--   0     1001      123       25 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/mod.rs
+-rw-r--r--   0     1001      123     9623 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/approx_algo/hyperloglogplus.rs
+-rw-r--r--   0     1001      123      118 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/approx_algo/mod.rs
+-rw-r--r--   0     1001      123     2016 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/approx_unique.rs
+-rw-r--r--   0     1001      123    11866 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/arg_min_max.rs
+-rw-r--r--   0     1001      123     5156 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/cut.rs
+-rw-r--r--   0     1001      123     3688 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/floor_divide.rs
+-rw-r--r--   0     1001      123     5245 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/fused.rs
+-rw-r--r--   0     1001      123     3423 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/is_first.rs
+-rw-r--r--   0     1001      123     2975 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/is_unique.rs
+-rw-r--r--   0     1001      123     3626 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/log.rs
+-rw-r--r--   0     1001      123     1341 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/mod.rs
+-rw-r--r--   0     1001      123     1342 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/rle.rs
+-rw-r--r--   0     1001      123     1769 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/rolling.rs
+-rw-r--r--   0     1001      123     7642 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/search_sorted.rs
+-rw-r--r--   0     1001      123     2603 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/to_dummies.rs
+-rw-r--r--   0     1001      123     3039 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/various.rs
+-rw-r--r--   0        0        0     5449 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/LICENSE
+-rw-r--r--   0     1001      123       45 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/constants.rs
+-rw-r--r--   0     1001      123    16258 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dot.rs
+-rw-r--r--   0     1001      123     4789 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/arithmetic.rs
+-rw-r--r--   0     1001      123     3992 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/arity.rs
+-rw-r--r--   0     1001      123     1278 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/array.rs
+-rw-r--r--   0     1001      123      935 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/binary.rs
+-rw-r--r--   0     1001      123      650 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/cat.rs
+-rw-r--r--   0     1001      123    10729 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/dt.rs
+-rw-r--r--   0     1001      123     9542 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/expr.rs
+-rw-r--r--   0     1001      123     8359 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/expr_dyn_fn.rs
+-rw-r--r--   0     1001      123      753 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/from.rs
+-rw-r--r--   0     1001      123       85 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/abs.rs
+-rw-r--r--   0     1001      123     1431 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/arg_where.rs
+-rw-r--r--   0     1001      123     1074 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/array.rs
+-rw-r--r--   0     1001      123     1327 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/binary.rs
+-rw-r--r--   0     1001      123     4221 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/boolean.rs
+-rw-r--r--   0     1001      123     1910 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/bounds.rs
+-rw-r--r--   0     1001      123     1216 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/cat.rs
+-rw-r--r--   0     1001      123      344 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/clip.rs
+-rw-r--r--   0     1001      123      257 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/concat.rs
+-rw-r--r--   0     1001      123     6125 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/correlation.rs
+-rw-r--r--   0     1001      123     1593 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/cum.rs
+-rw-r--r--   0     1001      123    11615 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/datetime.rs
+-rw-r--r--   0     1001      123      782 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/dispatch.rs
+-rw-r--r--   0     1001      123     2567 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/fill_null.rs
+-rw-r--r--   0     1001      123      992 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/fused.rs
+-rw-r--r--   0     1001      123     8997 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/list.rs
+-rw-r--r--   0     1001      123      581 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/log.rs
+-rw-r--r--   0     1001      123    25570 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/mod.rs
+-rw-r--r--   0     1001      123      462 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/nan.rs
+-rw-r--r--   0     1001      123     3132 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/pow.rs
+-rw-r--r--   0     1001      123     1410 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/random.rs
+-rw-r--r--   0     1001      123     5150 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/range.rs
+-rw-r--r--   0     1001      123      152 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/rolling.rs
+-rw-r--r--   0     1001      123      260 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/round.rs
+-rw-r--r--   0     1001      123      200 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/row_hash.rs
+-rw-r--r--   0     1001      123    19613 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/schema.rs
+-rw-r--r--   0     1001      123      306 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/search_sorted.rs
+-rw-r--r--   0     1001      123     3812 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/shift_and_fill.rs
+-rw-r--r--   0     1001      123     1517 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/shrink_type.rs
+-rw-r--r--   0     1001      123      972 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/sign.rs
+-rw-r--r--   0     1001      123    22249 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/strings.rs
+-rw-r--r--   0     1001      123     1017 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/struct_.rs
+-rw-r--r--   0     1001      123     8934 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/temporal.rs
+-rw-r--r--   0     1001      123     6112 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/trigonometry.rs
+-rw-r--r--   0     1001      123      170 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/unique.rs
+-rw-r--r--   0     1001      123     1155 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/arity.rs
+-rw-r--r--   0     1001      123      611 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/coerce.rs
+-rw-r--r--   0     1001      123     2717 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/concat.rs
+-rw-r--r--   0     1001      123     4525 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/correlation.rs
+-rw-r--r--   0     1001      123     8987 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/horizontal.rs
+-rw-r--r--   0     1001      123     1045 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/index.rs
+-rw-r--r--   0     1001      123      968 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/mod.rs
+-rw-r--r--   0     1001      123     4129 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/range.rs
+-rw-r--r--   0     1001      123     1308 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/selectors.rs
+-rw-r--r--   0     1001      123     1973 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/syntactic_sugar.rs
+-rw-r--r--   0     1001      123    11328 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/temporal.rs
+-rw-r--r--   0     1001      123    12282 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/list.rs
+-rw-r--r--   0     1001      123     4501 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/meta.rs
+-rw-r--r--   0     1001      123    61521 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/mod.rs
+-rw-r--r--   0     1001      123       40 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/names.rs
+-rw-r--r--   0     1001      123     2658 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/options.rs
+-rw-r--r--   0     1001      123     7181 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/python_udf.rs
+-rw-r--r--   0     1001      123     1432 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/random.rs
+-rw-r--r--   0     1001      123     1068 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/selector.rs
+-rw-r--r--   0     1001      123    17626 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/string.rs
+-rw-r--r--   0     1001      123     2715 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/struct_.rs
+-rw-r--r--   0     1001      123       38 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/frame/mod.rs
+-rw-r--r--   0     1001      123      933 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/frame/opt_state.rs
+-rw-r--r--   0     1001      123      466 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/global.rs
+-rw-r--r--   0     1001      123      175 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/lib.rs
+-rw-r--r--   0     1001      123    10651 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/aexpr/mod.rs
+-rw-r--r--   0     1001      123    11920 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/aexpr/schema.rs
+-rw-r--r--   0     1001      123    21934 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/alp.rs
+-rw-r--r--   0     1001      123     1622 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/anonymous_scan.rs
+-rw-r--r--   0     1001      123     1428 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/apply.rs
+-rw-r--r--   0     1001      123    26994 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/builder.rs
+-rw-r--r--   0     1001      123    28379 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/conversion.rs
+-rw-r--r--   0     1001      123      301 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/debug.rs
+-rw-r--r--   0     1001      123     1518 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/file_scan.rs
+-rw-r--r--   0     1001      123    14307 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/format.rs
+-rw-r--r--   0     1001      123      895 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/functions/drop.rs
+-rw-r--r--   0     1001      123      137 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/functions/explode.rs
+-rw-r--r--   0     1001      123     1169 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/functions/merge_sorted.rs
+-rw-r--r--   0     1001      123    13743 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/functions/mod.rs
+-rw-r--r--   0     1001      123     1031 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/functions/python_udf.rs
+-rw-r--r--   0     1001      123     1330 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/functions/rename.rs
+-rw-r--r--   0     1001      123    10157 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/iterator.rs
+-rw-r--r--   0     1001      123    10559 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/lit.rs
+-rw-r--r--   0     1001      123     7665 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/mod.rs
+-rw-r--r--   0     1001      123     7416 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/cache_states.rs
+-rw-r--r--   0     1001      123    13628 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/cse.rs
+-rw-r--r--   0     1001      123     2100 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/delay_rechunk.rs
+-rw-r--r--   0     1001      123     3236 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/drop_nulls.rs
+-rw-r--r--   0     1001      123     4663 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/fast_projection.rs
+-rw-r--r--   0     1001      123     9013 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/file_caching.rs
+-rw-r--r--   0     1001      123     1556 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/flatten_union.rs
+-rw-r--r--   0     1001      123     6017 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/fused.rs
+-rw-r--r--   0     1001      123     6778 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/mod.rs
+-rw-r--r--   0     1001      123     1222 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/keys.rs
+-rw-r--r--   0     1001      123    27692 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/mod.rs
+-rw-r--r--   0     1001      123     2571 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/rename.rs
+-rw-r--r--   0     1001      123    16171 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/utils.rs
+-rw-r--r--   0     1001      123     1755 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/functions/melt.rs
+-rw-r--r--   0     1001      123     3930 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/functions/mod.rs
+-rw-r--r--   0     1001      123     1799 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/generic.rs
+-rw-r--r--   0     1001      123     3269 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/groupby.rs
+-rw-r--r--   0     1001      123     2638 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/hstack.rs
+-rw-r--r--   0     1001      123    15874 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/joins.rs
+-rw-r--r--   0     1001      123    25235 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/mod.rs
+-rw-r--r--   0     1001      123     3707 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/projection.rs
+-rw-r--r--   0     1001      123     2639 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/rename.rs
+-rw-r--r--   0     1001      123     3509 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/semi_anti_join.rs
+-rw-r--r--   0     1001      123    27269 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/simplify_expr.rs
+-rw-r--r--   0     1001      123     3496 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/slice_pushdown_expr.rs
+-rw-r--r--   0     1001      123    12611 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/slice_pushdown_lp.rs
+-rw-r--r--   0     1001      123     4181 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/stack_opt.rs
+-rw-r--r--   0     1001      123     9796 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/type_coercion/binary.rs
+-rw-r--r--   0     1001      123    20344 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/type_coercion/mod.rs
+-rw-r--r--   0     1001      123     9748 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/options.rs
+-rw-r--r--   0     1001      123    20501 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/projection.rs
+-rw-r--r--   0     1001      123     6178 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/pyarrow.rs
+-rw-r--r--   0     1001      123    12286 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/schema.rs
+-rw-r--r--   0     1001      123     6681 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/tree_format.rs
+-rw-r--r--   0     1001      123     3544 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/visitor/expr.rs
+-rw-r--r--   0     1001      123      930 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/visitor/mod.rs
+-rw-r--r--   0     1001      123     4440 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/visitor/visitors.rs
+-rw-r--r--   0     1001      123      832 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/prelude.rs
+-rw-r--r--   0     1001      123    12335 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/utils.rs
+-rw-r--r--   0        0        0      894 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.7/local_dependencies/polars-error/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-error/LICENSE
+-rw-r--r--   0     1001      123      145 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-error/README.md
+-rw-r--r--   0     1001      123     7567 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-error/src/lib.rs
+-rw-r--r--   0        0        0     5484 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/LICENSE
+-rw-r--r--   0     1001      123      144 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/README.md
+-rw-r--r--   0     1001      123     5158 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/arithmetic/decimal.rs
+-rw-r--r--   0     1001      123     8275 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/arithmetic/mod.rs
+-rw-r--r--   0     1001      123     9417 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/arithmetic/numeric.rs
+-rw-r--r--   0     1001      123     3588 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/array/iterator.rs
+-rw-r--r--   0     1001      123     2551 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/array/mod.rs
+-rw-r--r--   0     1001      123     6448 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/bitwise.rs
+-rw-r--r--   0     1001      123     2298 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/binary.rs
+-rw-r--r--   0     1001      123     1207 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/boolean.rs
+-rw-r--r--   0     1001      123     4311 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/fixed_size_list.rs
+-rw-r--r--   0     1001      123     1556 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/from.rs
+-rw-r--r--   0     1001      123     5762 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/list/anonymous.rs
+-rw-r--r--   0     1001      123     4418 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/list/binary.rs
+-rw-r--r--   0     1001      123     2374 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/list/boolean.rs
+-rw-r--r--   0     1001      123     1392 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/list/categorical.rs
+-rw-r--r--   0     1001      123     1575 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/list/dtypes.rs
+-rw-r--r--   0     1001      123     4953 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/list/mod.rs
+-rw-r--r--   0     1001      123     3506 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/list/primitive.rs
+-rw-r--r--   0     1001      123     8996 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/mod.rs
+-rw-r--r--   0     1001      123     1410 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/primitive.rs
+-rw-r--r--   0     1001      123     2291 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/utf8.rs
+-rw-r--r--   0     1001      123    17014 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/cast.rs
+-rw-r--r--   0     1001      123    50501 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/comparison/mod.rs
+-rw-r--r--   0     1001      123    10060 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/comparison/scalar.rs
+-rw-r--r--   0     1001      123      551 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/drop.rs
+-rw-r--r--   0     1001      123      963 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/float.rs
+-rw-r--r--   0     1001      123     7945 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/from.rs
+-rw-r--r--   0     1001      123    42339 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/iterator/mod.rs
+-rw-r--r--   0     1001      123     1453 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/iterator/par/list.rs
+-rw-r--r--   0     1001      123       28 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/iterator/par/mod.rs
+-rw-r--r--   0     1001      123     1129 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/iterator/par/utf8.rs
+-rw-r--r--   0     1001      123       21 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/kernels/mod.rs
+-rw-r--r--   0     1001      123     2347 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/kernels/take.rs
+-rw-r--r--   0     1001      123     7990 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/list/iterator.rs
+-rw-r--r--   0     1001      123     3242 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/list/mod.rs
+-rw-r--r--   0     1001      123    19831 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/categorical/builder.rs
+-rw-r--r--   0     1001      123     3688 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/categorical/from.rs
+-rw-r--r--   0     1001      123     5693 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/categorical/merge.rs
+-rw-r--r--   0     1001      123    10219 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/categorical/mod.rs
+-rw-r--r--   0     1001      123     1263 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/append.rs
+-rw-r--r--   0     1001      123      358 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/full.rs
+-rw-r--r--   0     1001      123      192 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/mod.rs
+-rw-r--r--   0     1001      123     2731 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/take_random.rs
+-rw-r--r--   0     1001      123     2179 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/unique.rs
+-rw-r--r--   0     1001      123      925 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/zip.rs
+-rw-r--r--   0     1001      123     6805 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/categorical/stringcache.rs
+-rw-r--r--   0     1001      123     1604 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/date.rs
+-rw-r--r--   0     1001      123     4105 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/datetime.rs
+-rw-r--r--   0     1001      123     4443 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/decimal.rs
+-rw-r--r--   0     1001      123     2434 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/duration.rs
+-rw-r--r--   0     1001      123     2556 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/mod.rs
+-rw-r--r--   0     1001      123      476 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/struct_/from.rs
+-rw-r--r--   0     1001      123    15983 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/struct_/mod.rs
+-rw-r--r--   0     1001      123     1182 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/time.rs
+-rw-r--r--   0     1001      123    23309 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/mod.rs
+-rw-r--r--   0     1001      123     9064 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ndarray.rs
+-rw-r--r--   0     1001      123     4484 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/object/builder.rs
+-rw-r--r--   0     1001      123     1547 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/object/extension/drop.rs
+-rw-r--r--   0     1001      123     3097 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/object/extension/list.rs
+-rw-r--r--   0     1001      123     7054 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/object/extension/mod.rs
+-rw-r--r--   0     1001      123     3410 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/object/extension/polars_extension.rs
+-rw-r--r--   0     1001      123      137 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/object/is_valid.rs
+-rw-r--r--   0     1001      123     4419 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/object/iterator.rs
+-rw-r--r--   0     1001      123     4806 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/object/mod.rs
+-rw-r--r--   0     1001      123     2956 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/object/registry.rs
+-rw-r--r--   0     1001      123      272 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/abs.rs
+-rw-r--r--   0     1001      123    32662 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/aggregate/mod.rs
+-rw-r--r--   0     1001      123    10025 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/aggregate/quantile.rs
+-rw-r--r--   0     1001      123     2880 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/aggregate/var.rs
+-rw-r--r--   0     1001      123    10551 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/any_value.rs
+-rw-r--r--   0     1001      123     4526 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/append.rs
+-rw-r--r--   0     1001      123    28257 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/apply.rs
+-rw-r--r--   0     1001      123    12799 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/bit_repr.rs
+-rw-r--r--   0     1001      123     6236 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/chunkops.rs
+-rw-r--r--   0     1001      123    11537 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/compare_inner.rs
+-rw-r--r--   0     1001      123     1737 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/concat_str.rs
+-rw-r--r--   0     1001      123     4801 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/cum_agg.rs
+-rw-r--r--   0     1001      123      908 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/decimal.rs
+-rw-r--r--   0     1001      123     7056 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/downcast.rs
+-rw-r--r--   0     1001      123    20007 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/explode.rs
+-rw-r--r--   0     1001      123     8691 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/explode_and_offsets.rs
+-rw-r--r--   0     1001      123     9103 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/extend.rs
+-rw-r--r--   0     1001      123    13777 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/fill_null.rs
+-rw-r--r--   0     1001      123     6356 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/filter.rs
+-rw-r--r--   0     1001      123     5886 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/full.rs
+-rw-r--r--   0     1001      123        1 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/interpolate.rs
+-rw-r--r--   0     1001      123    16797 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/is_in.rs
+-rw-r--r--   0     1001      123        1 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/len.rs
+-rw-r--r--   0     1001      123     2658 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/min_max_binary.rs
+-rw-r--r--   0     1001      123    23364 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/mod.rs
+-rw-r--r--   0     1001      123     2414 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/nulls.rs
+-rw-r--r--   0     1001      123      593 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/peaks.rs
+-rw-r--r--   0     1001      123     4375 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/repeat_by.rs
+-rw-r--r--   0     1001      123     2771 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/reverse.rs
+-rw-r--r--   0     1001      123    10267 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/rolling_window.rs
+-rw-r--r--   0     1001      123    12518 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/set.rs
+-rw-r--r--   0     1001      123     7391 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/shift.rs
+-rw-r--r--   0     1001      123     2299 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/sort/arg_sort.rs
+-rw-r--r--   0     1001      123     5522 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/sort/arg_sort_multiple.rs
+-rw-r--r--   0     1001      123     7592 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/sort/categorical.rs
+-rw-r--r--   0     1001      123    28481 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/sort/mod.rs
+-rw-r--r--   0     1001      123      380 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/sort/slice.rs
+-rw-r--r--   0     1001      123    22089 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/take/mod.rs
+-rw-r--r--   0     1001      123     7848 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/take/take_chunked.rs
+-rw-r--r--   0     1001      123      301 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/take/take_every.rs
+-rw-r--r--   0     1001      123    16256 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/take/take_random.rs
+-rw-r--r--   0     1001      123     6275 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/take/take_single.rs
+-rw-r--r--   0     1001      123     6072 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/take/traits.rs
+-rw-r--r--   0     1001      123      459 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/tile.rs
+-rw-r--r--   0     1001      123    12251 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/unique/mod.rs
+-rw-r--r--   0     1001      123    14620 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/unique/rank.rs
+-rw-r--r--   0     1001      123     5846 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/zip.rs
+-rw-r--r--   0     1001      123     9093 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/random.rs
+-rw-r--r--   0     1001      123     1875 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/temporal/conversion.rs
+-rw-r--r--   0     1001      123     2826 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/temporal/date.rs
+-rw-r--r--   0     1001      123    10336 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/temporal/datetime.rs
+-rw-r--r--   0     1001      123     3201 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/temporal/duration.rs
+-rw-r--r--   0     1001      123     1061 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/temporal/mod.rs
+-rw-r--r--   0     1001      123     3042 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/temporal/time.rs
+-rw-r--r--   0     1001      123      872 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/to_vec.rs
+-rw-r--r--   0     1001      123     8114 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/trusted_len.rs
+-rw-r--r--   0     1001      123    26020 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/upstream_traits.rs
+-rw-r--r--   0     1001      123     7955 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/cloud.rs
+-rw-r--r--   0     1001      123     1549 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/config.rs
+-rw-r--r--   0     1001      123     4469 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/datatypes/_serde.rs
+-rw-r--r--   0     1001      123     2509 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/datatypes/aliases.rs
+-rw-r--r--   0     1001      123    42659 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/datatypes/any_value.rs
+-rw-r--r--   0     1001      123    13381 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/datatypes/dtype.rs
+-rw-r--r--   0     1001      123     5609 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/datatypes/field.rs
+-rw-r--r--   0     1001      123     8059 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/datatypes/mod.rs
+-rw-r--r--   0     1001      123     2016 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/datatypes/time_unit.rs
+-rw-r--r--   0     1001      123      118 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/doc/changelog/mod.rs
+-rw-r--r--   0     1001      123      898 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/doc/changelog/v0_10_0_11.rs
+-rw-r--r--   0     1001      123      481 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/doc/changelog/v0_3.rs
+-rw-r--r--   0     1001      123      293 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/doc/changelog/v0_4.rs
+-rw-r--r--   0     1001      123      499 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/doc/changelog/v0_5.rs
+-rw-r--r--   0     1001      123      288 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/doc/changelog/v0_6.rs
+-rw-r--r--   0     1001      123     1071 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/doc/changelog/v0_7.rs
+-rw-r--r--   0     1001      123      819 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/doc/changelog/v0_8.rs
+-rw-r--r--   0     1001      123      596 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/doc/changelog/v0_9.rs
+-rw-r--r--   0     1001      123       43 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/doc/mod.rs
+-rw-r--r--   0     1001      123       25 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/error.rs
+-rw-r--r--   0     1001      123      263 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/export.rs
+-rw-r--r--   0     1001      123    38812 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/fmt.rs
+-rw-r--r--   0     1001      123     5177 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/arithmetic.rs
+-rw-r--r--   0     1001      123     9916 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/asof_join/asof.rs
+-rw-r--r--   0     1001      123    35743 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/asof_join/groups.rs
+-rw-r--r--   0     1001      123     7168 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/asof_join/mod.rs
+-rw-r--r--   0     1001      123      559 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/chunks.rs
+-rw-r--r--   0     1001      123     5181 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/cross_join.rs
+-rw-r--r--   0     1001      123    16744 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/explode.rs
+-rw-r--r--   0     1001      123     1019 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/from.rs
+-rw-r--r--   0     1001      123    19239 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/groupby/aggregations/agg_list.rs
+-rw-r--r--   0     1001      123     4113 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/groupby/aggregations/boolean.rs
+-rw-r--r--   0     1001      123     7749 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/groupby/aggregations/dispatch.rs
+-rw-r--r--   0     1001      123    40479 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/groupby/aggregations/mod.rs
+-rw-r--r--   0     1001      123     5634 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/groupby/aggregations/utf8.rs
+-rw-r--r--   0     1001      123      218 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/groupby/expr.rs
+-rw-r--r--   0     1001      123    22901 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/groupby/hashing.rs
+-rw-r--r--   0     1001      123    14380 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/groupby/into_groups.rs
+-rw-r--r--   0     1001      123    39630 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/groupby/mod.rs
+-rw-r--r--   0     1001      123    10637 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/groupby/perfect.rs
+-rw-r--r--   0     1001      123    19780 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/groupby/proxy.rs
+-rw-r--r--   0     1001      123     5416 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/args.rs
+-rw-r--r--   0     1001      123    13172 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/mod.rs
+-rw-r--r--   0     1001      123    22364 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/multiple_keys.rs
+-rw-r--r--   0     1001      123     2400 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/single_keys.rs
+-rw-r--r--   0     1001      123    17372 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/single_keys_dispatch.rs
+-rw-r--r--   0     1001      123     4677 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/single_keys_inner.rs
+-rw-r--r--   0     1001      123     6502 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/single_keys_left.rs
+-rw-r--r--   0     1001      123     4665 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/single_keys_outer.rs
+-rw-r--r--   0     1001      123     3913 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/single_keys_semi_anti.rs
+-rw-r--r--   0     1001      123    12430 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/sort_merge.rs
+-rw-r--r--   0     1001      123     3865 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/zip_outer.rs
+-rw-r--r--   0     1001      123   127138 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/mod.rs
+-rw-r--r--   0     1001      123    27652 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/row/av_buffer.rs
+-rw-r--r--   0     1001      123     5183 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/row/dataframe.rs
+-rw-r--r--   0     1001      123     6036 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/row/mod.rs
+-rw-r--r--   0     1001      123     9875 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/row/transpose.rs
+-rw-r--r--   0     1001      123     3129 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/top_k.rs
+-rw-r--r--   0     1001      123     1388 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/upstream_traits.rs
+-rw-r--r--   0     1001      123    10198 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/functions.rs
+-rw-r--r--   0     1001      123     2149 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/hashing/fx.rs
+-rw-r--r--   0     1001      123     1503 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/hashing/identity.rs
+-rw-r--r--   0     1001      123      457 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/hashing/mod.rs
+-rw-r--r--   0     1001      123     2684 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/hashing/partition.rs
+-rw-r--r--   0     1001      123    17704 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/hashing/vector_hasher.rs
+-rw-r--r--   0     1001      123     1896 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/lib.rs
+-rw-r--r--   0     1001      123    15763 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/named_from.rs
+-rw-r--r--   0     1001      123     2502 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/prelude.rs
+-rw-r--r--   0     1001      123    18265 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/schema.rs
+-rw-r--r--   0     1001      123     3995 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/serde/chunked_array.rs
+-rw-r--r--   0     1001      123     1094 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/serde/df.rs
+-rw-r--r--   0     1001      123     4734 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/serde/mod.rs
+-rw-r--r--   0     1001      123     9938 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/serde/series.rs
+-rw-r--r--   0     1001      123    18543 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/any_value.rs
+-rw-r--r--   0     1001      123    28755 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/arithmetic/borrowed.rs
+-rw-r--r--   0     1001      123      222 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/arithmetic/mod.rs
+-rw-r--r--   0     1001      123     3546 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/arithmetic/owned.rs
+-rw-r--r--   0     1001      123    19293 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/comparison.rs
+-rw-r--r--   0     1001      123    29865 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/from.rs
+-rw-r--r--   0     1001      123     6098 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/array.rs
+-rw-r--r--   0     1001      123     9089 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/binary.rs
+-rw-r--r--   0     1001      123    10835 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/boolean.rs
+-rw-r--r--   0     1001      123    12800 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/categorical.rs
+-rw-r--r--   0     1001      123    18214 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/dates_time.rs
+-rw-r--r--   0     1001      123    15034 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/datetime.rs
+-rw-r--r--   0     1001      123     7981 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/decimal.rs
+-rw-r--r--   0     1001      123    14734 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/duration.rs
+-rw-r--r--   0     1001      123    14063 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/floats.rs
+-rw-r--r--   0     1001      123     6078 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/list.rs
+-rw-r--r--   0     1001      123    18396 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/mod.rs
+-rw-r--r--   0     1001      123     5522 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/null.rs
+-rw-r--r--   0     1001      123     7939 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/object.rs
+-rw-r--r--   0     1001      123    11828 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/struct_.rs
+-rw-r--r--   0     1001      123     9607 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/utf8.rs
+-rw-r--r--   0     1001      123     4471 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/into.rs
+-rw-r--r--   0     1001      123     6241 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/iterator.rs
+-rw-r--r--   0     1001      123    39074 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/mod.rs
+-rw-r--r--   0     1001      123      853 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/ops/diff.rs
+-rw-r--r--   0     1001      123     5814 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/ops/downcast.rs
+-rw-r--r--   0     1001      123     3601 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/ops/ewm.rs
+-rw-r--r--   0     1001      123      413 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/ops/extend.rs
+-rw-r--r--   0     1001      123      562 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/ops/mod.rs
+-rw-r--r--   0     1001      123     5974 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/ops/moment.rs
+-rw-r--r--   0     1001      123     3390 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/ops/null.rs
+-rw-r--r--   0     1001      123     1347 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/ops/pct_change.rs
+-rw-r--r--   0     1001      123     4620 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/ops/round.rs
+-rw-r--r--   0     1001      123     5091 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/ops/to_list.rs
+-rw-r--r--   0     1001      123     1476 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/ops/unique.rs
+-rw-r--r--   0     1001      123    18408 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/series_trait.rs
+-rw-r--r--   0     1001      123     2912 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/unstable.rs
+-rw-r--r--   0     1001      123     7046 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/testing.rs
+-rw-r--r--   0     1001      123      508 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/tests.rs
+-rw-r--r--   0     1001      123     2492 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/utils/flatten.rs
+-rw-r--r--   0     1001      123    31194 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/utils/mod.rs
+-rw-r--r--   0     1001      123     1600 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/utils/series.rs
+-rw-r--r--   0     1001      123    13201 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-core/src/utils/supertype.rs
+-rw-r--r--   0        0        0      954 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.7/local_dependencies/polars-row/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-row/LICENSE
+-rw-r--r--   0     1001      123      137 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-row/README.md
+-rw-r--r--   0     1001      123     2377 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-row/src/decode.rs
+-rw-r--r--   0     1001      123    14130 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-row/src/encode.rs
+-rw-r--r--   0     1001      123     7767 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-row/src/fixed.rs
+-rw-r--r--   0     1001      123    13846 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-row/src/lib.rs
+-rw-r--r--   0     1001      123     3019 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-row/src/row.rs
+-rw-r--r--   0     1001      123      682 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-row/src/utils.rs
+-rw-r--r--   0     1001      123     8702 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-row/src/variable.rs
+-rw-r--r--   0        0        0      587 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/LICENSE
+-rw-r--r--   0     1001      123      141 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/README.md
+-rw-r--r--   0     1001      123      151 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/aliases.rs
+-rw-r--r--   0     1001      123     2879 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/arena.rs
+-rw-r--r--   0     1001      123     1379 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/atomic.rs
+-rw-r--r--   0     1001      123     2659 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/cell.rs
+-rw-r--r--   0     1001      123     1015 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/contention_pool.rs
+-rw-r--r--   0     1001      123      509 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/error.rs
+-rw-r--r--   0     1001      123      271 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/fmt.rs
+-rw-r--r--   0     1001      123      763 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/functions.rs
+-rw-r--r--   0     1001      123     2709 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/iter/enumerate_idx.rs
+-rw-r--r--   0     1001      123       61 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/iter/mod.rs
+-rw-r--r--   0     1001      123      503 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/lib.rs
+-rw-r--r--   0     1001      123      573 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/macros.rs
+-rw-r--r--   0     1001      123      282 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/mem.rs
+-rw-r--r--   0     1001      123     2642 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/slice.rs
+-rw-r--r--   0     1001      123     2467 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/sort.rs
+-rw-r--r--   0     1001      123     1115 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/sync.rs
+-rw-r--r--   0     1001      123      504 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/sys.rs
+-rw-r--r--   0     1001      123      697 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/unwrap.rs
+-rw-r--r--   0     1001      123     2024 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/vec.rs
+-rw-r--r--   0     1001      123      616 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/wasm.rs
+-rw-r--r--   0        0        0     1353 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.7/local_dependencies/polars-json/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-json/LICENSE
+-rw-r--r--   0     1001      123    16461 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-json/src/json/deserialize.rs
+-rw-r--r--   0     1001      123     6564 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-json/src/json/infer_schema.rs
+-rw-r--r--   0     1001      123      189 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-json/src/json/mod.rs
+-rw-r--r--   0     1001      123       30 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-json/src/lib.rs
+-rw-r--r--   0     1001      123     1198 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-json/src/ndjson/deserialize.rs
+-rw-r--r--   0     1001      123     4808 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-json/src/ndjson/file.rs
+-rw-r--r--   0     1001      123      143 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-json/src/ndjson/mod.rs
+-rw-r--r--   0        0        0     1106 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/LICENSE
+-rw-r--r--   0     1001      123      466 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/README.md
+-rw-r--r--   0     1001      123    23380 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/src/context.rs
+-rw-r--r--   0     1001      123    28210 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/src/functions.rs
+-rw-r--r--   0     1001      123     2122 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/src/keywords.rs
+-rw-r--r--   0     1001      123      239 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/src/lib.rs
+-rw-r--r--   0     1001      123    21267 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/src/sql_expr.rs
+-rw-r--r--   0     1001      123     4572 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/src/table_functions.rs
+-rw-r--r--   0     1001      123     1682 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/functions_cumulative.rs
+-rw-r--r--   0     1001      123     3063 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/functions_io.rs
+-rw-r--r--   0     1001      123     1539 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/functions_math.rs
+-rw-r--r--   0     1001      123      860 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/functions_meta.rs
+-rw-r--r--   0     1001      123     2982 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/functions_string.rs
+-rw-r--r--   0     1001      123     1056 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/iss_7436.rs
+-rw-r--r--   0     1001      123      902 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/iss_7437.rs
+-rw-r--r--   0     1001      123      652 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/iss_7440.rs
+-rw-r--r--   0     1001      123      700 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/iss_8395.rs
+-rw-r--r--   0     1001      123     1062 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/iss_8419.rs
+-rw-r--r--   0     1001      123     1001 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/ops_distinct_on.rs
+-rw-r--r--   0     1001      123    15921 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/simple_exprs.rs
+-rw-r--r--   0     1001      123     3976 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/statements.rs
+-rw-r--r--   0        0        0     2037 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/LICENSE
+-rw-r--r--   0     1001      123      143 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/README.md
+-rw-r--r--   0     1001      123     1018 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/base_utc_offset.rs
+-rw-r--r--   0     1001      123     3569 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/date.rs
+-rw-r--r--   0     1001      123     6465 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/datetime.rs
+-rw-r--r--   0     1001      123     3305 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/duration.rs
+-rw-r--r--   0     1001      123     5607 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/kernels.rs
+-rw-r--r--   0     1001      123     1062 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/mod.rs
+-rw-r--r--   0     1001      123     6759 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/rolling_window/floats.rs
+-rw-r--r--   0     1001      123     2582 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/rolling_window/ints.rs
+-rw-r--r--   0     1001      123    11122 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/rolling_window/mod.rs
+-rw-r--r--   0     1001      123      413 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/rolling_window/rolling_kernels/mod.rs
+-rw-r--r--   0     1001      123     4810 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/rolling_window/rolling_kernels/no_nulls.rs
+-rw-r--r--   0     1001      123     2372 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/time.rs
+-rw-r--r--   0     1001      123    21334 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/utf8/infer.rs
+-rw-r--r--   0     1001      123    18997 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/utf8/mod.rs
+-rw-r--r--   0     1001      123     3975 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/utf8/patterns.rs
+-rw-r--r--   0     1001      123    11229 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/utf8/strptime.rs
+-rw-r--r--   0     1001      123     3340 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/date_range.rs
+-rw-r--r--   0     1001      123      994 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/dst_offset.rs
+-rw-r--r--   0     1001      123    34617 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/groupby/dynamic.rs
+-rw-r--r--   0     1001      123       88 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/groupby/mod.rs
+-rw-r--r--   0     1001      123      769 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/lib.rs
+-rw-r--r--   0     1001      123     2976 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/month_end.rs
+-rw-r--r--   0     1001      123     3365 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/month_start.rs
+-rw-r--r--   0     1001      123      274 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/prelude.rs
+-rw-r--r--   0     1001      123     1381 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/round.rs
+-rw-r--r--   0     1001      123     3992 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/series/_trait.rs
+-rw-r--r--   0     1001      123      136 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/series/implementations/boolean.rs
+-rw-r--r--   0     1001      123      140 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/series/implementations/categoricals.rs
+-rw-r--r--   0     1001      123      133 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/series/implementations/date.rs
+-rw-r--r--   0     1001      123      137 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/series/implementations/datetime.rs
+-rw-r--r--   0     1001      123      137 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/series/implementations/duration.rs
+-rw-r--r--   0     1001      123     1863 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/series/implementations/floats.rs
+-rw-r--r--   0     1001      123     1792 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/series/implementations/integers.rs
+-rw-r--r--   0     1001      123      133 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/series/implementations/list.rs
+-rw-r--r--   0     1001      123      486 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/series/implementations/mod.rs
+-rw-r--r--   0     1001      123      155 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/series/implementations/object.rs
+-rw-r--r--   0     1001      123      135 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/series/implementations/struct_.rs
+-rw-r--r--   0     1001      123      133 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/series/implementations/time.rs
+-rw-r--r--   0     1001      123      133 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/series/implementations/utf8.rs
+-rw-r--r--   0     1001      123    12791 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/series/mod.rs
+-rw-r--r--   0     1001      123     1443 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/truncate.rs
+-rw-r--r--   0     1001      123     7619 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/upsample.rs
+-rw-r--r--   0     1001      123     2511 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/utils.rs
+-rw-r--r--   0     1001      123     1524 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/windows/bounds.rs
+-rw-r--r--   0     1001      123     2672 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/windows/calendar.rs
+-rw-r--r--   0     1001      123    25421 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/windows/duration.rs
+-rw-r--r--   0     1001      123    20201 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/windows/groupby.rs
+-rw-r--r--   0     1001      123      503 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/windows/mod.rs
+-rw-r--r--   0     1001      123    23627 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/windows/test.rs
+-rw-r--r--   0     1001      123    10657 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-time/src/windows/window.rs
+-rw-r--r--   0        0        0     1998 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/LICENSE
+-rw-r--r--   0     1001      123      165 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/README.md
+-rw-r--r--   0     1001      123       98 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/mod.rs
+-rw-r--r--   0     1001      123     1219 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/operators/filter.rs
+-rw-r--r--   0     1001      123     4103 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/operators/function.rs
+-rw-r--r--   0     1001      123      266 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/operators/mod.rs
+-rw-r--r--   0     1001      123      682 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/operators/pass.rs
+-rw-r--r--   0     1001      123      548 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/operators/placeholder.rs
+-rw-r--r--   0     1001      123     3553 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/operators/projection.rs
+-rw-r--r--   0     1001      123     3559 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/operators/reproject.rs
+-rw-r--r--   0     1001      123     6479 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/file_sink.rs
+-rw-r--r--   0     1001      123    11288 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/convert.rs
+-rw-r--r--   0     1001      123     1207 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/count.rs
+-rw-r--r--   0     1001      123     1888 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/first.rs
+-rw-r--r--   0     1001      123     4554 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/interface.rs
+-rw-r--r--   0     1001      123     1746 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/last.rs
+-rw-r--r--   0     1001      123     5413 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/mean.rs
+-rw-r--r--   0     1001      123     4951 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/min_max.rs
+-rw-r--r--   0     1001      123      211 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/mod.rs
+-rw-r--r--   0     1001      123      856 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/null.rs
+-rw-r--r--   0     1001      123     4294 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/sum.rs
+-rw-r--r--   0     1001      123     4109 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/eval.rs
+-rw-r--r--   0     1001      123     7404 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/global.rs
+-rw-r--r--   0     1001      123    10554 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/hash_table.rs
+-rw-r--r--   0     1001      123     3589 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/mod.rs
+-rw-r--r--   0     1001      123     2767 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/ooc_state.rs
+-rw-r--r--   0     1001      123     6326 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/sink.rs
+-rw-r--r--   0     1001      123     3116 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/source.rs
+-rw-r--r--   0     1001      123    10194 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/thread_local.rs
+-rw-r--r--   0     1001      123     2119 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/mod.rs
+-rw-r--r--   0     1001      123     4695 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/ooc.rs
+-rw-r--r--   0     1001      123     1887 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/ooc_state.rs
+-rw-r--r--   0     1001      123    20783 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/primitive/mod.rs
+-rw-r--r--   0     1001      123    23825 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/string.rs
+-rw-r--r--   0     1001      123     2457 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/utils.rs
+-rw-r--r--   0     1001      123     9239 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/io.rs
+-rw-r--r--   0     1001      123     5451 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/joins/cross.rs
+-rw-r--r--   0     1001      123    12056 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/joins/generic_build.rs
+-rw-r--r--   0     1001      123    11658 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/joins/inner_left.rs
+-rw-r--r--   0     1001      123      178 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/joins/mod.rs
+-rw-r--r--   0     1001      123     2241 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/memory.rs
+-rw-r--r--   0     1001      123      589 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/mod.rs
+-rw-r--r--   0     1001      123     1492 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/ordered.rs
+-rw-r--r--   0     1001      123     1824 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/reproject.rs
+-rw-r--r--   0     1001      123     3108 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/slice.rs
+-rw-r--r--   0     1001      123      130 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/sort/mod.rs
+-rw-r--r--   0     1001      123     6774 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/sort/ooc.rs
+-rw-r--r--   0     1001      123     7404 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/sort/sink.rs
+-rw-r--r--   0     1001      123    11718 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/sort/sink_multiple.rs
+-rw-r--r--   0     1001      123     3908 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/sort/source.rs
+-rw-r--r--   0     1001      123      526 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/utils.rs
+-rw-r--r--   0     1001      123     6208 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sources/csv.rs
+-rw-r--r--   0     1001      123     1231 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sources/frame.rs
+-rw-r--r--   0     1001      123      987 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sources/ipc_one_shot.rs
+-rw-r--r--   0     1001      123      366 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sources/mod.rs
+-rw-r--r--   0     1001      123     4569 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sources/parquet.rs
+-rw-r--r--   0     1001      123     1146 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sources/reproject.rs
+-rw-r--r--   0     1001      123     1022 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sources/union.rs
+-rw-r--r--   0     1001      123      448 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/expressions.rs
+-rw-r--r--   0     1001      123      272 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/lib.rs
+-rw-r--r--   0     1001      123      719 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/operators/chunks.rs
+-rw-r--r--   0     1001      123      474 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/operators/context.rs
+-rw-r--r--   0     1001      123      223 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/operators/mod.rs
+-rw-r--r--   0     1001      123      514 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/operators/operator.rs
+-rw-r--r--   0     1001      123      626 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/operators/sink.rs
+-rw-r--r--   0     1001      123      241 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/operators/source.rs
+-rw-r--r--   0     1001      123        1 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/pipeline/config.rs
+-rw-r--r--   0     1001      123    21076 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/pipeline/convert.rs
+-rw-r--r--   0     1001      123    20362 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/pipeline/dispatcher.rs
+-rw-r--r--   0     1001      123     1155 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/pipeline/mod.rs
+-rw-r--r--   0        0        0     4584 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.7/Cargo.toml
+-rw-r--r--   0     1001      123       76 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/.gitignore
+-rw-r--r--   0     1001      123     1055 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/LICENSE
+-rw-r--r--   0     1001      123     2414 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/Makefile
+-rw-r--r--   0     1001      123    11696 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/README.md
+-rw-r--r--   0     1001      123      651 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/build.rs
+-rw-r--r--   0     1001      123       32 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/.gitignore
+-rw-r--r--   0     1001      123      682 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/Makefile
+-rw-r--r--   0     1001      123      318 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/_templates/api_redirect.html
+-rw-r--r--   0     1001      123      151 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/_templates/autosummary/accessor.rst
+-rw-r--r--   0     1001      123      160 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/_templates/autosummary/accessor_attribute.rst
+-rw-r--r--   0     1001      123      168 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/_templates/autosummary/accessor_callable.rst
+-rw-r--r--   0     1001      123      157 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/_templates/autosummary/accessor_method.rst
+-rw-r--r--   0     1001      123      836 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/_templates/autosummary/class.rst
+-rw-r--r--   0     1001      123       94 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/_templates/autosummary/class_without_autosummary.rst
+-rw-r--r--   0     1001      123      406 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/_templates/sidebar-nav-bs.html
+-rw-r--r--   0     1001      123      559 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/requirements-docs.txt
+-rw-r--r--   0     1001      123     1164 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/run_live_docs_server.py
+-rw-r--r--   0     1001      123     1567 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/_static/css/custom.css
+-rw-r--r--   0     1001      123     7297 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/conf.py
+-rw-r--r--   0     1001      123       51 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/index.rst
+-rw-r--r--   0     1001      123     6767 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/api.rst
+-rw-r--r--   0     1001      123     2069 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/config.rst
+-rw-r--r--   0     1001      123      274 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/dataframe/aggregation.rst
+-rw-r--r--   0     1001      123      221 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/dataframe/attributes.rst
+-rw-r--r--   0     1001      123      142 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/dataframe/computation.rst
+-rw-r--r--   0     1001      123      319 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/dataframe/descriptive.rst
+-rw-r--r--   0     1001      123      319 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/dataframe/export.rst
+-rw-r--r--   0     1001      123      464 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/dataframe/groupby.rst
+-rw-r--r--   0     1001      123      379 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/dataframe/index.rst
+-rw-r--r--   0     1001      123      189 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/dataframe/miscellaneous.rst
+-rw-r--r--   0     1001      123     1564 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/dataframe/modify_select.rst
+-rw-r--r--   0     1001      123      673 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/datatypes.rst
+-rw-r--r--   0     1001      123      421 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/exceptions.rst
+-rw-r--r--   0     1001      123      391 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/expressions/aggregation.rst
+-rw-r--r--   0     1001      123      267 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/expressions/array.rst
+-rw-r--r--   0     1001      123      309 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/expressions/binary.rst
+-rw-r--r--   0     1001      123      338 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/expressions/boolean.rst
+-rw-r--r--   0     1001      123      237 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/expressions/categories.rst
+-rw-r--r--   0     1001      123      221 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/expressions/columns.rst
+-rw-r--r--   0     1001      123     1095 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/expressions/computation.rst
+-rw-r--r--   0     1001      123     1334 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/expressions/functions.rst
+-rw-r--r--   0     1001      123      470 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/expressions/index.rst
+-rw-r--r--   0     1001      123      830 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/expressions/list.rst
+-rw-r--r--   0     1001      123      458 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/expressions/meta.rst
+-rw-r--r--   0     1001      123      159 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/expressions/miscellaneous.rst
+-rw-r--r--   0     1001      123     1033 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/expressions/modify_select.rst
+-rw-r--r--   0     1001      123      679 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/expressions/operators.rst
+-rw-r--r--   0     1001      123      977 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/expressions/string.rst
+-rw-r--r--   0     1001      123      254 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/expressions/struct.rst
+-rw-r--r--   0     1001      123     1087 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/expressions/temporal.rst
+-rw-r--r--   0     1001      123       98 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/expressions/window.rst
+-rw-r--r--   0     1001      123      694 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/functions.rst
+-rw-r--r--   0     1001      123      405 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/index.rst
+-rw-r--r--   0     1001      123     1294 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/io.rst
+-rw-r--r--   0     1001      123      277 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/lazyframe/aggregation.rst
+-rw-r--r--   0     1001      123      179 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/lazyframe/attributes.rst
+-rw-r--r--   0     1001      123      146 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/lazyframe/descriptive.rst
+-rw-r--r--   0     1001      123      497 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/lazyframe/groupby.rst
+-rw-r--r--   0     1001      123      354 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/lazyframe/index.rst
+-rw-r--r--   0     1001      123      455 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/lazyframe/miscellaneous.rst
+-rw-r--r--   0     1001      123     1013 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/lazyframe/modify_select.rst
+-rw-r--r--   0     1001      123     3279 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/selectors.rst
+-rw-r--r--   0     1001      123      358 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/series/aggregation.rst
+-rw-r--r--   0     1001      123      277 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/series/array.rst
+-rw-r--r--   0     1001      123      257 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/series/attributes.rst
+-rw-r--r--   0     1001      123      321 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/series/binary.rst
+-rw-r--r--   0     1001      123      117 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/series/boolean.rst
+-rw-r--r--   0     1001      123      241 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/series/categories.rst
+-rw-r--r--   0     1001      123     1103 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/series/computation.rst
+-rw-r--r--   0     1001      123      744 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/series/descriptive.rst
+-rw-r--r--   0     1001      123      240 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/series/export.rst
+-rw-r--r--   0     1001      123      437 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/series/index.rst
+-rw-r--r--   0     1001      123      894 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/series/list.rst
+-rw-r--r--   0     1001      123      236 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/series/miscellaneous.rst
+-rw-r--r--   0     1001      123     1110 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/series/modify_select.rst
+-rw-r--r--   0     1001      123     1049 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/series/string.rst
+-rw-r--r--   0     1001      123      421 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/series/struct.rst
+-rw-r--r--   0     1001      123     1247 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/series/temporal.rst
+-rw-r--r--   0     1001      123      503 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/sql.rst
+-rw-r--r--   0     1001      123     8067 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/testing.rst
+-rw-r--r--   0     1001      123      168 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/docs/source/reference/utils.rst
+-rw-r--r--   0     1001      123     6663 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/__init__.py
+-rw-r--r--   0     1001      123      280 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/_reexport.py
+-rw-r--r--   0     1001      123    13229 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/api.py
+-rw-r--r--   0     1001      123    29652 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/config.py
+-rw-r--r--   0     1001      123    28090 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/convert.py
+-rw-r--r--   0     1001      123       77 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/dataframe/__init__.py
+-rw-r--r--   0     1001      123     5227 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/dataframe/_html.py
+-rw-r--r--   0     1001      123   326398 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/dataframe/frame.py
+-rw-r--r--   0     1001      123    41618 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/dataframe/groupby.py
+-rw-r--r--   0     1001      123     2692 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/datatypes/__init__.py
+-rw-r--r--   0     1001      123    17874 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/datatypes/classes.py
+-rw-r--r--   0     1001      123     1690 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/datatypes/constants.py
+-rw-r--r--   0     1001      123     4962 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/datatypes/constructor.py
+-rw-r--r--   0     1001      123    15446 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/datatypes/convert.py
+-rw-r--r--   0     1001      123     7358 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/dependencies.py
+-rw-r--r--   0     1001      123     3792 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/exceptions.py
+-rw-r--r--   0     1001      123       61 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/expr/__init__.py
+-rw-r--r--   0     1001      123     3020 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/expr/array.py
+-rw-r--r--   0     1001      123    10330 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/expr/binary.py
+-rw-r--r--   0     1001      123     1698 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/expr/categorical.py
+-rw-r--r--   0     1001      123    80633 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/expr/datetime.py
+-rw-r--r--   0     1001      123   323018 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/expr/expr.py
+-rw-r--r--   0     1001      123    31956 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/expr/list.py
+-rw-r--r--   0     1001      123     4683 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/expr/meta.py
+-rw-r--r--   0     1001      123    60086 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/expr/string.py
+-rw-r--r--   0     1001      123     5426 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/expr/struct.py
+-rw-r--r--   0     1001      123     2464 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/functions/__init__.py
+-rw-r--r--   0     1001      123      480 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/functions/aggregation/__init__.py
+-rw-r--r--   0     1001      123     8369 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/functions/aggregation/horizontal.py
+-rw-r--r--   0     1001      123    15284 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/functions/aggregation/vertical.py
+-rw-r--r--   0     1001      123    16430 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/functions/as_datatype.py
+-rw-r--r--   0     1001      123    18735 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/functions/eager.py
+-rw-r--r--   0     1001      123    55462 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/functions/lazy.py
+-rw-r--r--   0     1001      123    20769 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/functions/range.py
+-rw-r--r--   0     1001      123     6043 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/functions/repeat.py
+-rw-r--r--   0     1001      123     6051 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/functions/whenthen.py
+-rw-r--r--   0     1001      123      952 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/__init__.py
+-rw-r--r--   0     1001      123     6364 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/_utils.py
+-rw-r--r--   0     1001      123      861 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/avro.py
+-rw-r--r--   0     1001      123      144 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/csv/__init__.py
+-rw-r--r--   0     1001      123     1072 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/csv/_utils.py
+-rw-r--r--   0     1001      123     4681 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/csv/batched_reader.py
+-rw-r--r--   0     1001      123    35482 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/csv/functions.py
+-rw-r--r--   0     1001      123     6428 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/database.py
+-rw-r--r--   0     1001      123    11047 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/delta.py
+-rw-r--r--   0     1001      123       75 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/excel/__init__.py
+-rw-r--r--   0     1001      123    18338 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/excel/_write_utils.py
+-rw-r--r--   0     1001      123     6355 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/excel/functions.py
+-rw-r--r--   0     1001      123      142 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/ipc/__init__.py
+-rw-r--r--   0     1001      123     1227 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/ipc/anonymous_scan.py
+-rw-r--r--   0     1001      123     5804 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/ipc/functions.py
+-rw-r--r--   0     1001      123      510 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/json.py
+-rw-r--r--   0     1001      123     2215 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/ndjson.py
+-rw-r--r--   0     1001      123      170 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/parquet/__init__.py
+-rw-r--r--   0     1001      123     1259 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/parquet/anonymous_scan.py
+-rw-r--r--   0     1001      123     7177 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/parquet/functions.py
+-rw-r--r--   0     1001      123      136 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/pyarrow_dataset/__init__.py
+-rw-r--r--   0     1001      123     2186 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/pyarrow_dataset/anonymous_scan.py
+-rw-r--r--   0     1001      123     3601 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/io/pyarrow_dataset/functions.py
+-rw-r--r--   0     1001      123       77 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/lazyframe/__init__.py
+-rw-r--r--   0     1001      123   172996 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/lazyframe/frame.py
+-rw-r--r--   0     1001      123    25094 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/lazyframe/groupby.py
+-rw-r--r--   0     1001      123        0 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/py.typed
+-rw-r--r--   0     1001      123    42936 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/selectors.py
+-rw-r--r--   0     1001      123       69 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/series/__init__.py
+-rw-r--r--   0     1001      123     1572 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/series/_numpy.py
+-rw-r--r--   0     1001      123     2515 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/series/array.py
+-rw-r--r--   0     1001      123     1913 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/series/binary.py
+-rw-r--r--   0     1001      123     1692 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/series/categorical.py
+-rw-r--r--   0     1001      123    54653 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/series/datetime.py
+-rw-r--r--   0     1001      123    16940 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/series/list.py
+-rw-r--r--   0     1001      123   173824 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/series/series.py
+-rw-r--r--   0     1001      123    38879 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/series/string.py
+-rw-r--r--   0     1001      123     2542 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/series/struct.py
+-rw-r--r--   0     1001      123     5361 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/series/utils.py
+-rw-r--r--   0     1001      123     7559 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/slice.py
+-rw-r--r--   0     1001      123       75 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/sql/__init__.py
+-rw-r--r--   0     1001      123    17286 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/sql/context.py
+-rw-r--r--   0     1001      123     4793 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/string_cache.py
+-rw-r--r--   0     1001      123      362 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/testing/__init__.py
+-rw-r--r--   0     1001      123     1060 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/testing/_private.py
+-rw-r--r--   0     1001      123    16964 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/testing/asserts.py
+-rw-r--r--   0     1001      123      898 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/testing/parametric/__init__.py
+-rw-r--r--   0     1001      123    28187 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/testing/parametric/primitives.py
+-rw-r--r--   0     1001      123     3371 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/testing/parametric/profiles.py
+-rw-r--r--   0     1001      123    13165 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/testing/parametric/strategies.py
+-rw-r--r--   0     1001      123     6460 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/type_aliases.py
+-rw-r--r--   0     1001      123     1157 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/utils/__init__.py
+-rw-r--r--   0     1001      123    56946 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/utils/_construction.py
+-rw-r--r--   0     1001      123     4937 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/utils/_parse_expr_input.py
+-rw-r--r--   0     1001      123      647 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/utils/_scan.py
+-rw-r--r--   0     1001      123      579 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/utils/_wrap.py
+-rw-r--r--   0     1001      123      683 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/utils/build_info.py
+-rw-r--r--   0     1001      123     8702 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/utils/convert.py
+-rw-r--r--   0     1001      123     7199 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/utils/decorators.py
+-rw-r--r--   0     1001      123     1660 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/utils/meta.py
+-rw-r--r--   0     1001      123      514 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/utils/polars_version.py
+-rw-r--r--   0     1001      123     2509 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/utils/show_versions.py
+-rw-r--r--   0     1001      123    13392 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/polars/utils/various.py
+-rw-r--r--   0     1001      123     5370 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/pyproject.toml
+-rw-r--r--   0     1001      123      767 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/requirements-dev.txt
+-rw-r--r--   0     1001      123       70 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/requirements-lint.txt
+-rw-r--r--   0     1001      123     1610 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/scripts/check_stacklevels.py
+-rw-r--r--   0     1001      123    10980 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/apply/dataframe.rs
+-rw-r--r--   0     1001      123     6428 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/apply/lazy.rs
+-rw-r--r--   0     1001      123     8535 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/apply/mod.rs
+-rw-r--r--   0     1001      123    90654 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/apply/series.rs
+-rw-r--r--   0     1001      123       32 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/arrow_interop/mod.rs
+-rw-r--r--   0     1001      123     1306 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/arrow_interop/to_py.rs
+-rw-r--r--   0     1001      123     3902 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/arrow_interop/to_rust.rs
+-rw-r--r--   0     1001      123     5250 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/batched_csv.rs
+-rw-r--r--   0     1001      123    53825 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/conversion.rs
+-rw-r--r--   0     1001      123    46236 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/dataframe.rs
+-rw-r--r--   0     1001      123     3950 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/datatypes.rs
+-rw-r--r--   0     1001      123     3506 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/error.rs
+-rw-r--r--   0     1001      123      570 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/expr/array.rs
+-rw-r--r--   0     1001      123     2080 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/expr/binary.rs
+-rw-r--r--   0     1001      123      274 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/expr/categorical.rs
+-rw-r--r--   0     1001      123     6206 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/expr/datetime.rs
+-rw-r--r--   0     1001      123    35587 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/expr/general.rs
+-rw-r--r--   0     1001      123     4693 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/expr/list.rs
+-rw-r--r--   0     1001      123     3152 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/expr/meta.rs
+-rw-r--r--   0     1001      123      870 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/expr/mod.rs
+-rw-r--r--   0     1001      123     8366 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/expr/string.rs
+-rw-r--r--   0     1001      123      467 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/expr/struct.rs
+-rw-r--r--   0     1001      123     9482 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/file.rs
+-rw-r--r--   0     1001      123      806 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/functions/aggregation.rs
+-rw-r--r--   0     1001      123     2777 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/functions/eager.rs
+-rw-r--r--   0     1001      123     1657 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/functions/io.rs
+-rw-r--r--   0     1001      123    11196 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/functions/lazy.rs
+-rw-r--r--   0     1001      123     1312 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/functions/meta.rs
+-rw-r--r--   0     1001      123      217 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/functions/misc.rs
+-rw-r--r--   0     1001      123      123 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/functions/mod.rs
+-rw-r--r--   0     1001      123      845 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/functions/range.rs
+-rw-r--r--   0     1001      123     1474 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/functions/whenthen.rs
+-rw-r--r--   0     1001      123     1597 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/gil_once_cell.rs
+-rw-r--r--   0     1001      123    28437 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/lazyframe.rs
+-rw-r--r--   0     1001      123     2670 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/lazygroupby.rs
+-rw-r--r--   0     1001      123     8841 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/lib.rs
+-rw-r--r--   0     1001      123       47 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/object.rs
+-rw-r--r--   0     1001      123     3243 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/on_startup.rs
+-rw-r--r--   0     1001      123      122 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/prelude.rs
+-rw-r--r--   0     1001      123      435 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/py_modules.rs
+-rw-r--r--   0     1001      123     1964 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/series/aggregation.rs
+-rw-r--r--   0     1001      123     5406 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/series/arithmetic.rs
+-rw-r--r--   0     1001      123     5138 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/series/comparison.rs
+-rw-r--r--   0     1001      123     9077 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/series/construction.rs
+-rw-r--r--   0     1001      123     8971 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/series/export.rs
+-rw-r--r--   0     1001      123    25167 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/series/mod.rs
+-rw-r--r--   0     1001      123     4569 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/series/numpy_ufunc.rs
+-rw-r--r--   0     1001      123     4046 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/series/set_at_idx.rs
+-rw-r--r--   0     1001      123     1036 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/sql.rs
+-rw-r--r--   0     1001      123     2335 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/src/utils.rs
+-rw-r--r--   0     1001      123     6165 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/README.md
+-rw-r--r--   0     1001      123     2189 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/benchmark/groupby-datagen.R
+-rw-r--r--   0     1001      123     7963 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/benchmark/run_h2oai_benchmark.py
+-rw-r--r--   0     1001      123     6530 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/benchmark/test_release.py
+-rw-r--r--   0     1001      123     4589 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/docs/run_doctest.py
+-rw-r--r--   0     1001      123        0 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/parametric/__init__.py
+-rw-r--r--   0     1001      123      179 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/parametric/conftest.py
+-rw-r--r--   0     1001      123     3856 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/parametric/test_dataframe.py
+-rw-r--r--   0     1001      123     2398 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/parametric/test_groupby_rolling.py
+-rw-r--r--   0     1001      123     1692 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/parametric/test_lazyframe.py
+-rw-r--r--   0     1001      123      976 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/parametric/test_lit.py
+-rw-r--r--   0     1001      123     6853 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/parametric/test_series.py
+-rw-r--r--   0     1001      123     8467 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/parametric/test_testing.py
+-rw-r--r--   0     1001      123     1554 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/parametric/time_series/test_to_datetime.py
+-rw-r--r--   0     1001      123        0 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/__init__.py
+-rw-r--r--   0     1001      123     3382 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/conftest.py
+-rw-r--r--   0     1001      123       86 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/datatypes/__init__.py
+-rw-r--r--   0     1001      123     1673 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/datatypes/test_array.py
+-rw-r--r--   0     1001      123      847 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/datatypes/test_binary.py
+-rw-r--r--   0     1001      123     1420 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/datatypes/test_bool.py
+-rw-r--r--   0     1001      123    13983 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/datatypes/test_categorical.py
+-rw-r--r--   0     1001      123     5222 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/datatypes/test_decimal.py
+-rw-r--r--   0     1001      123      549 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/datatypes/test_duration.py
+-rw-r--r--   0     1001      123      423 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/datatypes/test_integer.py
+-rw-r--r--   0     1001      123    14052 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/datatypes/test_list.py
+-rw-r--r--   0     1001      123      284 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/datatypes/test_null.py
+-rw-r--r--   0     1001      123     3028 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/datatypes/test_object.py
+-rw-r--r--   0     1001      123    27697 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/datatypes/test_struct.py
+-rw-r--r--   0     1001      123    88525 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/datatypes/test_temporal.py
+-rw-r--r--   0     1001      123      418 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/datatypes/test_time.py
+-rw-r--r--   0     1001      123        0 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/functions/__init__.py
+-rw-r--r--   0     1001      123        0 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/functions/aggregation/__init__.py
+-rw-r--r--   0     1001      123     6783 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/functions/aggregation/test_horizontal.py
+-rw-r--r--   0     1001      123     3008 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/functions/aggregation/test_vertical.py
+-rw-r--r--   0     1001      123    13970 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/functions/test_as_datatype.py
+-rw-r--r--   0     1001      123      480 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/functions/test_concat.py
+-rw-r--r--   0     1001      123    14595 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/functions/test_functions.py
+-rw-r--r--   0     1001      123    30418 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/functions/test_range.py
+-rw-r--r--   0     1001      123     3847 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/functions/test_repeat.py
+-rw-r--r--   0     1001      123      218 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/conftest.py
+-rw-r--r--   0     1001      123       16 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/delta-table/.part-00000-e42312d7-60e5-454d-acbc-db192d220e73-c000.snappy.parquet.crc
+-rw-r--r--   0     1001      123       16 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/delta-table/.part-00000-e4a999da-df45-4fb0-bdc4-d999fc0f58aa-c000.snappy.parquet.crc
+-rw-r--r--   0     1001      123       16 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/delta-table/_delta_log/.00000000000000000000.json.crc
+-rw-r--r--   0     1001      123       16 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/delta-table/_delta_log/.00000000000000000001.json.crc
+-rw-r--r--   0     1001      123      905 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/delta-table/_delta_log/00000000000000000000.json
+-rw-r--r--   0     1001      123      936 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/delta-table/_delta_log/00000000000000000001.json
+-rw-r--r--   0     1001      123      972 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/delta-table/part-00000-e42312d7-60e5-454d-acbc-db192d220e73-c000.snappy.parquet
+-rw-r--r--   0     1001      123      690 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/delta-table/part-00000-e4a999da-df45-4fb0-bdc4-d999fc0f58aa-c000.snappy.parquet
+-rw-r--r--   0     1001      123        0 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/empty.csv
+-rw-r--r--   0     1001      123     5959 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/example.xlsx
+-rw-r--r--   0     1001      123      457 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/foods1.csv
+-rw-r--r--   0     1001      123     2351 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/foods1.ipc
+-rw-r--r--   0     1001      123     1713 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/foods1.ndjson
+-rw-r--r--   0     1001      123     1427 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/foods1.parquet
+-rw-r--r--   0     1001      123      455 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/foods2.csv
+-rw-r--r--   0     1001      123     2351 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/foods2.ipc
+-rw-r--r--   0     1001      123     1711 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/foods2.ndjson
+-rw-r--r--   0     1001      123     1916 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/foods2.parquet
+-rw-r--r--   0     1001      123      455 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/foods3.csv
+-rw-r--r--   0     1001      123      457 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/foods4.csv
+-rw-r--r--   0     1001      123      452 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/foods5.csv
+-rw-r--r--   0     1001      123       49 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/gzipped.csv
+-rw-r--r--   0     1001      123       57 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/small.csv
+-rw-r--r--   0     1001      123      756 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/small.parquet
+-rwxr-xr-x   0     1001      123      420 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/files/tz_aware.parquet
+-rw-r--r--   0     1001      123     1884 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/test_avro.py
+-rw-r--r--   0     1001      123    41164 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/test_csv.py
+-rw-r--r--   0     1001      123     7157 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/test_database.py
+-rw-r--r--   0     1001      123     6172 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/test_delta.py
+-rw-r--r--   0     1001      123    11169 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/test_excel.py
+-rw-r--r--   0     1001      123     5483 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/test_ipc.py
+-rw-r--r--   0     1001      123     4389 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/test_json.py
+-rw-r--r--   0     1001      123     7379 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/test_lazy_csv.py
+-rw-r--r--   0     1001      123     2060 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/test_lazy_ipc.py
+-rw-r--r--   0     1001      123     2867 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/test_lazy_json.py
+-rw-r--r--   0     1001      123    11153 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/test_lazy_parquet.py
+-rw-r--r--   0     1001      123     2012 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/test_other.py
+-rw-r--r--   0     1001      123    14881 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/test_parquet.py
+-rw-r--r--   0     1001      123      612 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/test_pickle.py
+-rw-r--r--   0     1001      123     3706 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/io/test_pyarrow_dataset.py
+-rw-r--r--   0     1001      123      509 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/namespaces/__init__.py
+-rw-r--r--   0     1001      123      589 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/namespaces/test_array.py
+-rw-r--r--   0     1001      123     3218 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/namespaces/test_binary.py
+-rw-r--r--   0     1001      123     2489 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/namespaces/test_categorical.py
+-rw-r--r--   0     1001      123    24031 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/namespaces/test_datetime.py
+-rw-r--r--   0     1001      123    15528 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/namespaces/test_list.py
+-rw-r--r--   0     1001      123     2472 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/namespaces/test_meta.py
+-rw-r--r--   0     1001      123    24050 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/namespaces/test_string.py
+-rw-r--r--   0     1001      123    20819 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/namespaces/test_strptime.py
+-rw-r--r--   0     1001      123      982 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/namespaces/test_struct.py
+-rw-r--r--   0     1001      123       85 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/__init__.py
+-rw-r--r--   0     1001      123     8008 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_aggregations.py
+-rw-r--r--   0     1001      123    10613 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_apply.py
+-rw-r--r--   0     1001      123     6915 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_arithmetic.py
+-rw-r--r--   0     1001      123     4940 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_comparison.py
+-rw-r--r--   0     1001      123     3275 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_drop.py
+-rw-r--r--   0     1001      123     8813 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_explode.py
+-rw-r--r--   0     1001      123     3732 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_filter.py
+-rw-r--r--   0     1001      123     1096 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_folds.py
+-rw-r--r--   0     1001      123    25037 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_groupby.py
+-rw-r--r--   0     1001      123     7649 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_groupby_rolling.py
+-rw-r--r--   0     1001      123     2983 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_is_in.py
+-rw-r--r--   0     1001      123    18993 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_join.py
+-rw-r--r--   0     1001      123    14952 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_join_asof.py
+-rw-r--r--   0     1001      123      643 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_melt.py
+-rw-r--r--   0     1001      123    10253 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_pivot.py
+-rw-r--r--   0     1001      123     3187 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_random.py
+-rw-r--r--   0     1001      123    24274 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_rolling.py
+-rw-r--r--   0     1001      123     2389 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_select.py
+-rw-r--r--   0     1001      123    20770 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_sort.py
+-rw-r--r--   0     1001      123     6597 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_statistics.py
+-rw-r--r--   0     1001      123     4130 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_transpose.py
+-rw-r--r--   0     1001      123      771 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_unique.py
+-rw-r--r--   0     1001      123    11644 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_window.py
+-rw-r--r--   0     1001      123     5480 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/operations/test_with_columns.py
+-rw-r--r--   0     1001      123        0 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/streaming/__init__.py
+-rw-r--r--   0     1001      123      196 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/streaming/conftest.py
+-rw-r--r--   0     1001      123      908 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/streaming/test_ooc.py
+-rw-r--r--   0     1001      123    21051 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/streaming/test_streaming.py
+-rw-r--r--   0     1001      123     4831 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_api.py
+-rw-r--r--   0     1001      123     2035 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_arity.py
+-rw-r--r--   0     1001      123    20852 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_cfg.py
+-rw-r--r--   0     1001      123    43560 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_constructors.py
+-rw-r--r--   0     1001      123      454 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_context.py
+-rw-r--r--   0     1001      123     3224 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_cse.py
+-rw-r--r--   0     1001      123     5191 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_datatypes.py
+-rw-r--r--   0     1001      123   117178 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_df.py
+-rw-r--r--   0     1001      123     2741 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_empty.py
+-rw-r--r--   0     1001      123    19268 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_errors.py
+-rw-r--r--   0     1001      123     1391 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_expansion.py
+-rw-r--r--   0     1001      123     2435 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_expr_multi_cols.py
+-rw-r--r--   0     1001      123    32477 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_exprs.py
+-rw-r--r--   0     1001      123     3516 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_fmt.py
+-rw-r--r--   0     1001      123     3512 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_interchange.py
+-rw-r--r--   0     1001      123    38530 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_interop.py
+-rw-r--r--   0     1001      123    48063 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_lazy.py
+-rw-r--r--   0     1001      123     2463 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_polars_import.py
+-rw-r--r--   0     1001      123     4900 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_predicates.py
+-rw-r--r--   0     1001      123     7572 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_projections.py
+-rw-r--r--   0     1001      123    11551 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_queries.py
+-rw-r--r--   0     1001      123     8100 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_rows.py
+-rw-r--r--   0     1001      123    15059 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_schema.py
+-rw-r--r--   0     1001      123    12958 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_selectors.py
+-rw-r--r--   0     1001      123     4107 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_serde.py
+-rw-r--r--   0     1001      123    82889 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_series.py
+-rw-r--r--   0     1001      123      657 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_single.py
+-rw-r--r--   0     1001      123    21587 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_sql.py
+-rw-r--r--   0     1001      123    35314 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/test_testing.py
+-rw-r--r--   0     1001      123       41 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/utils/__init__.py
+-rw-r--r--   0     1001      123      306 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/utils/test_build_info.py
+-rw-r--r--   0     1001      123     2855 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/utils/test_parse_expr_input.py
+-rw-r--r--   0     1001      123      247 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/utils/test_show_versions.py
+-rw-r--r--   0     1001      123     5026 2023-07-12 19:04:05.000000 polars_u64_idx-0.18.7/tests/unit/utils/test_utils.py
+-rw-r--r--   0     1001      123    65129 2023-07-12 19:05:01.000000 polars_u64_idx-0.18.7/Cargo.lock
+-rw-r--r--   0        0        0    14286 1970-01-01 00:00:00.000000 polars_u64_idx-0.18.7/PKG-INFO
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/Cargo.toml` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/Cargo.toml`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/LICENSE` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/base_utc_offset.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/base_utc_offset.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/date.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/date.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/datetime.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/datetime.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/duration.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/duration.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/kernels.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/kernels.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/rolling_window/floats.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/rolling_window/floats.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/rolling_window/ints.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/rolling_window/ints.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/rolling_window/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/rolling_window/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/rolling_window/rolling_kernels/no_nulls.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/rolling_window/rolling_kernels/no_nulls.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/time.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/time.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/utf8/infer.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/utf8/infer.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/utf8/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/utf8/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/utf8/patterns.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/utf8/patterns.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/chunkedarray/utf8/strptime.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/chunkedarray/utf8/strptime.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/date_range.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/date_range.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/dst_offset.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/dst_offset.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/groupby/dynamic.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/groupby/dynamic.rs`

 * *Files 1% similar despite different names*

```diff
@@ -756,25 +756,19 @@
         assert_eq!(max, expected);
 
         let var = unsafe { a.agg_var(&groups, 1) };
         let expected = Series::new(
             "",
             [0.0, 8.0, 4.000000000000002, 6.666666666666667, 24.5, 0.0],
         );
-        assert_eq!(
-            (var - expected).abs().unwrap().lt(1e-12).unwrap().all(),
-            true
-        );
+        assert!((var - expected).abs().unwrap().lt(1e-12).unwrap().all());
 
         let var = unsafe { nulls.agg_var(&groups, 1) };
         let expected = Series::new("", [0.0, 8.0, 8.0, 9.333333333333343, 24.5, 0.0]);
-        assert_eq!(
-            (var - expected).abs().unwrap().lt(1e-12).unwrap().all(),
-            true
-        );
+        assert!((var - expected).abs().unwrap().lt(1e-12).unwrap().all());
 
         let quantile = unsafe { a.agg_quantile(&groups, 0.5, QuantileInterpolOptions::Linear) };
         let expected = Series::new("", [3.0, 5.0, 5.0, 6.0, 5.5, 1.0]);
         assert_eq!(quantile, expected);
 
         let quantile = unsafe { nulls.agg_quantile(&groups, 0.5, QuantileInterpolOptions::Linear) };
         let expected = Series::new("", [3.0, 5.0, 5.0, 7.0, 5.5, 1.0]);
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/lib.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/lib.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/month_end.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/month_end.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/month_start.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/month_start.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/round.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/round.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/series/_trait.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/series/_trait.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/series/implementations/floats.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/series/implementations/floats.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/series/implementations/integers.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/series/implementations/integers.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/series/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/series/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/truncate.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/truncate.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/upsample.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/upsample.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/utils.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/utils.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/windows/bounds.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/windows/bounds.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/windows/calendar.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/windows/calendar.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/windows/duration.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/windows/duration.rs`

 * *Files 1% similar despite different names*

```diff
@@ -334,14 +334,18 @@
         self.months == 0 && self.weeks == 0 && self.days != 0 && self.nsecs == 0
     }
 
     pub fn days(&self) -> i64 {
         self.days
     }
 
+    pub fn is_constant_duration(&self) -> bool {
+        self.months == 0 && self.weeks == 0 && self.days == 0
+    }
+
     /// Returns the nanoseconds from the `Duration` without the weeks or months part.
     pub fn nanoseconds(&self) -> i64 {
         self.nsecs
     }
 
     /// Estimated duration of the window duration. Not a very good one if months != 0.
     #[doc(hidden)]
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/windows/groupby.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/windows/groupby.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/windows/test.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/windows/test.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-time/src/windows/window.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/src/windows/window.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-sql/Cargo.toml` & `polars_u64_idx-0.18.7/local_dependencies/polars-sql/Cargo.toml`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-sql/LICENSE` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-sql/src/context.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-sql/src/context.rs`

 * *Files 0% similar despite different names*

```diff
@@ -473,15 +473,15 @@
             }
             polars_ensure!(
                 ob.nulls_first.is_none(),
                 ComputeError: "nulls first/last is not yet supported",
             );
         }
 
-        Ok(lf.sort_by_exprs(&by, descending, false))
+        Ok(lf.sort_by_exprs(&by, descending, false, false))
     }
 
     fn process_groupby(
         &mut self,
         lf: LazyFrame,
         contains_wildcard: bool,
         groupby_keys: &[Expr],
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-sql/src/functions.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-sql/src/functions.rs`

 * *Files 6% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 use polars_core::prelude::{polars_bail, polars_err, PolarsError, PolarsResult};
 use polars_lazy::dsl::Expr;
 use polars_plan::dsl::count;
 use polars_plan::logical_plan::LiteralValue;
+use polars_plan::prelude::lit;
 use sqlparser::ast::{
     Expr as SqlExpr, Function as SQLFunction, FunctionArg, FunctionArgExpr, Value as SqlValue,
     WindowSpec, WindowType,
 };
 
 use crate::sql_expr::parse_sql_expr;
 use crate::SQLContext;
@@ -141,49 +142,66 @@
     /// ```
     Pow,
     /// SQL 'round' function
     /// ```sql
     /// SELECT ROUND(column_1, 3) from df;
     /// ```
     Round,
+
     // ----
     // String functions
     // ----
+    /// SQL 'ends_with' function
+    /// ```sql
+    /// SELECT ENDS_WITH(column_1, 'a') from df;
+    /// SELECT column_2 from df WHERE ENDS_WITH(column_1, 'a');
+    /// ```
+    EndsWith,
+    /// SQL 'left' function
+    /// ```sql
+    /// SELECT LEFT(column_1, 3) from df;
+    /// ```
+    Left,
     /// SQL 'lower' function
     /// ```sql
     /// SELECT LOWER(column_1) from df;
     /// ```
     Lower,
-    /// SQL 'upper' function
-    /// ```sql
-    /// SELECT UPPER(column_1) from df;
-    /// ```
-    Upper,
     /// SQL 'ltrim' function
     /// ```sql
     /// SELECT LTRIM(column_1) from df;
     /// ```
     LTrim,
+    /// SQL 'regexp_like' function
+    /// ```sql
+    /// SELECT REGEXP_LIKE(column_1,'xyz', 'i') from df;
+    /// ```
+    RegexpLike,
     /// SQL 'rtrim' function
     /// ```sql
     /// SELECT RTRIM(column_1) from df;
     /// ```
     RTrim,
     /// SQL 'starts_with' function
     /// ```sql
     /// SELECT STARTS_WITH(column_1, 'a') from df;
     /// SELECT column_2 from df WHERE STARTS_WITH(column_1, 'a');
     /// ```
     StartsWith,
-    /// SQL 'ends_with' function
+    /// SQL 'substr' function
     /// ```sql
-    /// SELECT ENDS_WITH(column_1, 'a') from df;
-    /// SELECT column_2 from df WHERE ENDS_WITH(column_1, 'a');
+    /// SELECT SUBSTR(column_1, 3, 5) from df;
     /// ```
-    EndsWith,
+    Substring,
+    /// SQL 'upper' function
+    /// ```sql
+    /// SELECT UPPER(column_1) from df;
+    /// ```
+    Upper,
+
     // ----
     // Aggregate functions
     // ----
     /// SQL 'count' function
     /// ```sql
     /// SELECT COUNT(column_1) from df;
     /// SELECT COUNT(*) from df;
@@ -227,14 +245,15 @@
     /// ```
     First,
     /// SQL 'last' function
     /// ```sql
     /// SELECT LAST(column_1) from df;
     /// ```
     Last,
+
     // ----
     // Array functions
     // ----
     /// SQL 'array_length' function
     /// ```sql
     /// SELECT ARRAY_LENGTH(column_1) from df;
     /// ```
@@ -400,48 +419,55 @@
             "ln" => Self::Ln,
             "log" => Self::Log,
             "log10" => Self::Log10,
             "log1p" => Self::Log1p,
             "log2" => Self::Log2,
             "pow" => Self::Pow,
             "round" => Self::Round,
+
             // ----
             // String functions
             // ----
             "ends_with" => Self::EndsWith,
+            "left" => Self::Left,
             "lower" => Self::Lower,
             "ltrim" => Self::LTrim,
+            "regexp_like" => Self::RegexpLike,
             "rtrim" => Self::RTrim,
             "starts_with" => Self::StartsWith,
+            "substr" => Self::Substring,
             "upper" => Self::Upper,
+
             // ----
             // Aggregate functions
             // ----
             "avg" => Self::Avg,
             "count" => Self::Count,
             "first" => Self::First,
             "last" => Self::Last,
             "max" => Self::Max,
             "min" => Self::Min,
             "stddev" | "stddev_samp" => Self::StdDev,
             "sum" => Self::Sum,
             "variance" | "var_samp" => Self::Variance,
+
             // ----
             // Array functions
             // ----
             "array_contains" => Self::ArrayContains,
             "array_get" => Self::ArrayGet,
             "array_length" => Self::ArrayLength,
             "array_lower" => Self::ArrayMin,
             "array_mean" => Self::ArrayMean,
             "array_reverse" => Self::ArrayReverse,
             "array_sum" => Self::ArraySum,
             "array_unique" => Self::ArrayUnique,
             "array_upper" => Self::ArrayMax,
             "unnest" => Self::Explode,
+
             other => polars_bail!(InvalidOperation: "unsupported SQL function: {}", other),
         })
     }
 }
 
 impl SqlFunctionVisitor<'_> {
     pub(crate) fn visit_function(&self) -> PolarsResult<Expr> {
@@ -494,32 +520,85 @@
                     polars_bail!(InvalidOperation:"Invalid number of arguments for Round: {}",function.args.len());
                 },
             },
             // ----
             // String functions
             // ----
             EndsWith => self.visit_binary(|e, s| e.str().ends_with(s)),
+            Left => self.try_visit_binary(|e, length| {
+                Ok(e.str().str_slice(0, match length {
+                    Expr::Literal(LiteralValue::Int64(n)) => Some(n as u64),
+                    _ => {
+                        polars_bail!(InvalidOperation: "Invalid 'length' for Left: {}", function.args[1]);
+                    }
+                }))
+            }),
             Lower => self.visit_unary(|e| e.str().to_lowercase()),
             LTrim => match function.args.len() {
                 1 => self.visit_unary(|e| e.str().lstrip(None)),
                 2 => self.visit_binary(|e, s| e.str().lstrip(Some(s))),
                 _ => polars_bail!(InvalidOperation:
                     "Invalid number of arguments for LTrim: {}",
                     function.args.len()
                 ),
             },
+            RegexpLike => match function.args.len() {
+                2 => self.visit_binary(|e, s| e.str().contains(s, true)),
+                3 => self.try_visit_ternary(|e, pat, flags| {
+                    Ok(e.str().contains(
+                        match (pat, flags) {
+                            (Expr::Literal(LiteralValue::Utf8(s)), Expr::Literal(LiteralValue::Utf8(f))) => {
+                                if f.is_empty() { polars_bail!(InvalidOperation: "Invalid/empty 'flags' for RegexpLike: {}", function.args[2]); };
+                                lit(format!("(?{}){}", f, s))
+                            },
+                            _ => {
+                                polars_bail!(InvalidOperation: "Invalid arguments for RegexpLike: {}, {}", function.args[1], function.args[2]);
+                            },
+                        },
+                        true))
+                }),
+                _ => polars_bail!(InvalidOperation:"Invalid number of arguments for RegexpLike: {}",function.args.len()),
+            },
             RTrim => match function.args.len() {
                 1 => self.visit_unary(|e| e.str().rstrip(None)),
                 2 => self.visit_binary(|e, s| e.str().rstrip(Some(s))),
                 _ => polars_bail!(InvalidOperation:
                     "Invalid number of arguments for RTrim: {}",
                     function.args.len()
                 ),
             },
             StartsWith => self.visit_binary(|e, s| e.str().starts_with(s)),
+            Substring => match function.args.len() {
+                2 => self.try_visit_binary(|e, start| {
+                    Ok(e.str().str_slice(match start {
+                        Expr::Literal(LiteralValue::Int64(n)) => n,
+                        _ => {
+                            polars_bail!(InvalidOperation: "Invalid 'start' for Substring: {}", function.args[1]);
+                        }
+                    }, None))
+                }),
+                3 => self.try_visit_ternary(|e, start, length| {
+                    Ok(e.str().str_slice(
+                        match start {
+                            Expr::Literal(LiteralValue::Int64(n)) => n,
+                            _ => {
+                                polars_bail!(InvalidOperation: "Invalid 'start' for Substring: {}", function.args[1]);
+                            }
+                        }, match length {
+                            Expr::Literal(LiteralValue::Int64(n)) => Some(n as u64),
+                            _ => {
+                                polars_bail!(InvalidOperation: "Invalid 'length' for Substring: {}", function.args[2]);
+                            }
+                        }))
+                }),
+                _ => polars_bail!(InvalidOperation:
+                    "Invalid number of arguments for Substring: {}",
+                    function.args.len()
+                ),
+            }
             Upper => self.visit_unary(|e| e.str().to_uppercase()),
             // ----
             // Aggregate functions
             // ----
             Avg => self.visit_unary(Expr::mean),
             Count => self.visit_count(),
             First => self.visit_unary(Expr::first),
@@ -623,18 +702,43 @@
     fn try_visit_binary<Arg: FromSqlExpr>(
         &self,
         f: impl Fn(Expr, Arg) -> PolarsResult<Expr>,
     ) -> PolarsResult<Expr> {
         let function = self.func;
         let args = extract_args(function);
         match args.as_slice() {
-            [FunctionArgExpr::Expr(sql_expr), FunctionArgExpr::Expr(sql_expr2)] => {
-                let expr = parse_sql_expr(sql_expr, self.ctx)?;
+            [FunctionArgExpr::Expr(sql_expr1), FunctionArgExpr::Expr(sql_expr2)] => {
+                let expr1 = parse_sql_expr(sql_expr1, self.ctx)?;
+                let expr2 = Arg::from_sql_expr(sql_expr2, self.ctx)?;
+                f(expr1, expr2)
+            }
+            _ => self.not_supported_error(),
+        }
+    }
+
+    // fn visit_ternary<Arg: FromSqlExpr>(
+    //     &self,
+    //     f: impl Fn(Expr, Arg, Arg) -> Expr,
+    // ) -> PolarsResult<Expr> {
+    //     self.try_visit_ternary(|e, a1, a2| Ok(f(e, a1, a2)))
+    // }
+
+    fn try_visit_ternary<Arg: FromSqlExpr>(
+        &self,
+        f: impl Fn(Expr, Arg, Arg) -> PolarsResult<Expr>,
+    ) -> PolarsResult<Expr> {
+        let function = self.func;
+        let args = extract_args(function);
+        match args.as_slice() {
+            [FunctionArgExpr::Expr(sql_expr1), FunctionArgExpr::Expr(sql_expr2), FunctionArgExpr::Expr(sql_expr3)] =>
+            {
+                let expr1 = parse_sql_expr(sql_expr1, self.ctx)?;
                 let expr2 = Arg::from_sql_expr(sql_expr2, self.ctx)?;
-                f(expr, expr2)
+                let expr3 = Arg::from_sql_expr(sql_expr3, self.ctx)?;
+                f(expr1, expr2, expr3)
             }
             _ => self.not_supported_error(),
         }
     }
 
     fn visit_count(&self) -> PolarsResult<Expr> {
         let args = extract_args(self.func);
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-sql/src/keywords.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-sql/src/keywords.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-sql/src/sql_expr.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-sql/src/sql_expr.rs`

 * *Files 3% similar despite different names*

```diff
@@ -16,33 +16,39 @@
 
 pub(crate) fn map_sql_polars_datatype(data_type: &SQLDataType) -> PolarsResult<DataType> {
     Ok(match data_type {
         SQLDataType::Array(Some(inner_type)) => {
             DataType::List(Box::new(map_sql_polars_datatype(inner_type)?))
         }
         SQLDataType::BigInt(_) => DataType::Int64,
+        SQLDataType::Binary(_) | SQLDataType::Blob(_) | SQLDataType::Varbinary(_) => {
+            DataType::Binary
+        }
         SQLDataType::Boolean => DataType::Boolean,
         SQLDataType::Char(_)
-        | SQLDataType::Varchar(_)
-        | SQLDataType::Uuid
+        | SQLDataType::CharVarying(_)
+        | SQLDataType::Character(_)
+        | SQLDataType::CharacterVarying(_)
         | SQLDataType::Clob(_)
+        | SQLDataType::String
         | SQLDataType::Text
-        | SQLDataType::String => DataType::Utf8,
+        | SQLDataType::Uuid
+        | SQLDataType::Varchar(_) => DataType::Utf8,
         SQLDataType::Date => DataType::Date,
-        SQLDataType::Double => DataType::Float64,
+        SQLDataType::Double | SQLDataType::DoublePrecision => DataType::Float64,
         SQLDataType::Float(_) => DataType::Float32,
-        SQLDataType::Int(_) => DataType::Int32,
+        SQLDataType::Int(_) | SQLDataType::Integer(_) => DataType::Int32,
         SQLDataType::Interval => DataType::Duration(TimeUnit::Milliseconds),
         SQLDataType::Real => DataType::Float32,
         SQLDataType::SmallInt(_) => DataType::Int16,
         SQLDataType::Time { .. } => DataType::Time,
         SQLDataType::Timestamp { .. } => DataType::Datetime(TimeUnit::Milliseconds, None),
         SQLDataType::TinyInt(_) => DataType::Int8,
         SQLDataType::UnsignedBigInt(_) => DataType::UInt64,
-        SQLDataType::UnsignedInt(_) => DataType::UInt32,
+        SQLDataType::UnsignedInt(_) | SQLDataType::UnsignedInteger(_) => DataType::UInt32,
         SQLDataType::UnsignedSmallInt(_) => DataType::UInt16,
         SQLDataType::UnsignedTinyInt(_) => DataType::UInt8,
 
         _ => polars_bail!(ComputeError: "SQL datatype {:?} is not yet supported", data_type),
     })
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-sql/src/table_functions.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-sql/src/table_functions.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/functions_cumulative.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/functions_cumulative.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/functions_io.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/functions_io.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/functions_math.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/functions_math.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/functions_meta.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/functions_meta.rs`

 * *Files 10% similar despite different names*

```diff
@@ -15,15 +15,15 @@
     context.register("df", lf.clone());
     let sql = r#"EXPLAIN SELECT year, country, MAX(year) FROM df"#;
     let res = context.execute(sql).unwrap();
     let df = res.collect().unwrap();
     let lf = lf.select([col("year"), col("country"), col("year").max()]);
     let expected = lf.describe_optimized_plan().unwrap();
 
-    let expected = expected.split("\n").map(Some).collect::<Vec<_>>();
+    let expected = expected.split('\n').map(Some).collect::<Vec<_>>();
     let actual = df
         .column("Logical Plan")
         .unwrap()
         .utf8()
         .unwrap()
         .into_iter()
         .collect::<Vec<_>>();
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/functions_string.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/functions_string.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/iss_7436.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/iss_7436.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/iss_7437.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/iss_7437.rs`

 * *Files 24% similar despite different names*

```diff
@@ -17,19 +17,19 @@
             r#"
             SELECT "category" as category
             FROM foods
             GROUP BY "category"
     "#,
         )?
         .collect()?
-        .sort(["category"], vec![false])?;
+        .sort(["category"], vec![false], false)?;
 
     let expected = LazyCsvReader::new("../../examples/datasets/foods1.csv")
         .finish()?
         .groupby(vec![col("category").alias("category")])
         .agg(vec![])
         .collect()?
-        .sort(["category"], vec![false])?;
+        .sort(["category"], vec![false], false)?;
 
     assert!(df_sql.frame_equal(&expected));
     Ok(())
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/iss_7440.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/iss_7440.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/iss_8395.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/iss_8395.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/iss_8419.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/iss_8419.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/ops_distinct_on.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/ops_distinct_on.rs`

 * *Files 1% similar despite different names*

```diff
@@ -28,13 +28,14 @@
     let lf = ctx.execute(sql).unwrap();
     let actual = lf.collect().unwrap();
     let expected = df
         .sort_by_exprs(
             vec![col("Name"), col("Record Date")],
             vec![false, true],
             true,
+            false,
         )
         .groupby_stable(vec![col("Name")])
         .agg(vec![col("*").first()]);
     let expected = expected.collect().unwrap();
     assert!(actual.frame_equal(&expected))
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/simple_exprs.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/simple_exprs.rs`

 * *Files 1% similar despite different names*

```diff
@@ -104,24 +104,26 @@
     let mut context = SQLContext::new();
     context.register("df", df.clone().lazy());
     let sql = r#"
         SELECT
             cast(a as FLOAT) as floats,
             cast(a as INT) as ints,
             cast(a as BIGINT) as bigints,
-            cast(a as STRING) as strings
+            cast(a as STRING) as strings,
+            cast(a as BLOB) as binary
         FROM df"#;
     let df_sql = context.execute(sql).unwrap().collect().unwrap();
     let df_pl = df
         .lazy()
         .select(&[
             col("a").cast(DataType::Float32).alias("floats"),
             col("a").cast(DataType::Int32).alias("ints"),
             col("a").cast(DataType::Int64).alias("bigints"),
             col("a").cast(DataType::Utf8).alias("strings"),
+            col("a").cast(DataType::Binary).alias("binary"),
         ])
         .collect()
         .unwrap();
     assert!(df_sql.frame_equal(&df_pl));
 }
 
 #[test]
@@ -490,14 +492,15 @@
             col("calories").max(),
             col("fats_g").min(),
         ])
         .sort_by_exprs(
             vec![col("count"), col("category")],
             vec![false, true],
             false,
+            false,
         )
         .limit(2);
     let expected = expected.collect()?;
     assert!(df_sql.frame_equal(&expected));
     Ok(())
 }
 
@@ -533,20 +536,20 @@
     let expected = df.lazy().select(&[col("a").min()]).collect().unwrap();
     assert!(actual.frame_equal(&expected));
 }
 
 #[test]
 fn test_iss_9471() {
     let sql = r#"
-    SELECT 
+    SELECT
         ABS(a,a,a,a,1,2,3,XYZRandomLetters,"XYZRandomLetters") as "abs",
     FROM df"#;
     let df = df! {
         "a" => [-4, -3, -2, -1, 0, 1, 2, 3, 4],
     }
     .unwrap()
     .lazy();
     let mut context = SQLContext::new();
-    context.register("df", df.clone());
+    context.register("df", df);
     let res = context.execute(sql);
     assert!(res.is_err())
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-sql/tests/statements.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-sql/tests/statements.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-algo/Cargo.toml` & `polars_u64_idx-0.18.7/local_dependencies/polars-algo/Cargo.toml`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-algo/LICENSE` & `polars_u64_idx-0.18.7/local_dependencies/polars-algo/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-algo/src/algo.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/list/iterator.rs`

 * *Files 27% similar despite different names*

```diff
@@ -1,251 +1,237 @@
-use polars_core::error::PolarsResult as Result;
-use polars_core::prelude::*;
-use polars_core::series::IsSorted;
-use polars_lazy::prelude::*;
-use polars_ops::prelude::*;
-
-pub fn hist(s: &Series, bins: Option<&Series>, bin_count: Option<usize>) -> Result<DataFrame> {
-    let breakpoint_str = &"break_point";
-    let s = s.cast(&DataType::Float64)?.sort(false);
-
-    // if the bins are provided, then we can just use them
-    let bins = if let Some(bins_in) = bins {
-        Series::new(breakpoint_str, bins_in).sort(false)
-    } else {
-        // data is sorted, so this is O(1)
-        let start = s.min::<f64>().unwrap().floor() - 1.0;
-        let stop = s.max::<f64>().unwrap().ceil() + 1.0;
-
-        // If bin_count is omitted, default to the difference between start and stop (unit bins)
-        let bin_count = if let Some(bin_count) = bin_count {
-            bin_count
-        } else {
-            (stop - start).round() as usize
-        };
-
-        // Calculate the breakpoints and make the array
-        let interval = (stop - start) / (bin_count as f64);
-        let breaks: Vec<f64> = (0..(bin_count))
-            .map(|b| start + (b as f64) * interval)
-            .collect();
-
-        Series::new(breakpoint_str, breaks)
-    };
-
-    let category_str = "category";
-
-    let (min_value, max_value): (Expr, AnyValue) = match s.dtype() {
-        // Floating point values have a notion of infinity
-        DataType::Float64 => (lit(f64::NEG_INFINITY), AnyValue::Float64(f64::INFINITY)),
-        DataType::Float32 => (lit(f32::NEG_INFINITY), AnyValue::Float32(f32::INFINITY)),
-        // However, integers don't.  So, the best we can do is use the maximum for the type
-        DataType::Int64 => (lit(i64::MIN), AnyValue::Int64(i64::MAX)),
-        DataType::Int32 => (lit(i32::MIN), AnyValue::Int32(i32::MAX)),
-        DataType::Int16 => (lit(i32::MIN), AnyValue::Int16(i16::MAX)),
-        DataType::UInt64 => (lit(u64::MIN), AnyValue::UInt64(u64::MAX)),
-        DataType::UInt32 => (lit(u32::MIN), AnyValue::UInt32(u32::MAX)),
-        DataType::UInt16 => (lit(u32::MIN), AnyValue::UInt16(u16::MAX)),
-        _ => polars_bail!(
-            InvalidOperation:
-            "cannot take histogram of non-numeric types; consider a groupby and count"
-        ),
-    };
-    let mut bins = bins.extend_constant(max_value, 1)?;
-    bins.set_sorted_flag(IsSorted::Ascending);
-
-    let cuts_df = df![
-        breakpoint_str => bins
-    ]?;
-
-    let cuts_df = cuts_df
-        .lazy()
-        .with_column(
-            format_str(
-                "({}, {}]",
-                [
-                    col(breakpoint_str).shift_and_fill(1, min_value),
-                    col(breakpoint_str),
-                ],
-            )?
-            .alias(category_str),
-        )
-        .collect()?;
+use std::marker::PhantomData;
+use std::ptr::NonNull;
 
-    let cuts = cuts_df
-        .lazy()
-        .with_columns([
-            col(category_str).cast(DataType::Categorical(None)),
-            col(breakpoint_str)
-                .cast(s.dtype().to_owned())
-                .set_sorted_flag(IsSorted::Ascending),
-        ])
-        .collect()?;
-
-    let out = s.clone().into_frame().join_asof(
-        &cuts,
-        s.name(),
-        breakpoint_str,
-        AsofStrategy::Forward,
-        None,
-        None,
-    )?;
-
-    let out = out
-        .select(["category", s.name()])?
-        .groupby(["category"])?
-        .count()?;
-
-    cuts.left_join(&out, [category_str], [category_str])?
-        .fill_null(FillNullStrategy::Zero)?
-        .sort(["category"], false)
+use crate::prelude::*;
+use crate::series::unstable::{ArrayBox, UnstableSeries};
+use crate::utils::CustomIterTools;
+
+pub struct AmortizedListIter<'a, I: Iterator<Item = Option<ArrayBox>>> {
+    len: usize,
+    series_container: Box<Series>,
+    inner: NonNull<ArrayRef>,
+    lifetime: PhantomData<&'a ArrayRef>,
+    iter: I,
+    // used only if feature="dtype-struct"
+    #[allow(dead_code)]
+    inner_dtype: DataType,
 }
 
-pub fn qcut(
-    s: &Series,
-    quantiles: &[f64],
-    labels: Option<Vec<&str>>,
-    break_point_label: Option<&str>,
-    category_label: Option<&str>,
-    maintain_order: bool,
-) -> PolarsResult<DataFrame> {
-    let s = s.cast(&DataType::Float64)?;
-
-    // amortize quantile computation
-    let s_sorted = s.sort(false);
-    let ca = s_sorted.f64().unwrap();
-
-    let mut bins = Vec::with_capacity(quantiles.len());
-    for quantile_level in quantiles {
-        if let Some(quantile) = ca.quantile(*quantile_level, QuantileInterpolOptions::Linear)? {
-            bins.push(quantile)
+impl<'a, I: Iterator<Item = Option<ArrayBox>>> AmortizedListIter<'a, I> {
+    pub(crate) fn new(
+        len: usize,
+        series_container: Box<Series>,
+        inner: NonNull<ArrayRef>,
+        iter: I,
+        inner_dtype: DataType,
+    ) -> Self {
+        Self {
+            len,
+            series_container,
+            inner,
+            lifetime: PhantomData,
+            iter,
+            inner_dtype,
         }
     }
+}
 
-    let bins = Series::new("", bins);
-    if maintain_order {
-        cut(
-            &s,
-            bins,
-            labels,
-            break_point_label,
-            category_label,
-            maintain_order,
-        )
-    } else {
-        // already sorted, saves an extra sort
-        cut(
-            &s_sorted,
-            bins,
-            labels,
-            break_point_label,
-            category_label,
-            maintain_order,
-        )
+impl<'a, I: Iterator<Item = Option<ArrayBox>>> Iterator for AmortizedListIter<'a, I> {
+    type Item = Option<UnstableSeries<'a>>;
+
+    fn next(&mut self) -> Option<Self::Item> {
+        self.iter.next().map(|opt_val| {
+            opt_val.map(|array_ref| {
+                #[cfg(feature = "dtype-struct")]
+                // structs arrays are bound to the series not to the arrayref
+                // so we must get a hold to the new array
+                if matches!(self.inner_dtype, DataType::Struct(_)) {
+                    // Safety
+                    // dtype is known
+                    unsafe {
+                        let mut s = Series::from_chunks_and_dtype_unchecked(
+                            "",
+                            vec![array_ref],
+                            &self.inner_dtype.to_physical(),
+                        )
+                        .cast_unchecked(&self.inner_dtype)
+                        .unwrap();
+                        // swap the new series with the container
+                        std::mem::swap(&mut *self.series_container, &mut s);
+                        // return a reference to the container
+                        // this lifetime is now bound to 'a
+                        return UnstableSeries::new(
+                            &mut *(&mut *self.series_container as *mut Series),
+                        );
+                    }
+                }
+
+                // update the inner state
+                unsafe { *self.inner.as_mut() = array_ref };
+
+                // make sure that the length is correct
+                self.series_container._get_inner_mut().compute_len();
+
+                // Safety
+                // we cannot control the lifetime of an iterators `next` method.
+                // but as long as self is alive the reference to the series container is valid
+                let refer = &mut *self.series_container;
+                unsafe {
+                    let s = std::mem::transmute::<&mut Series, &'a mut Series>(refer);
+                    UnstableSeries::new_with_chunk(s, self.inner.as_ref())
+                }
+            })
+        })
+    }
+
+    fn size_hint(&self) -> (usize, Option<usize>) {
+        (self.len, Some(self.len))
     }
 }
 
-pub fn cut(
-    s: &Series,
-    mut bins: Series,
-    labels: Option<Vec<&str>>,
-    break_point_label: Option<&str>,
-    category_label: Option<&str>,
-    maintain_order: bool,
-) -> PolarsResult<DataFrame> {
-    let var_name = s.name();
-    let breakpoint_str = break_point_label.unwrap_or("break_point");
-    let category_str = category_label.unwrap_or("category");
-
-    let bins_len = bins.len();
-
-    bins.rename(breakpoint_str);
-
-    let mut s_bins = bins
-        .cast(&DataType::Float64)
-        .map_err(|_| PolarsError::ComputeError("expected numeric bins".into()))?
-        .extend_constant(AnyValue::Float64(f64::INFINITY), 1)?;
-    s_bins.set_sorted_flag(IsSorted::Ascending);
-    let cuts_df = df![
-        breakpoint_str => s_bins
-    ]?;
-
-    let cuts_df = if let Some(labels) = labels {
-        polars_ensure!(
-            labels.len() == (bins_len + 1),
-            ShapeMismatch: "labels count must equal bins count",
-        );
-        cuts_df
-            .lazy()
-            .with_column(lit(Series::new(category_str, labels)))
-    } else {
-        cuts_df.lazy().with_column(
-            format_str(
-                "({}, {}]",
-                [
-                    col(breakpoint_str).shift_and_fill(1, lit(f64::NEG_INFINITY)),
-                    col(breakpoint_str),
-                ],
-            )?
-            .alias(category_str),
-        )
+// # Safety
+// we correctly implemented size_hint
+unsafe impl<'a, I: Iterator<Item = Option<ArrayBox>>> TrustedLen for AmortizedListIter<'a, I> {}
+
+impl ListChunked {
+    /// This is an iterator over a ListChunked that save allocations.
+    /// A Series is:
+    ///     1. [`Arc<ChunkedArray>`]
+    ///     ChunkedArray is:
+    ///         2. Vec< 3. ArrayRef>
+    ///
+    /// The ArrayRef we indicated with 3. will be updated during iteration.
+    /// The Series will be pinned in memory, saving an allocation for
+    /// 1. Arc<..>
+    /// 2. Vec<...>
+    ///
+    /// # Warning
+    /// Though memory safe in the sense that it will not read unowned memory, UB, or memory leaks
+    /// this function still needs precautions. The returned should never be cloned or taken longer
+    /// than a single iteration, as every call on `next` of the iterator will change the contents of
+    /// that Series.
+    pub fn amortized_iter(&self) -> AmortizedListIter<impl Iterator<Item = Option<ArrayBox>> + '_> {
+        self.amortized_iter_with_name("")
     }
-    .collect()?;
 
-    const ROW_COUNT: &str = "__POLARS_IDX";
+    pub fn amortized_iter_with_name(
+        &self,
+        name: &str,
+    ) -> AmortizedListIter<impl Iterator<Item = Option<ArrayBox>> + '_> {
+        // we create the series container from the inner array
+        // so that the container has the proper dtype.
+        let arr = self.downcast_iter().next().unwrap();
+        let inner_values = arr.values();
+
+        let inner_dtype = self.inner_dtype();
+        let iter_dtype = match inner_dtype {
+            #[cfg(feature = "dtype-struct")]
+            DataType::Struct(_) => inner_dtype.to_physical(),
+            // TODO: figure out how to deal with physical/logical distinction
+            // physical primitives like time, date etc. work
+            // physical nested need more
+            _ => inner_dtype.clone(),
+        };
 
-    let cuts = cuts_df
-        .lazy()
-        .with_columns([col(category_str).cast(DataType::Categorical(None))])
-        .collect()?;
-
-    let mut s = s.cast(&DataType::Float64)?;
-    let valids = if s.null_count() > 0 {
-        let valids = Some(s.is_not_null());
-        s = s.fill_null(FillNullStrategy::MaxBound).unwrap();
-        valids
-    } else {
-        None
-    };
-    let mut frame = s.clone().into_frame();
-
-    if maintain_order {
-        frame = frame.with_row_count(ROW_COUNT, None)?;
-    }
-
-    let mut out = frame.sort(vec![var_name], vec![false])?.join_asof(
-        &cuts,
-        var_name,
-        breakpoint_str,
-        AsofStrategy::Forward,
-        None,
-        None,
-    )?;
-
-    if maintain_order {
-        out = out.sort([ROW_COUNT], false)?.drop(ROW_COUNT).unwrap()
-    };
-
-    if let Some(mut valids) = valids {
-        if !maintain_order {
-            let idx = s.arg_sort(SortOptions {
-                nulls_last: true,
-                ..Default::default()
-            });
-            valids = unsafe { valids.take_unchecked((&idx).into()) };
-        }
+        // Safety:
+        // inner type passed as physical type
+        let series_container = unsafe {
+            Box::new(Series::from_chunks_and_dtype_unchecked(
+                name,
+                vec![inner_values.clone()],
+                &iter_dtype,
+            ))
+        };
+
+        let ptr = series_container.array_ref(0) as *const ArrayRef as *mut ArrayRef;
 
-        let arr = valids.downcast_iter().next().unwrap();
-        let validity = arr.values().clone();
+        AmortizedListIter::new(
+            self.len(),
+            series_container,
+            NonNull::new(ptr).unwrap(),
+            self.downcast_iter().flat_map(|arr| arr.iter()),
+            inner_dtype,
+        )
+    }
 
-        // Safety: we don't change the length/dtype
-        unsafe {
-            for col in out.get_columns_mut() {
-                let mut s = col.rechunk();
-                let chunks = s.chunks_mut();
-                chunks[0] = chunks[0].with_validity(Some(validity.clone()));
-                *col = s;
-            }
+    /// Apply a closure `F` elementwise.
+    #[must_use]
+    pub fn apply_amortized<'a, F>(&'a self, mut f: F) -> Self
+    where
+        F: FnMut(UnstableSeries<'a>) -> Series,
+    {
+        if self.is_empty() {
+            return self.clone();
         }
+        let mut fast_explode = self.null_count() == 0;
+        let mut ca: ListChunked = self
+            .amortized_iter()
+            .map(|opt_v| {
+                opt_v.map(|v| {
+                    let out = f(v);
+                    if out.is_empty() {
+                        fast_explode = false;
+                    }
+                    out
+                })
+            })
+            .collect_trusted();
+
+        ca.rename(self.name());
+        if fast_explode {
+            ca.set_fast_explode();
+        }
+        ca
+    }
+
+    pub fn try_apply_amortized<'a, F>(&'a self, mut f: F) -> PolarsResult<Self>
+    where
+        F: FnMut(UnstableSeries<'a>) -> PolarsResult<Series>,
+    {
+        if self.is_empty() {
+            return Ok(self.clone());
+        }
+        let mut fast_explode = self.null_count() == 0;
+        let mut ca: ListChunked = self
+            .amortized_iter()
+            .map(|opt_v| {
+                opt_v
+                    .map(|v| {
+                        let out = f(v);
+                        if let Ok(out) = &out {
+                            if out.is_empty() {
+                                fast_explode = false
+                            }
+                        };
+                        out
+                    })
+                    .transpose()
+            })
+            .collect::<PolarsResult<_>>()?;
+        ca.rename(self.name());
+        if fast_explode {
+            ca.set_fast_explode();
+        }
+        Ok(ca)
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+    use crate::chunked_array::builder::get_list_builder;
+
+    #[test]
+    fn test_iter_list() {
+        let mut builder = get_list_builder(&DataType::Int32, 10, 10, "").unwrap();
+        builder.append_series(&Series::new("", &[1, 2, 3])).unwrap();
+        builder.append_series(&Series::new("", &[3, 2, 1])).unwrap();
+        builder.append_series(&Series::new("", &[1, 1])).unwrap();
+        let ca = builder.finish();
+
+        ca.amortized_iter()
+            .zip(ca.into_iter())
+            .for_each(|(s1, s2)| {
+                assert!(s1.unwrap().as_ref().series_equal(&s2.unwrap()));
+            });
     }
-    Ok(out)
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/Cargo.toml` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/Cargo.toml`

 * *Files 2% similar despite different names*

```diff
@@ -46,15 +46,16 @@
 performant = ["polars-core/performant", "fused"]
 big_idx = ["polars-core/bigidx"]
 round_series = []
 is_first = []
 is_unique = []
 approx_unique = []
 fused = []
-cutqcut = ["dtype-categorical"]
+cutqcut = ["dtype-categorical", "dtype-struct"]
+rle = ["dtype-struct"]
 
 # extra utilities for BinaryChunked
 binary_encoding = ["base64", "hex"]
 string_encoding = ["base64", "hex"]
 
 # ops
 to_dummies = []
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/LICENSE` & `polars_u64_idx-0.18.7/local_dependencies/polars/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/array/min_max.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/array/min_max.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/array/namespace.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/array/namespace.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/array/sum_mean.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/array/sum_mean.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/binary/namespace.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/binary/namespace.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/interpolate.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/interpolate.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/list/any_all.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/list/any_all.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/list/count.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/list/count.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/list/hash.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/list/hash.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/list/min_max.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/list/min_max.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/list/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/list/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/list/namespace.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/list/namespace.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/list/sets.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/list/sets.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/list/sum_mean.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/list/sum_mean.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/list/to_struct.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/list/to_struct.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/nan_propagating_aggregate.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/nan_propagating_aggregate.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/set.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/set.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/strings/case.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/strings/case.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/strings/json_path.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/strings/json_path.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/strings/justify.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/strings/justify.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/strings/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/strings/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/strings/namespace.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/strings/namespace.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/strings/replace.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/strings/replace.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/chunked_array/top_k.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/chunked_array/top_k.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/frame/join/merge_sorted.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/frame/join/merge_sorted.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/frame/join/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/frame/join/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/frame/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/frame/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/frame/pivot/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/frame/pivot/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/frame/pivot/positioning.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/frame/pivot/positioning.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/approx_algo/hyperloglogplus.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/approx_algo/hyperloglogplus.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/approx_unique.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/approx_unique.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/arg_min_max.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/arg_min_max.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/cut.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/floor_divide.rs`

 * *Files 23% similar despite different names*

```diff
@@ -1,100 +1,119 @@
-use std::iter::once;
-
+use arrow::array::{Array, PrimitiveArray};
+use num::NumCast;
+use polars_arrow::prelude::ArrayRef;
+use polars_arrow::utils::combine_validities_and;
+use polars_core::datatypes::PolarsNumericType;
+use polars_core::export::num;
 use polars_core::prelude::*;
+#[cfg(feature = "dtype-struct")]
+use polars_core::series::arithmetic::_struct_arithmetic;
+use polars_core::utils::align_chunks_binary;
+use polars_core::with_match_physical_numeric_polars_type;
+
+#[inline]
+fn floor_div_element<T: NumericNative>(a: T, b: T) -> T {
+    // Safety: the casts of those primitives always succeed
+    unsafe {
+        let a: f64 = NumCast::from(a).unwrap_unchecked();
+        let b: f64 = NumCast::from(b).unwrap_unchecked();
 
-pub fn cut(
-    s: &Series,
-    breaks: Vec<f64>,
-    labels: Option<Vec<String>>,
-    left_closed: bool,
-) -> PolarsResult<Series> {
-    polars_ensure!(!breaks.is_empty(), ShapeMismatch: "Breaks are empty");
-    polars_ensure!(!breaks.iter().any(|x| x.is_nan()), ComputeError: "Breaks cannot be NaN");
-    // Breaks must be sorted to cut inputs properly.
-    let mut breaks = breaks;
-    let sorted_breaks = breaks.as_mut_slice();
-    sorted_breaks.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap());
-    polars_ensure!(sorted_breaks.windows(2).all(|x| x[0] != x[1]), Duplicate: "Breaks are not unique");
-
-    polars_ensure!(sorted_breaks[0] > f64::NEG_INFINITY, ComputeError: "Don't include -inf in breaks");
-    polars_ensure!(sorted_breaks[sorted_breaks.len() - 1] < f64::INFINITY, ComputeError: "Don't include inf in breaks");
-
-    let cutlabs = match labels {
-        Some(ll) => {
-            polars_ensure!(ll.len() == sorted_breaks.len() + 1, ShapeMismatch: "Provide nbreaks + 1 labels");
-            ll
-        }
-        None => (once(&f64::NEG_INFINITY).chain(sorted_breaks.iter()))
-            .zip(sorted_breaks.iter().chain(once(&f64::INFINITY)))
-            .map(|v| {
-                if left_closed {
-                    format!("[{}, {})", v.0, v.1)
-                } else {
-                    format!("({}, {}]", v.0, v.1)
-                }
-            })
-            .collect::<Vec<String>>(),
-    };
-
-    let cl: Vec<&str> = cutlabs.iter().map(String::as_str).collect();
-    let s_flt = s.cast(&DataType::Float64)?;
-    let bin_iter = s_flt.f64()?.into_iter();
+        let out = (a / b).floor();
+        let out: T = NumCast::from(out).unwrap_unchecked();
+        out
+    }
+}
 
-    let out_name = format!("{}_bin", s.name());
-    let mut bld = CategoricalChunkedBuilder::new(&out_name, s.len());
-    unsafe {
-        if left_closed {
-            bld.drain_iter(bin_iter.map(|opt| {
-                opt.map(|x| *cl.get_unchecked(sorted_breaks.partition_point(|&v| x >= v)))
-            }));
-        } else {
-            bld.drain_iter(bin_iter.map(|opt| {
-                opt.map(|x| *cl.get_unchecked(sorted_breaks.partition_point(|&v| x > v)))
-            }));
-        }
+fn floor_div_array<T: NumericNative>(
+    a: &PrimitiveArray<T>,
+    b: &PrimitiveArray<T>,
+) -> PrimitiveArray<T> {
+    assert_eq!(a.len(), b.len());
+
+    if a.null_count() == 0 && b.null_count() == 0 {
+        let values = a
+            .values()
+            .as_slice()
+            .iter()
+            .copied()
+            .zip(b.values().as_slice().iter().copied())
+            .map(|(a, b)| floor_div_element(a, b))
+            .collect::<Vec<_>>();
+
+        let validity = combine_validities_and(a.validity(), b.validity());
+
+        PrimitiveArray::new(a.data_type().clone(), values.into(), validity)
+    } else {
+        let iter = a
+            .into_iter()
+            .zip(b.into_iter())
+            .map(|(opt_a, opt_b)| match (opt_a, opt_b) {
+                (Some(&a), Some(&b)) => Some(floor_div_element(a, b)),
+                _ => None,
+            });
+        PrimitiveArray::from_trusted_len_iter(iter)
     }
-    Ok(bld.finish().into_series())
 }
 
-pub fn qcut(
-    s: &Series,
-    probs: Vec<f64>,
-    labels: Option<Vec<String>>,
-    left_closed: bool,
-    allow_duplicates: bool,
-) -> PolarsResult<Series> {
-    let s = s.cast(&DataType::Float64)?;
-    let s2 = s.sort(false);
-    let ca = s2.f64()?;
-    let f = |&p| {
-        ca.quantile(p, QuantileInterpolOptions::Linear)
-            .unwrap()
-            .unwrap()
-    };
-    let mut qbreaks: Vec<_> = probs.iter().map(f).collect();
-    qbreaks.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap());
-
-    // When probs are spaced too closely for the number of repeated values in the distribution
-    // some quantiles may be duplicated. The only thing to do if we want to go on, is to drop
-    // the repeated values and live with some bins being larger than intended.
-    if allow_duplicates {
-        let lfilt = match labels {
-            None => None,
-            Some(ll) => {
-                polars_ensure!(ll.len() == qbreaks.len() + 1,
-                    ShapeMismatch: "Wrong number of labels");
-                let blen = ll.len();
-                Some(
-                    ll.into_iter()
-                        .enumerate()
-                        .filter(|(i, _)| *i == 0 || *i == blen || qbreaks[*i] != qbreaks[i - 1])
-                        .unzip::<_, _, Vec<_>, Vec<_>>()
-                        .1,
-                )
+fn floor_div_ca<T: PolarsNumericType>(a: &ChunkedArray<T>, b: &ChunkedArray<T>) -> ChunkedArray<T> {
+    if a.len() == 1 {
+        let name = a.name();
+        return if let Some(a) = a.get(0) {
+            let mut out = if b.null_count() == 0 {
+                b.apply(|b| floor_div_element(a, b))
+            } else {
+                b.apply_on_opt(|b| b.map(|b| floor_div_element(a, b)))
+            };
+            out.rename(name);
+            out
+        } else {
+            ChunkedArray::full_null(a.name(), b.len())
+        };
+    }
+    if b.len() == 1 {
+        return if let Some(b) = b.get(0) {
+            if a.null_count() == 0 {
+                a.apply(|a| floor_div_element(a, b))
+            } else {
+                a.apply_on_opt(|a| a.map(|a| floor_div_element(a, b)))
             }
+        } else {
+            ChunkedArray::full_null(a.name(), a.len())
         };
-        qbreaks.dedup();
-        return cut(&s, qbreaks, lfilt, left_closed);
     }
-    cut(&s, qbreaks, labels, left_closed)
+    let (a, b) = align_chunks_binary(a, b);
+
+    let chunks = a
+        .downcast_iter()
+        .zip(b.downcast_iter())
+        .map(|(a, b)| Box::new(floor_div_array(a, b)) as ArrayRef)
+        .collect();
+
+    // safety: same dtypes
+    unsafe { ChunkedArray::from_chunks(a.name(), chunks) }
+}
+
+pub fn floor_div_series(a: &Series, b: &Series) -> PolarsResult<Series> {
+    match (a.dtype(), b.dtype()) {
+        #[cfg(feature = "dtype-struct")]
+        (DataType::Struct(_), DataType::Struct(_)) => {
+            return Ok(_struct_arithmetic(a, b, |a, b| {
+                floor_div_series(a, b).unwrap()
+            }))
+        }
+        _ => {}
+    }
+
+    let logical_type = a.dtype();
+
+    let a = a.to_physical_repr();
+    let b = b.to_physical_repr();
+
+    let out = with_match_physical_numeric_polars_type!(a.dtype(), |$T| {
+        let a: &ChunkedArray<$T> = a.as_ref().as_ref().as_ref();
+        let b: &ChunkedArray<$T> = b.as_ref().as_ref().as_ref();
+
+        floor_div_ca(a, b).into_series()
+    });
+
+    out.cast(logical_type)
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/fused.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/fused.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/is_first.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/is_first.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/is_unique.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/is_unique.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/log.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/log.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/mod.rs`

 * *Files 3% similar despite different names*

```diff
@@ -10,14 +10,16 @@
 mod fused;
 #[cfg(feature = "is_first")]
 mod is_first;
 #[cfg(feature = "is_unique")]
 mod is_unique;
 #[cfg(feature = "log")]
 mod log;
+#[cfg(feature = "rle")]
+mod rle;
 #[cfg(feature = "rolling_window")]
 mod rolling;
 #[cfg(feature = "search_sorted")]
 mod search_sorted;
 #[cfg(feature = "to_dummies")]
 mod to_dummies;
 mod various;
@@ -35,14 +37,16 @@
 #[cfg(feature = "is_first")]
 pub use is_first::*;
 #[cfg(feature = "is_unique")]
 pub use is_unique::*;
 #[cfg(feature = "log")]
 pub use log::*;
 use polars_core::prelude::*;
+#[cfg(feature = "rle")]
+pub use rle::*;
 #[cfg(feature = "rolling_window")]
 pub use rolling::*;
 #[cfg(feature = "search_sorted")]
 pub use search_sorted::*;
 #[cfg(feature = "to_dummies")]
 pub use to_dummies::*;
 pub use various::*;
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/rolling.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/rolling.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/search_sorted.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/search_sorted.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/to_dummies.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/to_dummies.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-ops/src/series/ops/various.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/src/series/ops/various.rs`

 * *Files 15% similar despite different names*

```diff
@@ -13,15 +13,15 @@
         // we need to sort here as well in case of `maintain_order` because duplicates behavior is undefined
         let groups = s.group_tuples(multithreaded, sorted)?;
         let values = unsafe { s.agg_first(&groups) };
         let counts = groups.group_lengths("counts");
         let cols = vec![values, counts.into_series()];
         let df = DataFrame::new_no_checks(cols);
         if sorted {
-            df.sort(["counts"], true)
+            df.sort(["counts"], true, false)
         } else {
             Ok(df)
         }
     }
 
     #[cfg(feature = "hash")]
     fn hash(&self, build_hasher: ahash::RandomState) -> UInt64Chunked {
@@ -35,28 +35,46 @@
                 let mut h = vec![];
                 s.0.vec_hash(build_hasher, &mut h).unwrap();
                 UInt64Chunked::from_vec(s.name(), h)
             }
         }
     }
 
-    fn is_sorted(&self, options: SortOptions) -> bool {
+    fn is_sorted(&self, options: SortOptions) -> PolarsResult<bool> {
         let s = self.as_series();
 
         // fast paths
         if (options.descending
             && options.nulls_last
             && matches!(s.is_sorted_flag(), IsSorted::Descending))
             || (!options.descending
                 && !options.nulls_last
                 && matches!(s.is_sorted_flag(), IsSorted::Ascending))
         {
-            return true;
+            return Ok(true);
+        }
+        let nc = s.null_count();
+        let slen = s.len() - nc - 1; // Number of comparisons we might have to do
+        if nc == s.len() {
+            // All nulls is all equal
+            return Ok(true);
+        }
+        if nc > 0 {
+            let nulls = s.chunks().iter().flat_map(|c| c.validity().unwrap());
+            let mut npairs = nulls.clone().zip(nulls.skip(1));
+            // A null never precedes (follows) a non-null iff all nulls are at the end (beginning)
+            if (options.nulls_last && npairs.any(|(a, b)| !a && b)) || npairs.any(|(a, b)| a && !b)
+            {
+                return Ok(false);
+            }
+        }
+        // Compare adjacent elements with no-copy slices that don't include any nulls
+        let offset = !options.nulls_last as i64 * nc as i64;
+        let (s1, s2) = (s.slice(offset, slen), s.slice(offset + 1, slen));
+        match options.descending {
+            true => Ok(Series::gt_eq(&s1, &s2)?.all()),
+            false => Ok(Series::lt_eq(&s1, &s2)?.all()),
         }
-
-        // TODO! optimize
-        let out = s.sort_with(options);
-        out.eq(s)
     }
 }
 
 impl SeriesMethods for Series {}
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-row/Cargo.toml` & `polars_u64_idx-0.18.7/local_dependencies/polars-row/Cargo.toml`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-row/LICENSE` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-row/src/decode.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-row/src/decode.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-row/src/encode.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-row/src/encode.rs`

 * *Files 4% similar despite different names*

```diff
@@ -296,15 +296,15 @@
 }
 
 #[cfg(test)]
 mod test {
     use arrow::array::{Int32Array, Utf8Array};
 
     use super::*;
-    use crate::variable::{BLOCK_SIZE, EMPTY_SENTINEL, NON_EMPTY_SENTINEL};
+    use crate::variable::{decode_binary, BLOCK_SIZE, EMPTY_SENTINEL, NON_EMPTY_SENTINEL};
 
     #[test]
     fn test_fixed_and_variable_encode() {
         let a = Int32Array::from_vec(vec![1, 2, 3]);
         let b = Int32Array::from_vec(vec![213, 12, 12]);
         let c = Utf8Array::<i64>::from_iter([Some("a"), Some(""), Some("meep")]);
 
@@ -358,8 +358,31 @@
             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,
         ];
         assert_eq!(row4, expected);
         let row5 = rows_encoded.get(4);
         let expected = &[0u8];
         assert_eq!(row5, expected);
     }
+
+    #[test]
+    fn test_str_encode_block_size() {
+        // create a key of exactly block size
+        // and check the round trip
+        let mut val = String::new();
+        for i in 0..BLOCK_SIZE {
+            val.push(char::from_u32(i as u32).unwrap())
+        }
+
+        let a = [val.as_str(), val.as_str(), val.as_str()];
+
+        let field = SortField {
+            descending: false,
+            nulls_last: false,
+        };
+        let arr = BinaryArray::<i64>::from_iter_values(a.iter());
+        let rows_encoded = convert_columns_no_order(&[arr.clone().boxed()]);
+
+        let mut rows = rows_encoded.iter().collect::<Vec<_>>();
+        let decoded = unsafe { decode_binary(&mut rows, &field) };
+        assert_eq!(decoded, arr);
+    }
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-row/src/fixed.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-row/src/fixed.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-row/src/lib.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-row/src/lib.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-row/src/row.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-row/src/row.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-row/src/utils.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-row/src/utils.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-row/src/variable.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-row/src/variable.rs`

 * *Files 3% similar despite different names*

```diff
@@ -73,16 +73,14 @@
         Some(val) if val.is_empty() => {
             let byte = if field.descending {
                 !EMPTY_SENTINEL
             } else {
                 EMPTY_SENTINEL
             };
             *out.get_unchecked_release_mut(0) = MaybeUninit::new(byte);
-            // write remainder as zeros
-            out.get_unchecked_release_mut(1..).fill(MaybeUninit::new(0));
             1
         }
         Some(val) => {
             let block_count = ceil(val.len(), BLOCK_SIZE);
             let end_offset = 1 + block_count * (BLOCK_SIZE + 1);
 
             let dst = out.get_unchecked_release_mut(..end_offset);
@@ -102,25 +100,25 @@
                 // we copy src.len() that leaves 1 bytes for the continuation tkn.
                 std::ptr::copy_nonoverlapping(src.as_ptr(), dst.as_mut_ptr(), src.len());
                 // Indicate that there are further blocks to follow
                 *dst.get_unchecked_release_mut(BLOCK_SIZE) =
                     MaybeUninit::new(BLOCK_CONTINUATION_TOKEN);
             }
 
+            // exactly BLOCK_SIZE bytes
+            // this means we only need to set the length
+            // all other bytes are already initialized
             if src_remainder.is_empty() {
-                // get the last block
-                let start_offset = 1 + (block_count - 1) * (BLOCK_SIZE + 1);
-                let last_dst = dst.get_unchecked_release_mut(start_offset..);
-                last_dst.fill(MaybeUninit::new(0));
-
                 // overwrite the latest continuation marker.
                 // replace the "there is another block" with
                 // "we are finished this, this is the length of this block"
                 *dst.last_mut().unwrap_unchecked() = MaybeUninit::new(BLOCK_SIZE as u8);
-            } else {
+            }
+            // there are remainder bytes
+            else {
                 // get the last block
                 let start_offset = 1 + (block_count - 1) * (BLOCK_SIZE + 1);
                 let last_dst = dst.get_unchecked_release_mut(start_offset..);
                 let n_bytes_to_write = src_remainder.len();
 
                 std::ptr::copy_nonoverlapping(
                     src_remainder.as_ptr(),
@@ -139,16 +137,16 @@
                     *byte = MaybeUninit::new(!byte.assume_init());
                 }
             }
             end_offset
         }
         None => {
             *out.get_unchecked_release_mut(0) = MaybeUninit::new(get_null_sentinel(field));
-            // write remainder as zeros
-            out.get_unchecked_release_mut(1..).fill(MaybeUninit::new(0));
+            // // write remainder as zeros
+            // out.get_unchecked_release_mut(1..).fill(MaybeUninit::new(0));
             1
         }
     }
 }
 pub(crate) unsafe fn encode_iter<'a, I: Iterator<Item = Option<&'a [u8]>>>(
     input: I,
     out: &mut RowsEncoded,
@@ -157,14 +155,18 @@
     out.values.set_len(0);
     let values = out.values.spare_capacity_mut();
     for (offset, opt_value) in out.offsets.iter_mut().skip(1).zip(input) {
         let dst = values.get_unchecked_release_mut(*offset..);
         let written_len = encode_one(dst, opt_value.map(|v| v.as_uninit()), field);
         *offset += written_len;
     }
+    let offset = out.offsets.last().unwrap();
+    let dst = values.get_unchecked_release_mut(*offset..);
+    // write remainder as zeros
+    dst.fill(MaybeUninit::new(0));
     out.values.set_len(out.values.capacity())
 }
 
 unsafe fn has_nulls(rows: &[&[u8]], null_sentinel: u8) -> bool {
     rows.iter()
         .any(|row| *row.get_unchecked(0) == null_sentinel)
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/Cargo.toml` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/Cargo.toml`

 * *Files 2% similar despite different names*

```diff
@@ -126,14 +126,15 @@
   "polars-io/serde",
   "polars-ops/serde",
 ]
 fused = ["polars-plan/fused", "polars-ops/fused"]
 list_sets = ["polars-plan/list_sets", "polars-ops/list_sets"]
 list_any_all = ["polars-ops/list_any_all", "polars-plan/list_any_all"]
 cutqcut = ["polars-plan/cutqcut", "polars-ops/cutqcut"]
+rle = ["polars-plan/rle", "polars-ops/rle"]
 
 binary_encoding = ["polars-plan/binary_encoding"]
 
 bigidx = ["polars-plan/bigidx"]
 
 panic_on_schema = ["polars-plan/panic_on_schema"]
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/LICENSE` & `polars_u64_idx-0.18.7/local_dependencies/polars-ops/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/dot.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/dot.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/dsl/eval.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/dsl/eval.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/dsl/functions.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/dsl/functions.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/dsl/list.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/dsl/list.rs`

 * *Files 2% similar despite different names*

```diff
@@ -152,22 +152,22 @@
                 match e {
                     #[cfg(feature = "dtype-categorical")]
                     Expr::Cast {
                         data_type: DataType::Categorical(_),
                         ..
                     } => {
                         polars_bail!(
-                            ComputeError: "casting to categorical not allowed in `arr.eval`"
+                            ComputeError: "casting to categorical not allowed in `list.eval`"
                         )
                     }
                     Expr::Column(name) => {
                         polars_ensure!(
                             name.is_empty(),
                             ComputeError:
-                            "named columns are not allowed in `arr.eval`; consider using `element` or `col(\"\")`"
+                            "named columns are not allowed in `list.eval`; consider using `element` or `col(\"\")`"
                         );
                     }
                     _ => {}
                 }
             }
             let lst = s.list()?.clone();
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/dsl/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/dsl/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/frame/anonymous_scan.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/frame/anonymous_scan.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/frame/csv.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/frame/csv.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/frame/file_list_reader.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/frame/file_list_reader.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/frame/ipc.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/frame/ipc.rs`

 * *Files 4% similar despite different names*

```diff
@@ -38,28 +38,32 @@
     }
 }
 
 impl LazyFileListReader for LazyIpcReader {
     fn finish_no_glob(self) -> PolarsResult<LazyFrame> {
         let args = self.args;
         let path = self.path;
+
         let options = IpcScanOptions {
-            n_rows: args.n_rows,
-            cache: args.cache,
-            with_columns: None,
-            row_count: None,
-            rechunk: args.rechunk,
             memmap: args.memmap,
         };
-        let row_count = args.row_count;
-        let mut lf: LazyFrame = LogicalPlanBuilder::scan_ipc(path, options)?.build().into();
+        let mut lf: LazyFrame = LogicalPlanBuilder::scan_ipc(
+            path,
+            options,
+            args.n_rows,
+            args.cache,
+            args.row_count.clone(),
+            args.rechunk,
+        )?
+        .build()
+        .into();
         lf.opt_state.file_caching = true;
 
         // it is a bit hacky, but this row_count function updates the schema
-        if let Some(row_count) = row_count {
+        if let Some(row_count) = args.row_count {
             lf = lf.with_row_count(&row_count.name, Some(row_count.offset))
         }
 
         Ok(lf)
     }
 
     fn path(&self) -> &Path {
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/frame/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/frame/mod.rs`

 * *Files 8% similar despite different names*

```diff
@@ -7,14 +7,15 @@
 mod ndjson;
 #[cfg(feature = "parquet")]
 mod parquet;
 #[cfg(feature = "python")]
 mod python;
 
 mod anonymous_scan;
+mod err;
 mod file_list_reader;
 #[cfg(feature = "pivot")]
 pub mod pivot;
 
 use std::borrow::Cow;
 #[cfg(any(feature = "parquet", feature = "ipc"))]
 use std::path::PathBuf;
@@ -39,14 +40,15 @@
 use polars_plan::global::FETCH_ROWS;
 #[cfg(any(feature = "ipc", feature = "parquet", feature = "csv"))]
 use polars_plan::logical_plan::collect_fingerprints;
 use polars_plan::logical_plan::optimize;
 use polars_plan::utils::expr_to_leaf_column_names;
 use smartstring::alias::String as SmartString;
 
+use crate::fallible;
 use crate::physical_plan::executors::Executor;
 use crate::physical_plan::planner::create_physical_plan;
 use crate::physical_plan::state::ExecutionState;
 #[cfg(feature = "streaming")]
 use crate::physical_plan::streaming::insert_streaming_nodes;
 use crate::prelude::*;
 
@@ -214,19 +216,25 @@
     ///       df.lazy()
     ///         .sort("sepal.width", Default::default())
     /// }
     /// ```
     pub fn sort(self, by_column: &str, options: SortOptions) -> Self {
         let descending = options.descending;
         let nulls_last = options.nulls_last;
+        let maintain_order = options.maintain_order;
 
         let opt_state = self.get_opt_state();
         let lp = self
             .get_plan_builder()
-            .sort(vec![col(by_column)], vec![descending], nulls_last)
+            .sort(
+                vec![col(by_column)],
+                vec![descending],
+                nulls_last,
+                maintain_order,
+            )
             .build();
         Self::from_logical_plan(lp, opt_state)
     }
 
     /// Add a sort operation to the logical plan.
     ///
     /// # Example
@@ -234,64 +242,67 @@
     /// ```rust
     /// use polars_core::prelude::*;
     /// use polars_lazy::prelude::*;
     ///
     /// /// Sort DataFrame by 'sepal.width' column
     /// fn example(df: DataFrame) -> LazyFrame {
     ///       df.lazy()
-    ///         .sort_by_exprs(vec![col("sepal.width")], vec![false], false)
+    ///         .sort_by_exprs(vec![col("sepal.width")], vec![false], false, false)
     /// }
     /// ```
     pub fn sort_by_exprs<E: AsRef<[Expr]>, B: AsRef<[bool]>>(
         self,
         by_exprs: E,
         descending: B,
         nulls_last: bool,
+        maintain_order: bool,
     ) -> Self {
         let by_exprs = by_exprs.as_ref().to_vec();
         let descending = descending.as_ref().to_vec();
         if by_exprs.is_empty() {
             self
         } else {
             let opt_state = self.get_opt_state();
             let lp = self
                 .get_plan_builder()
-                .sort(by_exprs, descending, nulls_last)
+                .sort(by_exprs, descending, nulls_last, maintain_order)
                 .build();
             Self::from_logical_plan(lp, opt_state)
         }
     }
 
     pub fn top_k<E: AsRef<[Expr]>, B: AsRef<[bool]>>(
         self,
         k: IdxSize,
         by_exprs: E,
         descending: B,
         nulls_last: bool,
+        maintain_order: bool,
     ) -> Self {
         let mut descending = descending.as_ref().to_vec();
         // top-k is reverse from sort
         for v in &mut descending {
             *v = !*v;
         }
         // this will optimize to top-k
-        self.sort_by_exprs(by_exprs, descending, nulls_last)
+        self.sort_by_exprs(by_exprs, descending, nulls_last, maintain_order)
             .slice(0, k)
     }
 
     pub fn bottom_k<E: AsRef<[Expr]>, B: AsRef<[bool]>>(
         self,
         k: IdxSize,
         by_exprs: E,
         descending: B,
         nulls_last: bool,
+        maintain_order: bool,
     ) -> Self {
         let descending = descending.as_ref().to_vec();
         // this will optimize to bottom-k
-        self.sort_by_exprs(by_exprs, descending, nulls_last)
+        self.sort_by_exprs(by_exprs, descending, nulls_last, maintain_order)
             .slice(0, k)
     }
 
     /// Reverse the DataFrame
     ///
     /// # Example
     ///
@@ -1088,17 +1099,17 @@
     }
 
     /// Drop null rows.
     ///
     /// Equal to `LazyFrame::filter(col("*").is_not_null())`
     pub fn drop_nulls(self, subset: Option<Vec<Expr>>) -> LazyFrame {
         match subset {
-            None => self.filter(all_exprs([col("*").is_not_null()])),
+            None => self.filter(all_horizontal([col("*").is_not_null()])),
             Some(subset) => {
-                let predicate = all_exprs(
+                let predicate = all_horizontal(
                     subset
                         .into_iter()
                         .map(|e| e.is_not_null())
                         .collect::<Vec<_>>(),
                 );
                 self.filter(predicate)
             }
@@ -1196,77 +1207,48 @@
     /// Add a new column at index 0 that counts the rows.
     ///
     /// # Warning
     /// This can have a negative effect on query performance.
     /// This may for instance block predicate pushdown optimization.
     pub fn with_row_count(mut self, name: &str, offset: Option<IdxSize>) -> LazyFrame {
         let add_row_count_in_map = match &mut self.logical_plan {
-            // Do the row count at scan
-            #[cfg(feature = "csv")]
-            LogicalPlan::CsvScan { options, .. } => {
-                options.row_count = Some(RowCount {
-                    name: name.to_string(),
-                    offset: offset.unwrap_or(0),
-                });
-                false
-            }
-            #[cfg(feature = "ipc")]
-            LogicalPlan::IpcScan { options, .. } => {
-                options.row_count = Some(RowCount {
-                    name: name.to_string(),
-                    offset: offset.unwrap_or(0),
-                });
-                false
-            }
-            #[cfg(feature = "parquet")]
-            LogicalPlan::ParquetScan { options, .. } => {
+            LogicalPlan::Scan {
+                file_options: options,
+                file_info,
+                ..
+            } => {
                 options.row_count = Some(RowCount {
                     name: name.to_string(),
                     offset: offset.unwrap_or(0),
                 });
+                file_info.schema = Arc::new(
+                    file_info
+                        .schema
+                        .new_inserting_at_index(0, name.into(), IDX_DTYPE)
+                        .unwrap(),
+                );
                 false
             }
             _ => true,
         };
 
-        let name2: SmartString = name.into();
-        let udf_schema = move |s: &Schema| {
-            // Can't error, index 0 is always in bounds
-            let new = s
-                .new_inserting_at_index(0, name2.clone(), IDX_DTYPE)
+        if add_row_count_in_map {
+            let schema = fallible!(self.schema(), &self);
+            let schema = schema
+                .new_inserting_at_index(0, name.into(), IDX_DTYPE)
                 .unwrap();
-            Ok(Arc::new(new))
-        };
-
-        let name = name.to_owned();
 
-        // if we do the row count at scan we add a dummy map, to update the schema
-        let opt = if add_row_count_in_map {
-            AllowedOptimizations {
-                slice_pushdown: false,
-                predicate_pushdown: false,
-                streaming: false,
-                ..Default::default()
-            }
+            self.map_private(FunctionNode::RowCount {
+                name: Arc::from(name),
+                offset,
+                schema: Arc::new(schema),
+            })
         } else {
-            AllowedOptimizations::default()
-        };
-
-        self.map(
-            move |df: DataFrame| {
-                if add_row_count_in_map {
-                    df.with_row_count(&name, offset)
-                } else {
-                    Ok(df)
-                }
-            },
-            opt,
-            Some(Arc::new(udf_schema)),
-            Some("WITH ROW COUNT"),
-        )
+            self
+        }
     }
 
     /// Unnest the given `Struct` columns. This means that the fields of the `Struct` type will be
     /// inserted as columns.
     #[cfg(feature = "dtype-struct")]
     pub fn unnest<I: IntoIterator<Item = S>, S: AsRef<str>>(self, cols: I) -> Self {
         self.map_private(FunctionNode::Unnest {
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/frame/ndjson.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/frame/ndjson.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/frame/parquet.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/frame/parquet.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/frame/pivot.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/frame/pivot.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/lib.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/lib.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/cache.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/cache.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/executor.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/executor.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/ext_context.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/ext_context.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/filter.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/filter.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/groupby.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/groupby.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_dynamic.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_dynamic.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_partitioned.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_partitioned.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_rolling.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_rolling.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/join.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/join.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/projection.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/projection.rs`

 * *Files 5% similar despite different names*

```diff
@@ -20,20 +20,20 @@
         #[allow(clippy::let_and_return)]
         let df = evaluate_physical_expressions(&df, &self.expr, state, self.has_windows);
 
         // this only runs during testing and check if the runtime type matches the predicted schema
         #[cfg(test)]
         #[allow(unused_must_use)]
         {
-            // TODO: check also the types.
-            df.as_ref().map(|df| {
+            // TODO: also check the types.
+            if let Ok(df) = df.as_ref() {
                 for (l, r) in df.iter().zip(self.schema.iter_names()) {
                     assert_eq!(l.name(), r);
                 }
-            });
+            }
         }
 
         df
     }
 }
 
 impl Executor for ProjectionExec {
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/python_scan.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/python_scan.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/scan/csv.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/scan/csv.rs`

 * *Files 10% similar despite different names*

```diff
@@ -2,30 +2,31 @@
 
 use super::*;
 
 pub struct CsvExec {
     pub path: PathBuf,
     pub schema: SchemaRef,
     pub options: CsvParserOptions,
+    pub file_options: FileScanOptions,
     pub predicate: Option<Arc<dyn PhysicalExpr>>,
 }
 
 impl CsvExec {
     fn read(&mut self) -> PolarsResult<DataFrame> {
-        let mut with_columns = mem::take(&mut self.options.with_columns);
+        let mut with_columns = mem::take(&mut self.file_options.with_columns);
         let mut projected_len = 0;
         with_columns.as_ref().map(|columns| {
             projected_len = columns.len();
             columns
         });
 
         if projected_len == 0 {
             with_columns = None;
         }
-        let n_rows = _set_n_rows_for_scan(self.options.n_rows);
+        let n_rows = _set_n_rows_for_scan(self.file_options.n_rows);
         let predicate = self.predicate.clone().map(phys_expr_to_io_expr);
 
         CsvReader::from_path(&self.path)
             .unwrap()
             .has_header(self.options.has_header)
             .with_dtypes(Some(self.schema.clone()))
             .with_delimiter(self.options.delimiter)
@@ -37,30 +38,30 @@
             .with_null_values(std::mem::take(&mut self.options.null_values))
             .with_predicate(predicate)
             .with_encoding(CsvEncoding::LossyUtf8)
             .with_comment_char(self.options.comment_char)
             .with_quote_char(self.options.quote_char)
             .with_end_of_line_char(self.options.eol_char)
             .with_encoding(self.options.encoding)
-            .with_rechunk(self.options.rechunk)
-            .with_row_count(std::mem::take(&mut self.options.row_count))
+            .with_rechunk(self.file_options.rechunk)
+            .with_row_count(std::mem::take(&mut self.file_options.row_count))
             .with_try_parse_dates(self.options.try_parse_dates)
             .finish()
     }
 }
 
 impl Executor for CsvExec {
     fn execute(&mut self, state: &mut ExecutionState) -> PolarsResult<DataFrame> {
         let finger_print = FileFingerPrint {
             path: self.path.clone(),
             predicate: self
                 .predicate
                 .as_ref()
                 .map(|ae| ae.as_expression().unwrap().clone()),
-            slice: (self.options.skip_rows, self.options.n_rows),
+            slice: (self.options.skip_rows, self.file_options.n_rows),
         };
 
         let profile_name = if state.has_node_timer() {
             let mut ids = vec![self.path.to_string_lossy().into()];
             if self.predicate.is_some() {
                 ids.push("predicate".into())
             }
@@ -70,13 +71,15 @@
             Cow::Borrowed("")
         };
 
         state.record(
             || {
                 state
                     .file_cache
-                    .read(finger_print, self.options.file_counter, &mut || self.read())
+                    .read(finger_print, self.file_options.file_counter, &mut || {
+                        self.read()
+                    })
             },
             profile_name,
         )
     }
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/scan/ipc.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/sort.rs`

 * *Files 23% similar despite different names*

```diff
@@ -1,64 +1,74 @@
-use std::path::PathBuf;
-
 use super::*;
 
-pub struct IpcExec {
-    pub(crate) path: PathBuf,
-    pub(crate) schema: SchemaRef,
-    pub(crate) predicate: Option<Arc<dyn PhysicalExpr>>,
-    pub(crate) options: IpcScanOptionsInner,
+pub(crate) struct SortExec {
+    pub(crate) input: Box<dyn Executor>,
+    pub(crate) by_column: Vec<Arc<dyn PhysicalExpr>>,
+    pub(crate) args: SortArguments,
 }
 
-impl IpcExec {
-    fn read(&mut self, verbose: bool) -> PolarsResult<DataFrame> {
-        let (file, projection, n_rows, predicate) = prepare_scan_args(
-            &self.path,
-            &self.predicate,
-            &mut self.options.with_columns,
-            &mut self.schema,
-            self.options.n_rows,
-        );
-        IpcReader::new(file)
-            .with_n_rows(n_rows)
-            .with_row_count(std::mem::take(&mut self.options.row_count))
-            .set_rechunk(self.options.rechunk)
-            .with_projection(projection)
-            .memory_mapped(self.options.memmap)
-            .finish_with_scan_ops(predicate, verbose)
+impl SortExec {
+    fn execute_impl(
+        &mut self,
+        state: &mut ExecutionState,
+        mut df: DataFrame,
+    ) -> PolarsResult<DataFrame> {
+        df.as_single_chunk_par();
+
+        let by_columns = self
+            .by_column
+            .iter()
+            .enumerate()
+            .map(|(i, e)| {
+                let mut s = e.evaluate(&df, state)?;
+                // polars core will try to set the sorted columns as sorted
+                // this should only be done with simple col("foo") expressions
+                // therefore we rename more complex expressions so that
+                // polars core does not match these
+                if !matches!(e.as_expression(), Some(&Expr::Column(_))) {
+                    s.rename(&format!("_POLARS_SORT_BY_{i}"));
+                }
+                Ok(s)
+            })
+            .collect::<PolarsResult<Vec<_>>>()?;
+
+        df.sort_impl(
+            by_columns,
+            std::mem::take(&mut self.args.descending),
+            self.args.nulls_last,
+            self.args.maintain_order,
+            self.args.slice,
+            true,
+        )
     }
 }
 
-impl Executor for IpcExec {
+impl Executor for SortExec {
     fn execute(&mut self, state: &mut ExecutionState) -> PolarsResult<DataFrame> {
-        let finger_print = FileFingerPrint {
-            path: self.path.clone(),
-            predicate: self
-                .predicate
-                .as_ref()
-                .map(|ae| ae.as_expression().unwrap().clone()),
-            slice: (0, self.options.n_rows),
-        };
+        #[cfg(debug_assertions)]
+        {
+            if state.verbose() {
+                println!("run SortExec")
+            }
+        }
+        let df = self.input.execute(state)?;
 
         let profile_name = if state.has_node_timer() {
-            let mut ids = vec![self.path.to_string_lossy().into()];
-            if self.predicate.is_some() {
-                ids.push("predicate".into())
-            }
-            let name = comma_delimited("ipc".to_string(), &ids);
+            let by = self
+                .by_column
+                .iter()
+                .map(|s| Ok(s.to_field(&df.schema())?.name))
+                .collect::<PolarsResult<Vec<_>>>()?;
+            let name = comma_delimited("sort".to_string(), &by);
             Cow::Owned(name)
         } else {
             Cow::Borrowed("")
         };
 
-        state.record(
-            || {
-                state
-                    .file_cache
-                    .read(finger_print, self.options.file_counter, &mut || {
-                        self.read(state.verbose())
-                    })
-            },
-            profile_name,
-        )
+        if state.has_node_timer() {
+            let new_state = state.clone();
+            new_state.record(|| self.execute_impl(state, df), profile_name)
+        } else {
+            self.execute_impl(state, df)
+        }
     }
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/scan/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/scan/mod.rs`

 * *Files 3% similar despite different names*

```diff
@@ -36,24 +36,25 @@
 #[cfg(any(feature = "ipc", feature = "parquet"))]
 fn prepare_scan_args(
     path: &std::path::Path,
     predicate: &Option<Arc<dyn PhysicalExpr>>,
     with_columns: &mut Option<Arc<Vec<String>>>,
     schema: &mut SchemaRef,
     n_rows: Option<usize>,
+    has_row_count: bool,
 ) -> (std::fs::File, Projection, StopNRows, Predicate) {
     let file = std::fs::File::open(path).unwrap();
 
     let with_columns = mem::take(with_columns);
     let schema = mem::take(schema);
 
     let projection: Option<Vec<_>> = with_columns.map(|with_columns| {
         with_columns
             .iter()
-            .map(|name| schema.index_of(name).unwrap())
+            .map(|name| schema.index_of(name).unwrap() - has_row_count as usize)
             .collect()
     });
 
     let n_rows = _set_n_rows_for_scan(n_rows);
     let predicate = predicate.clone().map(phys_expr_to_io_expr);
 
     (file, projection, n_rows, predicate)
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/scan/ndjson.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/scan/ndjson.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/scan/parquet.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/scan/ipc.rs`

 * *Files 25% similar despite different names*

```diff
@@ -1,84 +1,66 @@
 use std::path::PathBuf;
 
-use polars_core::cloud::CloudOptions;
-
 use super::*;
 
-#[allow(dead_code)]
-pub struct ParquetExec {
-    path: PathBuf,
-    schema: SchemaRef,
-    predicate: Option<Arc<dyn PhysicalExpr>>,
-    options: ParquetOptions,
-    cloud_options: Option<CloudOptions>,
+pub struct IpcExec {
+    pub(crate) path: PathBuf,
+    pub(crate) schema: SchemaRef,
+    pub(crate) predicate: Option<Arc<dyn PhysicalExpr>>,
+    pub(crate) options: IpcScanOptions,
+    pub(crate) file_options: FileScanOptions,
 }
 
-impl ParquetExec {
-    pub(crate) fn new(
-        path: PathBuf,
-        schema: SchemaRef,
-        predicate: Option<Arc<dyn PhysicalExpr>>,
-        options: ParquetOptions,
-        cloud_options: Option<CloudOptions>,
-    ) -> Self {
-        ParquetExec {
-            path,
-            schema,
-            predicate,
-            options,
-            cloud_options,
-        }
-    }
-
-    fn read(&mut self) -> PolarsResult<DataFrame> {
+impl IpcExec {
+    fn read(&mut self, verbose: bool) -> PolarsResult<DataFrame> {
         let (file, projection, n_rows, predicate) = prepare_scan_args(
             &self.path,
             &self.predicate,
-            &mut self.options.with_columns,
+            &mut self.file_options.with_columns,
             &mut self.schema,
-            self.options.n_rows,
+            self.file_options.n_rows,
+            self.file_options.row_count.is_some(),
         );
-
-        ParquetReader::new(file)
+        IpcReader::new(file)
             .with_n_rows(n_rows)
-            .read_parallel(self.options.parallel)
-            .with_row_count(mem::take(&mut self.options.row_count))
-            .set_rechunk(self.options.rechunk)
-            .set_low_memory(self.options.low_memory)
-            .use_statistics(self.options.use_statistics)
-            ._finish_with_scan_ops(predicate, projection.as_ref().map(|v| v.as_ref()))
+            .with_row_count(std::mem::take(&mut self.file_options.row_count))
+            .set_rechunk(self.file_options.rechunk)
+            .with_projection(projection)
+            .memory_mapped(self.options.memmap)
+            .finish_with_scan_ops(predicate, verbose)
     }
 }
 
-impl Executor for ParquetExec {
+impl Executor for IpcExec {
     fn execute(&mut self, state: &mut ExecutionState) -> PolarsResult<DataFrame> {
         let finger_print = FileFingerPrint {
             path: self.path.clone(),
             predicate: self
                 .predicate
                 .as_ref()
                 .map(|ae| ae.as_expression().unwrap().clone()),
-            slice: (0, self.options.n_rows),
+            slice: (0, self.file_options.n_rows),
         };
 
         let profile_name = if state.has_node_timer() {
             let mut ids = vec![self.path.to_string_lossy().into()];
             if self.predicate.is_some() {
                 ids.push("predicate".into())
             }
-            let name = comma_delimited("parquet".to_string(), &ids);
+            let name = comma_delimited("ipc".to_string(), &ids);
             Cow::Owned(name)
         } else {
             Cow::Borrowed("")
         };
 
         state.record(
             || {
                 state
                     .file_cache
-                    .read(finger_print, self.options.file_counter, &mut || self.read())
+                    .read(finger_print, self.file_options.file_counter, &mut || {
+                        self.read(state.verbose())
+                    })
             },
             profile_name,
         )
     }
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/slice.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/slice.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/sort.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/alias.rs`

 * *Files 27% similar despite different names*

```diff
@@ -1,73 +1,102 @@
-use super::*;
+use std::sync::Arc;
 
-pub(crate) struct SortExec {
-    pub(crate) input: Box<dyn Executor>,
-    pub(crate) by_column: Vec<Arc<dyn PhysicalExpr>>,
-    pub(crate) args: SortArguments,
+use polars_core::frame::groupby::GroupsProxy;
+use polars_core::prelude::*;
+
+use crate::physical_plan::state::ExecutionState;
+use crate::prelude::*;
+
+pub struct AliasExpr {
+    pub(crate) physical_expr: Arc<dyn PhysicalExpr>,
+    pub(crate) name: Arc<str>,
+    expr: Expr,
 }
 
-impl SortExec {
-    fn execute_impl(
-        &mut self,
-        state: &mut ExecutionState,
-        mut df: DataFrame,
-    ) -> PolarsResult<DataFrame> {
-        df.as_single_chunk_par();
-
-        let by_columns = self
-            .by_column
-            .iter()
-            .enumerate()
-            .map(|(i, e)| {
-                let mut s = e.evaluate(&df, state)?;
-                // polars core will try to set the sorted columns as sorted
-                // this should only be done with simple col("foo") expressions
-                // therefore we rename more complex expressions so that
-                // polars core does not match these
-                if !matches!(e.as_expression(), Some(&Expr::Column(_))) {
-                    s.rename(&format!("_POLARS_SORT_BY_{i}"));
-                }
-                Ok(s)
-            })
-            .collect::<PolarsResult<Vec<_>>>()?;
-
-        df.sort_impl(
-            by_columns,
-            std::mem::take(&mut self.args.descending),
-            self.args.nulls_last,
-            self.args.slice,
-            true,
-        )
+impl AliasExpr {
+    pub fn new(physical_expr: Arc<dyn PhysicalExpr>, name: Arc<str>, expr: Expr) -> Self {
+        Self {
+            physical_expr,
+            name,
+            expr,
+        }
+    }
+    fn finish(&self, mut input: Series) -> Series {
+        input.rename(&self.name);
+        input
     }
 }
 
-impl Executor for SortExec {
-    fn execute(&mut self, state: &mut ExecutionState) -> PolarsResult<DataFrame> {
-        #[cfg(debug_assertions)]
-        {
-            if state.verbose() {
-                println!("run SortExec")
-            }
-        }
-        let df = self.input.execute(state)?;
+impl PhysicalExpr for AliasExpr {
+    fn as_expression(&self) -> Option<&Expr> {
+        Some(&self.expr)
+    }
 
-        let profile_name = if state.has_node_timer() {
-            let by = self
-                .by_column
-                .iter()
-                .map(|s| Ok(s.to_field(&df.schema())?.name))
-                .collect::<PolarsResult<Vec<_>>>()?;
-            let name = comma_delimited("sort".to_string(), &by);
-            Cow::Owned(name)
-        } else {
-            Cow::Borrowed("")
-        };
+    fn evaluate(&self, df: &DataFrame, state: &ExecutionState) -> PolarsResult<Series> {
+        let series = self.physical_expr.evaluate(df, state)?;
+        Ok(self.finish(series))
+    }
 
-        if state.has_node_timer() {
-            let new_state = state.clone();
-            new_state.record(|| self.execute_impl(state, df), profile_name)
+    #[allow(clippy::ptr_arg)]
+    fn evaluate_on_groups<'a>(
+        &self,
+        df: &DataFrame,
+        groups: &'a GroupsProxy,
+        state: &ExecutionState,
+    ) -> PolarsResult<AggregationContext<'a>> {
+        let mut ac = self.physical_expr.evaluate_on_groups(df, groups, state)?;
+        let s = ac.take();
+        let s = self.finish(s);
+
+        if ac.is_literal() {
+            ac.with_literal(s);
         } else {
-            self.execute_impl(state, df)
+            ac.with_series(s, ac.is_aggregated(), Some(&self.expr))?;
         }
+        Ok(ac)
+    }
+
+    fn to_field(&self, input_schema: &Schema) -> PolarsResult<Field> {
+        Ok(Field::new(
+            &self.name,
+            self.physical_expr
+                .to_field(input_schema)?
+                .data_type()
+                .clone(),
+        ))
+    }
+
+    fn as_partitioned_aggregator(&self) -> Option<&dyn PartitionedAggregation> {
+        Some(self)
+    }
+    fn is_valid_aggregation(&self) -> bool {
+        self.physical_expr.is_valid_aggregation()
+    }
+}
+
+impl PartitionedAggregation for AliasExpr {
+    fn evaluate_partitioned(
+        &self,
+        df: &DataFrame,
+        groups: &GroupsProxy,
+        state: &ExecutionState,
+    ) -> PolarsResult<Series> {
+        let agg = self.physical_expr.as_partitioned_aggregator().unwrap();
+        agg.evaluate_partitioned(df, groups, state).map(|mut s| {
+            s.rename(&self.name);
+            s
+        })
+    }
+
+    fn finalize(
+        &self,
+        partitioned: Series,
+        groups: &GroupsProxy,
+        state: &ExecutionState,
+    ) -> PolarsResult<Series> {
+        let agg = self.physical_expr.as_partitioned_aggregator().unwrap();
+        agg.finalize(partitioned, groups, state).map(|mut s| {
+            s.rename(&self.name);
+            s
+        })
     }
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/stack.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/stack.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/udf.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/udf.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/union.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/union.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/executors/unique.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/executors/unique.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/exotic.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/exotic.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/aggregation.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/aggregation.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/alias.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/cache.rs`

 * *Files 18% similar despite different names*

```diff
@@ -1,102 +1,89 @@
-use std::sync::Arc;
+use super::*;
 
-use polars_core::frame::groupby::GroupsProxy;
-use polars_core::prelude::*;
-
-use crate::physical_plan::state::ExecutionState;
-use crate::prelude::*;
-
-pub struct AliasExpr {
+pub struct CacheExpr {
     pub(crate) physical_expr: Arc<dyn PhysicalExpr>,
-    pub(crate) name: Arc<str>,
     expr: Expr,
+    id: usize,
 }
 
-impl AliasExpr {
-    pub fn new(physical_expr: Arc<dyn PhysicalExpr>, name: Arc<str>, expr: Expr) -> Self {
+impl CacheExpr {
+    pub fn new(physical_expr: Arc<dyn PhysicalExpr>, expr: Expr, id: usize) -> Self {
         Self {
             physical_expr,
-            name,
             expr,
+            id,
         }
     }
-    fn finish(&self, mut input: Series) -> Series {
-        input.rename(&self.name);
-        input
-    }
 }
 
-impl PhysicalExpr for AliasExpr {
+impl PhysicalExpr for CacheExpr {
     fn as_expression(&self) -> Option<&Expr> {
         Some(&self.expr)
     }
 
     fn evaluate(&self, df: &DataFrame, state: &ExecutionState) -> PolarsResult<Series> {
-        let series = self.physical_expr.evaluate(df, state)?;
-        Ok(self.finish(series))
+        if let Some(cached) = state.get_expr_cache(self.id) {
+            let mut hit = true;
+            let out = cached
+                .get_or_try_init(|| {
+                    hit = false;
+                    self.physical_expr.evaluate(df, state)
+                })
+                .cloned();
+            if state.verbose() {
+                if hit {
+                    eprintln!("cache hit: {:?}", self.expr)
+                } else {
+                    eprintln!("cache miss: {:?}", self.expr)
+                }
+            }
+            out
+        } else {
+            self.physical_expr.evaluate(df, state)
+        }
     }
 
     #[allow(clippy::ptr_arg)]
     fn evaluate_on_groups<'a>(
         &self,
         df: &DataFrame,
         groups: &'a GroupsProxy,
         state: &ExecutionState,
     ) -> PolarsResult<AggregationContext<'a>> {
-        let mut ac = self.physical_expr.evaluate_on_groups(df, groups, state)?;
-        let s = ac.take();
-        let s = self.finish(s);
-
-        if ac.is_literal() {
-            ac.with_literal(s);
+        if let Some(cached) = state.get_expr_cache(self.id) {
+            let mut hit = true;
+            let aggregated = cached
+                .get_or_try_init(|| {
+                    let mut agg = self.physical_expr.evaluate_on_groups(df, groups, state)?;
+                    hit = false;
+                    PolarsResult::Ok(agg.aggregated())
+                })?
+                .clone();
+            if state.verbose() {
+                if hit {
+                    eprintln!("cache hit: {:?}", self.expr)
+                } else {
+                    eprintln!("cache miss: {:?}", self.expr)
+                }
+            }
+            Ok(AggregationContext::new(
+                aggregated,
+                Cow::Borrowed(groups),
+                true,
+            ))
         } else {
-            ac.with_series(s, ac.is_aggregated(), Some(&self.expr))?;
+            self.physical_expr.evaluate_on_groups(df, groups, state)
         }
-        Ok(ac)
     }
 
     fn to_field(&self, input_schema: &Schema) -> PolarsResult<Field> {
-        Ok(Field::new(
-            &self.name,
-            self.physical_expr
-                .to_field(input_schema)?
-                .data_type()
-                .clone(),
-        ))
+        self.physical_expr.to_field(input_schema)
     }
 
     fn as_partitioned_aggregator(&self) -> Option<&dyn PartitionedAggregation> {
-        Some(self)
+        None
     }
     fn is_valid_aggregation(&self) -> bool {
         self.physical_expr.is_valid_aggregation()
     }
 }
-
-impl PartitionedAggregation for AliasExpr {
-    fn evaluate_partitioned(
-        &self,
-        df: &DataFrame,
-        groups: &GroupsProxy,
-        state: &ExecutionState,
-    ) -> PolarsResult<Series> {
-        let agg = self.physical_expr.as_partitioned_aggregator().unwrap();
-        agg.evaluate_partitioned(df, groups, state).map(|mut s| {
-            s.rename(&self.name);
-            s
-        })
-    }
-
-    fn finalize(
-        &self,
-        partitioned: Series,
-        groups: &GroupsProxy,
-        state: &ExecutionState,
-    ) -> PolarsResult<Series> {
-        let agg = self.physical_expr.as_partitioned_aggregator().unwrap();
-        agg.finalize(partitioned, groups, state).map(|mut s| {
-            s.rename(&self.name);
-            s
-        })
-    }
-}
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/apply.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/apply.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/binary.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/binary.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/cast.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/cast.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/column.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/column.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/count.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/count.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/filter.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/filter.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/group_iter.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/group_iter.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/literal.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/literal.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/slice.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/slice.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/sort.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/sort.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/sortby.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/sortby.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/take.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/take.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/ternary.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/ternary.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/expressions/window.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/expressions/window.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/file_cache.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/file_cache.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/node_timer.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/node_timer.rs`

 * *Files 5% similar despite different names*

```diff
@@ -53,11 +53,14 @@
         let end: NoNull<UInt64Chunked> = ticks
             .iter()
             .map(|(_, end)| (end.duration_since(self.query_start)).as_micros() as u64)
             .collect();
         let mut end = end.into_inner();
         end.rename("end");
 
-        DataFrame::new_no_checks(vec![nodes_s, start.into_series(), end.into_series()])
-            .sort(vec!["start"], vec![false])
+        DataFrame::new_no_checks(vec![nodes_s, start.into_series(), end.into_series()]).sort(
+            vec!["start"],
+            vec![false],
+            false,
+        )
     }
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/planner/expr.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/planner/expr.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/planner/lp.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/planner/lp.rs`

 * *Files 2% similar despite different names*

```diff
@@ -171,95 +171,66 @@
                 create_physical_expr(predicate, Context::Default, expr_arena, None, &mut state)?;
             Ok(Box::new(executors::FilterExec::new(
                 predicate,
                 input,
                 state.has_windows,
             )))
         }
-        #[cfg(feature = "csv")]
-        CsvScan {
+        Scan {
             path,
             file_info,
             output_schema,
-            options,
+            scan_type,
             predicate,
-        } => {
-            let predicate = predicate
-                .map(|pred| {
-                    create_physical_expr(
-                        pred,
-                        Context::Default,
-                        expr_arena,
-                        output_schema.as_ref(),
-                        &mut Default::default(),
-                    )
-                })
-                .map_or(Ok(None), |v| v.map(Some))?;
-            Ok(Box::new(executors::CsvExec {
-                path,
-                schema: file_info.schema,
-                options,
-                predicate,
-            }))
-        }
-        #[cfg(feature = "ipc")]
-        IpcScan {
-            path,
-            file_info,
-            output_schema,
-            predicate,
-            options,
+            file_options,
         } => {
             let predicate = predicate
                 .map(|pred| {
                     create_physical_expr(
                         pred,
                         Context::Default,
                         expr_arena,
                         output_schema.as_ref(),
                         &mut Default::default(),
                     )
                 })
                 .map_or(Ok(None), |v| v.map(Some))?;
 
-            Ok(Box::new(executors::IpcExec {
-                path,
-                schema: file_info.schema,
-                predicate,
-                options,
-            }))
-        }
-        #[cfg(feature = "parquet")]
-        ParquetScan {
-            path,
-            file_info,
-            output_schema,
-            predicate,
-            options,
-            cloud_options,
-        } => {
-            let predicate = predicate
-                .map(|pred| {
-                    create_physical_expr(
-                        pred,
-                        Context::Default,
-                        expr_arena,
-                        output_schema.as_ref(),
-                        &mut Default::default(),
-                    )
-                })
-                .map_or(Ok(None), |v| v.map(Some))?;
-
-            Ok(Box::new(executors::ParquetExec::new(
-                path,
-                file_info.schema,
-                predicate,
-                options,
-                cloud_options,
-            )))
+            match scan_type {
+                #[cfg(feature = "csv")]
+                FileScan::Csv {
+                    options: csv_options,
+                } => Ok(Box::new(executors::CsvExec {
+                    path,
+                    schema: file_info.schema,
+                    options: csv_options,
+                    predicate,
+                    file_options,
+                })),
+                #[cfg(feature = "ipc")]
+                FileScan::Ipc { options } => Ok(Box::new(executors::IpcExec {
+                    path,
+                    schema: file_info.schema,
+                    predicate,
+                    options,
+                    file_options,
+                })),
+                #[cfg(feature = "parquet")]
+                FileScan::Parquet {
+                    options,
+                    cloud_options,
+                } => Ok(Box::new(executors::ParquetExec::new(
+                    path,
+                    file_info.schema,
+                    predicate,
+                    options,
+                    cloud_options,
+                    file_options,
+                ))),
+            }
         }
         Projection {
             expr,
             input,
             schema: _schema,
             ..
         } => {
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/state.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/state.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/streaming/checks.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/streaming/checks.rs`

 * *Files 9% similar despite different names*

```diff
@@ -1,15 +1,22 @@
 use polars_core::prelude::{JoinArgs, JoinType};
 use polars_plan::prelude::*;
 
 pub(super) fn is_streamable_sort(args: &SortArguments) -> bool {
-    // check if slice is positive
-    match args.slice {
-        Some((offset, _)) => offset >= 0,
-        None => true,
+    // check if slice is positive or maintain order is true
+    match args {
+        SortArguments {
+            maintain_order: true,
+            ..
+        } => false,
+        SortArguments {
+            slice: Some((offset, _)),
+            ..
+        } => *offset >= 0,
+        SortArguments { slice: None, .. } => true,
     }
 }
 
 pub(super) fn is_streamable(node: Node, expr_arena: &Arena<AExpr>, context: Context) -> bool {
     // check whether leaf column is Col or Lit
     let mut seen_column = false;
     let mut seen_lit_range = false;
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/streaming/construct_pipeline.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/streaming/construct_pipeline.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/streaming/convert_alp.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/streaming/convert_alp.rs`

 * *Files 3% similar despite different names*

```diff
@@ -197,33 +197,32 @@
                         scratch,
                         &mut pipeline_trees,
                         lp,
                         &mut insert_file_sink_ptr,
                     )
                 }
             }
-            #[cfg(feature = "csv")]
-            CsvScan { options, .. } => {
+            Scan {
+                file_options: options,
+                scan_type,
+                ..
+            } if scan_type.streamable() => {
                 if state.streamable {
-                    // the batched csv reader doesn't stop exactly at n_rows
-                    if let Some(n_rows) = options.n_rows {
-                        insert_slice(root, 0, n_rows as IdxSize, lp_arena, &mut state);
+                    #[cfg(feature = "csv")]
+                    if matches!(scan_type, FileScan::Csv { .. }) {
+                        // the batched csv reader doesn't stop exactly at n_rows
+                        if let Some(n_rows) = options.n_rows {
+                            insert_slice(root, 0, n_rows as IdxSize, lp_arena, &mut state);
+                        }
                     }
 
                     state.sources.push(root);
                     pipeline_trees[current_idx].push(state)
                 }
             }
-            #[cfg(feature = "parquet")]
-            ParquetScan { .. } => {
-                if state.streamable {
-                    state.sources.push(root);
-                    pipeline_trees[current_idx].push(state)
-                }
-            }
             DataFrameScan { .. } => {
                 if state.streamable {
                     state.sources.push(root);
                     pipeline_trees[current_idx].push(state)
                 }
             }
             Join {
@@ -263,28 +262,19 @@
                 stack.push((input_right, state_right, current_idx));
             }
             // add globbing patterns
             #[cfg(any(feature = "csv", feature = "parquet"))]
             Union { inputs, options }
                 if options.slice.is_none()
                     && inputs.iter().all(|node| match lp_arena.get(*node) {
-                        #[cfg(feature = "parquet")]
-                        ParquetScan { .. } => true,
-                        #[cfg(feature = "csv")]
-                        CsvScan { .. } => true,
+                        Scan { .. } => true,
                         MapFunction {
                             input,
                             function: FunctionNode::Rechunk,
-                        } => match lp_arena.get(*input) {
-                            #[cfg(feature = "parquet")]
-                            ParquetScan { .. } => true,
-                            #[cfg(feature = "csv")]
-                            CsvScan { .. } => true,
-                            _ => false,
-                        },
+                        } => matches!(lp_arena.get(*input), Scan { .. }),
                         _ => false,
                     }) =>
             {
                 state.sources.push(root);
                 pipeline_trees[current_idx].push(state);
             }
             Union {
@@ -342,14 +332,15 @@
                 state.streamable = true;
                 state.operators_sinks.push(PipelineNode::Sink(root));
                 stack.push((*input, state, current_idx))
             }
             #[allow(unused_variables)]
             lp @ Aggregate {
                 input,
+                keys,
                 aggs,
                 maintain_order: false,
                 apply: None,
                 schema,
                 options,
                 ..
             } => {
@@ -375,26 +366,42 @@
                 #[cfg(feature = "dynamic_groupby")]
                 {
                     if options.rolling.is_some() || options.dynamic.is_some() {
                         can_stream = false
                     }
                 }
 
-                if can_stream
-                    && aggs.iter().all(|node| {
+                let valid_agg = || {
+                    aggs.iter().all(|node| {
                         polars_pipe::pipeline::can_convert_to_hash_agg(
                             *node,
                             expr_arena,
                             &input_schema,
                         )
                     })
-                    && schema
+                };
+
+                let valid_key = || {
+                    keys.iter().all(|node| {
+                        expr_arena
+                            .get(*node)
+                            .get_type(schema, Context::Default, expr_arena)
+                            // ensure we don't groupby list
+                            .map(|dt| !matches!(dt, DataType::List(_)))
+                            .unwrap_or(false)
+                    })
+                };
+
+                let valid_types = || {
+                    schema
                         .iter_dtypes()
                         .all(|dt| allowed_dtype(dt, string_cache))
-                {
+                };
+
+                if can_stream && valid_agg() && valid_key() && valid_types() {
                     state.streamable = true;
                     state.operators_sinks.push(PipelineNode::Sink(root));
                     stack.push((*input, state, current_idx))
                 } else if allow_partial {
                     process_non_streamable_node(
                         &mut current_idx,
                         &mut state,
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/physical_plan/streaming/tree.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/physical_plan/streaming/tree.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/prelude.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/prelude.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/aggregations.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/aggregations.rs`

 * *Files 2% similar despite different names*

```diff
@@ -95,15 +95,14 @@
 
 #[test]
 #[cfg(feature = "moment")]
 fn test_auto_skew_kurtosis_agg() -> PolarsResult<()> {
     let df = fruits_cars();
 
     let out = df
-        .clone()
         .lazy()
         .groupby([col("fruits")])
         .agg([
             col("B").skew(false).alias("bskew"),
             col("B").kurtosis(false, false).alias("bkurt"),
         ])
         .collect()?;
@@ -439,14 +438,15 @@
             col("book")
                 .take(
                     col("count")
                         .arg_sort(SortOptions {
                             descending: true,
                             nulls_last: false,
                             multithreaded: true,
+                            maintain_order: false,
                         })
                         .head(Some(2)),
                 )
                 .alias("ordered"),
         ])
         .sort("user", Default::default())
         .collect()?;
@@ -477,14 +477,15 @@
         .clone()
         .lazy()
         .select([col("A")
             .arg_sort(SortOptions {
                 descending: true,
                 nulls_last: false,
                 multithreaded: true,
+                maintain_order: false,
             })
             .take(lit(0))])
         .collect()?;
 
     let a = out.column("A")?;
     let a = a.idx()?;
     assert_eq!(a.get(0), Some(4));
@@ -494,43 +495,45 @@
         .lazy()
         .groupby_stable([col("cars")])
         .agg([col("A")
             .arg_sort(SortOptions {
                 descending: true,
                 nulls_last: false,
                 multithreaded: true,
+                maintain_order: false,
             })
             .take(lit(0))])
         .collect()?;
 
     let out = out.column("A")?;
     let out = out.idx()?;
     assert_eq!(Vec::from(out), &[Some(3), Some(0)]);
 
     let out_df = df
-        .clone()
         .lazy()
         .groupby_stable([col("cars")])
         .agg([
             col("A"),
             col("A")
                 .arg_sort(SortOptions {
                     descending: true,
                     nulls_last: false,
                     multithreaded: true,
+                    maintain_order: false,
                 })
                 .take(lit(0))
                 .alias("1"),
             col("A")
                 .take(
                     col("A")
                         .arg_sort(SortOptions {
                             descending: true,
                             nulls_last: false,
                             multithreaded: true,
+                            maintain_order: false,
                         })
                         .take(lit(0)),
                 )
                 .alias("2"),
         ])
         .collect()?;
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/arity.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/arity.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/cse.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/cse.rs`

 * *Files 1% similar despite different names*

```diff
@@ -10,15 +10,15 @@
     }
 }
 
 #[test]
 fn test_cse_self_joins() -> PolarsResult<()> {
     let lf = scan_foods_ipc();
 
-    let lf = lf.clone().with_column(col("category").str().to_uppercase());
+    let lf = lf.with_column(col("category").str().to_uppercase());
 
     let lf = lf
         .clone()
         .left_join(lf, col("fats_g"), col("fats_g"))
         .with_common_subplan_elimination(true);
 
     cached_before_root(lf);
@@ -44,16 +44,16 @@
     .with_common_subplan_elimination(true);
 
     let (mut expr_arena, mut lp_arena) = get_arenas();
     let lp = lf.clone().optimize(&mut lp_arena, &mut expr_arena).unwrap();
     assert!((&lp_arena).iter(lp).all(|(_, lp)| {
         use ALogicalPlan::*;
         match lp {
-            IpcScan { options, .. } => {
-                if let Some(columns) = &options.with_columns {
+            Scan { file_options, .. } => {
+                if let Some(columns) = &file_options.with_columns {
                     columns.len() == 2
                 } else {
                     false
                 }
             }
             _ => true,
         }
@@ -70,18 +70,15 @@
         "a" => [1],
         "b" => [2],
         "c" => [3],
     ]?
     .lazy();
 
     let q1 = q.clone().filter(col("a").eq(lit(1))).select([col("a")]);
-    let q2 = q
-        .clone()
-        .filter(col("a").eq(lit(1)))
-        .select([col("a"), col("b")]);
+    let q2 = q.filter(col("a").eq(lit(1))).select([col("a"), col("b")]);
     let q = q1
         .left_join(q2, col("a"), col("a"))
         .with_common_subplan_elimination(true);
 
     // check that the projection of a is not done before the cache
     let (mut expr_arena, mut lp_arena) = get_arenas();
     let lp = q.optimize(&mut lp_arena, &mut expr_arena).unwrap();
@@ -170,15 +167,15 @@
 
     let z = df![
         "a"=> [1],
     ]?
     .lazy();
 
     let a = x.left_join(z.clone(), col("a"), col("a"));
-    let b = y.left_join(z.clone(), col("a"), col("a"));
+    let b = y.left_join(z, col("a"), col("a"));
     let c = a.join(
         b,
         &[col("a"), col("b")],
         &[col("a"), col("b")],
         JoinType::Left.into(),
     );
 
@@ -235,15 +232,15 @@
         .join(
             lf1.clone().filter(col("x").neq(lit(8))),
             [col("id")],
             [col("id")],
             JoinType::Semi.into(),
         )
         .join(
-            lf1.clone().filter(col("x").neq(lit(8))),
+            lf1.filter(col("x").neq(lit(8))),
             [col("id")],
             [col("id")],
             JoinType::Semi.into(),
         );
 
     let q = q.with_common_subplan_elimination(true);
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/io.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/io.rs`

 * *Files 1% similar despite different names*

```diff
@@ -220,23 +220,23 @@
     let df = lf.clone().collect()?;
     assert_eq!(df.shape(), (100, 4));
     let df = LazyCsvReader::new(glob).finish()?.slice(20, 60).collect()?;
     assert!(full_df.slice(20, 60).frame_equal(&df));
 
     let mut expr_arena = Arena::with_capacity(16);
     let mut lp_arena = Arena::with_capacity(8);
-    let node = lf.clone().optimize(&mut lp_arena, &mut expr_arena)?;
-    assert!(slice_at_union(&mut lp_arena, node));
+    let node = lf.optimize(&mut lp_arena, &mut expr_arena)?;
+    assert!(slice_at_union(&lp_arena, node));
 
     let lf = LazyCsvReader::new(glob)
         .finish()?
         .filter(col("sugars_g").lt(lit(1i32)))
         .slice(0, 100);
     let node = lf.optimize(&mut lp_arena, &mut expr_arena)?;
-    assert!(slice_at_union(&mut lp_arena, node));
+    assert!(slice_at_union(&lp_arena, node));
 
     Ok(())
 }
 
 #[test]
 #[cfg(not(target_os = "windows"))]
 #[cfg(feature = "json")]
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/logical.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/logical.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/optimization_checks.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/optimization_checks.rs`

 * *Files 12% similar despite different names*

```diff
@@ -2,62 +2,43 @@
 
 pub(crate) fn row_count_at_scan(q: LazyFrame) -> bool {
     let (mut expr_arena, mut lp_arena) = get_arenas();
     let lp = q.optimize(&mut lp_arena, &mut expr_arena).unwrap();
 
     (&lp_arena).iter(lp).any(|(_, lp)| {
         use ALogicalPlan::*;
-        match lp {
-            CsvScan {
-                options:
-                    CsvParserOptions {
-                        row_count: Some(_), ..
-                    },
-                ..
-            }
-            | ParquetScan {
-                options:
-                    ParquetOptions {
-                        row_count: Some(_), ..
-                    },
+        matches!(
+            lp,
+            Scan {
+                file_options: FileScanOptions {
+                    row_count: Some(_),
+                    ..
+                },
                 ..
             }
-            | IpcScan {
-                options:
-                    IpcScanOptionsInner {
-                        row_count: Some(_), ..
-                    },
-                ..
-            } => true,
-            _ => false,
-        }
+        )
     })
 }
 
 pub(crate) fn predicate_at_scan(q: LazyFrame) -> bool {
     let (mut expr_arena, mut lp_arena) = get_arenas();
     let lp = q.optimize(&mut lp_arena, &mut expr_arena).unwrap();
 
     (&lp_arena).iter(lp).any(|(_, lp)| {
         use ALogicalPlan::*;
-        match lp {
+        matches!(
+            lp,
             DataFrameScan {
-                selection: Some(_), ..
-            }
-            | CsvScan {
-                predicate: Some(_), ..
-            }
-            | ParquetScan {
-                predicate: Some(_), ..
+                selection: Some(_),
+                ..
+            } | Scan {
+                predicate: Some(_),
+                ..
             }
-            | IpcScan {
-                predicate: Some(_), ..
-            } => true,
-            _ => false,
-        }
+        )
     })
 }
 
 pub(crate) fn is_pipeline(q: LazyFrame) -> bool {
     let (mut expr_arena, mut lp_arena) = get_arenas();
     let lp = q.optimize(&mut lp_arena, &mut expr_arena).unwrap();
     matches!(
@@ -85,17 +66,15 @@
 
 fn slice_at_scan(q: LazyFrame) -> bool {
     let (mut expr_arena, mut lp_arena) = get_arenas();
     let lp = q.optimize(&mut lp_arena, &mut expr_arena).unwrap();
     (&lp_arena).iter(lp).any(|(_, lp)| {
         use ALogicalPlan::*;
         match lp {
-            CsvScan { options, .. } => options.n_rows.is_some(),
-            ParquetScan { options, .. } => options.n_rows.is_some(),
-            IpcScan { options, .. } => options.n_rows.is_some(),
+            Scan { file_options, .. } => file_options.n_rows.is_some(),
             _ => false,
         }
     })
 }
 
 #[test]
 fn test_pred_pd_1() -> PolarsResult<()> {
@@ -527,22 +506,22 @@
     let q = df.lazy().with_column(col("c0")).select([col("c1")]);
 
     let lp = q.clone().optimize(&mut lp_arena, &mut expr_arena).unwrap();
 
     // check if with_column is pruned
     assert!((&lp_arena).iter(lp).all(|(_, lp)| {
         use ALogicalPlan::*;
-        match lp {
+
+        matches!(
+            lp,
             ALogicalPlan::MapFunction {
                 function: FunctionNode::FastProjection { .. },
                 ..
-            }
-            | DataFrameScan { .. } => true,
-            _ => false,
-        }
+            } | DataFrameScan { .. }
+        )
     }));
     assert_eq!(
         q.schema().unwrap().as_ref(),
         &Schema::from_iter([Field::new("c1", DataType::Int32)])
     );
     Ok(())
 }
@@ -575,16 +554,16 @@
 
     let args = UnionArgs {
         rechunk: false,
         parallel: true,
         ..Default::default()
     };
     let lf2 = concat(&[lf.clone(), lf.clone()], args).unwrap();
-    let lf3 = concat(&[lf.clone(), lf.clone(), lf.clone()], args).unwrap();
-    let lf4 = concat(&[lf2.clone(), lf3], args).unwrap();
+    let lf3 = concat(&[lf.clone(), lf.clone(), lf], args).unwrap();
+    let lf4 = concat(&[lf2, lf3], args).unwrap();
     let root = lf4.optimize(&mut lp_arena, &mut expr_arena).unwrap();
     let lp = lp_arena.get(root);
     match lp {
         ALogicalPlan::Union { inputs, .. } => {
             // we make sure that the nested unions are flattened into a single union
             assert_eq!(inputs.len(), 5);
         }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/predicate_queries.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/predicate_queries.rs`

 * *Files 3% similar despite different names*

```diff
@@ -53,15 +53,15 @@
         .clone()
         .with_column(extract.clone())
         .filter(predicate.clone())
         .collect()?;
 
     assert_eq!(out.shape(), (2, 2));
 
-    let out = base.clone().select([extract]).filter(predicate).collect()?;
+    let out = base.select([extract]).filter(predicate).collect()?;
     assert_eq!(out.shape(), (2, 1));
 
     Ok(())
 }
 
 #[test]
 fn test_pass_unrelated_apply() -> PolarsResult<()> {
@@ -103,15 +103,15 @@
 
     let allowed = AllowedOptimizations {
         predicate_pushdown: false,
         ..Default::default()
     };
     let q = df
         .lazy()
-        .map(|df| Ok(df), allowed, None, None)
+        .map(Ok, allowed, None, None)
         .filter(col("A").gt(lit(2i32)));
 
     assert!(!predicate_at_scan(q.clone()));
     let out = q.collect()?;
     assert_eq!(out.shape(), (3, 4));
 
     Ok(())
@@ -186,15 +186,15 @@
         "bar" => [1],
         "flag" => &[None, Some(true)][0..1]
     ]?;
     assert!(out.frame_equal_missing(&expected));
 
     let out = a
         .lazy()
-        .join(b.clone(), [col("key")], [col("key")], JoinType::Left.into())
+        .join(b, [col("key")], [col("key")], JoinType::Left.into())
         .filter(col("flag").eq(lit(NULL)))
         .with_predicate_pushdown(false)
         .collect()?;
     assert!(out.frame_equal_missing(&expected));
 
     Ok(())
 }
@@ -232,15 +232,15 @@
         col("a"),
         col("a")
             .map_list(|s| Ok(Some(s)), GetOutput::same_type())
             .alias("a_applied"),
     ])
     .filter(col("a").lt(lit(3)));
 
-    assert!(predicate_at_scan(q.clone()));
+    assert!(predicate_at_scan(q));
     Ok(())
 }
 #[test]
 #[cfg(feature = "cse")]
 fn test_predicate_on_join_suffix_4788() -> PolarsResult<()> {
     let lf = df![
       "x" => [1, 2],
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/projection_queries.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/projection_queries.rs`

 * *Files 1% similar despite different names*

```diff
@@ -86,15 +86,15 @@
 
     Ok(())
 }
 
 #[test]
 #[cfg(feature = "cse")]
 fn scan_join_same_file() -> PolarsResult<()> {
-    let lf = LazyCsvReader::new(FOODS_CSV.to_string()).finish()?;
+    let lf = LazyCsvReader::new(FOODS_CSV).finish()?;
 
     for cse in [true, false] {
         let partial = lf.clone().select([col("category")]).limit(5);
         let q = lf
             .clone()
             .join(
                 partial,
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/queries.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/queries.rs`

 * *Files 2% similar despite different names*

```diff
@@ -625,15 +625,15 @@
     let rules: &mut [Box<dyn OptimizationRule>] = &mut [Box::new(TypeCoercionRule {})];
 
     let optimizer = StackOptimizer {};
     let mut lp_top = to_alp(lp, &mut expr_arena, &mut lp_arena).unwrap();
     lp_top = optimizer
         .optimize_loop(rules, &mut expr_arena, &mut lp_arena, lp_top)
         .unwrap();
-    let lp = node_to_lp(lp_top, &mut expr_arena, &mut lp_arena);
+    let lp = node_to_lp(lp_top, &expr_arena, &mut lp_arena);
 
     if let LogicalPlan::Projection { expr, .. } = lp {
         if let Expr::BinaryExpr { left, right, .. } = &expr[0] {
             assert!(matches!(&**left, Expr::Cast { .. }));
             // bar is already float, does not have to be coerced
             assert!(matches!(&**right, Expr::Column { .. }));
         } else {
@@ -773,29 +773,29 @@
     let out = df
         .clone()
         .lazy()
         .groupby([col("a")])
         .agg([col("b").sort(false).first()])
         .collect()
         .unwrap()
-        .sort(["a"], false)
+        .sort(["a"], false, false)
         .unwrap();
 
     assert_eq!(
         Vec::from(out.column("b").unwrap().i32().unwrap()),
         [Some(1), Some(2), Some(6)]
     );
 
     let out = df
         .lazy()
         .groupby([col("a")])
         .agg([col("b").sort(false).last()])
         .collect()
         .unwrap()
-        .sort(["a"], false)
+        .sort(["a"], false, false)
         .unwrap();
 
     assert_eq!(
         Vec::from(out.column("b").unwrap().i32().unwrap()),
         [Some(3), Some(5), Some(6)]
     );
 }
@@ -811,15 +811,15 @@
 
     let out = df
         .lazy()
         .groupby([col("a")])
         .agg([col("b").sort_by([col("c")], [true]).first()])
         .collect()
         .unwrap()
-        .sort(["a"], false)
+        .sort(["a"], false, false)
         .unwrap();
 
     assert_eq!(
         Vec::from(out.column("b").unwrap().i32().unwrap()),
         [Some(1), Some(4), Some(6)]
     );
 }
@@ -896,14 +896,15 @@
         ])
         .sort(
             "a",
             SortOptions {
                 descending: false,
                 nulls_last: false,
                 multithreaded: true,
+                maintain_order: false,
             },
         )
         .collect()?;
 
     assert_eq!(
         Vec::from(out.column("b_sum").unwrap().i32().unwrap()),
         [Some(6), None, None]
@@ -1444,15 +1445,15 @@
     Ok(())
 }
 
 #[test]
 fn test_list_in_select_context() -> PolarsResult<()> {
     let s = Series::new("a", &[1, 2, 3]);
     let mut builder = get_list_builder(s.dtype(), s.len(), 1, s.name()).unwrap();
-    builder.append_series(&s);
+    builder.append_series(&s).unwrap();
     let expected = builder.finish().into_series();
 
     let df = DataFrame::new(vec![s])?;
 
     let out = df.lazy().select([col("a").implode()]).collect()?;
 
     let s = out.column("a")?;
@@ -1596,22 +1597,19 @@
     // test type coercion
     // https://github.com/pola-rs/polars/issues/1649
     let df = df!(
             "nrs"=> [Some(1i64), Some(2), Some(3), None, Some(5)],
             "random"=> [0.1f64, 0.6, 0.2, 0.6, 0.3]
     )?;
 
-    let out = df
-        .lazy()
-        .select([when(col("random").gt(lit(0.5)))
-            .then(lit(2))
-            .otherwise(col("random"))
-            .alias("other")
-            * col("nrs").sum()])
-        .collect()?;
+    let other = when(col("random").gt(lit(0.5)))
+        .then(lit(2))
+        .otherwise(col("random"))
+        .alias("other");
+    let out = df.lazy().select([other * col("nrs").sum()]).collect()?;
     assert_eq!(out.dtypes(), &[DataType::Float64]);
     Ok(())
 }
 
 #[test]
 fn test_single_group_result() -> PolarsResult<()> {
     // the arg_sort should not auto explode
@@ -1623,14 +1621,15 @@
     let out = df
         .lazy()
         .select([col("a")
             .arg_sort(SortOptions {
                 descending: false,
                 nulls_last: false,
                 multithreaded: true,
+                maintain_order: false,
             })
             .over([col("a")])])
         .collect()?;
 
     let a = out.column("a")?.idx()?;
     assert_eq!(Vec::from(a), &[Some(0), Some(0)]);
 
@@ -1852,30 +1851,29 @@
         .agg([(col("col").cast(DataType::Float32) + lit(10.0))
             .sum()
             .alias("sum")])
         .collect()?;
 
     assert!(out.frame_equal(&df![
         "col" => [0],
-        "sum" => [200.0 as f32],
+        "sum" => [200.0_f32],
     ]?));
 
     Ok(())
 }
 
 #[test]
 fn test_partitioned_gb_ternary() -> PolarsResult<()> {
     // don't move these to integration tests
     let df = df![
         "col" => (0..20).map(|_| Some(0)).collect::<Int32Chunked>().into_series(),
-        "val" => (0..20).map(|i| Some(i)).collect::<Int32Chunked>().into_series(),
+        "val" => (0..20).map(Some).collect::<Int32Chunked>().into_series(),
     ]?;
 
     let out = df
-        .clone()
         .lazy()
         .groupby([col("col")])
         .agg([when(col("val").gt(lit(10)))
             .then(lit(1))
             .otherwise(lit(0))
             .sum()
             .alias("sum")])
@@ -1884,7 +1882,27 @@
     assert!(out.frame_equal(&df![
         "col" => [0],
         "sum" => [9],
     ]?));
 
     Ok(())
 }
+
+#[test]
+fn test_sort_maintain_order_true() -> PolarsResult<()> {
+    let q = df![
+        "A" => [1, 1, 1, 1],
+        "B" => ["A", "B", "C", "D"],
+    ]?
+    .lazy();
+
+    let res = q
+        .sort_by_exprs([col("A")], [false], false, true)
+        .slice(0, 3)
+        .collect()?;
+    println!("{:?}", res);
+    assert!(res.frame_equal(&df![
+        "A" => [1, 1, 1],
+        "B" => ["A", "B", "C"],
+    ]?));
+    Ok(())
+}
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/streaming.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/streaming.rs`

 * *Files 8% similar despite different names*

```diff
@@ -96,15 +96,20 @@
     let q = q
         .filter(col("sugars_g").gt(lit(10)))
         .groupby([col("sugars_g"), col("calories")])
         .agg([
             (col("fats_g") * lit(10)).sum(),
             col("calories").mean().alias("cal_mean"),
         ])
-        .sort_by_exprs([col("sugars_g"), col("calories")], [false, false], false);
+        .sort_by_exprs(
+            [col("sugars_g"), col("calories")],
+            [false, false],
+            false,
+            false,
+        );
 
     assert_streaming_with_default(q, true, false);
     Ok(())
 }
 
 #[test]
 fn test_streaming_first_sum() -> PolarsResult<()> {
@@ -126,30 +131,30 @@
 #[test]
 fn test_streaming_unique() -> PolarsResult<()> {
     let q = get_csv_file();
 
     let q = q
         .select([col("sugars_g"), col("calories")])
         .unique(None, Default::default())
-        .sort_by_exprs([cols(["sugars_g", "calories"])], [false], false);
+        .sort_by_exprs([cols(["sugars_g", "calories"])], [false], false, false);
 
     assert_streaming_with_default(q, true, false);
     Ok(())
 }
 
 #[test]
 fn test_streaming_aggregate_slice() -> PolarsResult<()> {
     let q = get_parquet_file();
 
     let q = q
         .groupby([col("sugars_g")])
         .agg([((lit(1) - col("fats_g")) + col("calories")).sum()])
         .slice(3, 3);
 
-    let q1 = q.clone().with_streaming(true);
+    let q1 = q.with_streaming(true);
     let out_streaming = q1.collect()?;
     assert_eq!(out_streaming.shape(), (3, 2));
     Ok(())
 }
 
 #[test]
 #[cfg(feature = "cross_join")]
@@ -161,27 +166,26 @@
     let out = q.clone().cross_join(q).with_streaming(true).collect()?;
     assert_eq!(out.shape(), (9, 2));
 
     let q = get_parquet_file().with_projection_pushdown(false);
     let q1 = q
         .clone()
         .select([col("calories")])
-        .clone()
         .cross_join(q.clone())
         .filter(col("calories").gt(col("calories_right")));
     let q2 = q1
         .select([all().suffix("_second")])
         .cross_join(q)
         .filter(col("calories_right_second").lt(col("calories")))
         .select([
             col("calories"),
             col("calories_right_second").alias("calories_right"),
         ]);
 
-    let q2 = q2.clone().with_streaming(true);
+    let q2 = q2.with_streaming(true);
     let out_streaming = q2.collect()?;
 
     assert_eq!(
         out_streaming.get_column_names(),
         &["calories", "calories_right"]
     );
     assert_eq!(out_streaming.shape(), (5753, 2));
@@ -255,15 +259,15 @@
     let s = Series::new("", vals);
     let lf_a = df![
         "a" => s
     ]?
     .lazy();
 
     let q = lf_a.clone().cross_join(lf_a).slice(10, 20);
-    let a = q.clone().with_streaming(true).collect().unwrap();
+    let a = q.with_streaming(true).collect().unwrap();
     assert_eq!(a.shape(), (20, 2));
 
     Ok(())
 }
 
 #[test]
 fn test_streaming_partial() -> PolarsResult<()> {
@@ -289,15 +293,15 @@
         .left_on([col("a")])
         .right_on([col("a")])
         .suffix("_foo")
         .how(JoinType::Outer)
         .finish();
 
     let q = q.left_join(
-        lf_left.clone().select([all().suffix("_foo")]),
+        lf_left.select([all().suffix("_foo")]),
         col("a"),
         col("a_foo"),
     );
     assert_streaming_with_default(q, false, true);
 
     Ok(())
 }
@@ -308,15 +312,15 @@
 
     let q = q
         .groupby([col("sugars_g")])
         .agg([((lit(1) - col("fats_g")) + col("calories")).sum()])
         .slice(0, 3);
 
     let q = q.clone().left_join(q, col("sugars_g"), col("sugars_g"));
-    let q1 = q.clone().with_streaming(true);
+    let q1 = q.with_streaming(true);
     let out_streaming = q1.collect()?;
     assert_eq!(out_streaming.shape(), (3, 3));
     Ok(())
 }
 
 #[test]
 fn test_streaming_double_left_join() -> PolarsResult<()> {
@@ -360,7 +364,27 @@
         .slice(0, 0)
         .left_join(q2.slice(0, 0), col("p_id"), col("p_id2"))
         .left_join(q3.slice(0, 0), col("m_id"), col("m_id3"));
 
     assert_streaming_with_default(q, true, false);
     Ok(())
 }
+
+#[test]
+fn test_sort_maintain_order_streaming() -> PolarsResult<()> {
+    let q = df![
+        "A" => [1, 1, 1, 1],
+        "B" => ["A", "B", "C", "D"],
+    ]?
+    .lazy();
+
+    let res = q
+        .sort_by_exprs([col("A")], [false], false, true)
+        .slice(0, 3)
+        .with_streaming(true)
+        .collect()?;
+    assert!(res.frame_equal(&df![
+        "A" => [1, 1, 1],
+        "B" => ["A", "B", "C"],
+    ]?));
+    Ok(())
+}
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-lazy/src/tests/tpch.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-lazy/src/tests/tpch.rs`

 * *Files 2% similar despite different names*

```diff
@@ -57,15 +57,15 @@
         .filter(col("p_size").eq(15))
         .filter(col("p_type").str().ends_with(lit("BRASS".to_string())));
     let q = q1
         .clone()
         .groupby([col("p_partkey")])
         .agg([col("ps_supplycost").min()])
         .join(
-            q1.clone(),
+            q1,
             [col("p_partkey"), col("ps_supplycost")],
             [col("p_partkey"), col("ps_supplycost")],
             JoinType::Inner.into(),
         )
         .select([cols([
             "s_acctbal",
             "s_name",
@@ -76,14 +76,15 @@
             "s_phone",
             "s_comment",
         ])])
         .sort_by_exprs(
             [cols(["s_acctbal", "n_name", "s_name", "p_partkey"])],
             [true, false, false, false],
             false,
+            false,
         )
         .limit(100)
         .with_common_subplan_elimination(true);
 
     let out = q.collect()?;
     let schema = Schema::from_iter([
         Field::new("s_acctbal", DataType::Float64),
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/Cargo.toml` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/Cargo.toml`

 * *Files 1% similar despite different names*

```diff
@@ -149,15 +149,15 @@
 "gcp" = ["async", "object_store/gcp"]
 
 [dependencies]
 ahash= "0.8"
 bitflags= "1.3"
 chrono = { version = "0.4", default-features = false, features = ["std"], optional = true }
 chrono-tz = { version = "0.8", optional = true }
-comfy-table = { version = "6.1.4", optional = true, default_features = false }
+comfy-table = { version = "7.0.1", optional = true, default_features = false }
 either= "1.8"
 hashbrown= { version = "0.14.0", features = ["rayon", "ahash"] }
 indexmap= { version = "2", features = ["std"] }
 itoap = { version = "1", optional = true, features = ["simd"] }
 ndarray = { version = "0.15", optional = true, default_features = false }
 num-traits= "0.2"
 object_store = { version = "0.6.0", default-features = false, optional = true }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/LICENSE` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/arithmetic/decimal.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/arithmetic/decimal.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/arithmetic/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/arithmetic/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/arithmetic/numeric.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/arithmetic/numeric.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/array/iterator.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/array/iterator.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/array/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/array/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/bitwise.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/bitwise.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/binary.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/binary.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/boolean.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/boolean.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/fixed_size_list.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/fixed_size_list.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/from.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/from.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/list/anonymous.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/list/anonymous.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/list/binary.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/list/binary.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/list/boolean.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/list/boolean.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/list/categorical.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/list/categorical.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/list/dtypes.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/list/dtypes.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/list/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/list/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/list/primitive.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/list/primitive.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/mod.rs`

 * *Files 1% similar despite different names*

```diff
@@ -234,16 +234,16 @@
             ListPrimitiveChunkedBuilder::<Int32Type>::new("a", 10, 5, DataType::Int32);
 
         // create a series containing two chunks
         let mut s1 = Int32Chunked::from_slice("a", &[1, 2, 3]).into_series();
         let s2 = Int32Chunked::from_slice("b", &[4, 5, 6]).into_series();
         s1.append(&s2).unwrap();
 
-        builder.append_series(&s1);
-        builder.append_series(&s2);
+        builder.append_series(&s1).unwrap();
+        builder.append_series(&s2).unwrap();
         let ls = builder.finish();
         if let AnyValue::List(s) = ls.get_any_value(0).unwrap() {
             // many chunks are aggregated to one in the ListArray
             assert_eq!(s.len(), 6)
         } else {
             panic!()
         }
@@ -255,15 +255,15 @@
         // test list collect
         let out = [&s1, &s2].iter().copied().collect::<ListChunked>();
         assert_eq!(out.get(0).unwrap().len(), 6);
         assert_eq!(out.get(1).unwrap().len(), 3);
 
         let mut builder =
             ListPrimitiveChunkedBuilder::<Int32Type>::new("a", 10, 5, DataType::Int32);
-        builder.append_series(&s1);
+        builder.append_series(&s1).unwrap();
         builder.append_null();
 
         let out = builder.finish();
         let out = out.explode().unwrap();
         assert_eq!(out.len(), 7);
         assert_eq!(out.get(6).unwrap(), AnyValue::Null);
     }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/primitive.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/primitive.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/builder/utf8.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/builder/utf8.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/cast.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/cast.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/comparison/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/comparison/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/comparison/scalar.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/comparison/scalar.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/drop.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/drop.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/float.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/float.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/from.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/from.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/iterator/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/iterator/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/iterator/par/list.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/iterator/par/list.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/iterator/par/utf8.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/iterator/par/utf8.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/kernels/take.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/kernels/take.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/list/iterator.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/object/extension/mod.rs`

 * *Files 23% similar despite different names*

```diff
@@ -1,237 +1,230 @@
-use std::marker::PhantomData;
-use std::ptr::NonNull;
+pub(crate) mod drop;
+mod list;
+pub(crate) mod polars_extension;
+
+use std::mem;
+
+use arrow::array::{Array, FixedSizeBinaryArray};
+use arrow::bitmap::MutableBitmap;
+use arrow::buffer::Buffer;
+use polars_extension::PolarsExtension;
 
 use crate::prelude::*;
-use crate::series::unstable::{ArrayBox, UnstableSeries};
-use crate::utils::CustomIterTools;
+use crate::PROCESS_ID;
 
-pub struct AmortizedListIter<'a, I: Iterator<Item = Option<ArrayBox>>> {
-    len: usize,
-    series_container: Box<Series>,
-    inner: NonNull<ArrayRef>,
-    lifetime: PhantomData<&'a ArrayRef>,
-    iter: I,
-    // used only if feature="dtype-struct"
-    #[allow(dead_code)]
-    inner_dtype: DataType,
-}
-
-impl<'a, I: Iterator<Item = Option<ArrayBox>>> AmortizedListIter<'a, I> {
-    pub(crate) fn new(
-        len: usize,
-        series_container: Box<Series>,
-        inner: NonNull<ArrayRef>,
-        iter: I,
-        inner_dtype: DataType,
-    ) -> Self {
-        Self {
-            len,
-            series_container,
-            inner,
-            lifetime: PhantomData,
-            iter,
-            inner_dtype,
+pub const EXTENSION_NAME: &str = "POLARS_EXTENSION_TYPE";
+
+/// Invariants
+/// `ptr` must point to start a `T` allocation
+/// `n_t_vals` must represent the correct number of `T` values in that allocation
+unsafe fn create_drop<T: Sized>(mut ptr: *const u8, n_t_vals: usize) -> Box<dyn FnMut()> {
+    Box::new(move || {
+        let t_size = std::mem::size_of::<T>() as isize;
+        for _ in 0..n_t_vals {
+            let _ = std::ptr::read_unaligned(ptr as *const T);
+            ptr = ptr.offset(t_size)
         }
-    }
+    })
 }
 
-impl<'a, I: Iterator<Item = Option<ArrayBox>>> Iterator for AmortizedListIter<'a, I> {
-    type Item = Option<UnstableSeries<'a>>;
-
-    fn next(&mut self) -> Option<Self::Item> {
-        self.iter.next().map(|opt_val| {
-            opt_val.map(|array_ref| {
-                #[cfg(feature = "dtype-struct")]
-                // structs arrays are bound to the series not to the arrayref
-                // so we must get a hold to the new array
-                if matches!(self.inner_dtype, DataType::Struct(_)) {
-                    // Safety
-                    // dtype is known
-                    unsafe {
-                        let mut s = Series::from_chunks_and_dtype_unchecked(
-                            "",
-                            vec![array_ref],
-                            &self.inner_dtype.to_physical(),
-                        )
-                        .cast_unchecked(&self.inner_dtype)
-                        .unwrap();
-                        // swap the new series with the container
-                        std::mem::swap(&mut *self.series_container, &mut s);
-                        // return a reference to the container
-                        // this lifetime is now bound to 'a
-                        return UnstableSeries::new(
-                            &mut *(&mut *self.series_container as *mut Series),
-                        );
-                    }
-                }
+#[allow(clippy::type_complexity)]
+struct ExtensionSentinel {
+    drop_fn: Option<Box<dyn FnMut()>>,
+    // A function on the heap that take a `array: FixedSizeBinary` and a `name: &str`
+    // and returns a `Series` of `ObjectChunked<T>`
+    pub(crate) to_series_fn: Option<Box<dyn Fn(&FixedSizeBinaryArray, &str) -> Series>>,
+}
 
-                // update the inner state
-                unsafe { *self.inner.as_mut() = array_ref };
+impl Drop for ExtensionSentinel {
+    fn drop(&mut self) {
+        let mut drop_fn = self.drop_fn.take().unwrap();
+        drop_fn()
+    }
+}
 
-                // make sure that the length is correct
-                self.series_container._get_inner_mut().compute_len();
+// https://stackoverflow.com/questions/28127165/how-to-convert-struct-to-u8d
+// not entirely sure if padding bytes in T are initialized or not.
+unsafe fn any_as_u8_slice<T: Sized>(p: &T) -> &[u8] {
+    std::slice::from_raw_parts((p as *const T) as *const u8, std::mem::size_of::<T>())
+}
 
-                // Safety
-                // we cannot control the lifetime of an iterators `next` method.
-                // but as long as self is alive the reference to the series container is valid
-                let refer = &mut *self.series_container;
+/// Create an extension Array that can be sent to arrow and (once wrapped in `[PolarsExtension]` will
+/// also call drop on `T`, when the array is dropped.
+pub(crate) fn create_extension<
+    I: IntoIterator<Item = Option<T>> + TrustedLen,
+    T: Sized + Default,
+>(
+    iter: I,
+) -> PolarsExtension {
+    let env = "POLARS_ALLOW_EXTENSION";
+    std::env::var(env).unwrap_or_else(|_| {
+        panic!("env var: {env} must be set to allow extension types to be created",)
+    });
+    let t_size = std::mem::size_of::<T>();
+    let t_alignment = std::mem::align_of::<T>();
+    let n_t_vals = iter.size_hint().1.unwrap();
+
+    let mut buf = Vec::with_capacity(n_t_vals * t_size);
+    let mut validity = MutableBitmap::with_capacity(n_t_vals);
+
+    // when we transmute from &[u8] to T, T must be aligned correctly,
+    // so we pad with bytes until the alignment matches
+    let n_padding = (buf.as_ptr() as usize) % t_alignment;
+    buf.extend(std::iter::repeat(0).take(n_padding));
+
+    let mut null_count = 0 as IdxSize;
+    // transmute T as bytes and copy in buffer
+    for opt_t in iter.into_iter() {
+        match opt_t {
+            Some(t) => {
+                unsafe {
+                    buf.extend_from_slice(any_as_u8_slice(&t));
+                    // Safety: we allocated upfront
+                    validity.push_unchecked(true)
+                }
+                mem::forget(t);
+            }
+            None => {
+                null_count += 1;
                 unsafe {
-                    let s = std::mem::transmute::<&mut Series, &'a mut Series>(refer);
-                    UnstableSeries::new_with_chunk(s, self.inner.as_ref())
+                    buf.extend_from_slice(any_as_u8_slice(&T::default()));
+                    // Safety: we allocated upfront
+                    validity.push_unchecked(false)
                 }
-            })
-        })
+            }
+        }
     }
 
-    fn size_hint(&self) -> (usize, Option<usize>) {
-        (self.len, Some(self.len))
-    }
+    // we slice the buffer because we want to ignore the padding bytes from here
+    // they can be forgotten
+    let buf: Buffer<u8> = buf.into();
+    let len = buf.len() - n_padding;
+    let buf = buf.sliced(n_padding, len);
+
+    // ptr to start of T, not to start of padding
+    let ptr = buf.as_slice().as_ptr();
+
+    // Safety:
+    // ptr and t are correct
+    let drop_fn = unsafe { create_drop::<T>(ptr, n_t_vals) };
+    let et = Box::new(ExtensionSentinel {
+        drop_fn: Some(drop_fn),
+        to_series_fn: None,
+    });
+    let et_ptr = &*et as *const ExtensionSentinel;
+    std::mem::forget(et);
+
+    let metadata = format!("{};{}", *PROCESS_ID, et_ptr as usize);
+
+    let physical_type = ArrowDataType::FixedSizeBinary(t_size);
+    let extension_type =
+        ArrowDataType::Extension(EXTENSION_NAME.into(), physical_type.into(), Some(metadata));
+    // first freeze, otherwise we compute null
+    let validity = if null_count > 0 {
+        Some(validity.into())
+    } else {
+        None
+    };
+
+    let array = FixedSizeBinaryArray::new(extension_type, buf, validity);
+
+    // Safety:
+    // we just heap allocated the ExtensionSentinel, so its alive.
+    unsafe { PolarsExtension::new(array) }
 }
 
-// # Safety
-// we correctly implemented size_hint
-unsafe impl<'a, I: Iterator<Item = Option<ArrayBox>>> TrustedLen for AmortizedListIter<'a, I> {}
-
-impl ListChunked {
-    /// This is an iterator over a ListChunked that save allocations.
-    /// A Series is:
-    ///     1. [`Arc<ChunkedArray>`]
-    ///     ChunkedArray is:
-    ///         2. Vec< 3. ArrayRef>
-    ///
-    /// The ArrayRef we indicated with 3. will be updated during iteration.
-    /// The Series will be pinned in memory, saving an allocation for
-    /// 1. Arc<..>
-    /// 2. Vec<...>
-    ///
-    /// # Warning
-    /// Though memory safe in the sense that it will not read unowned memory, UB, or memory leaks
-    /// this function still needs precautions. The returned should never be cloned or taken longer
-    /// than a single iteration, as every call on `next` of the iterator will change the contents of
-    /// that Series.
-    pub fn amortized_iter(&self) -> AmortizedListIter<impl Iterator<Item = Option<ArrayBox>> + '_> {
-        self.amortized_iter_with_name("")
-    }
-
-    pub fn amortized_iter_with_name(
-        &self,
-        name: &str,
-    ) -> AmortizedListIter<impl Iterator<Item = Option<ArrayBox>> + '_> {
-        // we create the series container from the inner array
-        // so that the container has the proper dtype.
-        let arr = self.downcast_iter().next().unwrap();
-        let inner_values = arr.values();
-
-        let inner_dtype = self.inner_dtype();
-        let iter_dtype = match inner_dtype {
-            #[cfg(feature = "dtype-struct")]
-            DataType::Struct(_) => inner_dtype.to_physical(),
-            // TODO: figure out how to deal with physical/logical distinction
-            // physical primitives like time, date etc. work
-            // physical nested need more
-            _ => inner_dtype.clone(),
-        };
-
-        // Safety:
-        // inner type passed as physical type
-        let series_container = unsafe {
-            Box::new(Series::from_chunks_and_dtype_unchecked(
-                name,
-                vec![inner_values.clone()],
-                &iter_dtype,
-            ))
-        };
-
-        let ptr = series_container.array_ref(0) as *const ArrayRef as *mut ArrayRef;
-
-        AmortizedListIter::new(
-            self.len(),
-            series_container,
-            NonNull::new(ptr).unwrap(),
-            self.downcast_iter().flat_map(|arr| arr.iter()),
-            inner_dtype,
-        )
-    }
-
-    /// Apply a closure `F` elementwise.
-    #[must_use]
-    pub fn apply_amortized<'a, F>(&'a self, mut f: F) -> Self
-    where
-        F: FnMut(UnstableSeries<'a>) -> Series,
-    {
-        if self.is_empty() {
-            return self.clone();
-        }
-        let mut fast_explode = self.null_count() == 0;
-        let mut ca: ListChunked = self
-            .amortized_iter()
-            .map(|opt_v| {
-                opt_v.map(|v| {
-                    let out = f(v);
-                    if out.is_empty() {
-                        fast_explode = false;
-                    }
-                    out
-                })
-            })
-            .collect_trusted();
-
-        ca.rename(self.name());
-        if fast_explode {
-            ca.set_fast_explode();
-        }
-        ca
+#[cfg(test)]
+mod test {
+    use std::fmt::{Display, Formatter};
+
+    use super::*;
+
+    #[derive(Clone, Debug, Default, Eq, Hash, PartialEq)]
+    struct Foo {
+        pub a: i32,
+        pub b: u8,
+        pub other_heap: String,
     }
 
-    pub fn try_apply_amortized<'a, F>(&'a self, mut f: F) -> PolarsResult<Self>
-    where
-        F: FnMut(UnstableSeries<'a>) -> PolarsResult<Series>,
-    {
-        if self.is_empty() {
-            return Ok(self.clone());
+    impl Display for Foo {
+        fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+            write!(f, "{:?}", self)
         }
-        let mut fast_explode = self.null_count() == 0;
-        let mut ca: ListChunked = self
-            .amortized_iter()
-            .map(|opt_v| {
-                opt_v
-                    .map(|v| {
-                        let out = f(v);
-                        if let Ok(out) = &out {
-                            if out.is_empty() {
-                                fast_explode = false
-                            }
-                        };
-                        out
-                    })
-                    .transpose()
-            })
-            .collect::<PolarsResult<_>>()?;
-        ca.rename(self.name());
-        if fast_explode {
-            ca.set_fast_explode();
+    }
+
+    impl PolarsObject for Foo {
+        fn type_name() -> &'static str {
+            "object"
         }
-        Ok(ca)
     }
-}
 
-#[cfg(test)]
-mod test {
-    use super::*;
-    use crate::chunked_array::builder::get_list_builder;
+    #[test]
+    fn test_create_extension() {
+        std::env::set_var("POLARS_ALLOW_EXTENSION", "1");
+        // Run this under MIRI.
+        let foo = Foo {
+            a: 1,
+            b: 1,
+            other_heap: "foo".into(),
+        };
+        let foo2 = Foo {
+            a: 1,
+            b: 1,
+            other_heap: "bar".into(),
+        };
+
+        let vals = vec![Some(foo), Some(foo2)];
+        create_extension(vals.into_iter());
+    }
 
     #[test]
-    fn test_iter_list() {
-        let mut builder = get_list_builder(&DataType::Int32, 10, 10, "").unwrap();
-        builder.append_series(&Series::new("", &[1, 2, 3]));
-        builder.append_series(&Series::new("", &[3, 2, 1]));
-        builder.append_series(&Series::new("", &[1, 1]));
-        let ca = builder.finish();
-
-        ca.amortized_iter()
-            .zip(ca.into_iter())
-            .for_each(|(s1, s2)| {
-                assert!(s1.unwrap().as_ref().series_equal(&s2.unwrap()));
-            });
+    fn test_extension_to_list() {
+        std::env::set_var("POLARS_ALLOW_EXTENSION", "1");
+        let foo1 = Foo {
+            a: 1,
+            b: 1,
+            other_heap: "foo".into(),
+        };
+        let foo2 = Foo {
+            a: 1,
+            b: 1,
+            other_heap: "bar".into(),
+        };
+
+        let values = &[Some(foo1), None, Some(foo2), None];
+        let ca = ObjectChunked::new("", values);
+
+        let groups = GroupsProxy::Idx(vec![(0, vec![0, 1]), (2, vec![2]), (3, vec![3])].into());
+        let out = unsafe { ca.agg_list(&groups) };
+        assert!(matches!(out.dtype(), DataType::List(_)));
+        assert_eq!(out.len(), groups.len());
+    }
+
+    #[test]
+    fn test_extension_to_list_explode() {
+        std::env::set_var("POLARS_ALLOW_EXTENSION", "1");
+        let foo1 = Foo {
+            a: 1,
+            b: 1,
+            other_heap: "foo".into(),
+        };
+        let foo2 = Foo {
+            a: 1,
+            b: 1,
+            other_heap: "bar".into(),
+        };
+
+        let values = &[Some(foo1.clone()), None, Some(foo2.clone()), None];
+        let ca = ObjectChunked::new("", values);
+
+        let groups = vec![(0, vec![0, 1]), (2, vec![2]), (3, vec![3])].into();
+        let out = unsafe { ca.agg_list(&GroupsProxy::Idx(groups)) };
+        let a = out.explode().unwrap();
+
+        let ca_foo = a.as_any().downcast_ref::<ObjectChunked<Foo>>().unwrap();
+        assert_eq!(ca_foo.get(0).unwrap(), &foo1);
+        assert_eq!(ca_foo.get(1), None);
+        assert_eq!(ca_foo.get(2).unwrap(), &foo2);
+        assert_eq!(ca_foo.get(3), None);
     }
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/list/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/list/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/categorical/builder.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/categorical/builder.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/categorical/from.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/categorical/from.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/categorical/merge.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/categorical/merge.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/categorical/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/categorical/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/append.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/append.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/take_random.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/take_random.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/unique.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/unique.rs`

 * *Files 1% similar despite different names*

```diff
@@ -57,10 +57,10 @@
         let mut values = self.clone();
         *values.logical_mut() = logical_values;
 
         let mut counts = groups.group_count();
         counts.rename("counts");
         let cols = vec![values.into_series(), counts.into_series()];
         let df = DataFrame::new_no_checks(cols);
-        df.sort(["counts"], true)
+        df.sort(["counts"], true, false)
     }
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/zip.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/zip.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/categorical/stringcache.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/categorical/stringcache.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/date.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/date.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/datetime.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/datetime.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/decimal.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/decimal.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/duration.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/duration.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/struct_/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/struct_/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/logical/time.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/logical/time.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ndarray.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ndarray.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/object/builder.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/object/builder.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/object/extension/drop.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/object/extension/drop.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/object/extension/list.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/object/extension/list.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/object/extension/polars_extension.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/object/extension/polars_extension.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/object/iterator.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/object/iterator.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/object/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/object/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/object/registry.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/object/registry.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/aggregate/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/aggregate/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/aggregate/quantile.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/aggregate/quantile.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/aggregate/var.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/aggregate/var.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/any_value.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/any_value.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/append.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/append.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/apply.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/apply.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/bit_repr.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/bit_repr.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/chunkops.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/chunkops.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/compare_inner.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/compare_inner.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/concat_str.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/concat_str.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/cum_agg.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/cum_agg.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/decimal.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/decimal.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/downcast.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/downcast.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/explode.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/explode.rs`

 * *Files 7% similar despite different names*

```diff
@@ -418,17 +418,19 @@
     use super::*;
     use crate::chunked_array::builder::get_list_builder;
 
     #[test]
     fn test_explode_list() -> PolarsResult<()> {
         let mut builder = get_list_builder(&DataType::Int32, 5, 5, "a")?;
 
-        builder.append_series(&Series::new("", &[1, 2, 3, 3]));
-        builder.append_series(&Series::new("", &[1]));
-        builder.append_series(&Series::new("", &[2]));
+        builder
+            .append_series(&Series::new("", &[1, 2, 3, 3]))
+            .unwrap();
+        builder.append_series(&Series::new("", &[1])).unwrap();
+        builder.append_series(&Series::new("", &[2])).unwrap();
 
         let ca = builder.finish();
         assert!(ca._can_fast_explode());
 
         // normal explode
         let exploded = ca.explode()?;
         let out: Vec<_> = exploded.i32()?.into_no_null_iter().collect();
@@ -468,69 +470,90 @@
         Ok(())
     }
 
     #[test]
     fn test_explode_empty_list_slot() -> PolarsResult<()> {
         // primitive
         let mut builder = get_list_builder(&DataType::Int32, 5, 5, "a")?;
-        builder.append_series(&Series::new("", &[1i32, 2]));
-        builder.append_series(&Int32Chunked::from_slice("", &[]).into_series());
-        builder.append_series(&Series::new("", &[3i32]));
+        builder.append_series(&Series::new("", &[1i32, 2])).unwrap();
+        builder
+            .append_series(&Int32Chunked::from_slice("", &[]).into_series())
+            .unwrap();
+        builder.append_series(&Series::new("", &[3i32])).unwrap();
 
         let ca = builder.finish();
         let exploded = ca.explode()?;
         assert_eq!(
             Vec::from(exploded.i32()?),
             &[Some(1), Some(2), None, Some(3)]
         );
 
         // more primitive
         let mut builder = get_list_builder(&DataType::Int32, 5, 5, "a")?;
-        builder.append_series(&Series::new("", &[1i32]));
-        builder.append_series(&Int32Chunked::from_slice("", &[]).into_series());
-        builder.append_series(&Series::new("", &[2i32]));
-        builder.append_series(&Int32Chunked::from_slice("", &[]).into_series());
-        builder.append_series(&Series::new("", &[3, 4i32]));
+        builder.append_series(&Series::new("", &[1i32])).unwrap();
+        builder
+            .append_series(&Int32Chunked::from_slice("", &[]).into_series())
+            .unwrap();
+        builder.append_series(&Series::new("", &[2i32])).unwrap();
+        builder
+            .append_series(&Int32Chunked::from_slice("", &[]).into_series())
+            .unwrap();
+        builder.append_series(&Series::new("", &[3, 4i32])).unwrap();
 
         let ca = builder.finish();
         let exploded = ca.explode()?;
         assert_eq!(
             Vec::from(exploded.i32()?),
             &[Some(1), None, Some(2), None, Some(3), Some(4)]
         );
 
         // utf8
         let mut builder = get_list_builder(&DataType::Utf8, 5, 5, "a")?;
-        builder.append_series(&Series::new("", &["abc"]));
-        builder.append_series(
-            &<Utf8Chunked as NewChunkedArray<Utf8Type, &str>>::from_slice("", &[]).into_series(),
-        );
-        builder.append_series(&Series::new("", &["de"]));
-        builder.append_series(
-            &<Utf8Chunked as NewChunkedArray<Utf8Type, &str>>::from_slice("", &[]).into_series(),
-        );
-        builder.append_series(&Series::new("", &["fg"]));
-        builder.append_series(
-            &<Utf8Chunked as NewChunkedArray<Utf8Type, &str>>::from_slice("", &[]).into_series(),
-        );
+        builder.append_series(&Series::new("", &["abc"])).unwrap();
+        builder
+            .append_series(
+                &<Utf8Chunked as NewChunkedArray<Utf8Type, &str>>::from_slice("", &[])
+                    .into_series(),
+            )
+            .unwrap();
+        builder.append_series(&Series::new("", &["de"])).unwrap();
+        builder
+            .append_series(
+                &<Utf8Chunked as NewChunkedArray<Utf8Type, &str>>::from_slice("", &[])
+                    .into_series(),
+            )
+            .unwrap();
+        builder.append_series(&Series::new("", &["fg"])).unwrap();
+        builder
+            .append_series(
+                &<Utf8Chunked as NewChunkedArray<Utf8Type, &str>>::from_slice("", &[])
+                    .into_series(),
+            )
+            .unwrap();
 
         let ca = builder.finish();
         let exploded = ca.explode()?;
         assert_eq!(
             Vec::from(exploded.utf8()?),
             &[Some("abc"), None, Some("de"), None, Some("fg"), None]
         );
 
         // boolean
         let mut builder = get_list_builder(&DataType::Boolean, 5, 5, "a")?;
-        builder.append_series(&Series::new("", &[true]));
-        builder.append_series(&BooleanChunked::from_slice("", &[]).into_series());
-        builder.append_series(&Series::new("", &[false]));
-        builder.append_series(&BooleanChunked::from_slice("", &[]).into_series());
-        builder.append_series(&Series::new("", &[true, true]));
+        builder.append_series(&Series::new("", &[true])).unwrap();
+        builder
+            .append_series(&BooleanChunked::from_slice("", &[]).into_series())
+            .unwrap();
+        builder.append_series(&Series::new("", &[false])).unwrap();
+        builder
+            .append_series(&BooleanChunked::from_slice("", &[]).into_series())
+            .unwrap();
+        builder
+            .append_series(&Series::new("", &[true, true]))
+            .unwrap();
 
         let ca = builder.finish();
         let exploded = ca.explode()?;
         assert_eq!(
             Vec::from(exploded.bool()?),
             &[Some(true), None, Some(false), None, Some(true), Some(true)]
         );
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/explode_and_offsets.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/explode_and_offsets.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/extend.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/extend.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/fill_null.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/fill_null.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/filter.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/filter.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/full.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/full.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/is_in.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/is_in.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/min_max_binary.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/min_max_binary.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/mod.rs`

 * *Files 0% similar despite different names*

```diff
@@ -475,14 +475,15 @@
 
 #[derive(Copy, Clone, Eq, PartialEq, Debug, Hash)]
 #[cfg_attr(feature = "serde-lazy", derive(Serialize, Deserialize))]
 pub struct SortOptions {
     pub descending: bool,
     pub nulls_last: bool,
     pub multithreaded: bool,
+    pub maintain_order: bool,
 }
 
 #[derive(Clone)]
 #[cfg_attr(feature = "serde-lazy", derive(Serialize, Deserialize))]
 pub struct SortMultipleOptions {
     pub other: Vec<Series>,
     pub descending: Vec<bool>,
@@ -491,14 +492,15 @@
 
 impl Default for SortOptions {
     fn default() -> Self {
         Self {
             descending: false,
             nulls_last: false,
             multithreaded: true,
+            maintain_order: false,
         }
     }
 }
 
 /// Sort operations on `ChunkedArray`.
 pub trait ChunkSort<T: PolarsDataType> {
     #[allow(unused_variables)]
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/nulls.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/nulls.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/peaks.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/peaks.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/repeat_by.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/repeat_by.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/reverse.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/reverse.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/rolling_window.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/rolling_window.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/set.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/set.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/shift.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/shift.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/sort/arg_sort.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/sort/arg_sort.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/sort/arg_sort_multiple.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/sort/arg_sort_multiple.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/sort/categorical.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/sort/categorical.rs`

 * *Files 6% similar despite different names*

```diff
@@ -95,14 +95,15 @@
     /// Returned a sorted `ChunkedArray`.
     #[must_use]
     pub fn sort(&self, descending: bool) -> CategoricalChunked {
         self.sort_with(SortOptions {
             nulls_last: false,
             descending,
             multithreaded: true,
+            maintain_order: false,
         })
     }
 
     /// Retrieve the indexes needed to sort this array.
     pub fn arg_sort(&self, options: SortOptions) -> IdxCa {
         if self.use_lexical_sort() {
             let iters = [self.iter_str()];
@@ -198,20 +199,20 @@
             let series = ca_lexical.into_series();
 
             let df = df![
                 "cat" => &series,
                 "vals" => [1, 1, 2, 2]
             ]?;
 
-            let out = df.sort(["cat", "vals"], vec![false, false])?;
+            let out = df.sort(["cat", "vals"], vec![false, false], false)?;
             let out = out.column("cat")?;
             let cat = out.categorical()?;
             assert_order(cat, &["a", "a", "b", "c"]);
 
-            let out = df.sort(["vals", "cat"], vec![false, false])?;
+            let out = df.sort(["vals", "cat"], vec![false, false], false)?;
             let out = out.column("cat")?;
             let cat = out.categorical()?;
             assert_order(cat, &["b", "c", "a", "a"]);
         }
         Ok(())
     }
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/sort/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/sort/mod.rs`

 * *Files 3% similar despite different names*

```diff
@@ -422,14 +422,15 @@
     }
 
     fn sort(&self, descending: bool) -> Utf8Chunked {
         self.sort_with(SortOptions {
             descending,
             nulls_last: false,
             multithreaded: true,
+            maintain_order: false,
         })
     }
 
     fn arg_sort(&self, options: SortOptions) -> IdxCa {
         self.as_binary().arg_sort(options)
     }
 
@@ -541,14 +542,15 @@
     }
 
     fn sort(&self, descending: bool) -> BinaryChunked {
         self.sort_with(SortOptions {
             descending,
             nulls_last: false,
             multithreaded: true,
+            maintain_order: false,
         })
     }
 
     fn arg_sort(&self, options: SortOptions) -> IdxCa {
         arg_sort::arg_sort(
             self.name(),
             self.downcast_iter().map(|arr| arr.iter()),
@@ -633,14 +635,15 @@
     }
 
     fn sort(&self, descending: bool) -> BooleanChunked {
         self.sort_with(SortOptions {
             descending,
             nulls_last: false,
             multithreaded: true,
+            maintain_order: false,
         })
     }
 
     fn arg_sort(&self, options: SortOptions) -> IdxCa {
         arg_sort::arg_sort(
             self.name(),
             self.downcast_iter().map(|arr| arr.iter()),
@@ -771,14 +774,15 @@
                 Some(1),
             ],
         );
         let out = a.sort_with(SortOptions {
             descending: false,
             nulls_last: false,
             multithreaded: true,
+            maintain_order: false,
         });
         assert_eq!(
             Vec::from(&out),
             &[
                 None,
                 None,
                 Some(1),
@@ -789,14 +793,15 @@
                 Some(5)
             ]
         );
         let out = a.sort_with(SortOptions {
             descending: false,
             nulls_last: true,
             multithreaded: true,
+            maintain_order: false,
         });
         assert_eq!(
             Vec::from(&out),
             &[
                 Some(1),
                 Some(1),
                 Some(1),
@@ -813,15 +818,15 @@
     #[cfg_attr(miri, ignore)]
     fn test_arg_sort_multiple() -> PolarsResult<()> {
         let a = Int32Chunked::new("a", &[1, 2, 1, 1, 3, 4, 3, 3]);
         let b = Int64Chunked::new("b", &[0, 1, 2, 3, 4, 5, 6, 1]);
         let c = Utf8Chunked::new("c", &["a", "b", "c", "d", "e", "f", "g", "h"]);
         let df = DataFrame::new(vec![a.into_series(), b.into_series(), c.into_series()])?;
 
-        let out = df.sort(["a", "b", "c"], false)?;
+        let out = df.sort(["a", "b", "c"], false, false)?;
         assert_eq!(
             Vec::from(out.column("b")?.i64()?),
             &[
                 Some(0),
                 Some(2),
                 Some(3),
                 Some(1),
@@ -833,34 +838,34 @@
         );
 
         // now let the first sort be a string
         let a = Utf8Chunked::new("a", &["a", "b", "c", "a", "b", "c"]).into_series();
         let b = Int32Chunked::new("b", &[5, 4, 2, 3, 4, 5]).into_series();
         let df = DataFrame::new(vec![a, b])?;
 
-        let out = df.sort(["a", "b"], false)?;
+        let out = df.sort(["a", "b"], false, false)?;
         let expected = df!(
             "a" => ["a", "a", "b", "b", "c", "c"],
             "b" => [3, 5, 4, 4, 2, 5]
         )?;
         assert!(out.frame_equal(&expected));
 
         let df = df!(
             "groups" => [1, 2, 3],
             "values" => ["a", "a", "b"]
         )?;
 
-        let out = df.sort(["groups", "values"], vec![true, false])?;
+        let out = df.sort(["groups", "values"], vec![true, false], false)?;
         let expected = df!(
             "groups" => [3, 2, 1],
             "values" => ["b", "a", "a"]
         )?;
         assert!(out.frame_equal(&expected));
 
-        let out = df.sort(["values", "groups"], vec![false, true])?;
+        let out = df.sort(["values", "groups"], vec![false, true], false)?;
         let expected = df!(
             "groups" => [2, 1, 3],
             "values" => ["a", "a", "b"]
         )?;
         assert!(out.frame_equal(&expected));
 
         Ok(())
@@ -869,39 +874,43 @@
     #[test]
     fn test_sort_utf8() {
         let ca = Utf8Chunked::new("a", &[Some("a"), None, Some("c"), None, Some("b")]);
         let out = ca.sort_with(SortOptions {
             descending: false,
             nulls_last: false,
             multithreaded: true,
+            maintain_order: false,
         });
         let expected = &[None, None, Some("a"), Some("b"), Some("c")];
         assert_eq!(Vec::from(&out), expected);
 
         let out = ca.sort_with(SortOptions {
             descending: true,
             nulls_last: false,
             multithreaded: true,
+            maintain_order: false,
         });
 
         let expected = &[None, None, Some("c"), Some("b"), Some("a")];
         assert_eq!(Vec::from(&out), expected);
 
         let out = ca.sort_with(SortOptions {
             descending: false,
             nulls_last: true,
             multithreaded: true,
+            maintain_order: false,
         });
         let expected = &[Some("a"), Some("b"), Some("c"), None, None];
         assert_eq!(Vec::from(&out), expected);
 
         let out = ca.sort_with(SortOptions {
             descending: true,
             nulls_last: true,
             multithreaded: true,
+            maintain_order: false,
         });
         let expected = &[Some("c"), Some("b"), Some("a"), None, None];
         assert_eq!(Vec::from(&out), expected);
 
         // no nulls
         let ca = Utf8Chunked::new("a", &[Some("a"), Some("c"), Some("b")]);
         let out = ca.sort(false);
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/take/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/take/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/take/take_chunked.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/take/take_chunked.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/take/take_random.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/take/take_random.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/take/take_single.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/take/take_single.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/take/traits.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/take/traits.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/unique/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/unique/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/unique/rank.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/unique/rank.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/ops/zip.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/ops/zip.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/random.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/random.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/temporal/conversion.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/temporal/conversion.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/temporal/date.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/temporal/date.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/temporal/datetime.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/temporal/datetime.rs`

 * *Files 0% similar despite different names*

```diff
@@ -102,15 +102,15 @@
     ) -> PolarsResult<DatetimeChunked> {
         let out: PolarsResult<_> = {
             let from = self.time_zone().as_deref().unwrap_or("UTC");
             let to = time_zone.unwrap_or("UTC");
             let chunks = self
                 .downcast_iter()
                 .map(|arr| {
-                    replace_timezone(arr, self.time_unit().to_arrow(), to, from, use_earliest)
+                    replace_timezone(arr, self.time_unit().to_arrow(), from, to, use_earliest)
                 })
                 .collect::<PolarsResult<_>>()?;
             let out = unsafe { ChunkedArray::from_chunks(self.name(), chunks) };
             Ok(out.into_datetime(self.time_unit(), time_zone.map(|x| x.to_string())))
         };
         let mut out = out?;
         out.set_sorted_flag(self.is_sorted_flag());
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/temporal/duration.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/temporal/duration.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/temporal/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/temporal/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/temporal/time.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/temporal/time.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/to_vec.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/to_vec.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/trusted_len.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/trusted_len.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/chunked_array/upstream_traits.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/chunked_array/upstream_traits.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/cloud.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/cloud.rs`

 * *Files 1% similar despite different names*

```diff
@@ -27,15 +27,15 @@
 /// 2. be Serializable, required when the serde-lazy feature is defined.
 /// 3. not actually use HashMap since that type is disallowed in Polars for performance reasons.
 ///
 /// Currently this type is a vector of pairs config key - config value.
 #[allow(dead_code)]
 type Configs<T> = Vec<(T, String)>;
 
-#[derive(Clone, Debug, Default)]
+#[derive(Clone, Debug, Default, PartialEq)]
 #[cfg_attr(feature = "serde-lazy", derive(Serialize, Deserialize))]
 /// Options to connect to various cloud providers.
 pub struct CloudOptions {
     #[cfg(feature = "aws")]
     aws: Option<Configs<AmazonS3ConfigKey>>,
     #[cfg(feature = "azure")]
     azure: Option<Configs<AzureConfigKey>>,
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/config.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/config.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/datatypes/_serde.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/datatypes/_serde.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/datatypes/aliases.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/datatypes/aliases.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/datatypes/any_value.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/datatypes/any_value.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/datatypes/dtype.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/datatypes/dtype.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/datatypes/field.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/datatypes/field.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/datatypes/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/datatypes/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/datatypes/time_unit.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/datatypes/time_unit.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/doc/changelog/v0_10_0_11.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/doc/changelog/v0_10_0_11.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/doc/changelog/v0_7.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/doc/changelog/v0_7.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/doc/changelog/v0_8.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/doc/changelog/v0_8.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/doc/changelog/v0_9.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/doc/changelog/v0_9.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/fmt.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/fmt.rs`

 * *Files 5% similar despite different names*

```diff
@@ -20,15 +20,14 @@
 use comfy_table::presets::*;
 #[cfg(any(feature = "fmt", feature = "fmt_no_tty"))]
 use comfy_table::*;
 use num_traits::{Num, NumCast};
 
 use crate::config::*;
 use crate::prelude::*;
-
 const LIMIT: usize = 25;
 
 #[derive(Copy, Clone)]
 #[repr(u8)]
 pub enum FloatFmt {
     Mixed,
     Full,
@@ -348,32 +347,90 @@
         v.to_string()
     } else {
         format!("{v_trunc}")
     }
 }
 
 #[cfg(any(feature = "fmt", feature = "fmt_no_tty"))]
+fn field_to_str(f: &Field, str_truncate: usize) -> (String, usize) {
+    let name = make_str_val(f.name(), str_truncate);
+    let name_length = name.len();
+    let mut column_name = name;
+    if env_is_true(FMT_TABLE_HIDE_COLUMN_NAMES) {
+        column_name = "".to_string();
+    }
+    let column_data_type = if env_is_true(FMT_TABLE_HIDE_COLUMN_DATA_TYPES) {
+        "".to_string()
+    } else if env_is_true(FMT_TABLE_INLINE_COLUMN_DATA_TYPE)
+        | env_is_true(FMT_TABLE_HIDE_COLUMN_NAMES)
+    {
+        format!("{}", f.data_type())
+    } else {
+        format!("\n{}", f.data_type())
+    };
+    let mut dtype_length = column_data_type.trim_start().len();
+    let mut separator = "\n---";
+    if env_is_true(FMT_TABLE_HIDE_COLUMN_SEPARATOR)
+        | env_is_true(FMT_TABLE_HIDE_COLUMN_NAMES)
+        | env_is_true(FMT_TABLE_HIDE_COLUMN_DATA_TYPES)
+    {
+        separator = ""
+    }
+    let s = if env_is_true(FMT_TABLE_INLINE_COLUMN_DATA_TYPE)
+        & !env_is_true(FMT_TABLE_HIDE_COLUMN_DATA_TYPES)
+    {
+        let inline_name_dtype = format!("{column_name} ({column_data_type})");
+        dtype_length = inline_name_dtype.len();
+        inline_name_dtype
+    } else {
+        format!("{column_name}{separator}{column_data_type}")
+    };
+    let mut s_len = std::cmp::max(name_length, dtype_length);
+    let separator_length = separator.trim().len();
+    if s_len < separator_length {
+        s_len = separator_length;
+    }
+    (s, s_len + 2)
+}
+
+#[cfg(any(feature = "fmt", feature = "fmt_no_tty"))]
 fn prepare_row(
     row: Vec<Cow<'_, str>>,
     n_first: usize,
     n_last: usize,
     str_truncate: usize,
+    max_elem_lengths: &mut [usize],
 ) -> Vec<String> {
     let reduce_columns = n_first + n_last < row.len();
-    let mut row_str = Vec::with_capacity(n_first + n_last + reduce_columns as usize);
-    for v in row[0..n_first].iter() {
-        row_str.push(make_str_val(v, str_truncate));
+    let n_elems = n_first + n_last + reduce_columns as usize;
+    let mut row_strings = Vec::with_capacity(n_elems);
+
+    for (idx, v) in row[0..n_first].iter().enumerate() {
+        let elem_str = make_str_val(v, str_truncate);
+        let elem_len = elem_str.len() + 2;
+        if max_elem_lengths[idx] < elem_len {
+            max_elem_lengths[idx] = elem_len;
+        };
+        row_strings.push(elem_str);
     }
     if reduce_columns {
-        row_str.push("".to_string());
+        row_strings.push("".to_string());
+        max_elem_lengths[n_first] = 3;
     }
-    for v in row[row.len() - n_last..].iter() {
-        row_str.push(make_str_val(v, str_truncate));
+    let elem_offset = n_first + reduce_columns as usize;
+    for (idx, v) in row[row.len() - n_last..].iter().enumerate() {
+        let elem_str = make_str_val(v, str_truncate);
+        let elem_len = elem_str.len() + 2;
+        let elem_idx = elem_offset + idx;
+        if max_elem_lengths[elem_idx] < elem_len {
+            max_elem_lengths[elem_idx] = elem_len;
+        };
+        row_strings.push(elem_str);
     }
-    row_str
+    row_strings
 }
 
 fn env_is_true(varname: &str) -> bool {
     std::env::var(varname).as_deref().unwrap_or("0") == "1"
 }
 
 fn fmt_uint(num: &usize) -> String {
@@ -422,70 +479,34 @@
                 .map_or(8, |n: i64| if n < 0 { height } else { n as usize });
 
             let (n_first, n_last) = if self.width() > max_n_cols {
                 ((max_n_cols + 1) / 2, max_n_cols / 2)
             } else {
                 (self.width(), 0)
             };
-            let reduce_columns = n_first + n_last < self.width();
-            let mut names = Vec::with_capacity(n_first + n_last + reduce_columns as usize);
 
-            let field_to_str = |f: &Field| {
-                let name = make_str_val(f.name(), str_truncate);
-                let lower_bounds = name.len().clamp(5, 12);
-                let mut column_name = name;
-                if env_is_true(FMT_TABLE_HIDE_COLUMN_NAMES) {
-                    column_name = "".to_string();
-                }
-                let column_data_type = if env_is_true(FMT_TABLE_HIDE_COLUMN_DATA_TYPES) {
-                    "".to_string()
-                } else if env_is_true(FMT_TABLE_INLINE_COLUMN_DATA_TYPE)
-                    | env_is_true(FMT_TABLE_HIDE_COLUMN_NAMES)
-                {
-                    format!("{}", f.data_type())
-                } else {
-                    format!("\n{}", f.data_type())
-                };
-                let mut column_separator = "\n---";
-                if env_is_true(FMT_TABLE_HIDE_COLUMN_SEPARATOR)
-                    | env_is_true(FMT_TABLE_HIDE_COLUMN_NAMES)
-                    | env_is_true(FMT_TABLE_HIDE_COLUMN_DATA_TYPES)
-                {
-                    column_separator = ""
-                }
-                let s = if env_is_true(FMT_TABLE_INLINE_COLUMN_DATA_TYPE)
-                    & !env_is_true(FMT_TABLE_HIDE_COLUMN_DATA_TYPES)
-                {
-                    format!("{column_name} ({column_data_type})")
-                } else {
-                    format!("{column_name}{column_separator}{column_data_type}")
-                };
-                (s, lower_bounds)
-            };
-
-            let col_width_exact =
-                |l: usize| ColumnConstraint::Absolute(comfy_table::Width::Fixed(l as u16));
-            let col_width_lower_bound =
-                |l: usize| ColumnConstraint::LowerBoundary(comfy_table::Width::Fixed(l as u16));
+            let reduce_columns = n_first + n_last < self.width();
+            let n_tbl_cols = n_first + n_last + reduce_columns as usize;
+            let mut names = Vec::with_capacity(n_tbl_cols);
+            let mut name_lengths = Vec::with_capacity(n_tbl_cols);
 
-            let mut constraints = Vec::with_capacity(n_first + n_last + reduce_columns as usize);
             let fields = self.fields();
             for field in fields[0..n_first].iter() {
-                let (s, l) = field_to_str(field);
+                let (s, l) = field_to_str(field, str_truncate);
                 names.push(s);
-                constraints.push(col_width_lower_bound(l));
+                name_lengths.push(l);
             }
             if reduce_columns {
                 names.push("".into());
-                constraints.push(col_width_exact(3));
+                name_lengths.push(3);
             }
             for field in fields[self.width() - n_last..].iter() {
-                let (s, l) = field_to_str(field);
+                let (s, l) = field_to_str(field, str_truncate);
                 names.push(s);
-                constraints.push(col_width_lower_bound(l));
+                name_lengths.push(l);
             }
             let (preset, is_utf8) = match std::env::var(FMT_TABLE_FORMATTING)
                 .as_deref()
                 .unwrap_or("DEFAULT")
             {
                 "ASCII_FULL" => (ASCII_FULL, false),
                 "ASCII_FULL_CONDENSED" => (ASCII_FULL_CONDENSED, false),
@@ -508,88 +529,134 @@
             table
                 .load_preset(preset)
                 .set_content_arrangement(ContentArrangement::Dynamic);
 
             if is_utf8 && env_is_true(FMT_TABLE_ROUNDED_CORNERS) {
                 table.apply_modifier(UTF8_ROUND_CORNERS);
             }
+
+            let mut constraints = Vec::with_capacity(n_tbl_cols);
+            let mut max_elem_lengths: Vec<usize> = vec![0; n_tbl_cols];
+
             if max_n_rows > 0 {
                 if height > max_n_rows + 1 {
-                    // Truncate the table if we have more rows than the configured maximum number
-                    // of rows plus the single row which would contain "".
+                    // Truncate the table if we have more rows than the configured maximum
+                    // number of rows plus the single row which would contain "".
                     let mut rows = Vec::with_capacity(std::cmp::max(max_n_rows, 2));
                     for i in 0..std::cmp::max(max_n_rows / 2, 1) {
                         let row = self
                             .columns
                             .iter()
                             .map(|s| s.str_value(i).unwrap())
                             .collect();
-                        rows.push(prepare_row(row, n_first, n_last, str_truncate));
+
+                        let row_strings =
+                            prepare_row(row, n_first, n_last, str_truncate, &mut max_elem_lengths);
+
+                        rows.push(row_strings);
                     }
                     let dots = rows[0].iter().map(|_| "".to_string()).collect();
                     rows.push(dots);
                     if max_n_rows > 1 {
                         for i in (height - (max_n_rows + 1) / 2)..height {
                             let row = self
                                 .columns
                                 .iter()
                                 .map(|s| s.str_value(i).unwrap())
                                 .collect();
-                            rows.push(prepare_row(row, n_first, n_last, str_truncate));
+
+                            let row_strings = prepare_row(
+                                row,
+                                n_first,
+                                n_last,
+                                str_truncate,
+                                &mut max_elem_lengths,
+                            );
+                            rows.push(row_strings);
                         }
                     }
                     table.add_rows(rows);
                 } else {
                     for i in 0..height {
                         if self.width() > 0 {
                             let row = self
                                 .columns
                                 .iter()
                                 .map(|s| s.str_value(i).unwrap())
                                 .collect();
-                            table.add_row(prepare_row(row, n_first, n_last, str_truncate));
+
+                            let row_strings = prepare_row(
+                                row,
+                                n_first,
+                                n_last,
+                                str_truncate,
+                                &mut max_elem_lengths,
+                            );
+                            table.add_row(row_strings);
                         } else {
                             break;
                         }
                     }
                 }
             } else if height > 0 {
                 let dots: Vec<String> = self.columns.iter().map(|_| "".to_string()).collect();
                 table.add_row(dots);
             }
 
-            // insert a header row, unless both column names and column data types are already hidden
-            if !(env_is_true(FMT_TABLE_HIDE_COLUMN_NAMES)
-                && env_is_true(FMT_TABLE_HIDE_COLUMN_DATA_TYPES))
-            {
-                table.set_header(names).set_constraints(constraints);
-            }
+            let tbl_fallback_width = 100;
             let tbl_width = std::env::var("POLARS_TABLE_WIDTH")
                 .map(|s| {
                     Some(
                         s.parse::<u16>()
                             .expect("could not parse table width argument"),
                     )
                 })
                 .unwrap_or(None);
 
+            // column width constraints
+            let col_width_exact =
+                |w: usize| ColumnConstraint::Absolute(comfy_table::Width::Fixed(w as u16));
+            let col_width_bounds = |l: usize, u: usize| ColumnConstraint::Boundaries {
+                lower: Width::Fixed(l as u16),
+                upper: Width::Fixed(u as u16),
+            };
+            let min_col_width = 5;
+            for (idx, elem_len) in max_elem_lengths.iter().enumerate() {
+                let mx = std::cmp::min(
+                    str_truncate + 3, // (3 = 2 space chars of padding + ellipsis char)
+                    std::cmp::max(name_lengths[idx], *elem_len),
+                );
+                if mx <= min_col_width {
+                    constraints.push(col_width_exact(mx));
+                } else {
+                    constraints.push(col_width_bounds(min_col_width, mx));
+                }
+            }
+
+            // insert a header row, unless both column names and dtypes are hidden
+            if !(env_is_true(FMT_TABLE_HIDE_COLUMN_NAMES)
+                && env_is_true(FMT_TABLE_HIDE_COLUMN_DATA_TYPES))
+            {
+                table.set_header(names).set_constraints(constraints);
+            }
+
             // if tbl_width is explicitly set, use it
             if let Some(w) = tbl_width {
                 table.set_width(w);
-            }
-
-            // if no tbl_width (its not-tty && it is not explicitly set), then set default.
-            // this is needed to support non-tty applications
-            #[cfg(feature = "fmt")]
-            if table.width().is_none() && !table.is_tty() {
-                table.set_width(100);
-            }
-            #[cfg(feature = "fmt_no_tty")]
-            if table.width().is_none() {
-                table.set_width(100);
+            } else {
+                // if no tbl_width (it's not tty && width not explicitly set), apply
+                // a default value; this is needed to support non-tty applications
+                #[cfg(feature = "fmt")]
+                if table.width().is_none() && !table.is_tty() {
+                    table.set_width(tbl_fallback_width);
+                }
+                #[cfg(feature = "fmt_no_tty")]
+                if table.width().is_none() {
+                    table.set_width(tbl_fallback_width);
+                }
             }
 
             // set alignment of cells, if defined
             if std::env::var(FMT_TABLE_CELL_ALIGNMENT).is_ok() {
                 // for (column_index, column) in table.column_iter_mut().enumerate() {
                 let str_preset = std::env::var(FMT_TABLE_CELL_ALIGNMENT)
                     .unwrap_or_else(|_| "DEFAULT".to_string());
@@ -603,34 +670,34 @@
                     } else {
                         column.set_cell_alignment(CellAlignment::Left);
                     }
                 }
             }
 
             // establish 'shape' information (above/below/hidden)
-            let shape_str = fmt_df_shape(&self.shape());
-
             if env_is_true(FMT_TABLE_HIDE_DATAFRAME_SHAPE_INFORMATION) {
                 write!(f, "{table}")?;
-            } else if env_is_true(FMT_TABLE_DATAFRAME_SHAPE_BELOW) {
-                write!(f, "{table}\nshape: {}", shape_str)?;
             } else {
-                write!(f, "shape: {}\n{}", shape_str, table)?;
+                let shape_str = fmt_df_shape(&self.shape());
+                if env_is_true(FMT_TABLE_DATAFRAME_SHAPE_BELOW) {
+                    write!(f, "{table}\nshape: {}", shape_str)?;
+                } else {
+                    write!(f, "shape: {}\n{}", shape_str, table)?;
+                }
             }
         }
 
         #[cfg(not(any(feature = "fmt", feature = "fmt_no_tty")))]
         {
             write!(
                 f,
                 "shape: {:?}\nto see more, compile with the 'fmt' or 'fmt_no_tty' feature",
                 self.shape()
             )?;
         }
-
         Ok(())
     }
 }
 
 fn fmt_integer<T: Num + NumCast + Display>(
     f: &mut Formatter<'_>,
     width: usize,
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/arithmetic.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/arithmetic.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/asof_join/asof.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/asof_join/asof.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/asof_join/groups.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/asof_join/groups.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/asof_join/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/asof_join/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/chunks.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/chunks.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/cross_join.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/cross_join.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/explode.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/explode.rs`

 * *Files 0% similar despite different names*

```diff
@@ -397,15 +397,15 @@
             "B" => [1, 1, 1, 2, 2, 2, 3],
             "C" => [1, 1, 1, 1, 1, 1, 1],
         ]?;
 
         assert!(out.frame_equal_missing(&expected));
 
         let list = Series::new("foo", [s0.clone(), s1.clear(), s1.clone()]);
-        let df = DataFrame::new(vec![list, s0.clone(), s1.clone()])?;
+        let df = DataFrame::new(vec![list, s0, s1])?;
         let out = df.explode(["foo"])?;
         let expected = df![
             "foo" => [Some(1), Some(2), Some(3), None, Some(1), Some(1), Some(1)],
             "B" => [1, 1, 1, 2, 3, 3, 3],
             "C" => [1, 1, 1, 1, 1, 1, 1],
         ]?;
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/from.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/from.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/groupby/aggregations/agg_list.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/groupby/aggregations/agg_list.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/groupby/aggregations/boolean.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/groupby/aggregations/boolean.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/groupby/aggregations/dispatch.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/groupby/aggregations/dispatch.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/groupby/aggregations/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/groupby/aggregations/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/groupby/aggregations/utf8.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/groupby/aggregations/utf8.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/groupby/hashing.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/groupby/hashing.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/groupby/into_groups.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/groupby/into_groups.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/groupby/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/groupby/mod.rs`

 * *Files 0% similar despite different names*

```diff
@@ -1076,15 +1076,15 @@
         let df = df! {"flt" => [1., 1., 2., 2., 3.],
                     "val" => [1, 1, 1, 1, 1]
         }
         .unwrap();
         // Use of deprecated `sum()` for testing purposes
         #[allow(deprecated)]
         let res = df.groupby(["flt"]).unwrap().sum().unwrap();
-        let res = res.sort(["flt"], false).unwrap();
+        let res = res.sort(["flt"], false, false).unwrap();
         assert_eq!(
             Vec::from(res.column("val_sum").unwrap().i32().unwrap()),
             &[Some(2), Some(2), Some(1)]
         );
     }
 
     #[test]
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/groupby/perfect.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/groupby/perfect.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/groupby/proxy.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/groupby/proxy.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/args.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/args.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/multiple_keys.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/multiple_keys.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/single_keys.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/single_keys.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/single_keys_dispatch.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/single_keys_dispatch.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/single_keys_inner.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/single_keys_inner.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/single_keys_left.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/single_keys_left.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/single_keys_outer.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/single_keys_outer.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/single_keys_semi_anti.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/single_keys_semi_anti.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/sort_merge.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/sort_merge.rs`

 * *Files 2% similar despite different names*

```diff
@@ -220,14 +220,15 @@
                 eprintln!("right key will be descending sorted in inner join operation.")
             }
 
             let sort_idx = s_right.arg_sort(SortOptions {
                 descending: false,
                 nulls_last: false,
                 multithreaded: true,
+                maintain_order: false,
             });
             let s_right = unsafe { s_right.take_unchecked(&sort_idx).unwrap() };
             let ids = par_sorted_merge_inner_no_nulls(s_left, &s_right);
             let reverse_idx_map = create_reverse_map_from_arg_sort(sort_idx);
 
             let (left, mut right) = ids;
 
@@ -246,14 +247,15 @@
                 eprintln!("left key will be descending sorted in inner join operation.")
             }
 
             let sort_idx = s_left.arg_sort(SortOptions {
                 descending: false,
                 nulls_last: false,
                 multithreaded: true,
+                maintain_order: false,
             });
             let s_left = unsafe { s_left.take_unchecked(&sort_idx).unwrap() };
             let ids = par_sorted_merge_inner_no_nulls(&s_left, s_right);
             let reverse_idx_map = create_reverse_map_from_arg_sort(sort_idx);
 
             let (mut left, right) = ids;
 
@@ -314,14 +316,15 @@
                 eprintln!("right key will be reverse sorted in left join operation.")
             }
 
             let sort_idx = s_right.arg_sort(SortOptions {
                 descending: false,
                 nulls_last: false,
                 multithreaded: true,
+                maintain_order: false,
             });
             let s_right = unsafe { s_right.take_unchecked(&sort_idx).unwrap() };
 
             let ids = par_sorted_merge_left(s_left, &s_right);
             let reverse_idx_map = create_reverse_map_from_arg_sort(sort_idx);
             let (left, mut right) = ids;
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/hash_join/zip_outer.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/hash_join/zip_outer.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/mod.rs`

 * *Files 1% similar despite different names*

```diff
@@ -1069,29 +1069,34 @@
                 new_cols.push(s.clone())
             }
         });
 
         Ok(DataFrame::new_no_checks(new_cols))
     }
 
+    /// Drop columns that are in `names`.
     pub fn drop_many<S: AsRef<str>>(&self, names: &[S]) -> Self {
-        let names = names.iter().map(|s| s.as_ref()).collect();
-        fn inner(df: &DataFrame, names: Vec<&str>) -> DataFrame {
-            let mut new_cols = Vec::with_capacity(df.columns.len() - names.len());
-            df.columns.iter().for_each(|s| {
-                if !names.contains(&s.name()) {
-                    new_cols.push(s.clone())
-                }
-            });
+        let names: PlHashSet<_> = names.iter().map(|s| s.as_ref()).collect();
+        self.drop_many_amortized(&names)
+    }
 
-            DataFrame::new_no_checks(new_cols)
-        }
-        inner(self, names)
+    /// Drop columns that are in `names` without allocating a `HashSet`.
+    pub fn drop_many_amortized(&self, names: &PlHashSet<&str>) -> DataFrame {
+        let mut new_cols = Vec::with_capacity(self.columns.len().saturating_sub(names.len()));
+        self.columns.iter().for_each(|s| {
+            if !names.contains(&s.name()) {
+                new_cols.push(s.clone())
+            }
+        });
+
+        DataFrame::new_no_checks(new_cols)
     }
 
+    /// Insert a new column at a given index without checking for duplicates.
+    /// This can leave the DataFrame at an invalid state
     fn insert_at_idx_no_name_check(
         &mut self,
         index: usize,
         series: Series,
     ) -> PolarsResult<&mut Self> {
         polars_ensure!(
             series.len() == self.height(),
@@ -1832,29 +1837,31 @@
     }
 
     /// Sort `DataFrame` in place by a column.
     pub fn sort_in_place(
         &mut self,
         by_column: impl IntoVec<SmartString>,
         descending: impl IntoVec<bool>,
+        maintain_order: bool,
     ) -> PolarsResult<&mut Self> {
         let by_column = self.select_series(by_column)?;
         let descending = descending.into_vec();
         self.columns = self
-            .sort_impl(by_column, descending, false, None, true)?
+            .sort_impl(by_column, descending, false, maintain_order, None, true)?
             .columns;
         Ok(self)
     }
 
     /// This is the dispatch of Self::sort, and exists to reduce compile bloat by monomorphization.
     pub fn sort_impl(
         &self,
         by_column: Vec<Series>,
         descending: Vec<bool>,
         nulls_last: bool,
+        maintain_order: bool,
         slice: Option<(i64, usize)>,
         parallel: bool,
     ) -> PolarsResult<Self> {
         // note that the by_column argument also contains evaluated expression from polars-lazy
         // that may not even be present in this dataframe.
 
         // therefore when we try to set the first columns as sorted, we ignore the error
@@ -1881,15 +1888,15 @@
             let mut out = self.clone();
             set_sorted(&mut out);
 
             return Ok(out);
         }
 
         if let Some((0, k)) = slice {
-            return self.top_k_impl(k, descending, by_column, nulls_last);
+            return self.top_k_impl(k, descending, by_column, nulls_last, maintain_order);
         }
 
         #[cfg(feature = "dtype-struct")]
         let has_struct = by_column
             .iter()
             .any(|s| matches!(s.dtype(), DataType::Struct(_)));
 
@@ -1903,14 +1910,15 @@
         let mut take = match (by_column.len(), has_struct) {
             (1, false) => {
                 let s = &by_column[0];
                 let options = SortOptions {
                     descending: descending[0],
                     nulls_last,
                     multithreaded: parallel,
+                    maintain_order,
                 };
                 // fast path for a frame with a single series
                 // no need to compute the sort indices and then take by these indices
                 // simply sort and return as frame
                 if df.width() == 1 && df.check_name_to_idx(s.name()).is_ok() {
                     let mut out = s.sort_with(options);
                     if let Some((offset, len)) = slice {
@@ -1950,41 +1958,43 @@
     /// Return a sorted clone of this `DataFrame`.
     ///
     /// # Example
     ///
     /// ```
     /// # use polars_core::prelude::*;
     /// fn sort_example(df: &DataFrame, descending: bool) -> PolarsResult<DataFrame> {
-    ///     df.sort(["a"], descending)
+    ///     df.sort(["a"], descending, false)
     /// }
     ///
     /// fn sort_by_multiple_columns_example(df: &DataFrame) -> PolarsResult<DataFrame> {
-    ///     df.sort(&["a", "b"], vec![false, true])
+    ///     df.sort(&["a", "b"], vec![false, true], false)
     /// }
     /// ```
     pub fn sort(
         &self,
         by_column: impl IntoVec<SmartString>,
         descending: impl IntoVec<bool>,
+        maintain_order: bool,
     ) -> PolarsResult<Self> {
         let mut df = self.clone();
-        df.sort_in_place(by_column, descending)?;
+        df.sort_in_place(by_column, descending, maintain_order)?;
         Ok(df)
     }
 
     /// Sort the `DataFrame` by a single column with extra options.
     pub fn sort_with_options(&self, by_column: &str, options: SortOptions) -> PolarsResult<Self> {
         let mut df = self.clone();
         let by_column = vec![df.column(by_column)?.clone()];
         let descending = vec![options.descending];
         df.columns = df
             .sort_impl(
                 by_column,
                 descending,
                 options.nulls_last,
+                options.maintain_order,
                 None,
                 options.multithreaded,
             )?
             .columns;
         Ok(df)
     }
 
@@ -3324,55 +3334,71 @@
 
     #[cfg(feature = "partition_by")]
     #[doc(hidden)]
     pub fn _partition_by_impl(
         &self,
         cols: &[String],
         stable: bool,
+        include_key: bool,
     ) -> PolarsResult<Vec<DataFrame>> {
         let groups = if stable {
             self.groupby_stable(cols)?.take_groups()
         } else {
             self.groupby(cols)?.take_groups()
         };
 
+        // drop key columns prior to calculation if requested
+        let df = if include_key {
+            self.clone()
+        } else {
+            self.drop_many(cols)
+        };
+
         // don't parallelize this
         // there is a lot of parallelization in take and this may easily SO
         POOL.install(|| {
             match groups {
                 GroupsProxy::Idx(idx) => {
                     Ok(idx
                         .into_par_iter()
                         .map(|(_, group)| {
                             // groups are in bounds
-                            unsafe { self._take_unchecked_slice(&group, false) }
+                            unsafe { df._take_unchecked_slice(&group, false) }
                         })
                         .collect())
                 }
                 GroupsProxy::Slice { groups, .. } => Ok(groups
                     .into_par_iter()
-                    .map(|[first, len]| self.slice(first as i64, len as usize))
+                    .map(|[first, len]| df.slice(first as i64, len as usize))
                     .collect()),
             }
         })
     }
 
     /// Split into multiple DataFrames partitioned by groups
     #[cfg(feature = "partition_by")]
-    pub fn partition_by(&self, cols: impl IntoVec<String>) -> PolarsResult<Vec<DataFrame>> {
+    pub fn partition_by(
+        &self,
+        cols: impl IntoVec<String>,
+        include_key: bool,
+    ) -> PolarsResult<Vec<DataFrame>> {
         let cols = cols.into_vec();
-        self._partition_by_impl(&cols, false)
+        self._partition_by_impl(&cols, false, include_key)
     }
 
     /// Split into multiple DataFrames partitioned by groups
     /// Order of the groups are maintained.
     #[cfg(feature = "partition_by")]
-    pub fn partition_by_stable(&self, cols: impl IntoVec<String>) -> PolarsResult<Vec<DataFrame>> {
+    pub fn partition_by_stable(
+        &self,
+        cols: impl IntoVec<String>,
+        include_key: bool,
+    ) -> PolarsResult<Vec<DataFrame>> {
         let cols = cols.into_vec();
-        self._partition_by_impl(&cols, true)
+        self._partition_by_impl(&cols, true, include_key)
     }
 
     /// Unnest the given `Struct` columns. This means that the fields of the `Struct` type will be
     /// inserted as columns.
     #[cfg(feature = "dtype-struct")]
     pub fn unnest<I: IntoVec<String>>(&self, cols: I) -> PolarsResult<DataFrame> {
         let cols = cols.into_vec();
@@ -3594,15 +3620,15 @@
             "int" => [1, 1, 2, 2, 3, 3, ],
             "str" => ["a", "a", "b", "b", "c", "c"]
         }
         .unwrap();
         let df = df
             .unique_stable(None, UniqueKeepStrategy::First, None)
             .unwrap()
-            .sort(["flt"], false)
+            .sort(["flt"], false, false)
             .unwrap();
         let valid = df! {
             "flt" => [1., 2., 3.],
             "int" => [1, 2, 3],
             "str" => ["a", "b", "c"]
         }
         .unwrap();
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/row/av_buffer.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/row/av_buffer.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/row/dataframe.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/row/dataframe.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/row/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/row/mod.rs`

 * *Files 4% similar despite different names*

```diff
@@ -89,22 +89,23 @@
         AnyValue::List(s) => s.null_count() == s.len(),
         #[cfg(feature = "dtype-struct")]
         AnyValue::Struct(_, _, _) => av._iter_struct_av().all(|av| is_nested_null(&av)),
         _ => false,
     }
 }
 
-pub fn any_values_to_dtype(column: &[AnyValue]) -> PolarsResult<DataType> {
+pub fn any_values_to_dtype(column: &[AnyValue]) -> PolarsResult<(DataType, usize)> {
     // we need an index-map as the order of dtypes influences how the
     // struct fields are constructed.
     let mut types_set = PlIndexSet::new();
     for val in column.iter() {
         types_set.insert(val.into());
     }
-    types_set_to_dtype(types_set)
+    let n_types = types_set.len();
+    Ok((types_set_to_dtype(types_set)?, n_types))
 }
 
 fn types_set_to_dtype(types_set: PlIndexSet<DataType>) -> PolarsResult<DataType> {
     types_set
         .into_iter()
         .map(Ok)
         .fold_first_(|a, b| try_get_supertype(&a?, &b?))
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/row/transpose.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/row/transpose.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/top_k.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/top_k.rs`

 * *Files 8% similar despite different names*

```diff
@@ -42,36 +42,45 @@
         &self,
         k: usize,
         descending: impl IntoVec<bool>,
         by_column: impl IntoVec<SmartString>,
     ) -> PolarsResult<DataFrame> {
         let by_column = self.select_series(by_column)?;
         let descending = descending.into_vec();
-        self.top_k_impl(k, descending, by_column, false)
+        self.top_k_impl(k, descending, by_column, false, false)
     }
 
     pub(crate) fn top_k_impl(
         &self,
         k: usize,
         mut descending: Vec<bool>,
         by_column: Vec<Series>,
         nulls_last: bool,
+        maintain_order: bool,
     ) -> PolarsResult<DataFrame> {
         _broadcast_descending(by_column.len(), &mut descending);
         let encoded = _get_rows_encoded(&by_column, &descending, nulls_last)?;
         let arr = encoded.into_array();
         let mut rows = arr
             .values_iter()
             .enumerate_idx()
             .map(|(idx, bytes)| CompareRow { idx, bytes })
             .collect::<Vec<_>>();
 
         let sorted = if k >= self.height() {
-            rows.sort_unstable();
+            if maintain_order {
+                rows.sort();
+            } else {
+                rows.sort_unstable();
+            }
             &rows
+        } else if maintain_order {
+            // todo: maybe there is some more efficient method, comparable to select_nth_unstable
+            rows.sort();
+            &rows[..k]
         } else {
             let (lower, _el, _upper) = rows.select_nth_unstable(k);
             lower.sort_unstable();
             &*lower
         };
 
         let idx: NoNull<IdxCa> = sorted.iter().map(|cmp_row| cmp_row.idx).collect();
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/frame/upstream_traits.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/frame/upstream_traits.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/functions.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/functions.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/hashing/fx.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/hashing/fx.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/hashing/identity.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/hashing/identity.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/hashing/partition.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/hashing/partition.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/hashing/vector_hasher.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/hashing/vector_hasher.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/lib.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/lib.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/named_from.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/named_from.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/prelude.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/prelude.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/schema.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/schema.rs`

 * *Files 1% similar despite different names*

```diff
@@ -385,15 +385,15 @@
         polars_ensure!(self.len() == other.len(), ComputeError: "schema lengths differ");
 
         let mut changed = false;
         for ((k, dt), (other_k, other_dt)) in self.inner.iter_mut().zip(other.iter()) {
             polars_ensure!(k == other_k, ComputeError: "schema names differ: got {}, expected {}", k, other_k);
 
             let st = try_get_supertype(dt, other_dt)?;
-            changed |= &st != dt;
+            changed |= (&st != dt) || (&st != other_dt);
             *dt = st
         }
         Ok(changed)
     }
 }
 
 pub type SchemaRef = Arc<Schema>;
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/serde/chunked_array.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/serde/chunked_array.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/serde/df.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/serde/df.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/serde/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/serde/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/serde/series.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/serde/series.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/any_value.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/any_value.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/arithmetic/borrowed.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/arithmetic/borrowed.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/arithmetic/owned.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/arithmetic/owned.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/comparison.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/comparison.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/from.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/from.rs`

 * *Files 1% similar despite different names*

```diff
@@ -196,16 +196,17 @@
                 Ok(ca.into_datetime(TimeUnit::Milliseconds, None).into_series())
             }
             #[cfg(feature = "dtype-datetime")]
             ArrowDataType::Timestamp(tu, tz) => {
                 let mut tz = tz.clone();
                 if tz.as_deref() == Some("") {
                     tz = None;
-                }
-                if let Some(_tz) = &tz {
+                } else if tz.as_deref() == Some("+00:00") {
+                    tz = Some("UTC".to_string());
+                } else if let Some(_tz) = &tz {
                     #[cfg(feature = "timezones")]
                     validate_time_zone(_tz)?;
                 }
                 let chunks = cast_chunks(&chunks, &DataType::Int64, false).unwrap();
                 let s = Int64Chunked::from_chunks(name, chunks)
                     .into_datetime(tu.into(), tz)
                     .into_series();
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/array.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/list.rs`

 * *Files 1% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 use crate::chunked_array::ops::explode::ExplodeByOffsets;
 use crate::chunked_array::AsSinglePtr;
 use crate::frame::groupby::*;
 use crate::prelude::*;
 use crate::series::implementations::SeriesWrap;
 use crate::series::IsSorted;
 
-impl private::PrivateSeries for SeriesWrap<ArrayChunked> {
+impl private::PrivateSeries for SeriesWrap<ListChunked> {
     fn compute_len(&mut self) {
         self.0.compute_len()
     }
     fn _field(&self) -> Cow<Field> {
         Cow::Borrowed(self.0.ref_field())
     }
     fn _dtype(&self) -> &DataType {
@@ -42,15 +42,15 @@
     }
 
     fn group_tuples(&self, multithreaded: bool, sorted: bool) -> PolarsResult<GroupsProxy> {
         IntoGroupsProxy::group_tuples(&self.0, multithreaded, sorted)
     }
 }
 
-impl SeriesTrait for SeriesWrap<ArrayChunked> {
+impl SeriesTrait for SeriesWrap<ListChunked> {
     fn rename(&mut self, name: &str) {
         self.0.rename(name);
     }
 
     fn chunk_lengths(&self) -> ChunkIdIter {
         self.0.chunk_id()
     }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/binary.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/binary.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/boolean.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/boolean.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/categorical.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/categorical.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/dates_time.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/dates_time.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/datetime.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/datetime.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/decimal.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/decimal.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/duration.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/duration.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/floats.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/floats.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/list.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/array.rs`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 use crate::chunked_array::ops::explode::ExplodeByOffsets;
 use crate::chunked_array::AsSinglePtr;
 use crate::frame::groupby::*;
 use crate::prelude::*;
 use crate::series::implementations::SeriesWrap;
 use crate::series::IsSorted;
 
-impl private::PrivateSeries for SeriesWrap<ListChunked> {
+impl private::PrivateSeries for SeriesWrap<ArrayChunked> {
     fn compute_len(&mut self) {
         self.0.compute_len()
     }
     fn _field(&self) -> Cow<Field> {
         Cow::Borrowed(self.0.ref_field())
     }
     fn _dtype(&self) -> &DataType {
@@ -42,15 +42,15 @@
     }
 
     fn group_tuples(&self, multithreaded: bool, sorted: bool) -> PolarsResult<GroupsProxy> {
         IntoGroupsProxy::group_tuples(&self.0, multithreaded, sorted)
     }
 }
 
-impl SeriesTrait for SeriesWrap<ListChunked> {
+impl SeriesTrait for SeriesWrap<ArrayChunked> {
     fn rename(&mut self, name: &str) {
         self.0.rename(name);
     }
 
     fn chunk_lengths(&self) -> ChunkIdIter {
         self.0.chunk_id()
     }
@@ -67,15 +67,16 @@
 
     fn slice(&self, offset: i64, length: usize) -> Series {
         self.0.slice(offset, length).into_series()
     }
 
     fn append(&mut self, other: &Series) -> PolarsResult<()> {
         polars_ensure!(self.0.dtype() == other.dtype(), append);
-        self.0.append(other.as_ref().as_ref())
+        let other = other.array()?;
+        self.0.append(other)
     }
 
     fn extend(&mut self, other: &Series) -> PolarsResult<()> {
         polars_ensure!(self.0.dtype() == other.dtype(), extend);
         self.0.extend(other.as_ref().as_ref())
     }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/null.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/null.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/object.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/object.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/struct_.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/struct_.rs`

 * *Files 0% similar despite different names*

```diff
@@ -363,14 +363,15 @@
             vec![false; df.width()]
         };
         let out = df
             .sort_impl(
                 df.columns.clone(),
                 desc,
                 options.nulls_last,
+                options.maintain_order,
                 None,
                 options.multithreaded,
             )
             .unwrap();
         StructChunked::new_unchecked(self.name(), &out.columns).into_series()
     }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/implementations/utf8.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/implementations/utf8.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/into.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/into.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/iterator.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/iterator.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/ops/diff.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/ops/diff.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/ops/downcast.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/ops/downcast.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/ops/ewm.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/ops/ewm.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/ops/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/ops/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/ops/moment.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/ops/moment.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/ops/null.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/ops/null.rs`

 * *Files 7% similar despite different names*

```diff
@@ -3,14 +3,18 @@
 impl Series {
     pub fn full_null(name: &str, size: usize, dtype: &DataType) -> Self {
         // match the logical types and create them
         match dtype {
             DataType::List(inner_dtype) => {
                 ListChunked::full_null_with_dtype(name, size, inner_dtype).into_series()
             }
+            #[cfg(feature = "dtype-array")]
+            DataType::Array(inner_dtype, width) => {
+                ArrayChunked::full_null_with_dtype(name, size, inner_dtype, *width).into_series()
+            }
             #[cfg(feature = "dtype-categorical")]
             DataType::Categorical(rev_map) => {
                 let mut ca = CategoricalChunked::full_null(name, size);
                 // ensure we keep the rev-map of a cleared series
                 if let Some(rev_map) = rev_map {
                     unsafe { ca.set_rev_map(rev_map.clone(), false) }
                 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/ops/pct_change.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/ops/pct_change.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/ops/round.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/ops/round.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/ops/to_list.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/ops/to_list.rs`

 * *Files 2% similar despite different names*

```diff
@@ -137,15 +137,15 @@
     use crate::chunked_array::builder::get_list_builder;
 
     #[test]
     fn test_to_list() -> PolarsResult<()> {
         let s = Series::new("a", &[1, 2, 3]);
 
         let mut builder = get_list_builder(s.dtype(), s.len(), 1, s.name())?;
-        builder.append_series(&s);
+        builder.append_series(&s).unwrap();
         let expected = builder.finish();
 
         let out = s.implode()?;
         assert!(expected.into_series().series_equal(&out.into_series()));
 
         Ok(())
     }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/ops/unique.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/ops/unique.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/series_trait.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/series_trait.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/series/unstable.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/series/unstable.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/testing.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/testing.rs`

 * *Files 0% similar despite different names*

```diff
@@ -187,16 +187,15 @@
 
     #[test]
     fn test_df_equal() {
         let a = Series::new("a", [1, 2, 3].as_ref());
         let b = Series::new("b", [1, 2, 3].as_ref());
 
         let df1 = DataFrame::new(vec![a, b]).unwrap();
-        let df2 = df1.clone();
-        assert!(df1.frame_equal(&df2))
+        assert!(df1.frame_equal(&df1))
     }
 
     #[test]
     fn test_df_partialeq() {
         let df1 = df!("a" => &[1, 2, 3],
                       "b" => &[4, 5, 6])
         .unwrap();
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/utils/flatten.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/utils/flatten.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/utils/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/utils/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/utils/series.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/utils/series.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-core/src/utils/supertype.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/src/utils/supertype.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/Cargo.toml` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/Cargo.toml`

 * *Files 2% similar despite different names*

```diff
@@ -118,14 +118,15 @@
 cse = []
 propagate_nans = ["polars-ops/propagate_nans"]
 coalesce = []
 fused = []
 list_sets = ["polars-ops/list_sets"]
 list_any_all = ["polars-ops/list_any_all"]
 cutqcut = ["polars-ops/cutqcut"]
+rle = ["polars-ops/rle"]
 
 bigidx = ["polars-arrow/bigidx", "polars-core/bigidx", "polars-utils/bigidx"]
 
 panic_on_schema = []
 
 [package.metadata.docs.rs]
 all-features = true
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/LICENSE` & `polars_u64_idx-0.18.7/local_dependencies/polars-error/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dot.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dot.rs`

 * *Files 9% similar despite different names*

```diff
@@ -336,71 +336,36 @@
                 };
                 if self.is_single(branch, id) {
                     self.write_single_node(acc_str, current_node)
                 } else {
                     self.write_dot(acc_str, prev_node, current_node, id_map)
                 }
             }
-            #[cfg(feature = "csv")]
-            CsvScan {
-                path,
-                options,
-                file_info,
-                predicate,
-                ..
-            } => self.write_scan(
-                acc_str,
-                prev_node,
-                "CSV",
-                path.as_ref(),
-                options.with_columns.as_deref().map(|cols| cols.as_slice()),
-                file_info.schema.len(),
-                predicate,
-                branch,
-                id,
-                id_map,
-            ),
-            #[cfg(feature = "parquet")]
-            ParquetScan {
-                path,
-                file_info,
-                predicate,
-                options,
-                ..
-            } => self.write_scan(
-                acc_str,
-                prev_node,
-                "PARQUET",
-                path.as_ref(),
-                options.with_columns.as_deref().map(|cols| cols.as_slice()),
-                file_info.schema.len(),
-                predicate,
-                branch,
-                id,
-                id_map,
-            ),
-            #[cfg(feature = "ipc")]
-            IpcScan {
+            Scan {
                 path,
                 file_info,
-                options,
-                predicate,
-                ..
-            } => self.write_scan(
-                acc_str,
-                prev_node,
-                "IPC",
-                path.as_ref(),
-                options.with_columns.as_deref().map(|cols| cols.as_slice()),
-                file_info.schema.len(),
                 predicate,
-                branch,
-                id,
-                id_map,
-            ),
+                scan_type,
+                file_options: options,
+            } => {
+                let name: &str = scan_type.into();
+
+                self.write_scan(
+                    acc_str,
+                    prev_node,
+                    name,
+                    path.as_ref(),
+                    options.with_columns.as_ref().map(|cols| cols.as_slice()),
+                    file_info.schema.len(),
+                    predicate,
+                    branch,
+                    id,
+                    id_map,
+                )
+            }
             Join {
                 input_left,
                 input_right,
                 left_on,
                 right_on,
                 options,
                 ..
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/arithmetic.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/arithmetic.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/arity.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/arity.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/array.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/array.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/binary.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/binary.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/cat.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/cat.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/dt.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/dt.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/expr.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/expr.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/expr_dyn_fn.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/expr_dyn_fn.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/from.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/from.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/arg_where.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/arg_where.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/array.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/array.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/binary.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/binary.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/boolean.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/boolean.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/bounds.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/bounds.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/cat.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/cat.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/correlation.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/correlation.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/cum.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/cum.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/datetime.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/datetime.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/dispatch.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/dispatch.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/fill_null.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/fill_null.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/fused.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/fused.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/list.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/list.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/log.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/log.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/mod.rs`

 * *Files 0% similar despite different names*

```diff
@@ -61,14 +61,16 @@
 pub(crate) use correlation::CorrelationMethod;
 #[cfg(feature = "fused")]
 pub(crate) use fused::FusedOperator;
 pub(super) use list::ListFunction;
 use polars_core::prelude::*;
 #[cfg(feature = "cutqcut")]
 use polars_ops::prelude::{cut, qcut};
+#[cfg(feature = "rle")]
+use polars_ops::prelude::{rle, rle_id};
 #[cfg(feature = "random")]
 pub(crate) use random::RandomMethod;
 use schema::FieldsMapper;
 #[cfg(feature = "serde")]
 use serde::{Deserialize, Serialize};
 
 pub(crate) use self::binary::BinaryFunction;
@@ -201,22 +203,28 @@
         ddof: u8,
     },
     #[cfg(feature = "cutqcut")]
     Cut {
         breaks: Vec<f64>,
         labels: Option<Vec<String>>,
         left_closed: bool,
+        include_breaks: bool,
     },
     #[cfg(feature = "cutqcut")]
     QCut {
         probs: Vec<f64>,
         labels: Option<Vec<String>>,
         left_closed: bool,
         allow_duplicates: bool,
+        include_breaks: bool,
     },
+    #[cfg(feature = "rle")]
+    RLE,
+    #[cfg(feature = "rle")]
+    RLEID,
     ToPhysical,
     #[cfg(feature = "random")]
     Random {
         method: random::RandomMethod,
         #[cfg_attr(feature = "serde", serde(skip))]
         atomic_seed: Option<SpecialEq<Arc<AtomicU64>>>,
         seed: Option<u64>,
@@ -316,14 +324,18 @@
             ArrayExpr(af) => return Display::fmt(af, f),
             ConcatExpr(_) => "concat_expr",
             Correlation { method, .. } => return Display::fmt(method, f),
             #[cfg(feature = "cutqcut")]
             Cut { .. } => "cut",
             #[cfg(feature = "cutqcut")]
             QCut { .. } => "qcut",
+            #[cfg(feature = "rle")]
+            RLE => "rle",
+            #[cfg(feature = "rle")]
+            RLEID => "rle_id",
             ToPhysical => "to_physical",
             #[cfg(feature = "random")]
             Random { method, .. } => method.into(),
         };
         write!(f, "{s}")
     }
 }
@@ -550,28 +562,41 @@
             ConcatExpr(rechunk) => map_as_slice!(concat::concat_expr, rechunk),
             Correlation { method, ddof } => map_as_slice!(correlation::corr, ddof, method),
             #[cfg(feature = "cutqcut")]
             Cut {
                 breaks,
                 labels,
                 left_closed,
-            } => map!(cut, breaks.clone(), labels.clone(), left_closed),
+                include_breaks,
+            } => map!(
+                cut,
+                breaks.clone(),
+                labels.clone(),
+                left_closed,
+                include_breaks
+            ),
             #[cfg(feature = "cutqcut")]
             QCut {
                 probs,
                 labels,
                 left_closed,
                 allow_duplicates,
+                include_breaks,
             } => map!(
                 qcut,
                 probs.clone(),
                 labels.clone(),
                 left_closed,
-                allow_duplicates
+                allow_duplicates,
+                include_breaks
             ),
+            #[cfg(feature = "rle")]
+            RLE => map!(rle),
+            #[cfg(feature = "rle")]
+            RLEID => map!(rle_id),
             ToPhysical => map!(dispatch::to_physical),
             #[cfg(feature = "random")]
             Random {
                 method,
                 seed,
                 atomic_seed,
                 fixed_seed,
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/pow.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/pow.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/random.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/random.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/range.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/range.rs`

 * *Files 0% similar despite different names*

```diff
@@ -117,15 +117,15 @@
             start = start.new_from_index(0, end.len())
         } else if end.len() == 1 {
             end = end.new_from_index(0, start.len())
         } else {
             polars_bail!(
                 ComputeError:
                 "lengths of `start`: {} and `end`: {} arguments `\
-                cannot be matched in the `arange` expression",
+                cannot be matched in the `int_ranges` expression",
                 start.len(), end.len()
             );
         }
     }
 
     let start = start.i64()?;
     let end = end.i64()?;
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/schema.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/schema.rs`

 * *Files 0% similar despite different names*

```diff
@@ -234,14 +234,23 @@
             Fused(_) => mapper.map_to_supertype(),
             ConcatExpr(_) => mapper.map_to_supertype(),
             Correlation { .. } => mapper.map_to_float_dtype(),
             #[cfg(feature = "cutqcut")]
             Cut { .. } => mapper.with_dtype(DataType::Categorical(None)),
             #[cfg(feature = "cutqcut")]
             QCut { .. } => mapper.with_dtype(DataType::Categorical(None)),
+            #[cfg(feature = "rle")]
+            RLE => mapper.map_dtype(|dt| {
+                DataType::Struct(vec![
+                    Field::new("lengths", DataType::UInt64),
+                    Field::new("values", dt.clone()),
+                ])
+            }),
+            #[cfg(feature = "rle")]
+            RLEID => mapper.with_dtype(DataType::UInt32),
             ToPhysical => mapper.to_physical_type(),
             #[cfg(feature = "random")]
             Random { .. } => mapper.with_same_dtype(),
         }
     }
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/shift_and_fill.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/shift_and_fill.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/sign.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/sign.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/strings.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/strings.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/struct_.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/struct_.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/temporal.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/temporal.rs`

 * *Files 11% similar despite different names*

```diff
@@ -4,19 +4,21 @@
 #[cfg(feature = "date_offset")]
 use polars_time::prelude::*;
 
 use super::*;
 
 #[cfg(feature = "date_offset")]
 pub(super) fn date_offset(s: Series, offset: Duration) -> PolarsResult<Series> {
+    let preserve_sortedness: bool;
     let out = match s.dtype().clone() {
         DataType::Date => {
             let s = s
                 .cast(&DataType::Datetime(TimeUnit::Milliseconds, None))
                 .unwrap();
+            preserve_sortedness = true;
             date_offset(s, offset).and_then(|s| s.cast(&DataType::Date))
         }
         DataType::Datetime(tu, tz) => {
             let ca = s.datetime().unwrap();
 
             fn offset_fn(tu: TimeUnit) -> fn(&Duration, i64, Option<&Tz>) -> PolarsResult<i64> {
                 match tu {
@@ -33,24 +35,33 @@
                     ca.0.try_apply(|v| offset_fn(&offset, v, tz.parse::<Tz>().ok().as_ref()))
                 }
                 _ => {
                     let offset_fn = offset_fn(tu);
                     ca.0.try_apply(|v| offset_fn(&offset, v, None))
                 }
             }?;
+            // Sortedness may not be preserved when crossing daylight savings time boundaries
+            // for calendar-aware durations.
+            // Constant durations (e.g. 2 hours) always preserve sortedness.
+            preserve_sortedness =
+                tz.is_none() || tz.as_deref() == Some("UTC") || offset.is_constant_duration();
             out.cast(&DataType::Datetime(tu, tz))
         }
         dt => polars_bail!(
             ComputeError: "cannot use 'date_offset' on Series of datatype {}", dt,
         ),
     };
-    out.map(|mut out| {
-        out.set_sorted_flag(s.is_sorted_flag());
+    if preserve_sortedness {
+        out.map(|mut out| {
+            out.set_sorted_flag(s.is_sorted_flag());
+            out
+        })
+    } else {
         out
-    })
+    }
 }
 
 pub(super) fn combine(s: &[Series], tu: TimeUnit) -> PolarsResult<Series> {
     let date = &s[0];
     let time = &s[1];
 
     let tz = match date.dtype() {
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/function_expr/trigonometry.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/function_expr/trigonometry.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/arity.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/arity.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/coerce.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/coerce.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/concat.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/concat.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/correlation.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/correlation.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/horizontal.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/horizontal.rs`

 * *Files 4% similar despite different names*

```diff
@@ -186,74 +186,86 @@
             auto_explode: true,
             fmt_str: "cumfold",
             ..Default::default()
         },
     }
 }
 
-/// Create a new column with the the sum of the values in each row.
+/// Create a new column with the the bitwise-and of the elements in each row.
 ///
-/// The name of the resulting column will be `"sum"`; use [`alias`](Expr::alias) to choose a different name.
-pub fn sum_exprs<E: AsRef<[Expr]>>(exprs: E) -> Expr {
-    let mut exprs = exprs.as_ref().to_vec();
-    let func = |s1, s2| Ok(Some(&s1 + &s2));
-    let init = match exprs.pop() {
-        Some(e) => e,
-        // use u32 as that is not cast to float as eagerly
-        _ => lit(0u32),
+/// The name of the resulting column will be "all"; use [`alias`](Expr::alias) to choose a different name.
+pub fn all_horizontal<E: AsRef<[Expr]>>(exprs: E) -> Expr {
+    let exprs = exprs.as_ref().to_vec();
+    let func = |s1: Series, s2: Series| {
+        Ok(Some(
+            s1.bool()?
+                .bitand(s2.cast(&DataType::Boolean)?.bool()?)
+                .into_series(),
+        ))
     };
-    fold_exprs(init, func, exprs).alias("sum")
+    fold_exprs(lit(true), func, exprs).alias("all")
+}
+
+/// Create a new column with the the bitwise-or of the elements in each row.
+///
+/// The name of the resulting column will be "any"; use [`alias`](Expr::alias) to choose a different name.
+pub fn any_horizontal<E: AsRef<[Expr]>>(exprs: E) -> Expr {
+    let exprs = exprs.as_ref().to_vec();
+    let func = |s1: Series, s2: Series| {
+        Ok(Some(
+            s1.bool()?
+                .bitor(s2.cast(&DataType::Boolean)?.bool()?)
+                .into_series(),
+        ))
+    };
+    fold_exprs(lit(false), func, exprs).alias("any")
 }
 
 /// Create a new column with the the maximum value per row.
 ///
 /// The name of the resulting column will be `"max"`; use [`alias`](Expr::alias) to choose a different name.
-pub fn max_exprs<E: AsRef<[Expr]>>(exprs: E) -> Expr {
+pub fn max_horizontal<E: AsRef<[Expr]>>(exprs: E) -> Expr {
     let exprs = exprs.as_ref().to_vec();
     if exprs.is_empty() {
         return Expr::Columns(Vec::new());
     }
     let func = |s1, s2| {
         let df = DataFrame::new_no_checks(vec![s1, s2]);
         df.hmax()
     };
     reduce_exprs(func, exprs).alias("max")
 }
 
 /// Create a new column with the the minimum value per row.
 ///
 /// The name of the resulting column will be `"min"`; use [`alias`](Expr::alias) to choose a different name.
-pub fn min_exprs<E: AsRef<[Expr]>>(exprs: E) -> Expr {
+pub fn min_horizontal<E: AsRef<[Expr]>>(exprs: E) -> Expr {
     let exprs = exprs.as_ref().to_vec();
     if exprs.is_empty() {
         return Expr::Columns(Vec::new());
     }
     let func = |s1, s2| {
         let df = DataFrame::new_no_checks(vec![s1, s2]);
         df.hmin()
     };
     reduce_exprs(func, exprs).alias("min")
 }
 
-/// Create a new column with the the bitwise-or of the elements in each row.
-///
-/// The name of the resulting column is arbitrary; use [`alias`](Expr::alias) to choose a different name.
-pub fn any_exprs<E: AsRef<[Expr]>>(exprs: E) -> Expr {
-    let exprs = exprs.as_ref().to_vec();
-    let func = |s1: Series, s2: Series| Ok(Some(s1.bool()?.bitor(s2.bool()?).into_series()));
-    fold_exprs(lit(false), func, exprs)
-}
-
-/// Create a new column with the the bitwise-and of the elements in each row.
+/// Create a new column with the the sum of the values in each row.
 ///
-/// The name of the resulting column is arbitrary; use [`alias`](Expr::alias) to choose a different name.
-pub fn all_exprs<E: AsRef<[Expr]>>(exprs: E) -> Expr {
-    let exprs = exprs.as_ref().to_vec();
-    let func = |s1: Series, s2: Series| Ok(Some(s1.bool()?.bitand(s2.bool()?).into_series()));
-    fold_exprs(lit(true), func, exprs)
+/// The name of the resulting column will be `"sum"`; use [`alias`](Expr::alias) to choose a different name.
+pub fn sum_horizontal<E: AsRef<[Expr]>>(exprs: E) -> Expr {
+    let mut exprs = exprs.as_ref().to_vec();
+    let func = |s1, s2| Ok(Some(&s1 + &s2));
+    let init = match exprs.pop() {
+        Some(e) => e,
+        // use u32 as that is not cast to float as eagerly
+        _ => lit(0u32),
+    };
+    fold_exprs(init, func, exprs).alias("sum")
 }
 
 /// Folds the expressions from left to right keeping the first non-null values.
 ///
 /// It is an error to provide an empty `exprs`.
 pub fn coalesce(exprs: &[Expr]) -> Expr {
     let input = exprs.to_vec();
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/index.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/index.rs`

 * *Files 2% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 /// That means that the first `Series` will be used to determine the ordering
 /// until duplicates are found. Once duplicates are found, the next `Series` will
 /// be used and so on.
 #[cfg(feature = "range")]
 pub fn arg_sort_by<E: AsRef<[Expr]>>(by: E, descending: &[bool]) -> Expr {
     let e = &by.as_ref()[0];
     let name = expr_output_name(e).unwrap();
-    arange(lit(0 as IdxSize), count().cast(IDX_DTYPE), 1)
+    int_range(lit(0 as IdxSize), count().cast(IDX_DTYPE), 1)
         .sort_by(by, descending)
         .alias(name.as_ref())
 }
 
 #[cfg(feature = "arg_where")]
 /// Get the indices where `condition` evaluates `true`.
 pub fn arg_where<E: Into<Expr>>(condition: E) -> Expr {
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/range.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/range.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/selectors.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/selectors.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/syntactic_sugar.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/syntactic_sugar.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/functions/temporal.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/functions/temporal.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/list.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/list.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/meta.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/meta.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/mod.rs`

 * *Files 1% similar despite different names*

```diff
@@ -18,15 +18,15 @@
 #[cfg(feature = "compile")]
 pub mod functions;
 mod list;
 #[cfg(feature = "meta")]
 mod meta;
 pub(crate) mod names;
 mod options;
-#[cfg(all(feature = "python", feature = "serde"))]
+#[cfg(feature = "python")]
 pub mod python_udf;
 #[cfg(feature = "random")]
 mod random;
 mod selector;
 #[cfg(feature = "strings")]
 pub mod string;
 #[cfg(feature = "dtype-struct")]
@@ -1461,38 +1461,56 @@
                 _ => Field::new(fld.name(), IDX_DTYPE),
             }),
         )
         .with_fmt("rank")
     }
 
     #[cfg(feature = "cutqcut")]
-    pub fn cut(self, breaks: Vec<f64>, labels: Option<Vec<String>>, left_closed: bool) -> Expr {
+    pub fn cut(
+        self,
+        breaks: Vec<f64>,
+        labels: Option<Vec<String>>,
+        left_closed: bool,
+        include_breaks: bool,
+    ) -> Expr {
         self.apply_private(FunctionExpr::Cut {
             breaks,
             labels,
             left_closed,
+            include_breaks,
         })
     }
 
     #[cfg(feature = "cutqcut")]
     pub fn qcut(
         self,
         probs: Vec<f64>,
         labels: Option<Vec<String>>,
         left_closed: bool,
         allow_duplicates: bool,
+        include_breaks: bool,
     ) -> Expr {
         self.apply_private(FunctionExpr::QCut {
             probs,
             labels,
             left_closed,
             allow_duplicates,
+            include_breaks,
         })
     }
 
+    #[cfg(feature = "rle")]
+    pub fn rle(self) -> Expr {
+        self.apply_private(FunctionExpr::RLE)
+    }
+    #[cfg(feature = "rle")]
+    pub fn rle_id(self) -> Expr {
+        self.apply_private(FunctionExpr::RLEID)
+    }
+
     #[cfg(feature = "diff")]
     pub fn diff(self, n: i64, null_behavior: NullBehavior) -> Expr {
         self.apply_private(FunctionExpr::Diff(n, null_behavior))
     }
 
     #[cfg(feature = "pct_change")]
     pub fn pct_change(self, n: i64) -> Expr {
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/options.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/options.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/python_udf.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/python_udf.rs`

 * *Files 6% similar despite different names*

```diff
@@ -4,15 +4,17 @@
 use polars_arrow::error::PolarsResult;
 use polars_core::datatypes::{DataType, Field};
 use polars_core::error::*;
 use polars_core::frame::DataFrame;
 use polars_core::prelude::Series;
 use pyo3::types::{PyBytes, PyModule};
 use pyo3::{PyErr, PyObject, Python};
+#[cfg(feature = "serde")]
 use serde::ser::Error;
+#[cfg(feature = "serde")]
 use serde::{Deserialize, Deserializer, Serialize, Serializer};
 
 use super::expr_dyn_fn::*;
 use crate::constants::MAP_LIST_NAME;
 use crate::prelude::*;
 
 // Will be overwritten on python polar start up.
@@ -43,14 +45,15 @@
                 .unwrap()
                 .extract::<bool>(py)
                 .unwrap()
         })
     }
 }
 
+#[cfg(feature = "serde")]
 impl Serialize for PythonFunction {
     fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
     where
         S: Serializer,
     {
         Python::with_gil(|py| {
             let pickle = PyModule::import(py, "pickle")
@@ -66,14 +69,15 @@
             let dumped = dumped.extract::<&PyBytes>().unwrap();
 
             serializer.serialize_bytes(dumped.as_bytes())
         })
     }
 }
 
+#[cfg(feature = "serde")]
 impl<'a> Deserialize<'a> for PythonFunction {
     fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
     where
         D: Deserializer<'a>,
     {
         use serde::de::Error;
         let bytes = Vec::<u8>::deserialize(deserializer)?;
@@ -102,14 +106,15 @@
     pub fn new(lambda: PyObject, output_type: Option<DataType>) -> Self {
         Self {
             python_function: lambda,
             output_type,
         }
     }
 
+    #[cfg(feature = "serde")]
     pub(crate) fn try_deserialize(buf: &[u8]) -> PolarsResult<Arc<dyn SeriesUdf>> {
         debug_assert!(buf.starts_with(MAGIC_BYTE_MARK));
         // skip header
         let buf = &buf[MAGIC_BYTE_MARK.len()..];
         let mut reader = Cursor::new(buf);
         let output_type: Option<DataType> =
             ciborium::de::from_reader(&mut reader).map_err(map_err)?;
@@ -154,14 +159,15 @@
             SchemaMismatch:
             "expected output type '{:?}', got '{:?}'; set `return_dtype` to the proper datatype",
             output_type, out.dtype(),
         );
         Ok(Some(out))
     }
 
+    #[cfg(feature = "serde")]
     fn try_serialize(&self, buf: &mut Vec<u8>) -> PolarsResult<()> {
         buf.extend_from_slice(MAGIC_BYTE_MARK);
         ciborium::ser::into_writer(&self.output_type, &mut *buf).unwrap();
 
         Python::with_gil(|py| {
             let pickle = PyModule::import(py, "pickle")
                 .expect("Unable to import 'pickle'")
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/random.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/random.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/selector.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/selector.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/string.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/string.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/dsl/struct_.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/dsl/struct_.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/frame/opt_state.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/frame/opt_state.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/aexpr/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/aexpr/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/aexpr/schema.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/aexpr/schema.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/alp.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/alp.rs`

 * *Files 16% similar despite different names*

```diff
@@ -1,25 +1,17 @@
 use std::borrow::Cow;
-#[cfg(any(feature = "ipc", feature = "csv", feature = "parquet"))]
 use std::path::PathBuf;
 use std::sync::Arc;
 
-#[cfg(feature = "parquet")]
-use polars_core::cloud::CloudOptions;
 use polars_core::prelude::*;
 use polars_utils::arena::{Arena, Node};
 
 use crate::logical_plan::functions::FunctionNode;
 use crate::logical_plan::schema::{det_join_schema, FileInfo};
-#[cfg(feature = "csv")]
-use crate::logical_plan::CsvParserOptions;
-#[cfg(feature = "ipc")]
-use crate::logical_plan::IpcScanOptionsInner;
-#[cfg(feature = "parquet")]
-use crate::logical_plan::ParquetOptions;
+use crate::logical_plan::FileScan;
 use crate::prelude::*;
 use crate::utils::{aexprs_to_schema, PushNode};
 
 /// ALogicalPlan is a representation of LogicalPlan with Nodes which are allocated in an Arena
 #[derive(Clone, Debug)]
 pub enum ALogicalPlan {
     AnonymousScan {
@@ -39,41 +31,23 @@
         offset: i64,
         len: IdxSize,
     },
     Selection {
         input: Node,
         predicate: Node,
     },
-    #[cfg(feature = "csv")]
-    CsvScan {
+    Scan {
         path: PathBuf,
         file_info: FileInfo,
-        // schema of the projected file
-        output_schema: Option<SchemaRef>,
-        options: CsvParserOptions,
         predicate: Option<Node>,
-    },
-    #[cfg(feature = "ipc")]
-    IpcScan {
-        path: PathBuf,
-        file_info: FileInfo,
-        // schema of the projected file
-        output_schema: Option<SchemaRef>,
-        options: IpcScanOptionsInner,
-        predicate: Option<Node>,
-    },
-    #[cfg(feature = "parquet")]
-    ParquetScan {
-        path: PathBuf,
-        file_info: FileInfo,
-        // schema of the projected file
+        /// schema of the projected file
         output_schema: Option<SchemaRef>,
-        predicate: Option<Node>,
-        options: ParquetOptions,
-        cloud_options: Option<CloudOptions>,
+        scan_type: FileScan,
+        /// generic options that can be used for all file types.
+        file_options: FileScanOptions,
     },
     DataFrameScan {
         df: Arc<DataFrame>,
         schema: SchemaRef,
         // schema of the projected file
         output_schema: Option<SchemaRef>,
         projection: Option<Arc<Vec<String>>>,
@@ -157,41 +131,31 @@
 
 impl ALogicalPlan {
     /// Get the schema of the logical plan node but don't take projections into account at the scan
     /// level. This ensures we can apply the predicate
     pub(crate) fn scan_schema(&self) -> &SchemaRef {
         use ALogicalPlan::*;
         match self {
+            Scan { file_info, .. } => &file_info.schema,
             #[cfg(feature = "python")]
             PythonScan { options, .. } => &options.schema,
-            #[cfg(feature = "csv")]
-            CsvScan { file_info, .. } => &file_info.schema,
-            #[cfg(feature = "parquet")]
-            ParquetScan { file_info, .. } => &file_info.schema,
-            #[cfg(feature = "ipc")]
-            IpcScan { file_info, .. } => &file_info.schema,
             AnonymousScan { file_info, .. } => &file_info.schema,
             _ => unreachable!(),
         }
     }
 
     pub fn name(&self) -> &'static str {
         use ALogicalPlan::*;
         match self {
+            Scan { scan_type, .. } => scan_type.into(),
             AnonymousScan { .. } => "anonymous_scan",
             #[cfg(feature = "python")]
             PythonScan { .. } => "python_scan",
             Slice { .. } => "slice",
             Selection { .. } => "selection",
-            #[cfg(feature = "csv")]
-            CsvScan { .. } => "csv_scan",
-            #[cfg(feature = "ipc")]
-            IpcScan { .. } => "ipc_scan",
-            #[cfg(feature = "parquet")]
-            ParquetScan { .. } => "parquet_scan",
             DataFrameScan { .. } => "df",
             Projection { .. } => "projection",
             LocalProjection { .. } => "local_projection",
             Sort { .. } => "sort",
             Cache { .. } => "cache",
             Aggregate { .. } => "aggregate",
             Join { .. } => "join",
@@ -209,43 +173,30 @@
         use ALogicalPlan::*;
         let schema = match self {
             #[cfg(feature = "python")]
             PythonScan { options, .. } => &options.schema,
             Union { inputs, .. } => return arena.get(inputs[0]).schema(arena),
             Cache { input, .. } => return arena.get(*input).schema(arena),
             Sort { input, .. } => return arena.get(*input).schema(arena),
-            #[cfg(feature = "parquet")]
-            ParquetScan {
-                file_info,
+            Scan {
                 output_schema,
-                ..
-            } => output_schema.as_ref().unwrap_or(&file_info.schema),
-            #[cfg(feature = "ipc")]
-            IpcScan {
                 file_info,
-                output_schema,
                 ..
             } => output_schema.as_ref().unwrap_or(&file_info.schema),
             DataFrameScan {
                 schema,
                 output_schema,
                 ..
             } => output_schema.as_ref().unwrap_or(schema),
             AnonymousScan {
                 file_info,
                 output_schema,
                 ..
             } => output_schema.as_ref().unwrap_or(&file_info.schema),
             Selection { input, .. } => return arena.get(*input).schema(arena),
-            #[cfg(feature = "csv")]
-            CsvScan {
-                file_info,
-                output_schema,
-                ..
-            } => output_schema.as_ref().unwrap_or(&file_info.schema),
             Projection { schema, .. } => schema,
             LocalProjection { schema, .. } => schema,
             Aggregate { schema, .. } => schema,
             Join { schema, .. } => schema,
             HStack { schema, .. } => schema,
             Distinct { input, .. } | FileSink { input, .. } => {
                 return arena.get(*input).schema(arena)
@@ -351,80 +302,33 @@
                 options: options.clone(),
             },
             HStack { schema, .. } => HStack {
                 input: inputs[0],
                 exprs,
                 schema: schema.clone(),
             },
-            #[cfg(feature = "ipc")]
-            IpcScan {
+            Scan {
                 path,
                 file_info,
                 output_schema,
-                options,
                 predicate,
-                ..
+                file_options: options,
+                scan_type,
             } => {
                 let mut new_predicate = None;
                 if predicate.is_some() {
                     new_predicate = exprs.pop()
                 }
-
-                IpcScan {
+                Scan {
                     path: path.clone(),
                     file_info: file_info.clone(),
                     output_schema: output_schema.clone(),
+                    file_options: options.clone(),
                     predicate: new_predicate,
-                    options: options.clone(),
-                }
-            }
-
-            #[cfg(feature = "parquet")]
-            ParquetScan {
-                path,
-                file_info,
-                output_schema,
-                predicate,
-                options,
-                cloud_options,
-                ..
-            } => {
-                let mut new_predicate = None;
-                if predicate.is_some() {
-                    new_predicate = exprs.pop()
-                }
-
-                ParquetScan {
-                    path: path.clone(),
-                    file_info: file_info.clone(),
-                    output_schema: output_schema.clone(),
-                    predicate: new_predicate,
-                    options: options.clone(),
-                    cloud_options: cloud_options.clone(),
-                }
-            }
-            #[cfg(feature = "csv")]
-            CsvScan {
-                path,
-                file_info,
-                output_schema,
-                predicate,
-                options,
-                ..
-            } => {
-                let mut new_predicate = None;
-                if predicate.is_some() {
-                    new_predicate = exprs.pop()
-                }
-                CsvScan {
-                    path: path.clone(),
-                    file_info: file_info.clone(),
-                    output_schema: output_schema.clone(),
-                    options: options.clone(),
-                    predicate: new_predicate,
+                    scan_type: scan_type.clone(),
                 }
             }
             DataFrameScan {
                 df,
                 schema,
                 output_schema,
                 projection,
@@ -495,28 +399,15 @@
             Join {
                 left_on, right_on, ..
             } => {
                 let iter = left_on.iter().copied().chain(right_on.iter().copied());
                 container.extend(iter)
             }
             HStack { exprs, .. } => container.extend_from_slice(exprs),
-            #[cfg(feature = "parquet")]
-            ParquetScan { predicate, .. } => {
-                if let Some(node) = predicate {
-                    container.push(*node)
-                }
-            }
-            #[cfg(feature = "ipc")]
-            IpcScan { predicate, .. } => {
-                if let Some(node) = predicate {
-                    container.push(*node)
-                }
-            }
-            #[cfg(feature = "csv")]
-            CsvScan { predicate, .. } => {
+            Scan { predicate, .. } => {
                 if let Some(node) = predicate {
                     container.push(*node)
                 }
             }
             DataFrameScan { selection, .. } => {
                 if let Some(expr) = selection {
                     container.push(*expr)
@@ -579,20 +470,15 @@
                 input, contexts, ..
             } => {
                 for n in contexts {
                     container.push_node(*n)
                 }
                 *input
             }
-            #[cfg(feature = "parquet")]
-            ParquetScan { .. } => return,
-            #[cfg(feature = "ipc")]
-            IpcScan { .. } => return,
-            #[cfg(feature = "csv")]
-            CsvScan { .. } => return,
+            Scan { .. } => return,
             DataFrameScan { .. } => return,
             AnonymousScan { .. } => return,
             #[cfg(feature = "python")]
             PythonScan { .. } => return,
         };
         container.push_node(input)
     }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/anonymous_scan.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/anonymous_scan.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/apply.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/apply.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/builder.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/builder.rs`

 * *Files 2% similar despite different names*

```diff
@@ -8,15 +8,20 @@
 use polars_core::utils::try_get_supertype;
 #[cfg(feature = "ipc")]
 use polars_io::ipc::IpcReader;
 #[cfg(all(feature = "parquet", feature = "async"))]
 use polars_io::parquet::ParquetAsyncReader;
 #[cfg(feature = "parquet")]
 use polars_io::parquet::ParquetReader;
-#[cfg(any(feature = "parquet", feature = "parquet_async", feature = "csv"))]
+#[cfg(any(
+    feature = "parquet",
+    feature = "parquet_async",
+    feature = "csv",
+    feature = "ipc"
+))]
 use polars_io::RowCount;
 #[cfg(feature = "csv")]
 use polars_io::{
     csv::utils::{get_reader_bytes, infer_file_schema, is_compressed},
     csv::CsvEncoding,
     csv::NullValues,
 };
@@ -34,15 +39,15 @@
     schema: &Schema,
 ) -> PolarsResult<(Vec<Expr>, Schema)> {
     let exprs = rewrite_projections(exprs, schema, &[])?;
     let schema = utils::expressions_to_schema(&exprs, schema, Context::Default)?;
     Ok((exprs, schema))
 }
 
-pub struct LogicalPlanBuilder(LogicalPlan);
+pub struct LogicalPlanBuilder(pub LogicalPlan);
 
 impl From<LogicalPlan> for LogicalPlanBuilder {
     fn from(lp: LogicalPlan) -> Self {
         LogicalPlanBuilder(lp)
     }
 }
 
@@ -123,99 +128,121 @@
         low_memory: bool,
         cloud_options: Option<CloudOptions>,
         use_statistics: bool,
     ) -> PolarsResult<Self> {
         use polars_io::{is_cloud_url, SerReader as _};
 
         let path = path.into();
-        let file_info: PolarsResult<FileInfo> = if is_cloud_url(&path) {
+        let (mut schema, num_rows) = if is_cloud_url(&path) {
             #[cfg(not(feature = "async"))]
             panic!(
                 "One or more of the cloud storage features ('aws', 'gcp', ...) must be enabled."
             );
 
             #[cfg(feature = "async")]
             {
                 let uri = path.to_string_lossy();
-                let (schema, num_rows) =
-                    ParquetAsyncReader::file_info(&uri, cloud_options.as_ref())?;
-                Ok(FileInfo {
-                    schema: Arc::new(schema),
-                    row_estimation: (Some(num_rows), num_rows),
-                })
+                ParquetAsyncReader::file_info(&uri, cloud_options.as_ref())?
             }
         } else {
             let file = std::fs::File::open(&path)?;
             let mut reader = ParquetReader::new(file);
-            let schema = Arc::new(reader.schema()?);
-            let num_rows = reader.num_rows()?;
-            Ok(FileInfo {
-                schema,
-                row_estimation: (Some(num_rows), num_rows),
-            })
+            (reader.schema()?, reader.num_rows()?)
         };
-        let file_info = file_info?;
 
-        Ok(LogicalPlan::ParquetScan {
+        if let Some(rc) = &row_count {
+            let _ = schema.insert_at_index(0, rc.name.as_str().into(), IDX_DTYPE);
+        }
+
+        let file_info = FileInfo {
+            schema: Arc::new(schema),
+            row_estimation: (Some(num_rows), num_rows),
+        };
+
+        let options = FileScanOptions {
+            with_columns: None,
+            cache,
+            n_rows,
+            rechunk,
+            row_count,
+            file_counter: Default::default(),
+        };
+        Ok(LogicalPlan::Scan {
             path,
             file_info,
+            file_options: options,
             predicate: None,
-            options: ParquetOptions {
-                n_rows,
-                with_columns: None,
-                cache,
-                parallel,
-                row_count,
-                rechunk,
-                file_counter: Default::default(),
-                low_memory,
-                use_statistics,
+            scan_type: FileScan::Parquet {
+                options: ParquetOptions {
+                    parallel,
+                    low_memory,
+                    use_statistics,
+                },
+                cloud_options,
             },
-            cloud_options,
         }
         .into())
     }
 
     #[cfg(feature = "ipc")]
     pub fn scan_ipc<P: Into<std::path::PathBuf>>(
         path: P,
         options: IpcScanOptions,
+        n_rows: Option<usize>,
+        cache: bool,
+        row_count: Option<RowCount>,
+        rechunk: bool,
     ) -> PolarsResult<Self> {
         use polars_io::SerReader as _;
 
         let path = path.into();
         let file = std::fs::File::open(&path)?;
         let mut reader = IpcReader::new(file);
-        let schema = Arc::new(reader.schema()?);
+
+        let mut schema = reader.schema()?;
+        if let Some(rc) = &row_count {
+            let _ = schema.insert_at_index(0, rc.name.as_str().into(), IDX_DTYPE);
+        }
+        let schema = Arc::new(schema);
 
         let num_rows = reader._num_rows()?;
         let file_info = FileInfo {
             schema,
             row_estimation: (None, num_rows),
         };
-        Ok(LogicalPlan::IpcScan {
+
+        let file_options = FileScanOptions {
+            with_columns: None,
+            cache,
+            n_rows,
+            rechunk,
+            row_count,
+            file_counter: Default::default(),
+        };
+        Ok(LogicalPlan::Scan {
             path,
             file_info,
+            file_options,
             predicate: None,
-            options: options.into(),
+            scan_type: FileScan::Ipc { options },
         }
         .into())
     }
 
     #[allow(clippy::too_many_arguments)]
     #[cfg(feature = "csv")]
     pub fn scan_csv<P: Into<std::path::PathBuf>>(
         path: P,
         delimiter: u8,
         has_header: bool,
         ignore_errors: bool,
         mut skip_rows: usize,
         n_rows: Option<usize>,
         cache: bool,
-        schema: Option<Arc<Schema>>,
+        mut schema: Option<Arc<Schema>>,
         schema_overwrite: Option<&Schema>,
         low_memory: bool,
         comment_char: Option<u8>,
         quote_char: Option<u8>,
         eol_char: u8,
         null_values: Option<NullValues>,
         infer_schema_length: Option<usize>,
@@ -235,61 +262,82 @@
             ComputeError: "cannot scan compressed csv; use `read_csv` for compressed data",
         );
         file.rewind()?;
         let reader_bytes = get_reader_bytes(&mut file).expect("could not mmap file");
 
         // TODO! delay inferring schema until absolutely necessary
         // this needs a way to estimated bytes/rows.
-        let (inferred_schema, rows_read, bytes_read) = infer_file_schema(
+        let (mut inferred_schema, rows_read, bytes_read) = infer_file_schema(
             &reader_bytes,
             delimiter,
             infer_schema_length,
             has_header,
             schema_overwrite,
             &mut skip_rows,
             skip_rows_after_header,
             comment_char,
             quote_char,
             eol_char,
             null_values.as_ref(),
             try_parse_dates,
         )?;
 
+        if let Some(rc) = &row_count {
+            match schema {
+                None => {
+                    let _ = inferred_schema.insert_at_index(0, rc.name.as_str().into(), IDX_DTYPE);
+                }
+                Some(inner) => {
+                    schema = Some(Arc::new(
+                        inner
+                            .new_inserting_at_index(0, rc.name.as_str().into(), IDX_DTYPE)
+                            .unwrap(),
+                    ));
+                }
+            }
+        }
+
         let schema = schema.unwrap_or_else(|| Arc::new(inferred_schema));
         let n_bytes = reader_bytes.len();
         let estimated_n_rows = (rows_read as f64 / bytes_read as f64 * n_bytes as f64) as usize;
 
         skip_rows += skip_rows_after_header;
         let file_info = FileInfo {
             schema,
             row_estimation: (None, estimated_n_rows),
         };
-        Ok(LogicalPlan::CsvScan {
+
+        let options = FileScanOptions {
+            with_columns: None,
+            cache,
+            n_rows,
+            rechunk,
+            row_count,
+            file_counter: Default::default(),
+        };
+        Ok(LogicalPlan::Scan {
             path,
             file_info,
-            options: CsvParserOptions {
-                has_header,
-                delimiter,
-                ignore_errors,
-                skip_rows,
-                n_rows,
-                with_columns: None,
-                low_memory,
-                cache,
-                comment_char,
-                quote_char,
-                eol_char,
-                null_values,
-                rechunk,
-                encoding,
-                row_count,
-                try_parse_dates,
-                file_counter: Default::default(),
-            },
+            file_options: options,
             predicate: None,
+            scan_type: FileScan::Csv {
+                options: CsvParserOptions {
+                    has_header,
+                    delimiter,
+                    ignore_errors,
+                    skip_rows,
+                    low_memory,
+                    comment_char,
+                    quote_char,
+                    eol_char,
+                    null_values,
+                    encoding,
+                    try_parse_dates,
+                },
+            },
         }
         .into())
     }
 
     pub fn cache(self) -> Self {
         let input = Box::new(self.0);
         let id = input.as_ref() as *const LogicalPlan as usize;
@@ -458,15 +506,15 @@
                     }
 
                     let msg = if cfg!(feature = "python") {
                         format!("The predicate passed to 'LazyFrame.filter' expanded to multiple expressions: \n\n{expanded}\n\
                             This is ambiguous. Try to combine the predicates with the 'all' or `any' expression.")
                     } else {
                         format!("The predicate passed to 'LazyFrame.filter' expanded to multiple expressions: \n\n{expanded}\n\
-                            This is ambiguous. Try to combine the predicates with the 'all_exprs' or `any_exprs' expression.")
+                            This is ambiguous. Try to combine the predicates with the 'all_horizontal' or `any_horizontal' expression.")
                     };
                     return raise_err!(polars_err!(ComputeError: msg), &self.0, into);
                 }
             }
         } else {
             predicate
         };
@@ -581,24 +629,31 @@
             output_schema: None,
             projection: None,
             selection: None,
         }
         .into()
     }
 
-    pub fn sort(self, by_column: Vec<Expr>, descending: Vec<bool>, null_last: bool) -> Self {
+    pub fn sort(
+        self,
+        by_column: Vec<Expr>,
+        descending: Vec<bool>,
+        null_last: bool,
+        maintain_order: bool,
+    ) -> Self {
         let schema = try_delayed!(self.0.schema(), &self.0, into);
         let by_column = try_delayed!(rewrite_projections(by_column, &schema, &[]), &self.0, into);
         LogicalPlan::Sort {
             input: Box::new(self.0),
             by_column,
             args: SortArguments {
                 descending,
                 nulls_last: null_last,
                 slice: None,
+                maintain_order,
             },
         }
         .into()
     }
 
     pub fn explode(self, columns: Vec<Expr>) -> Self {
         let schema = try_delayed!(self.0.schema(), &self.0, into);
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/conversion.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/conversion.rs`

 * *Files 2% similar despite different names*

```diff
@@ -167,14 +167,28 @@
 /// finally it returns the top node of the logical plan
 pub fn to_alp(
     lp: LogicalPlan,
     expr_arena: &mut Arena<AExpr>,
     lp_arena: &mut Arena<ALogicalPlan>,
 ) -> PolarsResult<Node> {
     let v = match lp {
+        LogicalPlan::Scan {
+            file_info,
+            path,
+            predicate,
+            scan_type,
+            file_options: options,
+        } => ALogicalPlan::Scan {
+            file_info,
+            path,
+            output_schema: None,
+            predicate: predicate.map(|expr| to_aexpr(expr, expr_arena)),
+            scan_type,
+            file_options: options,
+        },
         LogicalPlan::AnonymousScan {
             function,
             file_info,
             predicate,
             options,
         } => ALogicalPlan::AnonymousScan {
             function,
@@ -203,55 +217,14 @@
                 predicate: p,
             }
         }
         LogicalPlan::Slice { input, offset, len } => {
             let input = to_alp(*input, expr_arena, lp_arena)?;
             ALogicalPlan::Slice { input, offset, len }
         }
-        #[cfg(feature = "csv")]
-        LogicalPlan::CsvScan {
-            path,
-            file_info,
-            options,
-            predicate,
-        } => ALogicalPlan::CsvScan {
-            path,
-            file_info,
-            output_schema: None,
-            options,
-            predicate: predicate.map(|expr| to_aexpr(expr, expr_arena)),
-        },
-        #[cfg(feature = "ipc")]
-        LogicalPlan::IpcScan {
-            path,
-            file_info,
-            predicate,
-            options,
-        } => ALogicalPlan::IpcScan {
-            path,
-            file_info,
-            output_schema: None,
-            predicate: predicate.map(|expr| to_aexpr(expr, expr_arena)),
-            options,
-        },
-        #[cfg(feature = "parquet")]
-        LogicalPlan::ParquetScan {
-            path,
-            file_info,
-            predicate,
-            options,
-            cloud_options,
-        } => ALogicalPlan::ParquetScan {
-            path,
-            file_info,
-            output_schema: None,
-            predicate: predicate.map(|expr| to_aexpr(expr, expr_arena)),
-            options,
-            cloud_options,
-        },
         LogicalPlan::DataFrameScan {
             df,
             schema,
             output_schema,
             projection,
             selection,
         } => ALogicalPlan::DataFrameScan {
@@ -652,14 +625,28 @@
         F: Fn(Node, &mut LPA) -> ALogicalPlan,
     {
         let lp = self;
         let convert_to_lp = |node: Node, lp_arena: &mut LPA| {
             conversion_fn(node, lp_arena).into_lp(conversion_fn, lp_arena, expr_arena)
         };
         match lp {
+            ALogicalPlan::Scan {
+                path,
+                file_info,
+                predicate,
+                scan_type,
+                output_schema: _,
+                file_options: options,
+            } => LogicalPlan::Scan {
+                path,
+                file_info,
+                predicate: predicate.map(|n| node_to_expr(n, expr_arena)),
+                scan_type,
+                file_options: options,
+            },
             ALogicalPlan::AnonymousScan {
                 function,
                 file_info,
                 output_schema: _,
                 predicate,
                 options,
             } => LogicalPlan::AnonymousScan {
@@ -689,55 +676,14 @@
                 let lp = convert_to_lp(input, lp_arena);
                 let p = node_to_expr(predicate, expr_arena);
                 LogicalPlan::Selection {
                     input: Box::new(lp),
                     predicate: p,
                 }
             }
-            #[cfg(feature = "csv")]
-            ALogicalPlan::CsvScan {
-                path,
-                file_info,
-                output_schema: _,
-                options,
-                predicate,
-            } => LogicalPlan::CsvScan {
-                path,
-                file_info,
-                options,
-                predicate: predicate.map(|n| node_to_expr(n, expr_arena)),
-            },
-            #[cfg(feature = "ipc")]
-            ALogicalPlan::IpcScan {
-                path,
-                file_info,
-                output_schema: _,
-                predicate,
-                options,
-            } => LogicalPlan::IpcScan {
-                path,
-                file_info,
-                predicate: predicate.map(|n| node_to_expr(n, expr_arena)),
-                options,
-            },
-            #[cfg(feature = "parquet")]
-            ALogicalPlan::ParquetScan {
-                path,
-                file_info,
-                output_schema: _,
-                predicate,
-                options,
-                cloud_options,
-            } => LogicalPlan::ParquetScan {
-                path,
-                file_info,
-                predicate: predicate.map(|n| node_to_expr(n, expr_arena)),
-                options,
-                cloud_options,
-            },
             ALogicalPlan::DataFrameScan {
                 df,
                 schema,
                 output_schema,
                 projection,
                 selection,
             } => LogicalPlan::DataFrameScan {
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/format.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/format.rs`

 * *Files 9% similar despite different names*

```diff
@@ -108,90 +108,42 @@
                 }
                 write!(f, "\n{:indent$}END {}", "", name)
             }
             Cache { input, id, count } => {
                 write!(f, "{:indent$}CACHE[id: {:x}, count: {}]", "", *id, *count)?;
                 input._format(f, sub_indent)
             }
-            #[cfg(feature = "parquet")]
-            ParquetScan {
+            Scan {
                 path,
                 file_info,
                 predicate,
-                options,
+                scan_type,
+                file_options,
                 ..
             } => {
-                let n_columns = options
+                let n_columns = file_options
                     .with_columns
                     .as_ref()
                     .map(|columns| columns.len() as i64)
                     .unwrap_or(-1);
                 write_scan(
                     f,
-                    "PARQUET",
+                    scan_type.into(),
                     path,
                     sub_indent,
                     n_columns,
                     file_info.schema.len(),
                     predicate,
-                    options.n_rows,
-                )
-            }
-            #[cfg(feature = "ipc")]
-            IpcScan {
-                path,
-                file_info,
-                options,
-                predicate,
-                ..
-            } => {
-                let n_columns = options
-                    .with_columns
-                    .as_ref()
-                    .map(|columns| columns.len() as i64)
-                    .unwrap_or(-1);
-                write_scan(
-                    f,
-                    "IPC",
-                    path,
-                    sub_indent,
-                    n_columns,
-                    file_info.schema.len(),
-                    predicate,
-                    options.n_rows,
+                    file_options.n_rows,
                 )
             }
             Selection { predicate, input } => {
                 write!(f, "{:indent$}FILTER {predicate:?} FROM", "")?;
                 input._format(f, indent)
             }
-            #[cfg(feature = "csv")]
-            CsvScan {
-                path,
-                options,
-                file_info,
-                predicate,
-                ..
-            } => {
-                let n_columns = options
-                    .with_columns
-                    .as_ref()
-                    .map(|columns| columns.len() as i64)
-                    .unwrap_or(-1);
-                write_scan(
-                    f,
-                    "CSV",
-                    path,
-                    sub_indent,
-                    n_columns,
-                    file_info.schema.len(),
-                    predicate,
-                    options.n_rows,
-                )
-            }
             DataFrameScan {
                 schema,
                 projection,
                 selection,
                 ..
             } => {
                 let total_columns = schema.len();
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/functions/drop.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/functions/drop.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/functions/merge_sorted.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/functions/merge_sorted.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/functions/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/functions/mod.rs`

 * *Files 6% similar despite different names*

```diff
@@ -87,14 +87,19 @@
         columns: Arc<[Arc<str>]>,
         schema: SchemaRef,
     },
     Melt {
         args: Arc<MeltArgs>,
         schema: SchemaRef,
     },
+    RowCount {
+        name: Arc<str>,
+        schema: SchemaRef,
+        offset: Option<IdxSize>,
+    },
 }
 
 impl PartialEq for FunctionNode {
     fn eq(&self, other: &Self) -> bool {
         use FunctionNode::*;
         match (self, other) {
             (FastProjection { columns: l }, FastProjection { columns: r }) => l == r,
@@ -111,14 +116,15 @@
                     new: new_r,
                     ..
                 },
             ) => existing_l == existing_r && new_l == new_r,
             (Drop { names: l }, Drop { names: r }) => l == r,
             (Explode { columns: l, .. }, Explode { columns: r, .. }) => l == r,
             (Melt { args: l, .. }, Melt { args: r, .. }) => l == r,
+            (RowCount { name: l, .. }, RowCount { name: r, .. }) => l == r,
             _ => false,
         }
     }
 }
 
 impl FunctionNode {
     /// Whether this function can run on batches of data at a time.
@@ -134,14 +140,15 @@
             | Rename { .. }
             | Explode { .. }
             | Drop { .. } => true,
             Melt { args, .. } => args.streamable,
             Opaque { streamable, .. } => *streamable,
             #[cfg(feature = "python")]
             OpaquePython { streamable, .. } => *streamable,
+            RowCount { .. } => false,
         }
     }
 
     /// Whether this function will increase the number of rows
     pub fn expands_rows(&self) -> bool {
         use FunctionNode::*;
         match self {
@@ -211,16 +218,17 @@
                     panic!("activate feature 'dtype-struct'")
                 }
             }
             #[cfg(feature = "merge_sorted")]
             MergeSorted { .. } => Ok(Cow::Borrowed(input_schema)),
             Rename { existing, new, .. } => rename::rename_schema(input_schema, existing, new),
             Drop { names } => drop::drop_schema(input_schema, names),
-            Explode { schema, .. } => Ok(Cow::Owned(schema.clone())),
-            Melt { schema, .. } => Ok(Cow::Owned(schema.clone())),
+            Explode { schema, .. } | RowCount { schema, .. } | Melt { schema, .. } => {
+                Ok(Cow::Owned(schema.clone()))
+            }
         }
     }
 
     pub(crate) fn allow_predicate_pd(&self) -> bool {
         use FunctionNode::*;
         match self {
             Opaque { predicate_pd, .. } => *predicate_pd,
@@ -232,14 +240,15 @@
             | Unnest { .. }
             | Rename { .. }
             | Explode { .. }
             | Melt { .. }
             | Drop { .. } => true,
             #[cfg(feature = "merge_sorted")]
             MergeSorted { .. } => true,
+            RowCount { .. } => false,
             Pipeline { .. } => unimplemented!(),
         }
     }
 
     pub(crate) fn allow_projection_pd(&self) -> bool {
         use FunctionNode::*;
         match self {
@@ -252,14 +261,15 @@
             | Unnest { .. }
             | Rename { .. }
             | Explode { .. }
             | Melt { .. }
             | Drop { .. } => true,
             #[cfg(feature = "merge_sorted")]
             MergeSorted { .. } => true,
+            RowCount { .. } => true,
             Pipeline { .. } => unimplemented!(),
         }
     }
 
     pub(crate) fn additional_projection_pd_columns(&self) -> Cow<[Arc<str>]> {
         use FunctionNode::*;
         match self {
@@ -316,14 +326,15 @@
             Rename { existing, new, .. } => rename::rename_impl(df, existing, new),
             Drop { names } => drop::drop_impl(df, names),
             Explode { columns, .. } => df.explode(columns.as_ref()),
             Melt { args, .. } => {
                 let args = (**args).clone();
                 df.melt2(args)
             }
+            RowCount { name, offset, .. } => df.with_row_count(name.as_ref(), *offset),
         }
     }
 }
 
 impl Debug for FunctionNode {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(f, "{self}")
@@ -365,10 +376,11 @@
                     writeln!(f, "PIPELINE")
                 }
             }
             Rename { .. } => write!(f, "RENAME"),
             Drop { .. } => write!(f, "DROP"),
             Explode { .. } => write!(f, "EXPLODE"),
             Melt { .. } => write!(f, "MELT"),
+            RowCount { .. } => write!(f, "WITH ROW COUNT"),
         }
     }
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/functions/python_udf.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/functions/python_udf.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/functions/rename.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/functions/rename.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/iterator.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/iterator.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/lit.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/lit.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/mod.rs`

 * *Files 10% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 use std::fmt::Debug;
-#[cfg(any(feature = "ipc", feature = "csv", feature = "parquet"))]
 use std::path::PathBuf;
 use std::sync::{Arc, Mutex};
 
 #[cfg(feature = "parquet")]
 use polars_core::cloud::CloudOptions;
 use polars_core::prelude::*;
 
@@ -16,14 +15,15 @@
 pub(crate) mod anonymous_scan;
 
 mod apply;
 mod builder;
 pub(crate) mod conversion;
 #[cfg(feature = "debugging")]
 pub(crate) mod debug;
+mod file_scan;
 mod format;
 mod functions;
 pub(crate) mod iterator;
 mod lit;
 pub(crate) mod optimizer;
 pub(crate) mod options;
 pub(crate) mod projection;
@@ -36,21 +36,23 @@
 
 pub use aexpr::*;
 pub use alp::*;
 pub use anonymous_scan::*;
 pub use apply::*;
 pub use builder::*;
 pub use conversion::*;
+pub use file_scan::*;
 pub use functions::*;
 pub use iterator::*;
 pub use lit::*;
 pub use optimizer::*;
 pub use schema::*;
 #[cfg(feature = "serde")]
 use serde::{Deserialize, Serialize};
+use strum_macros::IntoStaticStr;
 
 #[cfg(any(feature = "ipc", feature = "parquet", feature = "csv", feature = "cse"))]
 pub use crate::logical_plan::optimizer::file_caching::{
     collect_fingerprints, find_column_union_and_fingerprints, FileCacher, FileFingerPrint,
 };
 
 #[derive(Clone, Copy, Debug)]
@@ -151,38 +153,20 @@
     },
     /// Cache the input at this point in the LP
     Cache {
         input: Box<LogicalPlan>,
         id: usize,
         count: usize,
     },
-    /// Scan a CSV file
-    #[cfg(feature = "csv")]
-    CsvScan {
+    Scan {
         path: PathBuf,
         file_info: FileInfo,
-        options: CsvParserOptions,
-        /// Filters at the scan level
-        predicate: Option<Expr>,
-    },
-    #[cfg(feature = "parquet")]
-    /// Scan a Parquet file
-    ParquetScan {
-        path: PathBuf,
-        file_info: FileInfo,
-        predicate: Option<Expr>,
-        options: ParquetOptions,
-        cloud_options: Option<CloudOptions>,
-    },
-    #[cfg(feature = "ipc")]
-    IpcScan {
-        path: PathBuf,
-        file_info: FileInfo,
-        options: IpcScanOptionsInner,
         predicate: Option<Expr>,
+        file_options: FileScanOptions,
+        scan_type: FileScan,
     },
     // we keep track of the projection and selection as it is cheaper to first project and then filter
     /// In memory DataFrame
     DataFrameScan {
         df: Arc<DataFrame>,
         schema: SchemaRef,
         // schema of the projected file
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/cache_states.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/cache_states.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/cse.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/cse.rs`

 * *Files 14% similar despite different names*

```diff
@@ -112,70 +112,31 @@
             DataFrameScan {
                 df: right_df,
                 projection: None,
                 selection: None,
                 ..
             },
         ) => Arc::ptr_eq(left_df, right_df),
-        #[cfg(feature = "parquet")]
         (
-            ParquetScan {
+            Scan {
                 path: path_left,
-                predicate: predicate_l,
-                options: options_l,
+                predicate: predicate_left,
+                scan_type: scan_type_left,
                 ..
             },
-            ParquetScan {
+            Scan {
                 path: path_right,
-                predicate: predicate_r,
-                options: options_r,
+                predicate: predicate_right,
+                scan_type: scan_type_right,
                 ..
             },
         ) => {
             path_left == path_right
-                && options_l == options_r
-                && predicate_equal(*predicate_l, *predicate_r, expr_arena)
-        }
-        #[cfg(feature = "ipc")]
-        (
-            IpcScan {
-                path: path_left,
-                predicate: predicate_l,
-                options: options_l,
-                ..
-            },
-            IpcScan {
-                path: path_right,
-                predicate: predicate_r,
-                options: options_r,
-                ..
-            },
-        ) => {
-            path_left == path_right
-                && options_l == options_r
-                && predicate_equal(*predicate_l, *predicate_r, expr_arena)
-        }
-        #[cfg(feature = "csv")]
-        (
-            CsvScan {
-                path: path_left,
-                predicate: predicate_l,
-                options: options_l,
-                ..
-            },
-            CsvScan {
-                path: path_right,
-                predicate: predicate_r,
-                options: options_r,
-                ..
-            },
-        ) => {
-            path_left == path_right
-                && options_l == options_r
-                && predicate_equal(*predicate_l, *predicate_r, expr_arena)
+                && scan_type_left == scan_type_right
+                && predicate_equal(*predicate_left, *predicate_right, expr_arena)
         }
         (Selection { predicate: l, .. }, Selection { predicate: r, .. }) => {
             node_to_expr(*l, expr_arena) == node_to_expr(*r, expr_arena)
         }
         (Projection { expr: l, .. }, Projection { expr: r, .. })
         | (HStack { exprs: l, .. }, HStack { exprs: r, .. }) => expr_nodes_equal(l, r, expr_arena),
         (
@@ -419,32 +380,18 @@
     lp_arena: &mut Arena<ALogicalPlan>,
     _expr_arena: &Arena<AExpr>,
     acc_count: FileCount,
     scratch: &mut Vec<Node>,
 ) {
     use ALogicalPlan::*;
     match lp_arena.get_mut(root) {
-        #[cfg(feature = "parquet")]
-        ParquetScan { options, .. } => {
-            if acc_count >= options.file_counter {
-                options.file_counter = 1;
-            } else {
-                options.file_counter -= acc_count as FileCount
-            }
-        }
-        #[cfg(feature = "ipc")]
-        IpcScan { options, .. } => {
-            if acc_count >= options.file_counter {
-                options.file_counter = 1;
-            } else {
-                options.file_counter -= acc_count as FileCount
-            }
-        }
-        #[cfg(feature = "csv")]
-        CsvScan { options, .. } => {
+        Scan {
+            file_options: options,
+            ..
+        } => {
             if acc_count >= options.file_counter {
                 options.file_counter = 1;
             } else {
                 options.file_counter -= acc_count as FileCount
             }
         }
         Cache { count, input, .. } => {
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/delay_rechunk.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/delay_rechunk.rs`

 * *Files 17% similar despite different names*

```diff
@@ -30,27 +30,15 @@
                     return None;
                 };
 
                 use ALogicalPlan::*;
                 let mut input_node = None;
                 for (node, lp) in (&*lp_arena).iter(*input) {
                     match lp {
-                        // we get the input node
-                        #[cfg(feature = "parquet")]
-                        ParquetScan { .. } => {
-                            input_node = Some(node);
-                            break;
-                        }
-                        #[cfg(feature = "csv")]
-                        CsvScan { .. } => {
-                            input_node = Some(node);
-                            break;
-                        }
-                        #[cfg(feature = "ipc")]
-                        IpcScan { .. } => {
+                        Scan { .. } => {
                             input_node = Some(node);
                             break;
                         }
                         Union { .. } => {
                             input_node = Some(node);
                             break;
                         }
@@ -58,22 +46,18 @@
                         Join { .. } => break,
                         _ => {}
                     }
                 }
 
                 if let Some(node) = input_node {
                     match lp_arena.get_mut(node) {
-                        #[cfg(feature = "csv")]
-                        CsvScan { options, .. } => {
-                            options.rechunk = false;
-                        }
-                        #[cfg(feature = "parquet")]
-                        ParquetScan { options, .. } => options.rechunk = false,
-                        #[cfg(feature = "ipc")]
-                        IpcScan { options, .. } => {
+                        Scan {
+                            file_options: options,
+                            ..
+                        } => {
                             options.rechunk = false;
                         }
                         Union { options, .. } => {
                             options.rechunk = false;
                         }
                         _ => unreachable!(),
                     }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/drop_nulls.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/drop_nulls.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/fast_projection.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/fast_projection.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/file_caching.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/slice_pushdown_lp.rs`

 * *Files 20% similar despite different names*

```diff
@@ -1,420 +1,358 @@
-use std::path::{Path, PathBuf};
-use std::sync::Arc;
-
-use polars_core::datatypes::PlHashMap;
 use polars_core::prelude::*;
 
-use crate::logical_plan::ALogicalPlanBuilder;
 use crate::prelude::*;
 
-#[derive(Hash, Eq, PartialEq, Clone, Debug)]
-pub struct FileFingerPrint {
-    pub path: PathBuf,
-    pub predicate: Option<Expr>,
-    pub slice: (usize, Option<usize>),
+pub(super) struct SlicePushDown {
+    streaming: bool,
 }
 
-#[allow(clippy::type_complexity)]
-fn process_with_columns(
-    path: &Path,
-    with_columns: Option<&Vec<String>>,
-    predicate: Option<Expr>,
-    slice: (usize, Option<usize>),
-    file_count_and_column_union: &mut PlHashMap<FileFingerPrint, (FileCount, PlIndexSet<String>)>,
-    schema: &Schema,
-) {
-    let cols = file_count_and_column_union
-        .entry(FileFingerPrint {
-            path: path.into(),
-            predicate,
-            slice,
-        })
-        .or_insert_with(|| {
-            (
-                0,
-                PlIndexSet::with_capacity_and_hasher(32, Default::default()),
-            )
-        });
-
-    // increment file count
-    cols.0 += 1;
-
-    match with_columns {
-        // add only the projected columns
-        Some(with_columns) => cols.1.extend(with_columns.iter().cloned()),
-        // no projection, so we must take all columns
-        None => {
-            cols.1.extend(schema.iter_names().map(|t| t.to_string()));
-        }
-    }
+#[derive(Copy, Clone)]
+struct State {
+    offset: i64,
+    len: IdxSize,
 }
 
-#[allow(clippy::type_complexity)]
-pub fn collect_fingerprints(
-    root: Node,
-    fps: &mut Vec<FileFingerPrint>,
-    lp_arena: &Arena<ALogicalPlan>,
-    expr_arena: &Arena<AExpr>,
-) {
-    use ALogicalPlan::*;
-    match lp_arena.get(root) {
-        #[cfg(feature = "csv")]
-        CsvScan {
-            path,
-            options,
-            predicate,
-            ..
-        } => {
-            let slice = (options.skip_rows, options.n_rows);
-            let predicate = predicate.map(|node| node_to_expr(node, expr_arena));
-            let fp = FileFingerPrint {
-                path: path.clone(),
-                predicate,
-                slice,
-            };
-            fps.push(fp);
-        }
-        #[cfg(feature = "parquet")]
-        ParquetScan {
-            path,
-            options,
-            predicate,
-            ..
-        } => {
-            let slice = (0, options.n_rows);
-            let predicate = predicate.map(|node| node_to_expr(node, expr_arena));
-            let fp = FileFingerPrint {
-                path: path.clone(),
-                predicate,
-                slice,
-            };
-            fps.push(fp);
-        }
-        #[cfg(feature = "ipc")]
-        IpcScan {
-            path,
-            options,
-            predicate,
-            ..
-        } => {
-            let slice = (0, options.n_rows);
-            let predicate = predicate.map(|node| node_to_expr(node, expr_arena));
-            let fp = FileFingerPrint {
-                path: path.clone(),
-                predicate,
-                slice,
-            };
-            fps.push(fp);
-        }
-        lp => {
-            for input in lp.get_inputs() {
-                collect_fingerprints(input, fps, lp_arena, expr_arena)
-            }
-        }
+impl SlicePushDown {
+    pub(super) fn new(streaming: bool) -> Self {
+        Self { streaming }
     }
-}
 
-/// Find the union between the columns per unique IO operation.
-/// A unique IO operation is the file + the predicates pushed down to that file
-#[allow(clippy::type_complexity)]
-pub fn find_column_union_and_fingerprints(
-    root: Node,
-    // The hashmap maps files to a hashset over column names.
-    // we also keep track of how often a needs file needs to be read so we can cache until last read
-    columns: &mut PlHashMap<FileFingerPrint, (FileCount, PlIndexSet<String>)>,
-    lp_arena: &Arena<ALogicalPlan>,
-    expr_arena: &Arena<AExpr>,
-) {
-    use ALogicalPlan::*;
-    match lp_arena.get(root) {
-        #[cfg(feature = "csv")]
-        CsvScan {
-            path,
-            options,
-            predicate,
-            file_info,
-            ..
-        } => {
-            let slice = (options.skip_rows, options.n_rows);
-            let predicate = predicate.map(|node| node_to_expr(node, expr_arena));
-            process_with_columns(
-                path,
-                options.with_columns.as_deref(),
-                predicate,
-                slice,
-                columns,
-                &file_info.schema,
-            );
-        }
-        #[cfg(feature = "parquet")]
-        ParquetScan {
-            path,
-            options,
-            file_info,
-            predicate,
-            ..
-        } => {
-            let slice = (0, options.n_rows);
-            let predicate = predicate.map(|node| node_to_expr(node, expr_arena));
-            process_with_columns(
-                path,
-                options.with_columns.as_deref(),
-                predicate,
-                slice,
-                columns,
-                &file_info.schema,
-            );
-        }
-        #[cfg(feature = "ipc")]
-        IpcScan {
-            path,
-            options,
-            file_info,
-            predicate,
-            ..
-        } => {
-            let slice = (0, options.n_rows);
-            let predicate = predicate.map(|node| node_to_expr(node, expr_arena));
-            process_with_columns(
-                path,
-                options.with_columns.as_deref(),
-                predicate,
-                slice,
-                columns,
-                &file_info.schema,
-            );
-        }
-        lp => {
-            for input in lp.get_inputs() {
-                find_column_union_and_fingerprints(input, columns, lp_arena, expr_arena)
+    // slice will be done at this node if we found any
+    // we also stop optimization
+    fn no_pushdown_finish_opt(
+        &self,
+        lp: ALogicalPlan,
+        state: Option<State>,
+        lp_arena: &mut Arena<ALogicalPlan>,
+    ) -> PolarsResult<ALogicalPlan> {
+        match state {
+            Some(state) => {
+                let input = lp_arena.add(lp);
+
+                let lp = ALogicalPlan::Slice {
+                    input,
+                    offset: state.offset,
+                    len: state.len,
+                };
+                Ok(lp)
             }
+            None => Ok(lp),
         }
     }
-}
-
-/// Aggregate all the columns used in csv scans and make sure that all columns are scanned in one go.
-/// Due to self joins there can be multiple Scans of the same file in a LP. We already cache the scans
-/// in the PhysicalPlan, but we need to make sure that the first scan has all the columns needed.
-pub struct FileCacher {
-    file_count_and_column_union: PlHashMap<FileFingerPrint, (FileCount, Arc<Vec<String>>)>,
-}
 
-impl FileCacher {
-    pub(crate) fn new(
-        columns: PlHashMap<FileFingerPrint, (FileCount, PlIndexSet<String>)>,
-    ) -> Self {
-        let new_columns_mapping = columns
-            .into_iter()
-            .map(|(k, agg)| {
-                let file_count = agg.0;
-                let columns = agg.1.iter().cloned().collect::<Vec<_>>();
-                (k, (file_count, Arc::new(columns)))
+    /// slice will be done at this node, but we continue optimization
+    fn no_pushdown_restart_opt(
+        &self,
+        lp: ALogicalPlan,
+        state: Option<State>,
+        lp_arena: &mut Arena<ALogicalPlan>,
+        expr_arena: &mut Arena<AExpr>,
+    ) -> PolarsResult<ALogicalPlan> {
+        let inputs = lp.get_inputs();
+        let exprs = lp.get_exprs();
+
+        let new_inputs = inputs
+            .iter()
+            .map(|&node| {
+                let alp = lp_arena.take(node);
+                // No state, so we do not push down the slice here.
+                let state = None;
+                let alp = self.pushdown(alp, state, lp_arena, expr_arena)?;
+                lp_arena.replace(node, alp);
+                Ok(node)
             })
-            .collect();
-        Self {
-            file_count_and_column_union: new_columns_mapping,
-        }
+            .collect::<PolarsResult<Vec<_>>>()?;
+        let lp = lp.with_exprs_and_input(exprs, new_inputs);
+
+        self.no_pushdown_finish_opt(lp, state, lp_arena)
     }
 
-    fn finish_rewrite(
+    /// slice will be pushed down.
+    fn pushdown_and_continue(
         &self,
-        mut lp: ALogicalPlan,
-        expr_arena: &mut Arena<AExpr>,
+        lp: ALogicalPlan,
+        state: Option<State>,
         lp_arena: &mut Arena<ALogicalPlan>,
-        finger_print: &FileFingerPrint,
-        with_columns: Option<Arc<Vec<String>>>,
-        behind_cache: bool,
-    ) -> ALogicalPlan {
-        // if the original projection is less than the new one. Also project locally
-        if let Some(mut with_columns) = with_columns {
-            // we cannot always find the predicates, because some have `SpecialEq` functions so for those
-            // cases we may read the file twice and/or do an extra projection
-            let do_projection = match self.file_count_and_column_union.get(finger_print) {
-                Some((_file_count, agg_columns)) => with_columns.len() < agg_columns.len(),
-                None => true,
-            };
-            if !behind_cache && do_projection {
-                let node = lp_arena.add(lp);
-
-                let projections = std::mem::take(Arc::make_mut(&mut with_columns))
-                    .into_iter()
-                    .map(|s| expr_arena.add(AExpr::Column(Arc::from(s))))
-                    .collect();
-
-                lp = ALogicalPlanBuilder::new(node, expr_arena, lp_arena)
-                    .project(projections)
-                    .build();
-            }
-        }
-        lp
-    }
-
-    fn extract_columns_and_count(
-        &mut self,
-        finger_print: &FileFingerPrint,
-    ) -> Option<(FileCount, Arc<Vec<String>>)> {
-        self.file_count_and_column_union.get(finger_print).cloned()
+        expr_arena: &mut Arena<AExpr>,
+    ) -> PolarsResult<ALogicalPlan> {
+        let inputs = lp.get_inputs();
+        let exprs = lp.get_exprs();
+
+        let new_inputs = inputs
+            .iter()
+            .map(|&node| {
+                let alp = lp_arena.take(node);
+                let alp = self.pushdown(alp, state, lp_arena, expr_arena)?;
+                lp_arena.replace(node, alp);
+                Ok(node)
+            })
+            .collect::<PolarsResult<Vec<_>>>()?;
+        Ok(lp.with_exprs_and_input(exprs, new_inputs))
     }
 
-    // This will ensure that all read files have the amount of columns needed for the cache.
-    // In case of CSE, it will ensure that the union projected nodes are available.
-    pub(crate) fn assign_unions(
-        &mut self,
-        root: Node,
+    fn pushdown(
+        &self,
+        lp: ALogicalPlan,
+        state: Option<State>,
         lp_arena: &mut Arena<ALogicalPlan>,
         expr_arena: &mut Arena<AExpr>,
-        scratch: &mut Vec<Node>,
-    ) {
-        scratch.clear();
-        let mut stack = Vec::with_capacity(lp_arena.len() / 3 + 1);
-        stack.push((root, false));
-
-        // if behind cache we should not add a projection
-        while let Some((root, behind_cache)) = stack.pop() {
-            let lp = lp_arena.take(root);
-            match lp {
-                #[cfg(feature = "parquet")]
-                ALogicalPlan::ParquetScan {
-                    path,
+    ) -> PolarsResult<ALogicalPlan> {
+        use ALogicalPlan::*;
+
+        match (lp, state) {
+            (AnonymousScan {
+                function,
+                file_info,
+                output_schema,
+                predicate,
+                mut options,
+            },
+                // TODO! we currently skip slice pushdown if there is a predicate.
+                // we can modify the readers to only limit after predicates have been applied
+                Some(state)) if state.offset == 0 && predicate.is_none() => {
+                options.n_rows = Some(state.len as usize);
+                let lp = AnonymousScan {
+                    function,
                     file_info,
                     output_schema,
                     predicate,
-                    mut options,
-                    cloud_options,
-                } => {
-                    let predicate_expr = predicate.map(|node| node_to_expr(node, expr_arena));
-                    let finger_print = FileFingerPrint {
-                        path,
-                        predicate: predicate_expr,
-                        slice: (0, options.n_rows),
-                    };
-
-                    let with_columns = self.extract_columns_and_count(&finger_print);
-                    options.file_counter = with_columns.as_ref().map(|t| t.0).unwrap_or(0);
-                    let with_columns = with_columns.and_then(|t| {
-                        if t.1.len() != file_info.schema.len() {
-                            Some(t.1)
-                        } else {
-                            None
-                        }
-                    });
-
-                    options.with_columns = with_columns;
-                    let lp = ALogicalPlan::ParquetScan {
-                        path: finger_print.path.clone(),
-                        file_info,
-                        output_schema,
-                        predicate,
-                        options: options.clone(),
-                        cloud_options,
-                    };
-                    let lp = self.finish_rewrite(
-                        lp,
-                        expr_arena,
-                        lp_arena,
-                        &finger_print,
-                        options.with_columns,
-                        behind_cache,
-                    );
-                    lp_arena.replace(root, lp);
-                }
-                #[cfg(feature = "csv")]
-                ALogicalPlan::CsvScan {
+                    options,
+                };
+
+                Ok(lp)
+            },
+            #[cfg(feature = "python")]
+            (PythonScan {
+                mut options,
+                predicate,
+            },
+            // TODO! we currently skip slice pushdown if there is a predicate.
+            // we can modify the readers to only limit after predicates have been applied
+                Some(state)) if state.offset == 0 && predicate.is_none() => {
+                options.n_rows = Some(state.len as usize);
+                let lp = PythonScan {
+                    options,
+                    predicate
+                };
+                Ok(lp)
+            }
+            #[cfg(feature = "csv")]
+            (Scan {
+                path,
+                file_info,
+                output_schema,
+                file_options: mut options,
+                predicate,
+                scan_type: FileScan::Csv {options: mut csv_options}
+            }, Some(state)) if predicate.is_none() && state.offset >= 0 =>  {
+                options.n_rows = Some(state.len as usize);
+                csv_options.skip_rows += state.offset as usize;
+
+                let lp = Scan {
                     path,
                     file_info,
                     output_schema,
+                    scan_type: FileScan::Csv {options: csv_options},
+                    file_options: options,
                     predicate,
-                    mut options,
-                } => {
-                    let predicate_expr = predicate.map(|node| node_to_expr(node, expr_arena));
-                    let finger_print = FileFingerPrint {
-                        path,
-                        predicate: predicate_expr,
-                        slice: (options.skip_rows, options.n_rows),
-                    };
-
-                    let with_columns = self.extract_columns_and_count(&finger_print);
-                    options.file_counter = with_columns.as_ref().map(|t| t.0).unwrap_or(0);
-                    let with_columns = with_columns.and_then(|t| {
-                        if t.1.len() != file_info.schema.len() {
-                            Some(t.1)
-                        } else {
-                            None
-                        }
-                    });
-
-                    options.with_columns = with_columns;
-                    let lp = ALogicalPlan::CsvScan {
-                        path: finger_print.path.clone(),
-                        file_info,
-                        output_schema,
-                        predicate,
-                        options: options.clone(),
-                    };
-                    let lp = self.finish_rewrite(
-                        lp,
-                        expr_arena,
-                        lp_arena,
-                        &finger_print,
-                        options.with_columns,
-                        behind_cache,
-                    );
-                    lp_arena.replace(root, lp);
-                }
-                #[cfg(feature = "ipc")]
-                ALogicalPlan::IpcScan {
+                };
+                Ok(lp)
+            },
+            (Scan {
+                path,
+                file_info,
+                output_schema,
+                file_options: mut options,
+                predicate,
+                scan_type
+            }, Some(state)) if state.offset == 0 && predicate.is_none() => {
+
+                options.n_rows = Some(state.len as usize);
+                let lp = Scan {
                     path,
                     file_info,
                     output_schema,
                     predicate,
-                    mut options,
-                } => {
-                    let predicate_expr = predicate.map(|node| node_to_expr(node, expr_arena));
-                    let finger_print = FileFingerPrint {
-                        path,
-                        predicate: predicate_expr,
-                        slice: (0, options.n_rows),
-                    };
-
-                    let with_columns = self.extract_columns_and_count(&finger_print);
-                    options.file_counter = with_columns.as_ref().map(|t| t.0).unwrap_or(0);
-                    let with_columns = with_columns.and_then(|t| {
-                        if t.1.len() != file_info.schema.len() {
-                            Some(t.1)
-                        } else {
-                            None
-                        }
-                    });
-
-                    options.with_columns = with_columns;
-                    let lp = ALogicalPlan::IpcScan {
-                        path: finger_print.path.clone(),
-                        file_info,
-                        output_schema,
-                        predicate,
-                        options: options.clone(),
-                    };
-                    let lp = self.finish_rewrite(
-                        lp,
-                        expr_arena,
-                        lp_arena,
-                        &finger_print,
-                        options.with_columns,
-                        behind_cache,
-                    );
-                    lp_arena.replace(root, lp);
-                }
-                lp => {
-                    let behind_cache = behind_cache || matches!(&lp, ALogicalPlan::Cache { .. });
+                    file_options: options,
+                    scan_type
+                };
 
-                    lp.copy_inputs(scratch);
-                    while let Some(input) = scratch.pop() {
-                        stack.push((input, behind_cache))
-                    }
-                    lp_arena.replace(root, lp);
+                Ok(lp)
+            }
+            (Union {inputs, mut options }, Some(state)) => {
+                options.slice = Some((state.offset, state.len as usize));
+                Ok(Union {inputs, options})
+            },
+            (Join {
+                input_left,
+                input_right,
+                schema,
+                left_on,
+                right_on,
+                mut options
+            }, Some(state)) if !self.streaming => {
+                // first restart optimization in both inputs and get the updated LP
+                let lp_left = lp_arena.take(input_left);
+                let lp_left = self.pushdown(lp_left, None, lp_arena, expr_arena)?;
+                let input_left = lp_arena.add(lp_left);
+
+                let lp_right = lp_arena.take(input_right);
+                let lp_right = self.pushdown(lp_right, None, lp_arena, expr_arena)?;
+                let input_right = lp_arena.add(lp_right);
+
+                // then assign the slice state to the join operation
+
+                options.args.slice = Some((state.offset, state.len as usize));
+
+                Ok(Join {
+                    input_left,
+                    input_right,
+                    schema,
+                    left_on,
+                    right_on,
+                    options
+                })
+            }
+            (Aggregate { input, keys, aggs, schema, apply, maintain_order, mut options }, Some(state)) => {
+                // first restart optimization in inputs and get the updated LP
+                let input_lp = lp_arena.take(input);
+                let input_lp = self.pushdown(input_lp, None, lp_arena, expr_arena)?;
+                let input= lp_arena.add(input_lp);
+
+                options.slice = Some((state.offset, state.len as usize));
+
+                Ok(Aggregate {
+                    input,
+                    keys,
+                    aggs,
+                    schema,
+                    apply,
+                    maintain_order,
+                    options
+                })
+            }
+            (Distinct {input, mut options}, Some(state)) => {
+                // first restart optimization in inputs and get the updated LP
+                let input_lp = lp_arena.take(input);
+                let input_lp = self.pushdown(input_lp, None, lp_arena, expr_arena)?;
+                let input= lp_arena.add(input_lp);
+                options.slice = Some((state.offset, state.len as usize));
+                Ok(Distinct {
+                    input,
+                    options,
+                })
+            }
+            (Sort {input, by_column, mut args}, Some(state)) => {
+                // first restart optimization in inputs and get the updated LP
+                let input_lp = lp_arena.take(input);
+                let input_lp = self.pushdown(input_lp, None, lp_arena, expr_arena)?;
+                let input= lp_arena.add(input_lp);
+
+                args.slice = Some((state.offset, state.len as usize));
+                Ok(Sort {
+                    input,
+                    by_column,
+                    args
+                })
+            }
+            (Slice {
+                input,
+                offset,
+                len
+            }, Some(previous_state)) => {
+                let alp = lp_arena.take(input);
+                let state = Some(State {
+                    offset,
+                    len
+                });
+                let lp = self.pushdown(alp, state, lp_arena, expr_arena)?;
+                let input = lp_arena.add(lp);
+                Ok(Slice {
+                    input,
+                    offset: previous_state.offset,
+                    len: previous_state.len
+                })
+            }
+            (Slice {
+                input,
+                offset,
+                len
+            }, None) => {
+                let alp = lp_arena.take(input);
+                let state = Some(State {
+                    offset,
+                    len
+                });
+                self.pushdown(alp, state, lp_arena, expr_arena)
+            }
+            // [Do not pushdown] boundary
+            // here we do not pushdown.
+            // we reset the state and then start the optimization again
+            m @ (Selection { .. }, _)
+            // let's be conservative. projections may do aggregations and a pushed down slice
+            // will lead to incorrect aggregations
+            | m @ (LocalProjection {..},_)
+            // other blocking nodes
+            | m @ (DataFrameScan {..}, _)
+            | m @ (Sort {..}, _)
+            | m @ (MapFunction {function: FunctionNode::Explode {..}, ..}, _)
+            | m @ (MapFunction {function: FunctionNode::Melt {..}, ..}, _)
+            | m @ (Cache {..}, _)
+            | m @ (Distinct {..}, _)
+            | m @ (HStack {..},_)
+            | m @ (Aggregate{..},_)
+            // blocking in streaming
+            | m @ (Join{..},_)
+            => {
+                let (lp, state) = m;
+                self.no_pushdown_restart_opt(lp, state, lp_arena, expr_arena)
+            }
+            // [Pushdown]
+            (MapFunction {input, function}, _) if function.allow_predicate_pd() => {
+                let lp = MapFunction {input, function};
+                self.pushdown_and_continue(lp, state, lp_arena, expr_arena)
+            },
+            // [NO Pushdown]
+            m @ (MapFunction {..}, _) => {
+                let (lp, state) = m;
+                self.no_pushdown_restart_opt(lp, state, lp_arena, expr_arena)
+            }
+            // [Pushdown]
+            // these nodes will be pushed down.
+             // State is None, we can continue
+             m @(Projection{..}, None)
+            => {
+                let (lp, state) = m;
+                self.pushdown_and_continue(lp, state, lp_arena, expr_arena)
+            }
+            // there is state, inspect the projection to determine how to deal with it
+            (Projection {input, expr, schema}, Some(_)) => {
+                // The slice operation may only pass on simple projections. col("foo").alias("bar")
+                if expr.iter().all(|root|  {
+                    aexpr_is_elementwise(*root, expr_arena)
+                }) {
+                    let lp = Projection {input, expr, schema};
+                    self.pushdown_and_continue(lp, state, lp_arena, expr_arena)
+                }
+                // don't push down slice, but restart optimization
+                else {
+                    let lp = Projection {input, expr, schema};
+                    self.no_pushdown_restart_opt(lp, state, lp_arena, expr_arena)
                 }
             }
+            (catch_all, state) => {
+                self.no_pushdown_finish_opt(catch_all, state, lp_arena)
+            }
+
         }
-        scratch.clear();
+    }
+
+    pub fn optimize(
+        &self,
+        logical_plan: ALogicalPlan,
+        lp_arena: &mut Arena<ALogicalPlan>,
+        expr_arena: &mut Arena<AExpr>,
+    ) -> PolarsResult<ALogicalPlan> {
+        self.pushdown(logical_plan, None, lp_arena, expr_arena)
     }
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/flatten_union.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/flatten_union.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/fused.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/fused.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/keys.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/keys.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/mod.rs`

 * *Files 8% similar despite different names*

```diff
@@ -236,92 +236,56 @@
                 let schema = aexprs_to_schema(&expr, &schema, Context::Default, expr_arena);
                 Ok(ALogicalPlan::LocalProjection {
                     expr,
                     input,
                     schema: Arc::new(schema),
                 })
             }
-            #[cfg(feature = "ipc")]
-            IpcScan {
+            Scan {
                 path,
                 file_info,
-                output_schema,
                 predicate,
-                options,
+                scan_type,
+                file_options: options,
+                output_schema
             } => {
                 let local_predicates = partition_by_full_context(&mut acc_predicates, expr_arena);
                 let predicate = predicate_at_scan(acc_predicates, predicate, expr_arena);
 
-                let lp = IpcScan {
-                    path,
-                    file_info,
-                    output_schema,
-                    predicate,
-                    options,
-                };
-                Ok(self.optional_apply_predicate(lp, local_predicates, lp_arena, expr_arena))
-            }
-            #[cfg(feature = "parquet")]
-            ParquetScan {
-                path,
-                file_info,
-                output_schema,
-                predicate,
-                options,
-                cloud_options,
-            } => {
-                let local_predicates = partition_by_full_context(&mut acc_predicates, expr_arena);
-
-                let predicate = predicate_at_scan(acc_predicates, predicate, expr_arena);
-
-                let lp = ParquetScan {
-                    path,
-                    file_info,
-                    output_schema,
-                    predicate,
-                    options,
-                    cloud_options,
-                };
-                Ok(self.optional_apply_predicate(lp, local_predicates, lp_arena, expr_arena))
-            }
-            #[cfg(feature = "csv")]
-            CsvScan {
-                path,
-                file_info,
-                output_schema,
-                options,
-                predicate,
-            } => {
-                let local_predicates = partition_by_full_context(&mut acc_predicates, expr_arena);
-                let predicate = predicate_at_scan(acc_predicates, predicate, expr_arena);
-
-                let lp = if let (Some(predicate), Some(_)) = (predicate, options.n_rows) {
-                    let lp = CsvScan {
-                        path,
-                        file_info,
-                        output_schema,
-                        options,
-                        predicate: None,
-                    };
-                    let input = lp_arena.add(lp);
-                    Selection {
-                        input,
-                        predicate
-                    }
-                } else {
-                    CsvScan {
-                        path,
-                        file_info,
-                        output_schema,
-                        options,
-                        predicate,
+                let lp = match (predicate, &scan_type) {
+                    #[cfg(feature = "csv")]
+                    (Some(predicate), FileScan::Csv {..}) => {
+                        let lp = Scan {
+                            path,
+                            file_info,
+                            predicate: None,
+                            file_options: options,
+                            output_schema,
+                            scan_type
+                        };
+                        let input = lp_arena.add(lp);
+                        Selection {
+                            input,
+                            predicate
+                        }
+                    },
+                    _ => {
+                        Scan {
+                            path,
+                            file_info,
+                            predicate,
+                            file_options: options,
+                            output_schema,
+                            scan_type
+                        }
                     }
                 };
 
                 Ok(self.optional_apply_predicate(lp, local_predicates, lp_arena, expr_arena))
+
             }
             AnonymousScan {
                 function,
                 file_info,
                 output_schema,
                 options,
                 predicate,
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/rename.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/rename.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/utils.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/utils.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/functions/melt.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/functions/melt.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/functions/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/functions/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/generic.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/generic.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/groupby.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/groupby.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/hstack.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/hstack.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/joins.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/joins.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/mod.rs`

 * *Files 5% similar despite different names*

```diff
@@ -6,14 +6,15 @@
 mod projection;
 mod rename;
 #[cfg(feature = "semi_anti_join")]
 mod semi_anti_join;
 
 use polars_core::datatypes::PlHashSet;
 use polars_core::prelude::*;
+use polars_io::RowCount;
 #[cfg(feature = "semi_anti_join")]
 use semi_anti_join::process_semi_anti_join;
 
 use crate::logical_plan::Context;
 use crate::prelude::iterator::ArenaExprIter;
 use crate::prelude::optimizer::projection_pushdown::generic::process_generic;
 use crate::prelude::optimizer::projection_pushdown::groupby::process_groupby;
@@ -34,21 +35,31 @@
     PlHashSet::with_capacity(32)
 }
 
 /// utility function to get names of the columns needed in projection at scan level
 fn get_scan_columns(
     acc_projections: &mut Vec<Node>,
     expr_arena: &Arena<AExpr>,
+    row_count: Option<&RowCount>,
 ) -> Option<Arc<Vec<String>>> {
     let mut with_columns = None;
     if !acc_projections.is_empty() {
         let mut columns = Vec::with_capacity(acc_projections.len());
         for expr in acc_projections {
             for name in aexpr_to_leaf_names(*expr, expr_arena) {
-                columns.push((*name).to_owned())
+                // we shouldn't project the row-count column, as that is generated
+                // in the scan
+                let push = match row_count {
+                    Some(rc) if name.as_ref() != rc.name.as_str() => true,
+                    None => true,
+                    _ => false,
+                };
+                if push {
+                    columns.push((*name).to_owned())
+                }
             }
         }
         with_columns = Some(Arc::new(columns));
     }
     with_columns
 }
 
@@ -112,18 +123,14 @@
     }
 }
 
 fn update_scan_schema(
     acc_projections: &[Node],
     expr_arena: &Arena<AExpr>,
     schema: &Schema,
-    // this is only needed for parsers that sort the projections
-    // currently these are:
-    // sorting parsers: csv,
-    // non-sorting: parquet, ipc
     sort_projections: bool,
 ) -> PolarsResult<Schema> {
     let mut new_schema = Schema::with_capacity(acc_projections.len());
     let mut new_cols = Vec::with_capacity(acc_projections.len());
     for node in acc_projections.iter() {
         for name in aexpr_to_leaf_names(*node, expr_arena) {
             let item = schema.get_full(&name).ok_or_else(|| {
@@ -351,15 +358,15 @@
                 function,
                 file_info,
                 predicate,
                 mut options,
                 output_schema,
             } => {
                 if function.allows_projection_pushdown() {
-                    options.with_columns = get_scan_columns(&mut acc_projections, expr_arena);
+                    options.with_columns = get_scan_columns(&mut acc_projections, expr_arena, None);
 
                     let output_schema = if options.with_columns.is_none() {
                         None
                     } else {
                         Some(Arc::new(update_scan_schema(
                             &acc_projections,
                             expr_arena,
@@ -399,134 +406,76 @@
                 if !acc_projections.is_empty() {
                     output_schema = Some(Arc::new(update_scan_schema(
                         &acc_projections,
                         expr_arena,
                         &schema,
                         false,
                     )?));
-                    projection = get_scan_columns(&mut acc_projections, expr_arena);
+                    projection = get_scan_columns(&mut acc_projections, expr_arena, None);
                 }
                 let lp = DataFrameScan {
                     df,
                     schema,
                     output_schema,
                     projection,
                     selection,
                 };
                 Ok(lp)
             }
-            #[cfg(feature = "ipc")]
-            IpcScan {
-                path,
-                file_info,
-                predicate,
-                mut options,
-                ..
-            } => {
-                let with_columns = get_scan_columns(&mut acc_projections, expr_arena);
-                let output_schema = if with_columns.is_none() {
-                    None
-                } else {
-                    Some(Arc::new(update_scan_schema(
-                        &acc_projections,
-                        expr_arena,
-                        &file_info.schema,
-                        false,
-                    )?))
-                };
-                options.with_columns = with_columns;
-
-                let lp = IpcScan {
-                    path,
-                    file_info,
-                    output_schema,
-                    predicate,
-                    options,
-                };
-                Ok(lp)
-            }
-
-            #[cfg(feature = "parquet")]
-            ParquetScan {
-                path,
-                file_info,
-                predicate,
-                mut options,
-                cloud_options,
-                ..
-            } => {
-                let with_columns = get_scan_columns(&mut acc_projections, expr_arena);
-                let output_schema = if with_columns.is_none() {
-                    None
-                } else {
-                    Some(Arc::new(update_scan_schema(
-                        &acc_projections,
-                        expr_arena,
-                        &file_info.schema,
-                        false,
-                    )?))
-                };
-                options.with_columns = with_columns;
-
-                let lp = ParquetScan {
-                    path,
-                    file_info,
-                    output_schema,
-                    predicate,
-                    options,
-                    cloud_options,
-                };
-                Ok(lp)
-            }
             #[cfg(feature = "python")]
             PythonScan {
                 mut options,
                 predicate,
             } => {
-                options.with_columns = get_scan_columns(&mut acc_projections, expr_arena);
+                options.with_columns = get_scan_columns(&mut acc_projections, expr_arena, None);
 
                 options.output_schema = if options.with_columns.is_none() {
                     None
                 } else {
                     Some(Arc::new(update_scan_schema(
                         &acc_projections,
                         expr_arena,
                         &options.schema,
                         true,
                     )?))
                 };
                 Ok(PythonScan { options, predicate })
             }
-            #[cfg(feature = "csv")]
-            CsvScan {
+            Scan {
                 path,
                 file_info,
-                mut options,
+                scan_type,
                 predicate,
+                mut file_options,
                 ..
             } => {
-                options.with_columns = get_scan_columns(&mut acc_projections, expr_arena);
+                file_options.with_columns = get_scan_columns(
+                    &mut acc_projections,
+                    expr_arena,
+                    file_options.row_count.as_ref(),
+                );
 
-                let output_schema = if options.with_columns.is_none() {
+                let output_schema = if file_options.with_columns.is_none() {
                     None
                 } else {
                     Some(Arc::new(update_scan_schema(
                         &acc_projections,
                         expr_arena,
                         &file_info.schema,
-                        true,
+                        scan_type.sort_projection(&file_options),
                     )?))
                 };
 
-                let lp = CsvScan {
+                let lp = Scan {
                     path,
                     file_info,
                     output_schema,
-                    options,
+                    scan_type,
                     predicate,
+                    file_options,
                 };
                 Ok(lp)
             }
             Sort {
                 input,
                 by_column,
                 args,
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/projection.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/projection.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/rename.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/rename.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/semi_anti_join.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/semi_anti_join.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/simplify_expr.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/simplify_expr.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/slice_pushdown_expr.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/slice_pushdown_expr.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/slice_pushdown_lp.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/schema.rs`

 * *Files 26% similar despite different names*

```diff
@@ -1,382 +1,298 @@
+use std::borrow::Cow;
+
 use polars_core::prelude::*;
+use polars_utils::format_smartstring;
+#[cfg(feature = "serde")]
+use serde::{Deserialize, Serialize};
 
 use crate::prelude::*;
 
-pub(super) struct SlicePushDown {
-    streaming: bool,
-}
-
-#[derive(Copy, Clone)]
-struct State {
-    offset: i64,
-    len: IdxSize,
-}
-
-impl SlicePushDown {
-    pub(super) fn new(streaming: bool) -> Self {
-        Self { streaming }
-    }
-
-    // slice will be done at this node if we found any
-    // we also stop optimization
-    fn no_pushdown_finish_opt(
-        &self,
-        lp: ALogicalPlan,
-        state: Option<State>,
-        lp_arena: &mut Arena<ALogicalPlan>,
-    ) -> PolarsResult<ALogicalPlan> {
-        match state {
-            Some(state) => {
-                let input = lp_arena.add(lp);
-
-                let lp = ALogicalPlan::Slice {
-                    input,
-                    offset: state.offset,
-                    len: state.len,
-                };
-                Ok(lp)
+impl LogicalPlan {
+    pub fn schema(&self) -> PolarsResult<Cow<'_, SchemaRef>> {
+        use LogicalPlan::*;
+        match self {
+            Scan { file_info, .. } => Ok(Cow::Borrowed(&file_info.schema)),
+            #[cfg(feature = "python")]
+            PythonScan { options } => Ok(Cow::Borrowed(&options.schema)),
+            Union { inputs, .. } => inputs[0].schema(),
+            Cache { input, .. } => input.schema(),
+            Sort { input, .. } => input.schema(),
+            DataFrameScan { schema, .. } => Ok(Cow::Borrowed(schema)),
+            AnonymousScan { file_info, .. } => Ok(Cow::Borrowed(&file_info.schema)),
+            Selection { input, .. } => input.schema(),
+            Projection { schema, .. } => Ok(Cow::Borrowed(schema)),
+            LocalProjection { schema, .. } => Ok(Cow::Borrowed(schema)),
+            Aggregate { schema, .. } => Ok(Cow::Borrowed(schema)),
+            Join { schema, .. } => Ok(Cow::Borrowed(schema)),
+            HStack { schema, .. } => Ok(Cow::Borrowed(schema)),
+            Distinct { input, .. } | FileSink { input, .. } => input.schema(),
+            Slice { input, .. } => input.schema(),
+            MapFunction {
+                input, function, ..
+            } => {
+                let input_schema = input.schema()?;
+                match input_schema {
+                    Cow::Owned(schema) => Ok(Cow::Owned(function.schema(&schema)?.into_owned())),
+                    Cow::Borrowed(schema) => function.schema(schema),
+                }
             }
-            None => Ok(lp),
+            Error { err, .. } => Err(err.take()),
+            ExtContext { schema, .. } => Ok(Cow::Borrowed(schema)),
         }
     }
+}
 
-    /// slice will be done at this node, but we continue optimization
-    fn no_pushdown_restart_opt(
-        &self,
-        lp: ALogicalPlan,
-        state: Option<State>,
-        lp_arena: &mut Arena<ALogicalPlan>,
-        expr_arena: &mut Arena<AExpr>,
-    ) -> PolarsResult<ALogicalPlan> {
-        let inputs = lp.get_inputs();
-        let exprs = lp.get_exprs();
-
-        let new_inputs = inputs
-            .iter()
-            .map(|&node| {
-                let alp = lp_arena.take(node);
-                // No state, so we do not push down the slice here.
-                let state = None;
-                let alp = self.pushdown(alp, state, lp_arena, expr_arena)?;
-                lp_arena.replace(node, alp);
-                Ok(node)
-            })
-            .collect::<PolarsResult<Vec<_>>>()?;
-        let lp = lp.with_exprs_and_input(exprs, new_inputs);
+#[derive(Clone, Debug)]
+#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
+pub struct FileInfo {
+    pub schema: SchemaRef,
+    // - known size
+    // - estimated size
+    pub row_estimation: (Option<usize>, usize),
+}
 
-        self.no_pushdown_finish_opt(lp, state, lp_arena)
+#[cfg(feature = "streaming")]
+fn estimate_sizes(
+    known_size: Option<usize>,
+    estimated_size: usize,
+    filter_count: usize,
+) -> (Option<usize>, usize) {
+    match (known_size, filter_count) {
+        (Some(known_size), 0) => (Some(known_size), estimated_size),
+        (None, 0) => (None, estimated_size),
+        (_, _) => (
+            None,
+            (estimated_size as f32 * 0.9f32.powf(filter_count as f32)) as usize,
+        ),
     }
+}
 
-    /// slice will be pushed down.
-    fn pushdown_and_continue(
-        &self,
-        lp: ALogicalPlan,
-        state: Option<State>,
-        lp_arena: &mut Arena<ALogicalPlan>,
-        expr_arena: &mut Arena<AExpr>,
-    ) -> PolarsResult<ALogicalPlan> {
-        let inputs = lp.get_inputs();
-        let exprs = lp.get_exprs();
-
-        let new_inputs = inputs
-            .iter()
-            .map(|&node| {
-                let alp = lp_arena.take(node);
-                let alp = self.pushdown(alp, state, lp_arena, expr_arena)?;
-                lp_arena.replace(node, alp);
-                Ok(node)
-            })
-            .collect::<PolarsResult<Vec<_>>>()?;
-        Ok(lp.with_exprs_and_input(exprs, new_inputs))
+#[cfg(feature = "streaming")]
+pub fn set_estimated_row_counts(
+    root: Node,
+    lp_arena: &mut Arena<ALogicalPlan>,
+    expr_arena: &Arena<AExpr>,
+    mut _filter_count: usize,
+) -> (Option<usize>, usize, usize) {
+    use ALogicalPlan::*;
+
+    fn apply_slice(out: &mut (Option<usize>, usize, usize), slice: Option<(i64, usize)>) {
+        if let Some((_, len)) = slice {
+            out.0 = out.0.map(|known_size| std::cmp::min(len, known_size));
+            out.1 = std::cmp::min(len, out.1);
+        }
     }
 
-    fn pushdown(
-        &self,
-        lp: ALogicalPlan,
-        state: Option<State>,
-        lp_arena: &mut Arena<ALogicalPlan>,
-        expr_arena: &mut Arena<AExpr>,
-    ) -> PolarsResult<ALogicalPlan> {
-        use ALogicalPlan::*;
-
-        match (lp, state) {
-            (AnonymousScan {
-                function,
-                file_info,
-                output_schema,
-                predicate,
-                mut options,
-            },
-                // TODO! we currently skip slice pushdown if there is a predicate.
-                // we can modify the readers to only limit after predicates have been applied
-                Some(state)) if state.offset == 0 && predicate.is_none() => {
-                options.n_rows = Some(state.len as usize);
-                let lp = AnonymousScan {
-                    function,
-                    file_info,
-                    output_schema,
-                    predicate,
-                    options,
-                };
-
-                Ok(lp)
-            },
-            #[cfg(feature = "python")]
-            (PythonScan {
-                mut options,
-                predicate,
-            },
-            // TODO! we currently skip slice pushdown if there is a predicate.
-            // we can modify the readers to only limit after predicates have been applied
-                Some(state)) if state.offset == 0 && predicate.is_none() => {
-                options.n_rows = Some(state.len as usize);
-                let lp = PythonScan {
-                    options,
-                    predicate
-                };
-                Ok(lp)
-            }
-
-            #[cfg(feature = "parquet")]
-            (ParquetScan {
-                path,
-                file_info,
-                output_schema,
-                predicate,
-                mut options,
-                cloud_options,
-
-            },
-                // TODO! we currently skip slice pushdown if there is a predicate.
-                // we can modify the readers to only limit after predicates have been applied
-                Some(state)) if state.offset == 0 && predicate.is_none() => {
-                options.n_rows = Some(state.len as usize);
-                let lp = ParquetScan {
-                    path,
-                    file_info,
-                    output_schema,
-                    predicate,
-                    options,
-                    cloud_options,
-                };
-
-                Ok(lp)
-            },
-            #[cfg(feature = "ipc")]
-            (IpcScan {path,
-            file_info,
-                output_schema,
-                predicate,
-                mut options
-            }, Some(state)) if state.offset == 0 && predicate.is_none() => {
-                options.n_rows = Some(state.len as usize);
-                let lp = IpcScan {
-                    path,
-                    file_info,
-                    output_schema,
-                    predicate,
-                    options
-                };
-
-                Ok(lp)
-
-            }
-
-            #[cfg(feature = "csv")]
-            (CsvScan {
-                path,
-                file_info,
-                output_schema,
+    match lp_arena.get(root) {
+        Selection { predicate, input } => {
+            _filter_count += expr_arena
+                .iter(*predicate)
+                .filter(|(_, ae)| matches!(ae, AExpr::BinaryExpr { .. }))
+                .count()
+                + 1;
+            set_estimated_row_counts(*input, lp_arena, expr_arena, _filter_count)
+        }
+        Slice { input, len, .. } => {
+            let len = *len as usize;
+            let mut out = set_estimated_row_counts(*input, lp_arena, expr_arena, _filter_count);
+            apply_slice(&mut out, Some((0, len)));
+            out
+        }
+        Union { .. } => {
+            if let Union {
+                inputs,
                 mut options,
-                predicate,
-            }, Some(state)) if state.offset >= 0 && predicate.is_none() => {
-                options.skip_rows += state.offset as usize;
-                options.n_rows = Some(state.len as usize);
-
-                let lp = CsvScan {
-                    path,
-                    file_info,
-                    output_schema,
-                    options,
-                    predicate,
-                };
-                Ok(lp)
+            } = lp_arena.take(root)
+            {
+                let mut sum_output = (None, 0);
+                for input in &inputs {
+                    let mut out = set_estimated_row_counts(*input, lp_arena, expr_arena, 0);
+                    if let Some((_offset, len)) = options.slice {
+                        apply_slice(&mut out, Some((0, len)))
+                    }
+                    // todo! deal with known as well
+                    let out = estimate_sizes(out.0, out.1, out.2);
+                    sum_output.1 += out.1;
+                }
+                options.rows = sum_output;
+                lp_arena.replace(root, Union { inputs, options });
+                (sum_output.0, sum_output.1, 0)
+            } else {
+                unreachable!()
             }
-
-            (Union {inputs, mut options }, Some(state)) => {
-                options.slice = Some((state.offset, state.len as usize));
-                Ok(Union {inputs, options})
-            },
-            (Join {
+        }
+        Join { .. } => {
+            if let Join {
                 input_left,
                 input_right,
+                mut options,
                 schema,
                 left_on,
                 right_on,
-                mut options
-            }, Some(state)) if !self.streaming => {
-                // first restart optimization in both inputs and get the updated LP
-                let lp_left = lp_arena.take(input_left);
-                let lp_left = self.pushdown(lp_left, None, lp_arena, expr_arena)?;
-                let input_left = lp_arena.add(lp_left);
-
-                let lp_right = lp_arena.take(input_right);
-                let lp_right = self.pushdown(lp_right, None, lp_arena, expr_arena)?;
-                let input_right = lp_arena.add(lp_right);
-
-                // then assign the slice state to the join operation
-
-                options.args.slice = Some((state.offset, state.len as usize));
-
-                Ok(Join {
-                    input_left,
-                    input_right,
-                    schema,
-                    left_on,
-                    right_on,
-                    options
-                })
-            }
-            (Aggregate { input, keys, aggs, schema, apply, maintain_order, mut options }, Some(state)) => {
-                // first restart optimization in inputs and get the updated LP
-                let input_lp = lp_arena.take(input);
-                let input_lp = self.pushdown(input_lp, None, lp_arena, expr_arena)?;
-                let input= lp_arena.add(input_lp);
-
-                options.slice = Some((state.offset, state.len as usize));
-
-                Ok(Aggregate {
-                    input,
-                    keys,
-                    aggs,
-                    schema,
-                    apply,
-                    maintain_order,
-                    options
-                })
-            }
-            (Distinct {input, mut options}, Some(state)) => {
-                // first restart optimization in inputs and get the updated LP
-                let input_lp = lp_arena.take(input);
-                let input_lp = self.pushdown(input_lp, None, lp_arena, expr_arena)?;
-                let input= lp_arena.add(input_lp);
-                options.slice = Some((state.offset, state.len as usize));
-                Ok(Distinct {
-                    input,
-                    options,
-                })
-            }
-            (Sort {input, by_column, mut args}, Some(state)) => {
-                // first restart optimization in inputs and get the updated LP
-                let input_lp = lp_arena.take(input);
-                let input_lp = self.pushdown(input_lp, None, lp_arena, expr_arena)?;
-                let input= lp_arena.add(input_lp);
-
-                args.slice = Some((state.offset, state.len as usize));
-                Ok(Sort {
-                    input,
-                    by_column,
-                    args
-                })
-            }
-            (Slice {
-                input,
-                offset,
-                len
-            }, Some(previous_state)) => {
-                let alp = lp_arena.take(input);
-                let state = Some(State {
-                    offset,
-                    len
-                });
-                let lp = self.pushdown(alp, state, lp_arena, expr_arena)?;
-                let input = lp_arena.add(lp);
-                Ok(Slice {
-                    input,
-                    offset: previous_state.offset,
-                    len: previous_state.len
-                })
-            }
-            (Slice {
-                input,
-                offset,
-                len
-            }, None) => {
-                let alp = lp_arena.take(input);
-                let state = Some(State {
-                    offset,
-                    len
-                });
-                self.pushdown(alp, state, lp_arena, expr_arena)
-            }
-            // [Do not pushdown] boundary
-            // here we do not pushdown.
-            // we reset the state and then start the optimization again
-            m @ (Selection { .. }, _)
-            // let's be conservative. projections may do aggregations and a pushed down slice
-            // will lead to incorrect aggregations
-            | m @ (LocalProjection {..},_)
-            // other blocking nodes
-            | m @ (DataFrameScan {..}, _)
-            | m @ (Sort {..}, _)
-            | m @ (MapFunction {function: FunctionNode::Explode {..}, ..}, _)
-            | m @ (MapFunction {function: FunctionNode::Melt {..}, ..}, _)
-            | m @ (Cache {..}, _)
-            | m @ (Distinct {..}, _)
-            | m @ (HStack {..},_)
-            | m @ (Aggregate{..},_)
-            // blocking in streaming
-            | m @ (Join{..},_)
-            => {
-                let (lp, state) = m;
-                self.no_pushdown_restart_opt(lp, state, lp_arena, expr_arena)
-            }
-            // [Pushdown]
-            (MapFunction {input, function}, _) if function.allow_predicate_pd() => {
-                let lp = MapFunction {input, function};
-                self.pushdown_and_continue(lp, state, lp_arena, expr_arena)
-            },
-            // [NO Pushdown]
-            m @ (MapFunction {..}, _) => {
-                let (lp, state) = m;
-                self.no_pushdown_restart_opt(lp, state, lp_arena, expr_arena)
-            }
-            // [Pushdown]
-            // these nodes will be pushed down.
-             // State is None, we can continue
-             m @(Projection{..}, None)
-            => {
-                let (lp, state) = m;
-                self.pushdown_and_continue(lp, state, lp_arena, expr_arena)
+            } = lp_arena.take(root)
+            {
+                let (known_size, estimated_size, filter_count_left) =
+                    set_estimated_row_counts(input_left, lp_arena, expr_arena, 0);
+                options.rows_left = estimate_sizes(known_size, estimated_size, filter_count_left);
+                let (known_size, estimated_size, filter_count_right) =
+                    set_estimated_row_counts(input_right, lp_arena, expr_arena, 0);
+                options.rows_right = estimate_sizes(known_size, estimated_size, filter_count_right);
+
+                let mut out = match options.args.how {
+                    JoinType::Left => {
+                        let (known_size, estimated_size) = options.rows_left;
+                        (known_size, estimated_size, filter_count_left)
+                    }
+                    JoinType::Cross | JoinType::Outer => {
+                        let (known_size_left, estimated_size_left) = options.rows_left;
+                        let (known_size_right, estimated_size_right) = options.rows_right;
+                        match (known_size_left, known_size_right) {
+                            (Some(l), Some(r)) => {
+                                (Some(l * r), estimated_size_left, estimated_size_right)
+                            }
+                            _ => (None, estimated_size_left * estimated_size_right, 0),
+                        }
+                    }
+                    _ => {
+                        let (known_size_left, estimated_size_left) = options.rows_left;
+                        let (known_size_right, estimated_size_right) = options.rows_right;
+                        if estimated_size_left > estimated_size_right {
+                            (known_size_left, estimated_size_left, 0)
+                        } else {
+                            (known_size_right, estimated_size_right, 0)
+                        }
+                    }
+                };
+                apply_slice(&mut out, options.args.slice);
+                lp_arena.replace(
+                    root,
+                    Join {
+                        input_left,
+                        input_right,
+                        options,
+                        schema,
+                        left_on,
+                        right_on,
+                    },
+                );
+                out
+            } else {
+                unreachable!()
             }
-            // there is state, inspect the projection to determine how to deal with it
-            (Projection {input, expr, schema}, Some(_)) => {
-                // The slice operation may only pass on simple projections. col("foo").alias("bar")
-                if expr.iter().all(|root|  {
-                    aexpr_is_elementwise(*root, expr_arena)
-                }) {
-                    let lp = Projection {input, expr, schema};
-                    self.pushdown_and_continue(lp, state, lp_arena, expr_arena)
-                }
-                // don't push down slice, but restart optimization
-                else {
-                    let lp = Projection {input, expr, schema};
-                    self.no_pushdown_restart_opt(lp, state, lp_arena, expr_arena)
+        }
+        DataFrameScan { df, .. } => {
+            let len = df.height();
+            (Some(len), len, _filter_count)
+        }
+        Scan { file_info, .. } => {
+            let (known_size, estimated_size) = file_info.row_estimation;
+            (known_size, estimated_size, _filter_count)
+        }
+        #[cfg(feature = "python")]
+        PythonScan { .. } => {
+            // TODO! get row estimation.
+            (None, usize::MAX, _filter_count)
+        }
+        AnonymousScan { options, .. } => {
+            let size = options.n_rows;
+            (size, size.unwrap_or(usize::MAX), _filter_count)
+        }
+        lp => {
+            let input = lp.get_input().unwrap();
+            set_estimated_row_counts(input, lp_arena, expr_arena, _filter_count)
+        }
+    }
+}
+
+pub(crate) fn det_join_schema(
+    schema_left: &SchemaRef,
+    schema_right: &SchemaRef,
+    left_on: &[Expr],
+    right_on: &[Expr],
+    options: &JoinOptions,
+) -> PolarsResult<SchemaRef> {
+    match options.args.how {
+        // semi and anti joins are just filtering operations
+        // the schema will never change.
+        #[cfg(feature = "semi_anti_join")]
+        JoinType::Semi | JoinType::Anti => Ok(schema_left.clone()),
+        _ => {
+            // column names of left table
+            let mut names: PlHashSet<&str> =
+                PlHashSet::with_capacity(schema_left.len() + schema_right.len());
+            let mut new_schema = Schema::with_capacity(schema_left.len() + schema_right.len());
+
+            for (name, dtype) in schema_left.iter() {
+                names.insert(name.as_str());
+                new_schema.with_column(name.clone(), dtype.clone());
+            }
+
+            // make sure that expression are assigned to the schema
+            // an expression can have an alias, and change a dtype.
+            // we only do this for the left hand side as the right hand side
+            // is dropped.
+            let mut arena = Arena::with_capacity(8);
+            for e in left_on {
+                let field = e.to_field_amortized(schema_left, Context::Default, &mut arena)?;
+                new_schema.with_column(field.name, field.dtype);
+                arena.clear();
+            }
+            // except in asof joins. Asof joins are not equi-joins
+            // so the columns that are joined on, may have different
+            // values so if the right has a different name, it is added to the schema
+            #[cfg(feature = "asof_join")]
+            if let JoinType::AsOf(_) = &options.args.how {
+                for (left_on, right_on) in left_on.iter().zip(right_on) {
+                    let field_left =
+                        left_on.to_field_amortized(schema_left, Context::Default, &mut arena)?;
+                    let field_right =
+                        right_on.to_field_amortized(schema_right, Context::Default, &mut arena)?;
+                    if field_left.name != field_right.name {
+                        if schema_left.contains(&field_right.name) {
+                            use polars_core::frame::hash_join::_join_suffix_name;
+                            new_schema.with_column(
+                                _join_suffix_name(&field_right.name, options.args.suffix()).into(),
+                                field_right.dtype,
+                            );
+                        } else {
+                            new_schema.with_column(field_right.name, field_right.dtype);
+                        }
+                    }
                 }
             }
-            (catch_all, state) => {
-                self.no_pushdown_finish_opt(catch_all, state, lp_arena)
+
+            let mut right_names: PlHashSet<_> = PlHashSet::with_capacity(right_on.len());
+            for e in right_on {
+                let field = e.to_field_amortized(schema_right, Context::Default, &mut arena)?;
+                right_names.insert(field.name);
+            }
+
+            for (name, dtype) in schema_right.iter() {
+                if !right_names.contains(name.as_str()) {
+                    if names.contains(name.as_str()) {
+                        #[cfg(feature = "asof_join")]
+                        if let JoinType::AsOf(asof_options) = &options.args.how {
+                            if let (Some(left_by), Some(right_by)) =
+                                (&asof_options.left_by, &asof_options.right_by)
+                            {
+                                {
+                                    // Do not add suffix. The column of the left table will be used
+                                    if left_by.contains(name) && right_by.contains(name) {
+                                        continue;
+                                    }
+                                }
+                            }
+                        }
+
+                        let new_name = format_smartstring!("{}{}", name, options.args.suffix());
+                        new_schema.with_column(new_name, dtype.clone());
+                    } else {
+                        new_schema.with_column(name.clone(), dtype.clone());
+                    }
+                }
             }
 
+            Ok(Arc::new(new_schema))
         }
     }
-
-    pub fn optimize(
-        &self,
-        logical_plan: ALogicalPlan,
-        lp_arena: &mut Arena<ALogicalPlan>,
-        expr_arena: &mut Arena<AExpr>,
-    ) -> PolarsResult<ALogicalPlan> {
-        self.pushdown(logical_plan, None, lp_arena, expr_arena)
-    }
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/stack_opt.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/stack_opt.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/type_coercion/binary.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/type_coercion/binary.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/optimizer/type_coercion/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/optimizer/type_coercion/mod.rs`

 * *Files 2% similar despite different names*

```diff
@@ -511,31 +511,32 @@
     {
         None
     } else {
         Some(())
     }
 }
 
-#[cfg(test)]
-#[cfg(feature = "dtype-categorical")]
-mod test {
-    use polars_core::prelude::*;
+// TODO: Fix this test and re-enable it (currently does not compile)
+// #[cfg(test)]
+// #[cfg(feature = "dtype-categorical")]
+// mod test {
+//     use polars_core::prelude::*;
 
-    use super::*;
-    use crate::prelude::*;
+//     use super::*;
+//     use crate::prelude::*;
 
-    #[test]
-    fn test_categorical_utf8() {
-        let mut rules: Vec<Box<dyn OptimizationRule>> = vec![Box::new(TypeCoercionRule {})];
-        let schema = Schema::from_iter([Field::new("fruits", DataType::Categorical(None))]);
+//     #[test]
+//     fn test_categorical_utf8() {
+//         let mut rules: Vec<Box<dyn OptimizationRule>> = vec![Box::new(TypeCoercionRule {})];
+//         let schema = Schema::from_iter([Field::new("fruits", DataType::Categorical(None))]);
 
-        let expr = col("fruits").eq(lit("somestr"));
-        let out = optimize_expr(expr.clone(), schema.clone(), &mut rules);
-        // we test that the fruits column is not casted to utf8 for the comparison
-        assert_eq!(out, expr);
+//         let expr = col("fruits").eq(lit("somestr"));
+//         let out = optimize_expr(expr.clone(), schema.clone(), &mut rules);
+//         // we test that the fruits column is not casted to utf8 for the comparison
+//         assert_eq!(out, expr);
 
-        let expr = col("fruits") + (lit("somestr"));
-        let out = optimize_expr(expr, schema, &mut rules);
-        let expected = col("fruits").cast(DataType::Utf8) + lit("somestr");
-        assert_eq!(out, expected);
-    }
-}
+//         let expr = col("fruits") + (lit("somestr"));
+//         let out = optimize_expr(expr, schema, &mut rules);
+//         let expected = col("fruits").cast(DataType::Utf8) + lit("somestr");
+//         assert_eq!(out, expected);
+//     }
+// }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/options.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/options.rs`

 * *Files 11% similar despite different names*

```diff
@@ -25,38 +25,26 @@
 pub struct CsvParserOptions {
     pub delimiter: u8,
     pub comment_char: Option<u8>,
     pub quote_char: Option<u8>,
     pub eol_char: u8,
     pub has_header: bool,
     pub skip_rows: usize,
-    pub n_rows: Option<usize>,
-    pub with_columns: Option<Arc<Vec<String>>>,
     pub low_memory: bool,
     pub ignore_errors: bool,
-    pub cache: bool,
     pub null_values: Option<NullValues>,
-    pub rechunk: bool,
     pub encoding: CsvEncoding,
-    pub row_count: Option<RowCount>,
     pub try_parse_dates: bool,
-    pub file_counter: FileCount,
 }
 
 #[cfg(feature = "parquet")]
 #[derive(Clone, Debug, PartialEq, Eq)]
 #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
 pub struct ParquetOptions {
-    pub n_rows: Option<usize>,
-    pub with_columns: Option<Arc<Vec<String>>>,
-    pub cache: bool,
     pub parallel: polars_io::parquet::ParallelStrategy,
-    pub rechunk: bool,
-    pub row_count: Option<RowCount>,
-    pub file_counter: FileCount,
     pub low_memory: bool,
     pub use_statistics: bool,
 }
 
 #[cfg(feature = "parquet")]
 #[derive(Copy, Clone, Debug, PartialEq, Eq, Default)]
 #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
@@ -79,49 +67,30 @@
 pub struct IpcWriterOptions {
     /// Data page compression
     pub compression: Option<IpcCompression>,
     /// maintain the order the data was processed
     pub maintain_order: bool,
 }
 
-#[derive(Clone, Debug)]
+#[derive(Clone, Debug, PartialEq)]
 #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
 pub struct IpcScanOptions {
-    pub n_rows: Option<usize>,
-    pub with_columns: Option<Arc<Vec<String>>>,
-    pub cache: bool,
-    pub row_count: Option<RowCount>,
-    pub rechunk: bool,
     pub memmap: bool,
 }
 
 #[derive(Clone, Debug, PartialEq, Eq)]
 #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
-pub struct IpcScanOptionsInner {
+/// Generic options for all file types
+pub struct FileScanOptions {
     pub n_rows: Option<usize>,
     pub with_columns: Option<Arc<Vec<String>>>,
     pub cache: bool,
     pub row_count: Option<RowCount>,
     pub rechunk: bool,
     pub file_counter: FileCount,
-    pub memmap: bool,
-}
-
-impl From<IpcScanOptions> for IpcScanOptionsInner {
-    fn from(options: IpcScanOptions) -> Self {
-        Self {
-            n_rows: options.n_rows,
-            with_columns: options.with_columns,
-            cache: options.cache,
-            row_count: options.row_count,
-            rechunk: options.rechunk,
-            file_counter: Default::default(),
-            memmap: options.memmap,
-        }
-    }
 }
 
 #[derive(Clone, Debug, Copy, Default, Eq, PartialEq)]
 #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
 pub struct UnionOptions {
     pub slice: Option<(i64, usize)>,
     pub parallel: bool,
@@ -281,14 +250,15 @@
 
 #[derive(Clone, PartialEq, Eq, Debug, Default)]
 #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
 pub struct SortArguments {
     pub descending: Vec<bool>,
     pub nulls_last: bool,
     pub slice: Option<(i64, usize)>,
+    pub maintain_order: bool,
 }
 
 #[derive(Clone, PartialEq, Eq, Debug, Default)]
 #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
 #[cfg(feature = "python")]
 pub struct PythonOptions {
     pub scan_fn: Option<PythonFunction>,
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/projection.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/projection.rs`

 * *Files 5% similar despite different names*

```diff
@@ -92,19 +92,20 @@
 /// This function takes an expression containing a regex in `col("..")` and expands the columns
 /// that are selected by that regex in `result`.
 fn expand_regex(
     expr: &Expr,
     result: &mut Vec<Expr>,
     schema: &Schema,
     pattern: &str,
+    exclude: &PlHashSet<Arc<str>>,
 ) -> PolarsResult<()> {
     let re =
         regex::Regex::new(pattern).map_err(|e| polars_err!(ComputeError: "invalid regex {}", e))?;
     for name in schema.iter_names() {
-        if re.is_match(name) {
+        if re.is_match(name) && !exclude.contains(name.as_str()) {
             let mut new_expr = expr.clone();
 
             new_expr.mutate().apply(|e| match &e {
                 Expr::Column(pat) if pat.as_ref() == pattern => {
                     *e = Expr::Column(Arc::from(name.as_str()));
                     true
                 }
@@ -121,27 +122,44 @@
 pub(crate) fn is_regex_projection(name: &str) -> bool {
     name.starts_with('^') && name.ends_with('$')
 }
 
 #[cfg(feature = "regex")]
 /// This function searches for a regex expression in `col("..")` and expands the columns
 /// that are selected by that regex in `result`. The regex should start with `^` and end with `$`.
-fn replace_regex(expr: &Expr, result: &mut Vec<Expr>, schema: &Schema) -> PolarsResult<()> {
+fn replace_regex(
+    expr: &Expr,
+    result: &mut Vec<Expr>,
+    schema: &Schema,
+    exclude: &PlHashSet<Arc<str>>,
+) -> PolarsResult<()> {
     let roots = expr_to_leaf_column_names(expr);
     let mut regex = None;
     for name in &roots {
         if is_regex_projection(name) {
             match regex {
                 None => {
                     regex = Some(name);
-                    expand_regex(expr, result, schema, name)?
+                    if exclude.is_empty() {
+                        expand_regex(expr, result, schema, name, exclude)?
+                    } else {
+                        // iterate until we find the Exclude node
+                        // we remove that node from the expression
+                        for e in expr.into_iter() {
+                            if let Expr::Exclude(e, _) = e {
+                                expand_regex(e, result, schema, name, exclude)?;
+                                break;
+                            }
+                        }
+                    }
                 }
                 Some(r) => {
-                    assert_eq!(
-                        r, name,
+                    polars_ensure!(
+                        r == name,
+                        ComputeError:
                         "an expression is not allowed to have different regexes"
                     )
                 }
             }
         }
     }
     if regex.is_none() {
@@ -234,66 +252,73 @@
 
 // schema is not used if regex not activated
 #[allow(unused_variables)]
 fn prepare_excluded(
     expr: &Expr,
     schema: &Schema,
     keys: &[Expr],
+    has_exclude: bool,
 ) -> PolarsResult<PlHashSet<Arc<str>>> {
     let mut exclude = PlHashSet::new();
-    for e in expr {
-        if let Expr::Exclude(_, to_exclude) = e {
-            #[cfg(feature = "regex")]
-            {
-                // instead of matching the names for regex patterns and
-                // expanding the matches in the schema we reuse the
-                // `replace_regex` func; this is a bit slower but DRY.
-                let mut buf = vec![];
-                for to_exclude_single in to_exclude {
-                    match to_exclude_single {
-                        Excluded::Name(name) => {
-                            let e = Expr::Column(name.clone());
-                            replace_regex(&e, &mut buf, schema)?;
-                            // we cannot loop because of bchck
-                            while let Some(col) = buf.pop() {
-                                if let Expr::Column(name) = col {
-                                    exclude.insert(name);
+
+    // explicit exclude branch
+    if has_exclude {
+        for e in expr {
+            if let Expr::Exclude(_, to_exclude) = e {
+                #[cfg(feature = "regex")]
+                {
+                    // instead of matching the names for regex patterns and
+                    // expanding the matches in the schema we reuse the
+                    // `replace_regex` func; this is a bit slower but DRY.
+                    let mut buf = vec![];
+                    for to_exclude_single in to_exclude {
+                        match to_exclude_single {
+                            Excluded::Name(name) => {
+                                let e = Expr::Column(name.clone());
+                                replace_regex(&e, &mut buf, schema, &Default::default())?;
+                                // we cannot loop because of bchck
+                                while let Some(col) = buf.pop() {
+                                    if let Expr::Column(name) = col {
+                                        exclude.insert(name);
+                                    }
                                 }
                             }
-                        }
-                        Excluded::Dtype(dt) => {
-                            for fld in schema.iter_fields() {
-                                if dtypes_match(fld.data_type(), dt) {
-                                    exclude.insert(Arc::from(fld.name().as_ref()));
+                            Excluded::Dtype(dt) => {
+                                for fld in schema.iter_fields() {
+                                    if dtypes_match(fld.data_type(), dt) {
+                                        exclude.insert(Arc::from(fld.name().as_ref()));
+                                    }
                                 }
                             }
                         }
                     }
                 }
-            }
 
-            #[cfg(not(feature = "regex"))]
-            {
-                for to_exclude_single in to_exclude {
-                    match to_exclude_single {
-                        Excluded::Name(name) => {
-                            exclude.insert(name.clone());
-                        }
-                        Excluded::Dtype(dt) => {
-                            for (name, dtype) in schema.iter() {
-                                if matches!(dtype, dt) {
-                                    exclude.insert(Arc::from(name.as_str()));
+                #[cfg(not(feature = "regex"))]
+                {
+                    for to_exclude_single in to_exclude {
+                        match to_exclude_single {
+                            Excluded::Name(name) => {
+                                exclude.insert(name.clone());
+                            }
+                            Excluded::Dtype(dt) => {
+                                for (name, dtype) in schema.iter() {
+                                    if matches!(dtype, dt) {
+                                        exclude.insert(Arc::from(name.as_str()));
+                                    }
                                 }
                             }
                         }
                     }
                 }
             }
         }
     }
+
+    // exclude groupby keys
     for mut expr in keys.iter() {
         // Allow a number of aliases of a column expression, still exclude column from aggregation
         loop {
             match expr {
                 Expr::Column(name) => {
                     exclude.insert(name.clone());
                     break;
@@ -350,44 +375,48 @@
 #[derive(Copy, Clone)]
 struct ExpansionFlags {
     multiple_columns: bool,
     has_nth: bool,
     has_wildcard: bool,
     replace_fill_null_type: bool,
     has_selector: bool,
+    has_exclude: bool,
 }
 
 fn find_flags(expr: &Expr) -> ExpansionFlags {
     let mut multiple_columns = false;
     let mut has_nth = false;
     let mut has_wildcard = false;
     let mut replace_fill_null_type = false;
     let mut has_selector = false;
+    let mut has_exclude = false;
 
     // do a single pass and collect all flags at once.
     // supertypes/modification that can be done in place are also don e in that pass
     for expr in expr {
         match expr {
             Expr::Columns(_) | Expr::DtypeColumn(_) => multiple_columns = true,
             Expr::Nth(_) => has_nth = true,
             Expr::Wildcard => has_wildcard = true,
             Expr::Selector(_) => has_selector = true,
             Expr::Function {
                 function: FunctionExpr::FillNull { .. },
                 ..
             } => replace_fill_null_type = true,
+            Expr::Exclude(_, _) => has_exclude = true,
             _ => {}
         }
     }
     ExpansionFlags {
         multiple_columns,
         has_nth,
         has_wildcard,
         replace_fill_null_type,
         has_selector,
+        has_exclude,
     }
 }
 
 /// In case of single col(*) -> do nothing, no selection is the same as select all
 /// In other cases replace the wildcard with an expression with all columns
 pub(crate) fn rewrite_projections(
     exprs: Vec<Expr>,
@@ -458,34 +487,36 @@
             .into_iter()
             .find(|e| matches!(e, Expr::Columns(_) | Expr::DtypeColumn(_)))
         {
             match &e {
                 Expr::Columns(names) => expand_columns(&expr, result, names)?,
                 Expr::DtypeColumn(dtypes) => {
                     // keep track of column excluded from the dtypes
-                    let exclude = prepare_excluded(&expr, schema, keys)?;
+                    let exclude = prepare_excluded(&expr, schema, keys, flags.has_exclude)?;
                     expand_dtypes(&expr, result, schema, dtypes, &exclude)?
                 }
                 _ => {}
             }
         }
     }
     // has multiple column names due to wildcards
     else if flags.has_wildcard {
         // keep track of column excluded from the wildcard
-        let exclude = prepare_excluded(&expr, schema, keys)?;
+        let exclude = prepare_excluded(&expr, schema, keys, flags.has_exclude)?;
         // this path prepares the wildcard as input for the Function Expr
         replace_wildcard(&expr, result, &exclude, schema)?;
     }
     // can have multiple column names due to a regex
     else {
         #[allow(clippy::collapsible_else_if)]
         #[cfg(feature = "regex")]
         {
-            replace_regex(&expr, result, schema)?
+            // keep track of column excluded from the dtypes
+            let exclude = prepare_excluded(&expr, schema, keys, flags.has_exclude)?;
+            replace_regex(&expr, result, schema, &exclude)?;
         }
         #[cfg(not(feature = "regex"))]
         {
             let expr = rewrite_special_aliases(expr)?;
             result.push(expr)
         }
     }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/pyarrow.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/pyarrow.rs`

 * *Files 6% similar despite different names*

```diff
@@ -141,14 +141,15 @@
             input,
             ..
         } => {
             let input = input.first().unwrap();
             let input = predicate_to_pa(*input, expr_arena, args)?;
             Some(format!("~({input}).is_null()"))
         }
+        #[cfg(feature = "is_in")]
         AExpr::Function {
             function: FunctionExpr::Boolean(BooleanFunction::IsIn),
             input,
             ..
         } => {
             let col = predicate_to_pa(*input.get(0)?, expr_arena, args)?;
             let mut args = args;
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/tree_format.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/tree_format.rs`

 * *Files 2% similar despite different names*

```diff
@@ -182,25 +182,24 @@
     }
 }
 
 #[cfg(test)]
 mod test {
     use super::*;
     use crate::logical_plan::visitor::TreeWalker;
-    use crate::prelude::*;
 
     #[test]
     fn test_tree_fmt_visit() {
         let e = (col("foo") * lit(2) + lit(3) + lit(43)).sum();
         let mut arena = Default::default();
         let node = to_aexpr(e, &mut arena);
 
         let mut visitor = TreeFmtVisitor::new();
 
-        AexprNode::with_context(node, &mut arena, |ae_node| ae_node.visit(&mut visitor));
+        AexprNode::with_context(node, &mut arena, |ae_node| ae_node.visit(&mut visitor)).unwrap();
         let expected: &[&[&str]] = &[
             &["sum"],
             &["binary: +"],
             &["lit(43)", "binary: +"],
             &["", "lit(3)", "binary: *"],
             &["", "", "lit(2)", "col(foo)"],
         ];
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/visitor/expr.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/visitor/expr.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/visitor/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/visitor/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/logical_plan/visitor/visitors.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/logical_plan/visitor/visitors.rs`

 * *Files 2% similar despite different names*

```diff
@@ -81,14 +81,15 @@
     use crate::prelude::*;
 
     #[test]
     fn test_visitor() {
         struct VisitPath {
             pre_idx: usize,
             pre_stack: Vec<usize>,
+            #[allow(dead_code)]
             post_idx: usize,
             post_stack: Vec<usize>,
         }
 
         impl VisitPath {
             fn new() -> Self {
                 Self {
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/prelude.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/prelude.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-plan/src/utils.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-plan/src/utils.rs`

 * *Files 2% similar despite different names*

```diff
@@ -66,22 +66,20 @@
             [None] => self[0] = Some(value),
             _ => panic!("cannot push more than 1 node"),
         }
     }
 }
 
 pub(crate) fn is_scan(plan: &ALogicalPlan) -> bool {
-    match plan {
-        #[cfg(feature = "csv")]
-        ALogicalPlan::CsvScan { .. } => true,
-        ALogicalPlan::DataFrameScan { .. } => true,
-        #[cfg(feature = "parquet")]
-        ALogicalPlan::ParquetScan { .. } => true,
-        _ => false,
-    }
+    matches!(
+        plan,
+        ALogicalPlan::Scan { .. }
+            | ALogicalPlan::DataFrameScan { .. }
+            | ALogicalPlan::AnonymousScan { .. }
+    )
 }
 
 impl PushNode for &mut [Option<Node>] {
     fn push_node(&mut self, value: Node) {
         if self[0].is_some() {
             self[1] = Some(value)
         } else {
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/Cargo.toml` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/Cargo.toml`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/LICENSE` & `polars_u64_idx-0.18.7/local_dependencies/polars-core/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/avro/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/avro/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/avro/read.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/avro/read.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/avro/write.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/avro/write.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/cloud/adaptors.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/cloud/adaptors.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/cloud/glob.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/cloud/glob.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/cloud/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/cloud/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/buffer.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/buffer.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/parser.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/parser.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/read.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/read.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/read_impl/batched_mmap.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/read_impl/batched_mmap.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/read_impl/batched_read.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/read_impl/batched_read.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/read_impl/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/read_impl/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/splitfields.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/splitfields.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/utils.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/utils.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/write.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/write.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/csv/write_impl.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/csv/write_impl.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/ipc/ipc_file.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/ipc/ipc_file.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/ipc/ipc_stream.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/ipc/ipc_stream.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/ipc/mmap.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/ipc/mmap.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/ipc/write.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/ipc/write.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/ipc/write_async.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/ipc/write_async.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/json/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/json/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/lib.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/lib.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/mmap.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/mmap.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/ndjson/buffer.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/ndjson/buffer.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/ndjson/core.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/ndjson/core.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/parquet/async_impl.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/parquet/async_impl.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/parquet/mmap.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/parquet/mmap.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/parquet/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/parquet/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/parquet/predicates.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/parquet/predicates.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/parquet/read.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/parquet/read.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/parquet/read_impl.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/parquet/read_impl.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/parquet/write.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/parquet/write.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/partition.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/partition.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/predicates.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/predicates.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/prelude.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/prelude.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-io/src/utils.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-io/src/utils.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-utils/Cargo.toml` & `polars_u64_idx-0.18.7/local_dependencies/polars-utils/Cargo.toml`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-utils/LICENSE` & `polars_u64_idx-0.18.7/local_dependencies/polars-row/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/arena.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/arena.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/atomic.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/atomic.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/cell.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/cell.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/contention_pool.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/contention_pool.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/functions.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/functions.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/iter/enumerate_idx.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/iter/enumerate_idx.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/macros.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/macros.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/slice.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/slice.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/sort.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/sort.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/sync.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/sync.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/unwrap.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/unwrap.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/vec.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/vec.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-utils/src/wasm.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-utils/src/wasm.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-json/Cargo.toml` & `polars_u64_idx-0.18.7/local_dependencies/polars-json/Cargo.toml`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-json/LICENSE` & `polars_u64_idx-0.18.7/local_dependencies/polars-utils/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-json/src/json/deserialize.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-json/src/json/deserialize.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-json/src/json/infer_schema.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-json/src/json/infer_schema.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-json/src/ndjson/deserialize.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-json/src/ndjson/deserialize.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-json/src/ndjson/file.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-json/src/ndjson/file.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/Cargo.toml` & `polars_u64_idx-0.18.7/local_dependencies/polars/Cargo.toml`

 * *Files 0% similar despite different names*

```diff
@@ -158,14 +158,15 @@
 propagate_nans = ["polars-lazy/propagate_nans"]
 coalesce = ["polars-lazy/coalesce"]
 streaming = ["polars-lazy/streaming"]
 fused = ["polars-ops/fused", "polars-lazy/fused"]
 list_sets = ["polars-lazy/list_sets"]
 list_any_all = ["polars-lazy/list_any_all"]
 cutqcut = ["polars-lazy/cutqcut"]
+rle = ["polars-lazy/rle"]
 
 test = [
   "lazy",
   "rolling_window",
   "rank",
   "round_series",
   "csv",
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/LICENSE` & `polars_u64_idx-0.18.7/local_dependencies/polars-json/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/Makefile` & `polars_u64_idx-0.18.7/local_dependencies/polars/Makefile`

 * *Files 27% similar despite different names*

```diff
@@ -9,38 +9,18 @@
 	dprint fmt
 
 generate_test_files:
 	cargo run -p polars-cli "select * from read_csv('../examples/datasets/foods1.csv')" -o parquet > ../examples/datasets/foods1.parquet
 	cargo run -p polars-cli "select * from read_csv('../examples/datasets/foods1.csv')" -o arrow > ../examples/datasets/foods1.ipc
 
 check:
-	cargo check --all-features \
-		-p polars-core \
-		-p polars-io \
-		-p polars-lazy \
-		-p polars-arrow \
-		-p polars-time \
-		-p polars-error \
-		-p polars-ops \
-		-p polars-sql \
-		-p polars-json
+	cargo check --all-targets --all-features
 
 clippy:
-	cargo clippy --all-features \
-		-p polars-core \
-		-p polars-io \
-		-p polars-lazy \
-		-p polars-arrow \
-		-p polars-utils \
-		-p polars-ops \
-		-p polars-error \
-		-p polars-row \
-		-p polars-time \
-		-p polars-sql \
-		-p polars-json
+	cargo clippy --all-targets --all-features
 
 clippy-default:
 	cargo clippy
 
 test:  ## Run tests
 	cargo test --all-features \
 		-p polars-lazy \
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/src/docs/eager.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/src/docs/eager.rs`

 * *Files 0% similar despite different names*

```diff
@@ -345,15 +345,15 @@
 //! // sort this DataFrame by multiple columns
 //!
 //! // ordering of the columns
 //! let descending = vec![true, false];
 //! // columns to sort by
 //! let by = &["b", "a"];
 //! // do the sort operation
-//! let sorted = df.sort(by, descending)?;
+//! let sorted = df.sort(by, descending, true)?;
 //!
 //! // sorted:
 //!
 //! // 
 //! //  a    b   
 //! //  ---  --- 
 //! //  i64  str 
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/src/docs/lazy.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/src/docs/lazy.rs`

 * *Files 0% similar despite different names*

```diff
@@ -81,15 +81,15 @@
 //! ]?;
 //! // sort this DataFrame by multiple columns
 //!
 //! // ordering of the columns
 //! let descending = vec![true, false];
 //!
 //! let sorted = df.lazy()
-//!     .sort_by_exprs(vec![col("b"), col("a")], descending, false)
+//!     .sort_by_exprs(vec![col("b"), col("a")], descending, false, false)
 //!     .collect()?;
 //!
 //! // sorted:
 //!
 //! // 
 //! //  a    b   
 //! //  ---  --- 
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/src/docs/performance.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/src/docs/performance.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/src/lib.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/src/lib.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/core/date_like.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/core/date_like.rs`

 * *Files 3% similar despite different names*

```diff
@@ -4,23 +4,21 @@
 #[cfg(feature = "dtype-datetime")]
 fn test_agg_list_type() -> PolarsResult<()> {
     let s = Series::new("foo", &[1, 2, 3]);
     let s = s.cast(&DataType::Datetime(TimeUnit::Nanoseconds, None))?;
 
     let l = unsafe { s.agg_list(&GroupsProxy::Idx(vec![(0, vec![0, 1, 2])].into())) };
 
-    match l.dtype() {
+    let result = match l.dtype() {
         DataType::List(inner) => {
-            assert!(matches!(
-                &**inner,
-                DataType::Datetime(TimeUnit::Nanoseconds, None)
-            ))
+            matches!(&**inner, DataType::Datetime(TimeUnit::Nanoseconds, None))
         }
-        _ => assert!(false),
-    }
+        _ => false,
+    };
+    assert!(result);
 
     Ok(())
 }
 
 #[test]
 #[cfg(feature = "dtype-datetime")]
 #[cfg_attr(miri, ignore)]
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/core/groupby.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/core/groupby.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/core/joins.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/core/joins.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/core/list.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/core/list.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/core/pivot.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/core/pivot.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/core/random.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/core/random.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/core/rolling_window.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/core/rolling_window.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/core/series.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/core/series.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/io/csv.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/io/csv.rs`

 * *Files 0% similar despite different names*

```diff
@@ -776,18 +776,20 @@
     assert_eq!(df.dtypes(), &[DataType::Utf8, DataType::Int64,]);
     Ok(())
 }
 
 #[test]
 fn test_whitespace_delimiters() -> PolarsResult<()> {
     let tsv = "\ta\tb\tc\n1\ta1\tb1\tc1\n2\ta2\tb2\tc2\n".to_string();
-    let mut contents = Vec::with_capacity(3);
-    contents.push((tsv.replace('\t', " "), b' '));
-    contents.push((tsv.replace('\t', "-"), b'-'));
-    contents.push((tsv, b'\t'));
+
+    let contents = vec![
+        (tsv.replace('\t', " "), b' '),
+        (tsv.replace('\t', "-"), b'-'),
+        (tsv, b'\t'),
+    ];
 
     for (content, sep) in contents {
         let file = Cursor::new(&content);
         let df = CsvReader::new(file).with_delimiter(sep).finish()?;
 
         assert_eq!(df.shape(), (2, 4));
         assert_eq!(df.get_column_names(), &["", "a", "b", "c"]);
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/io/ipc_stream.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/io/ipc_stream.rs`

 * *Files 2% similar despite different names*

```diff
@@ -117,15 +117,15 @@
                 .with_compression(compression)
                 .finish(&mut df)
                 .expect("ipc writer");
             buf.set_position(0);
 
             let df_read = IpcStreamReader::new(buf)
                 .finish()
-                .expect(&format!("IPC reader: {:?}", compression));
+                .unwrap_or_else(|_| panic!("IPC reader: {:?}", compression));
             assert!(df.frame_equal(&df_read));
         }
     }
 
     #[test]
     fn write_and_read_ipc_stream_empty_series() {
         let mut buf: Cursor<Vec<u8>> = Cursor::new(Vec::new());
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/io/json.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/io/json.rs`

 * *Files 2% similar despite different names*

```diff
@@ -143,19 +143,15 @@
     let field_int_inner = Field::new("int_inner", DataType::List(Box::new(DataType::Int64)));
     let field_float_inner = Field::new("float_inner", DataType::Float64);
     let field_str_inner = Field::new("str_inner", DataType::List(Box::new(DataType::Utf8)));
 
     let mut schema = Schema::new();
     schema.with_column(
         "struct".into(),
-        DataType::Struct(vec![
-            field_int_inner.clone(),
-            field_float_inner.clone(),
-            field_str_inner.clone(),
-        ]),
+        DataType::Struct(vec![field_int_inner, field_float_inner, field_str_inner]),
     );
     schema.with_column("float".into(), DataType::Float64);
 
     assert_eq!(schema, df.unwrap().schema());
 }
 
 #[test]
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/io/parquet.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/io/parquet.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/joins.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/joins.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/aggregation.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/aggregation.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/cse.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/cse.rs`

 * *Files 16% similar despite different names*

```diff
@@ -1,24 +1,24 @@
 use super::*;
 
 #[test]
+#[cfg(feature = "semi_anti_join")]
 fn test_cse_union_schema_6504() -> PolarsResult<()> {
     use polars_core::df;
     let q1: LazyFrame = df![
         "a" => [1],
         "b" => [2],
     ]?
     .lazy();
     let q2: LazyFrame = df![
         "b" => [1],
     ]?
     .lazy();
 
     let q3 = q2
-        .clone()
         .join(q1.clone(), [col("b")], [col("b")], JoinType::Anti.into())
         .with_column(lit(0).alias("a"))
         .select([col("a"), col("b")]);
 
     let out = concat(
         [q1, q3],
         UnionArgs {
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/expressions/apply.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/expressions/apply.rs`

 * *Files 8% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 use super::*;
 
 #[test]
 #[cfg(feature = "range")]
-fn test_arange_agg() -> PolarsResult<()> {
+fn test_int_range_agg() -> PolarsResult<()> {
     let df = df![
         "x" => [5, 5, 4, 4, 2, 2]
     ]?;
 
     let out = df
         .lazy()
-        .with_columns([arange(lit(0i32), count(), 1).over([col("x")])])
+        .with_columns([int_range(lit(0i32), count(), 1).over([col("x")])])
         .collect()?;
     assert_eq!(
-        Vec::from_iter(out.column("arange")?.i64()?.into_no_null_iter()),
+        Vec::from_iter(out.column("int")?.i64()?.into_no_null_iter()),
         &[0, 1, 0, 1, 0, 1]
     );
 
     Ok(())
 }
 
 #[test]
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/expressions/arity.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/expressions/arity.rs`

 * *Files 2% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+use polars::enable_string_cache;
+
 use super::*;
 
 #[test]
 #[cfg(feature = "unique_counts")]
 fn test_list_broadcast() {
     // simply test if this runs
     df![
@@ -111,14 +113,16 @@
     assert!(res.frame_equal_missing(&exp_df));
 
     Ok(())
 }
 
 #[test]
 fn test_when_then_otherwise_cats() -> PolarsResult<()> {
+    enable_string_cache(true);
+
     let lf = df!["book" => [Some("bookA"),
         None,
         Some("bookB"),
         None,
         Some("bookA"),
         Some("bookC"),
         Some("bookC"),
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/expressions/expand.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/expressions/expand.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/expressions/filter.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/expressions/filter.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/expressions/slice.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/expressions/slice.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/expressions/window.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/expressions/window.rs`

 * *Files 0% similar despite different names*

```diff
@@ -264,15 +264,15 @@
         ])
         .collect()?;
     let expected = Series::new("foo", [None, Some(3), None, Some(-1), Some(-1)]);
     assert!(out.column("foo")?.series_equal_missing(&expected));
 
     // now sorted
     // this will trigger a fast path
-    let df = df.sort(["fruits"], vec![false])?;
+    let df = df.sort(["fruits"], vec![false], false)?;
 
     let out = df
         .clone()
         .lazy()
         .select([(lit(10) + col("A")).alias("foo").over([col("fruits")])])
         .collect()?;
     let expected = Series::new("foo", [13, 14, 11, 12, 15]);
@@ -291,15 +291,14 @@
         ])
         .collect()?;
 
     let expected = Series::new("foo", [8, 9, 11, 12, 15]);
     assert!(out.column("foo")?.series_equal(&expected));
 
     let out = df
-        .clone()
         .lazy()
         .select([
             col("fruits"),
             col("A"),
             col("B"),
             (col("B").shift(1) - col("A"))
                 .alias("foo")
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/functions.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/functions.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/groupby.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/groupby.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/groupby_dynamic.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/groupby_dynamic.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/predicate_queries.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/predicate_queries.rs`

 * *Files 2% similar despite different names*

```diff
@@ -31,15 +31,15 @@
         "b" => ["1", "2", "3"]
     }?;
     let filter = col("a").eq(lit(true));
     let with_true = df.clone().lazy().filter(filter.clone()).collect()?;
     let with_not_true = df
         .clone()
         .lazy()
-        .filter(not(filter.clone()))
+        .filter(not(filter))
         .with_predicate_pushdown(false)
         .with_projection_pushdown(false)
         .collect()?;
     let with_null = df
         .clone()
         .lazy()
         .filter(col("a").is_null())
@@ -50,15 +50,14 @@
     let res = res.vstack(&with_null)?;
     assert!(res.frame_equal_missing(&df));
     Ok(())
 }
 
 fn create_n_filters(col_name: &str, num_filters: usize) -> Vec<Expr> {
     (0..num_filters)
-        .into_iter()
         .map(|i| col(col_name).eq(lit(format!("{}", i))))
         .collect()
 }
 
 fn and_filters(expr: Vec<Expr>) -> Expr {
     expr.into_iter().reduce(polars::prelude::Expr::and).unwrap()
 }
@@ -161,15 +160,15 @@
         "b" => ["b1", "b2"]
     }?;
     let df2 = df! {
         "b" => ["b2", "b3"],
         "c" => ["c2", "c3"]
     }?;
     let df = df1.lazy().outer_join(df2.lazy(), col("b"), col("b"));
-    let out = df.clone().filter(col("a").eq(lit("a1"))).collect()?;
+    let out = df.filter(col("a").eq(lit("a1"))).collect()?;
     let null: Option<&str> = None;
     let expected = df![
         "a" => ["a1"],
         "b" => ["b1"],
         "c" => [null],
     ]?;
     assert!(out.frame_equal_missing(&expected));
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/projection_queries.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/projection_queries.rs`

 * *Files 0% similar despite different names*

```diff
@@ -103,15 +103,15 @@
     let out = df
         .lazy()
         .filter(col("date").gt(lit(1)))
         .select([col("*")])
         .with_columns([col("val").max().alias("max")])
         .with_column(col("max").alias("diff"))
         .with_column((col("val") / col("diff")).alias("output"))
-        .select([all().exclude(&["max", "diff"])])
+        .select([all().exclude(["max", "diff"])])
         .collect()?;
     let expected = df![
         "date" => [2, 3],
         "val" => [2, 3],
         "output" => [0, 1],
     ]?;
     assert!(out.frame_equal(&expected));
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/lazy/queries.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/lazy/queries.rs`

 * *Files 2% similar despite different names*

```diff
@@ -235,16 +235,16 @@
 #[test]
 fn test_groupby_on_lists() -> PolarsResult<()> {
     let s0 = Series::new("", [1i32, 2, 3]);
     let s1 = Series::new("groups", [4i32, 5]);
 
     let mut builder =
         ListPrimitiveChunkedBuilder::<Int32Type>::new("arrays", 10, 10, DataType::Int32);
-    builder.append_series(&s0);
-    builder.append_series(&s1);
+    builder.append_series(&s0).unwrap();
+    builder.append_series(&s1).unwrap();
     let s2 = builder.finish().into_series();
 
     let df = DataFrame::new(vec![s1, s2])?;
     let out = df
         .clone()
         .lazy()
         .groupby([col("groups")])
@@ -253,15 +253,14 @@
 
     assert_eq!(
         out.column("arrays")?.dtype(),
         &DataType::List(Box::new(DataType::Int32))
     );
 
     let out = df
-        .clone()
         .lazy()
         .groupby([col("groups")])
         .agg([col("arrays").implode()])
         .collect()?;
 
     // a list of lists
     assert_eq!(
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/schema.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/schema.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars/tests/it/time/date_range.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars/tests/it/time/date_range.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/Cargo.toml` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/Cargo.toml`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/LICENSE` & `polars_u64_idx-0.18.7/local_dependencies/polars-sql/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/array/default_arrays.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/array/default_arrays.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/array/fixed_size_list.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/array/fixed_size_list.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/array/get.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/array/get.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/array/list.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/array/list.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/array/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/array/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/array/null.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/array/null.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/array/slice.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/array/slice.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/array/utf8.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/array/utf8.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/bit_util.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/bit_util.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/bitmap/mutable.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/bitmap/mutable.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/commutative.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/commutative.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/div.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/div.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/mul.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/mul.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/bitwise.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/bitwise.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/cast.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/cast.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/decimal.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/decimal.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/take/boolean.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/take/boolean.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/take/fixed_size_list.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/take/fixed_size_list.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/take/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/take/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/compute/tile.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/compute/tile.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/conversion.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/conversion.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/data_types.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/data_types.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/floats/ord.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/floats/ord.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/index.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/index.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/is_valid.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/is_valid.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/agg_mean.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/agg_mean.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/comparison.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/comparison.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/concatenate.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/concatenate.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/ewm/average.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/ewm/average.rs`

 * *Files 1% similar despite different names*

```diff
@@ -143,15 +143,15 @@
                 Some(4.0),
                 Some(2.5),
                 Some(3.25),
             ]),
             EPS
         );
         assert_allclose!(
-            ewm_mean(xs1.clone(), 0.5, false, 0, false),
+            ewm_mean(xs1, 0.5, false, 0, false),
             PrimitiveArray::from([
                 None,
                 None,
                 Some(5.0),
                 Some(6.0),
                 Some(6.0),
                 Some(3.333_333_333_333_333_5),
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/ewm/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/ewm/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/ewm/variance.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/ewm/variance.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/float.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/float.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/list.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/list.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/list_bytes_iter.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/list_bytes_iter.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/mean.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/mean.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/min_max.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/min_max.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/quantile.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/quantile.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/sum.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/sum.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/variance.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/variance.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/nulls/mean.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/nulls/mean.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/nulls/min_max.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/nulls/min_max.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/nulls/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/nulls/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/nulls/quantile.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/nulls/quantile.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/nulls/sum.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/nulls/sum.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/nulls/variance.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/nulls/variance.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/rolling/window.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/rolling/window.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/set.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/set.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/sort_partition.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/sort_partition.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/sorted_join/inner.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/sorted_join/inner.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/sorted_join/left.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/sorted_join/left.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/string.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/string.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/take_agg/boolean.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/take_agg/boolean.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/take_agg/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/take_agg/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/take_agg/var.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/take_agg/var.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/kernels/time.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/kernels/time.rs`

 * *Files 5% similar despite different names*

```diff
@@ -17,27 +17,28 @@
 #[cfg(feature = "timezones")]
 fn convert_to_naive_local(
     from_tz: &Tz,
     to_tz: &Tz,
     ndt: NaiveDateTime,
     use_earliest: Option<bool>,
 ) -> Result<NaiveDateTime> {
-    match from_tz.from_local_datetime(&ndt) {
-        LocalResult::Single(dt) => Ok(dt.with_timezone(to_tz).naive_local()),
+    let ndt = from_tz.from_utc_datetime(&ndt).naive_local();
+    match to_tz.from_local_datetime(&ndt) {
+        LocalResult::Single(dt) => Ok(dt.naive_utc()),
         LocalResult::Ambiguous(dt_earliest, dt_latest) => match use_earliest {
-            Some(true) => Ok(dt_earliest.with_timezone(to_tz).naive_local()),
-            Some(false) => Ok(dt_latest.with_timezone(to_tz).naive_local()),
+            Some(true) => Ok(dt_earliest.naive_utc()),
+            Some(false) => Ok(dt_latest.naive_utc()),
             None => Err(ArrowError::InvalidArgumentError(
-                format!("datetime '{}' is ambiguous in time zone '{}'. Please use `use_earliest` to tell how it should be localized.", ndt, from_tz)
+                format!("datetime '{}' is ambiguous in time zone '{}'. Please use `use_earliest` to tell how it should be localized.", ndt, to_tz)
             ))
         },
         LocalResult::None => Err(ArrowError::InvalidArgumentError(
             format!(
                 "datetime '{}' is non-existent in time zone '{}'. Non-existent datetimes are not yet supported",
-                ndt, from_tz
+                ndt, to_tz
             )
             ,
         )),
     }
 }
 
 #[cfg(feature = "timezones")]
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/slice.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/slice.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/trusted_len/boolean.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/trusted_len/boolean.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/trusted_len/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/trusted_len/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/trusted_len/push_unchecked.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/trusted_len/push_unchecked.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-arrow/src/utils.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-arrow/src/utils.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/Cargo.toml` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/Cargo.toml`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/LICENSE` & `polars_u64_idx-0.18.7/local_dependencies/polars-time/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/operators/filter.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/operators/filter.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/operators/function.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/operators/function.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/operators/pass.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/operators/pass.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/operators/placeholder.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/operators/placeholder.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/operators/projection.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/operators/projection.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/operators/reproject.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/operators/reproject.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/file_sink.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/file_sink.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/convert.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/convert.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/count.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/count.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/first.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/first.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/interface.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/interface.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/last.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/last.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/mean.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/mean.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/min_max.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/min_max.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/null.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/null.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/sum.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/sum.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/eval.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/eval.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/global.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/global.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/hash_table.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/hash_table.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/ooc_state.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/ooc_state.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/sink.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/sink.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/source.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/source.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/thread_local.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/thread_local.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/ooc.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/ooc.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/ooc_state.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/ooc_state.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/primitive/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/primitive/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/string.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/string.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/groupby/utils.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/groupby/utils.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/io.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/io.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/joins/cross.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/joins/cross.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/joins/generic_build.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/joins/generic_build.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/joins/inner_left.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/joins/inner_left.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/memory.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/memory.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/ordered.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/ordered.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/reproject.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/reproject.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/slice.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/slice.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/sort/ooc.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/sort/ooc.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/sort/sink.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/sort/sink.rs`

 * *Files 5% similar despite different names*

```diff
@@ -171,14 +171,15 @@
             let io_thread = lock.as_ref().unwrap();
 
             let dist = Series::from_any_values("", &self.dist_sample, false).unwrap();
             let dist = dist.sort_with(SortOptions {
                 descending: self.sort_args.descending[0],
                 nulls_last: self.sort_args.nulls_last,
                 multithreaded: true,
+                maintain_order: self.sort_args.maintain_order,
             });
 
             block_thread_until_io_thread_done(io_thread);
 
             sort_ooc(
                 io_thread,
                 dist,
@@ -212,9 +213,16 @@
 pub(super) fn sort_accumulated(
     df: DataFrame,
     sort_idx: usize,
     descending: bool,
     slice: Option<(i64, usize)>,
 ) -> PolarsResult<DataFrame> {
     let sort_column = df.get_columns()[sort_idx].clone();
-    df.sort_impl(vec![sort_column], vec![descending], false, slice, true)
+    df.sort_impl(
+        vec![sort_column],
+        vec![descending],
+        false,
+        false,
+        slice,
+        true,
+    )
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/sort/sink_multiple.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/sort/sink_multiple.rs`

 * *Files 1% similar despite different names*

```diff
@@ -166,14 +166,15 @@
         let sort_sink = Box::new(SortSink::new(
             // we will set the last column as sort column
             schema.len() - 1,
             SortArguments {
                 descending: vec![false],
                 nulls_last: false,
                 slice: sort_args.slice,
+                maintain_order: false,
             },
             Arc::new(schema),
         ));
 
         SortSinkMultiple {
             sort_sink,
             sort_args,
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/sort/source.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/sort/source.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sinks/utils.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sinks/utils.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sources/csv.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sources/csv.rs`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 use std::path::PathBuf;
 
 use polars_core::export::arrow::Either;
 use polars_core::POOL;
 use polars_io::csv::read_impl::{BatchedCsvReaderMmap, BatchedCsvReaderRead};
 use polars_io::csv::{CsvEncoding, CsvReader};
 use polars_plan::global::_set_n_rows_for_scan;
-use polars_plan::prelude::CsvParserOptions;
+use polars_plan::prelude::{CsvParserOptions, FileScanOptions};
 
 use super::*;
 use crate::pipeline::determine_chunk_size;
 
 pub(crate) struct CsvSource {
     #[allow(dead_code)]
     // this exist because we need to keep ownership
@@ -18,25 +18,27 @@
     reader: Option<*mut CsvReader<'static, File>>,
     batched_reader:
         Option<Either<*mut BatchedCsvReaderMmap<'static>, *mut BatchedCsvReaderRead<'static>>>,
     n_threads: usize,
     chunk_index: IdxSize,
     path: Option<PathBuf>,
     options: Option<CsvParserOptions>,
+    file_options: Option<FileScanOptions>,
     verbose: bool,
 }
 
 impl CsvSource {
     // Delay initializing the reader
     // otherwise all files would be opened during construction of the pipeline
     // leading to Too many Open files error
     fn init_reader(&mut self) -> PolarsResult<()> {
         let options = self.options.take().unwrap();
+        let file_options = self.file_options.take().unwrap();
         let path = self.path.take().unwrap();
-        let mut with_columns = options.with_columns;
+        let mut with_columns = file_options.with_columns;
         let mut projected_len = 0;
         with_columns.as_ref().map(|columns| {
             projected_len = columns.len();
             columns
         });
 
         if projected_len == 0 {
@@ -44,15 +46,15 @@
         }
 
         let n_cols = if projected_len > 0 {
             projected_len
         } else {
             self.schema.len()
         };
-        let n_rows = _set_n_rows_for_scan(options.n_rows);
+        let n_rows = _set_n_rows_for_scan(file_options.n_rows);
         // inversely scale the chunk size by the number of threads so that we reduce memory pressure
         // in streaming
         let chunk_size = determine_chunk_size(n_cols, POOL.current_num_threads())?;
 
         if self.verbose {
             eprintln!("STREAMING CHUNK SIZE: {chunk_size} rows")
         }
@@ -72,15 +74,15 @@
             .with_comment_char(options.comment_char)
             .with_quote_char(options.quote_char)
             .with_end_of_line_char(options.eol_char)
             .with_encoding(options.encoding)
             // never rechunk in streaming
             .with_rechunk(false)
             .with_chunk_size(chunk_size)
-            .with_row_count(options.row_count)
+            .with_row_count(file_options.row_count)
             .with_try_parse_dates(options.try_parse_dates);
 
         let reader = Box::new(reader);
         let reader = Box::leak(reader) as *mut CsvReader<'static, File>;
 
         let batched_reader = if options.low_memory {
             let batched_reader = unsafe { Box::new((*reader).batched_borrowed_read()?) };
@@ -96,24 +98,26 @@
         Ok(())
     }
 
     pub(crate) fn new(
         path: PathBuf,
         schema: SchemaRef,
         options: CsvParserOptions,
+        file_options: FileScanOptions,
         verbose: bool,
     ) -> PolarsResult<Self> {
         Ok(CsvSource {
             schema,
             reader: None,
             batched_reader: None,
             n_threads: POOL.current_num_threads(),
             chunk_index: 0,
             path: Some(path),
             options: Some(options),
+            file_options: Some(file_options),
             verbose,
         })
     }
 }
 
 impl Drop for CsvSource {
     fn drop(&mut self) {
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sources/frame.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sources/frame.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sources/ipc_one_shot.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sources/ipc_one_shot.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sources/parquet.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sources/parquet.rs`

 * *Files 9% similar despite different names*

```diff
@@ -4,41 +4,43 @@
 use polars_core::error::PolarsResult;
 use polars_core::schema::*;
 use polars_core::POOL;
 use polars_io::parquet::{BatchedParquetReader, ParquetReader};
 #[cfg(feature = "async")]
 use polars_io::prelude::ParquetAsyncReader;
 use polars_io::{is_cloud_url, SerReader};
-use polars_plan::prelude::ParquetOptions;
+use polars_plan::prelude::{FileScanOptions, ParquetOptions};
 use polars_utils::IdxSize;
 
 use crate::operators::{DataChunk, PExecutionContext, Source, SourceResult};
 use crate::pipeline::determine_chunk_size;
 
 pub struct ParquetSource {
     batched_reader: Option<BatchedParquetReader>,
     n_threads: usize,
     chunk_index: IdxSize,
     path: Option<PathBuf>,
     options: Option<ParquetOptions>,
+    file_options: Option<FileScanOptions>,
     #[allow(dead_code)]
     cloud_options: Option<CloudOptions>,
     schema: Option<SchemaRef>,
     verbose: bool,
 }
 
 impl ParquetSource {
     // Delay initializing the reader
     // otherwise all files would be opened during construction of the pipeline
     // leading to Too many Open files error
     fn init_reader(&mut self) -> PolarsResult<()> {
         let path = self.path.take().unwrap();
         let options = self.options.take().unwrap();
+        let file_options = self.file_options.take().unwrap();
         let schema = self.schema.take().unwrap();
-        let projection: Option<Vec<_>> = options.with_columns.map(|with_columns| {
+        let projection: Option<Vec<_>> = file_options.with_columns.map(|with_columns| {
             with_columns
                 .iter()
                 .map(|name| schema.index_of(name).unwrap())
                 .collect()
         });
 
         let n_cols = projection.as_ref().map(|v| v.len()).unwrap_or(schema.len());
@@ -55,49 +57,51 @@
                     "Feature 'async' (or more likely one of the cloud provider features) is required to access parquet files on cloud storage."
                 )
             }
             #[cfg(feature = "async")]
             {
                 let uri = path.to_string_lossy();
                 ParquetAsyncReader::from_uri(&uri, self.cloud_options.as_ref())?
-                    .with_n_rows(options.n_rows)
-                    .with_row_count(options.row_count)
+                    .with_n_rows(file_options.n_rows)
+                    .with_row_count(file_options.row_count)
                     .with_projection(projection)
                     .use_statistics(options.use_statistics)
                     .batched(chunk_size)?
             }
         } else {
             let file = std::fs::File::open(path).unwrap();
 
             ParquetReader::new(file)
-                .with_n_rows(options.n_rows)
-                .with_row_count(options.row_count)
+                .with_n_rows(file_options.n_rows)
+                .with_row_count(file_options.row_count)
                 .with_projection(projection)
                 .use_statistics(options.use_statistics)
                 .batched(chunk_size)?
         };
         self.batched_reader = Some(batched_reader);
         Ok(())
     }
 
     #[allow(unused_variables)]
     pub(crate) fn new(
         path: PathBuf,
         options: ParquetOptions,
         cloud_options: Option<CloudOptions>,
+        file_options: FileScanOptions,
         schema: SchemaRef,
         verbose: bool,
     ) -> PolarsResult<Self> {
         let n_threads = POOL.current_num_threads();
 
         Ok(ParquetSource {
             batched_reader: None,
             n_threads,
             chunk_index: 0,
             options: Some(options),
+            file_options: Some(file_options),
             path: Some(path),
             cloud_options,
             schema: Some(schema),
             verbose,
         })
     }
 }
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sources/reproject.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sources/reproject.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/executors/sources/union.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/executors/sources/union.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/operators/chunks.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/operators/chunks.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/operators/operator.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/operators/operator.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/operators/sink.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/operators/sink.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/pipeline/convert.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/pipeline/convert.rs`

 * *Files 6% similar despite different names*

```diff
@@ -61,60 +61,62 @@
                 // projection is free
                 if let Some(projection) = projection {
                     df = df.select(projection.as_slice())?;
                 }
             }
             Ok(Box::new(sources::DataFrameSource::from_df(df)) as Box<dyn Source>)
         }
-        #[cfg(feature = "csv")]
-        CsvScan {
+        Scan {
             path,
             file_info,
-            options,
+            file_options,
             predicate,
             output_schema,
-            ..
+            scan_type,
         } => {
             // add predicate to operators
             if let (true, Some(predicate)) = (push_predicate, predicate) {
                 let predicate = to_physical(predicate, expr_arena, output_schema.as_ref())?;
                 let op = operators::FilterOperator { predicate };
                 let op = Box::new(op) as Box<dyn Operator>;
                 operator_objects.push(op)
             }
-            let src = sources::CsvSource::new(path, file_info.schema, options, verbose)?;
-            Ok(Box::new(src) as Box<dyn Source>)
-        }
-        #[cfg(feature = "parquet")]
-        ParquetScan {
-            path,
-            file_info,
-            options,
-            cloud_options,
-            predicate,
-            output_schema,
-            ..
-        } => {
-            // add predicate to operators
-            if let (true, Some(predicate)) = (push_predicate, predicate) {
-                let predicate = to_physical(predicate, expr_arena, output_schema.as_ref())?;
-                let op = operators::FilterOperator { predicate };
-                let op = Box::new(op) as Box<dyn Operator>;
-                operator_objects.push(op)
+            match scan_type {
+                #[cfg(feature = "csv")]
+                FileScan::Csv {
+                    options: csv_options,
+                } => {
+                    let src = sources::CsvSource::new(
+                        path,
+                        file_info.schema,
+                        csv_options,
+                        file_options,
+                        verbose,
+                    )?;
+                    Ok(Box::new(src) as Box<dyn Source>)
+                }
+                #[cfg(feature = "parquet")]
+                FileScan::Parquet {
+                    options: parquet_options,
+                    cloud_options,
+                } => {
+                    let src = sources::ParquetSource::new(
+                        path,
+                        parquet_options,
+                        cloud_options,
+                        file_options,
+                        file_info.schema,
+                        verbose,
+                    )?;
+                    Ok(Box::new(src) as Box<dyn Source>)
+                }
+                _ => todo!(),
             }
-            let src = sources::ParquetSource::new(
-                path,
-                options,
-                cloud_options,
-                file_info.schema,
-                verbose,
-            )?;
-            Ok(Box::new(src) as Box<dyn Source>)
         }
-        _ => todo!(),
+        _ => unreachable!(),
     }
 }
 
 pub fn get_sink<F>(
     node: Node,
     lp_arena: &mut Arena<ALogicalPlan>,
     expr_arena: &mut Arena<AExpr>,
@@ -476,25 +478,15 @@
                 lp.clone(),
                 &mut operator_objects,
                 expr_arena,
                 &to_physical,
                 true,
                 verbose,
             )?,
-            #[cfg(feature = "csv")]
-            lp @ CsvScan { .. } => get_source(
-                lp.clone(),
-                &mut operator_objects,
-                expr_arena,
-                &to_physical,
-                true,
-                verbose,
-            )?,
-            #[cfg(feature = "parquet")]
-            lp @ ParquetScan { .. } => get_source(
+            lp @ Scan { .. } => get_source(
                 lp.clone(),
                 &mut operator_objects,
                 expr_arena,
                 &to_physical,
                 true,
                 verbose,
             )?,
```

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/pipeline/dispatcher.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/pipeline/dispatcher.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-pipe/src/pipeline/mod.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/src/pipeline/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-error/Cargo.toml` & `polars_u64_idx-0.18.7/local_dependencies/polars-error/Cargo.toml`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-error/LICENSE` & `polars_u64_idx-0.18.7/local_dependencies/polars-pipe/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/local_dependencies/polars-error/src/lib.rs` & `polars_u64_idx-0.18.7/local_dependencies/polars-error/src/lib.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/Cargo.toml` & `polars_u64_idx-0.18.7/Cargo.toml`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 [package]
 name = "py-polars"
-version = "0.18.6"
+version = "0.18.7"
 edition = "2021"
 
 # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
 
 [workspace]
 # prevents package from thinking it's in the workspace
 [target.'cfg(any(not(target_os = "linux"), use_mimalloc))'.dependencies]
@@ -65,14 +65,15 @@
 merge_sorted = ["polars/merge_sorted"]
 list_take = ["polars/list_take"]
 list_count = ["polars/list_count"]
 binary_encoding = ["polars/binary_encoding"]
 list_sets = ["polars-lazy/list_sets"]
 list_any_all = ["polars/list_any_all"]
 cutqcut = ["polars/cutqcut"]
+rle = ["polars/rle"]
 
 all = [
   "json",
   "parquet",
   "ipc",
   "avro",
   "is_in",
@@ -103,14 +104,15 @@
   "streaming",
   "performant",
   "list_take",
   "list_count",
   "list_sets",
   "list_any_all",
   "cutqcut",
+  "rle",
 ]
 
 # we cannot conditionally activate simd
 # https://github.com/rust-lang/cargo/issues/1197
 # so we have an indirection and compile
 # with --no-default-features --features=all for targets without simd
 default = [
```

### Comparing `polars_u64_idx-0.18.6/LICENSE` & `polars_u64_idx-0.18.7/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/Makefile` & `polars_u64_idx-0.18.7/Makefile`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/README.md` & `polars_u64_idx-0.18.7/README.md`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/build.rs` & `polars_u64_idx-0.18.7/build.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/Makefile` & `polars_u64_idx-0.18.7/docs/Makefile`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/_templates/autosummary/class.rst` & `polars_u64_idx-0.18.7/docs/_templates/autosummary/class.rst`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/requirements-docs.txt` & `polars_u64_idx-0.18.7/docs/requirements-docs.txt`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/run_live_docs_server.py` & `polars_u64_idx-0.18.7/docs/run_live_docs_server.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/source/_static/css/custom.css` & `polars_u64_idx-0.18.7/docs/source/_static/css/custom.css`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/source/conf.py` & `polars_u64_idx-0.18.7/docs/source/conf.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/source/reference/api.rst` & `polars_u64_idx-0.18.7/docs/source/reference/api.rst`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/source/reference/config.rst` & `polars_u64_idx-0.18.7/docs/source/reference/config.rst`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/source/reference/dataframe/modify_select.rst` & `polars_u64_idx-0.18.7/docs/source/reference/dataframe/modify_select.rst`

 * *Files 1% similar despite different names*

```diff
@@ -41,14 +41,15 @@
     DataFrame.rechunk
     DataFrame.rename
     DataFrame.replace
     DataFrame.replace_at_idx
     DataFrame.reverse
     DataFrame.row
     DataFrame.rows
+    DataFrame.rows_by_key
     DataFrame.sample
     DataFrame.select
     DataFrame.set_sorted
     DataFrame.shift
     DataFrame.shift_and_fill
     DataFrame.shrink_to_fit
     DataFrame.slice
```

### Comparing `polars_u64_idx-0.18.6/docs/source/reference/datatypes.rst` & `polars_u64_idx-0.18.7/docs/source/reference/datatypes.rst`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/source/reference/expressions/computation.rst` & `polars_u64_idx-0.18.7/docs/source/reference/expressions/computation.rst`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/source/reference/expressions/functions.rst` & `polars_u64_idx-0.18.7/docs/source/reference/expressions/functions.rst`

 * *Files 19% similar despite different names*

```diff
@@ -9,15 +9,17 @@
 **Available in module namespace:**
 
 .. currentmodule:: polars
 .. autosummary::
    :toctree: api/
 
    all
+   all_horizontal
    any
+   any_horizontal
    apply
    approx_unique
    arange
    arg_sort_by
    arg_where
    avg
    coalesce
@@ -25,14 +27,15 @@
    concat_str
    corr
    count
    cov
    cumfold
    cumreduce
    cumsum
+   cumsum_horizontal
    date
    datetime
    date_range
    duration
    element
    exclude
    first
@@ -40,31 +43,35 @@
    format
    from_epoch
    groups
    head
    implode
    int_range
    int_ranges
+   last
    lit
    map
    max
+   max_horizontal
    mean
    median
    min
+   min_horizontal
    n_unique
    ones
    quantile
    reduce
    repeat
    rolling_corr
    rolling_cov
    select
    std
    struct
    sum
+   sum_horizontal
    sql_expr
    tail
    time
    time_range
    var
    when
    zeros
```

### Comparing `polars_u64_idx-0.18.6/docs/source/reference/expressions/list.rst` & `polars_u64_idx-0.18.7/docs/source/reference/expressions/list.rst`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/source/reference/expressions/operators.rst` & `polars_u64_idx-0.18.7/docs/source/reference/expressions/operators.rst`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/source/reference/expressions/string.rst` & `polars_u64_idx-0.18.7/docs/source/reference/expressions/string.rst`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/source/reference/expressions/temporal.rst` & `polars_u64_idx-0.18.7/docs/source/reference/expressions/temporal.rst`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/source/reference/functions.rst` & `polars_u64_idx-0.18.7/docs/source/reference/functions.rst`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/source/reference/io.rst` & `polars_u64_idx-0.18.7/docs/source/reference/io.rst`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/source/reference/lazyframe/modify_select.rst` & `polars_u64_idx-0.18.7/docs/source/reference/lazyframe/modify_select.rst`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/source/reference/selectors.rst` & `polars_u64_idx-0.18.7/docs/source/reference/selectors.rst`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/source/reference/series/computation.rst` & `polars_u64_idx-0.18.7/docs/source/reference/series/computation.rst`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/source/reference/series/descriptive.rst` & `polars_u64_idx-0.18.7/docs/source/reference/series/descriptive.rst`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/source/reference/series/list.rst` & `polars_u64_idx-0.18.7/docs/source/reference/series/list.rst`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/source/reference/series/modify_select.rst` & `polars_u64_idx-0.18.7/docs/source/reference/series/modify_select.rst`

 * *Files 19% similar despite different names*

```diff
@@ -33,14 +33,16 @@
     Series.limit
     Series.new_from_index
     Series.qcut
     Series.rechunk
     Series.rename
     Series.reshape
     Series.reverse
+    Series.rle
+    Series.rle_id
     Series.round
     Series.sample
     Series.set
     Series.set_at_idx
     Series.shift
     Series.shift_and_fill
     Series.shrink_dtype
```

### Comparing `polars_u64_idx-0.18.6/docs/source/reference/series/string.rst` & `polars_u64_idx-0.18.7/docs/source/reference/series/string.rst`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/source/reference/series/temporal.rst` & `polars_u64_idx-0.18.7/docs/source/reference/series/temporal.rst`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/docs/source/reference/testing.rst` & `polars_u64_idx-0.18.7/docs/source/reference/testing.rst`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/__init__.py` & `polars_u64_idx-0.18.7/polars/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -74,15 +74,17 @@
     ShapeError,
     StructFieldNotFoundError,
 )
 from polars.expr import Expr
 from polars.functions import (
     align_frames,
     all,
+    all_horizontal,
     any,
+    any_horizontal,
     apply,
     approx_unique,
     arange,
     arg_sort_by,
     arg_where,
     avg,
     coalesce,
@@ -93,14 +95,15 @@
     concat_str,
     corr,
     count,
     cov,
     cumfold,
     cumreduce,
     cumsum,
+    cumsum_horizontal,
     date,
     date_range,
     datetime,
     duration,
     element,
     exclude,
     first,
@@ -112,29 +115,32 @@
     implode,
     int_range,
     int_ranges,
     last,
     lit,
     map,
     max,
+    max_horizontal,
     mean,
     median,
     min,
+    min_horizontal,
     n_unique,
     ones,
     quantile,
     reduce,
     repeat,
     rolling_corr,
     rolling_cov,
     select,
     sql_expr,
     std,
     struct,
     sum,
+    sum_horizontal,
     tail,
     time,
     time_range,
     var,
     when,
     zeros,
 )
@@ -277,32 +283,42 @@
     "concat",
     "date_range",
     "element",
     "ones",
     "repeat",
     "time_range",
     "zeros",
-    # polars.functions.lazy
+    # polars.functions.aggregation
     "all",
     "any",
+    "cumsum",
+    "max",
+    "min",
+    "sum",
+    "all_horizontal",
+    "any_horizontal",
+    "cumsum_horizontal",
+    "max_horizontal",
+    "min_horizontal",
+    "sum_horizontal",
+    # polars.functions.lazy
     "apply",
     "arange",
     "arg_sort_by",
     "avg",
     "coalesce",
     "col",
     "collect_all",
     "concat_list",
     "concat_str",
     "corr",
     "count",
     "cov",
     "cumfold",
     "cumreduce",
-    "cumsum",
     "date",  # named date_, see import above
     "datetime",  # named datetime_, see import above
     "duration",
     "exclude",
     "first",
     "fold",
     "format",
@@ -311,28 +327,25 @@
     "head",
     "implode",
     "int_range",
     "int_ranges",
     "last",
     "lit",
     "map",
-    "max",
     "mean",
     "median",
-    "min",
     "n_unique",
     "approx_unique",
     "quantile",
     "reduce",
     "rolling_corr",
     "rolling_cov",
     "select",
     "std",
     "struct",
-    "sum",
     "tail",
     "time",  # named time_, see import above
     "var",
     # polars.convert
     "from_arrow",
     "from_dataframe",
     "from_dict",
```

### Comparing `polars_u64_idx-0.18.6/polars/api.py` & `polars_u64_idx-0.18.7/polars/api.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/config.py` & `polars_u64_idx-0.18.7/polars/config.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/convert.py` & `polars_u64_idx-0.18.7/polars/convert.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/dataframe/_html.py` & `polars_u64_idx-0.18.7/polars/dataframe/_html.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/dataframe/frame.py` & `polars_u64_idx-0.18.7/polars/dataframe/frame.py`

 * *Files 0% similar despite different names*

```diff
@@ -1892,21 +1892,22 @@
         if as_series:
             return {s.name: s for s in self}
         else:
             return {s.name: s.to_list() for s in self}
 
     def to_dicts(self) -> list[dict[str, Any]]:
         """
-        Convert every row to a dictionary of python-native values.
+        Convert every row to a dictionary of Python-native values.
 
         Notes
         -----
-        If you have ``ns``-precision temporal values you should be aware that python
-        natively only supports up to ``us``-precision; if this matters you should export
-        to a different format.
+        If you have ``ns``-precision temporal values you should be aware that Python
+        natively only supports up to ``s``-precision; `ns`-precision values will be
+        truncated to microseconds on conversion to Python. If this matters to your
+        use-case you should export to a different format (such as Arrow or NumPy).
 
         Examples
         --------
         >>> df = pl.DataFrame({"foo": [1, 2, 3], "bar": [4, 5, 6]})
         >>> df.to_dicts()
         [{'foo': 1, 'bar': 4}, {'foo': 2, 'bar': 5}, {'foo': 3, 'bar': 6}]
 
@@ -3091,16 +3092,17 @@
                 # extract the name before casting
                 name = f"column_{i}" if column._name is None else column._name
 
                 data[name] = column
 
             tbl = pa.table(data)
 
-            # do not remove this
+            # do not remove this import!
             # needed below
+            import pyarrow.parquet  # noqa: F401
 
             pa.parquet.write_table(
                 table=tbl,
                 where=file,
                 row_group_size=row_group_size,
                 compression=None if compression == "uncompressed" else compression,
                 compression_level=compression_level,
@@ -3122,19 +3124,21 @@
     ) -> None:
         """
         Write a polars frame to a database.
 
         Parameters
         ----------
         table_name
-            Name of the table to append to or create in the SQL database.
+            Name of the table to create or append to in the target SQL database.
+            If your table name contains special characters, it should be quoted.
         connection_uri
-            Connection uri, for example
+            Connection URI, for example:
 
-            * "postgresql://username:password@server:port/database"
+            * "postgresql://user:pass@server:port/database"
+            * "sqlite:////path/to/database.db"
         if_exists : {'append', 'replace', 'fail'}
             The insert mode.
             'replace' will create a new database table, overwriting an existing one.
             'append' will append to an existing table.
             'fail' will fail if table already exists.
         engine : {'sqlalchemy', 'adbc'}
             Select the engine used for writing the data.
@@ -3154,34 +3158,51 @@
                     f"Choose one of: {'fail', 'replace', 'append'}."
                 )
             with _open_adbc_connection(connection_uri) as conn:
                 cursor = conn.cursor()
                 cursor.adbc_ingest(table_name, self.to_arrow(), mode)
                 cursor.close()
                 conn.commit()
+
         elif engine == "sqlalchemy":
             if parse_version(pd.__version__) < parse_version("1.5"):
                 raise ModuleNotFoundError(
                     f"Writing with engine 'sqlalchemy' requires Pandas 1.5.x or higher, found Pandas {pd.__version__}."
                 )
+
             try:
                 from sqlalchemy import create_engine
             except ImportError as exc:
                 raise ImportError(
                     "'sqlalchemy' not found. Install polars with 'pip install polars[sqlalchemy]'."
                 ) from exc
+            from csv import reader as delimited_read
 
-            engine_sa = create_engine(connection_uri)
+            # the table name may also include the db schema; ensure that we identify
+            # both components and pass them through unquoted (sqlalachemy will quote)
+            table_ident = next(delimited_read([table_name], delimiter="."))
+            if len(table_ident) > 2:
+                raise ValueError(f"table_name appears to be invalid: {table_name!r}")
+            elif len(table_ident) > 1:
+                db_schema = table_ident[0]
+                table_name = table_ident[1]
+            else:
+                table_name = table_ident[0]
+                db_schema = None
 
-            # this conversion to pandas as zero-copy
-            # so we can utilize their sql utils for free
+            # ensure conversion to pandas uses the pyarrow extension array option
+            # so that we can make use of the sql/db export without copying data
+            engine_sa = create_engine(connection_uri)
             self.to_pandas(use_pyarrow_extension_array=True).to_sql(
-                name=table_name, con=engine_sa, if_exists=if_exists, index=False
+                name=table_name,
+                schema=db_schema,
+                con=engine_sa,
+                if_exists=if_exists,
+                index=False,
             )
-
         else:
             raise ValueError(f"'engine' {engine} is not supported.")
 
     def write_delta(
         self,
         target: str | Path | deltalake.DeltaTable,
         *,
@@ -3997,14 +4018,15 @@
     def top_k(
         self,
         k: int,
         *,
         by: IntoExpr | Iterable[IntoExpr],
         descending: bool | Sequence[bool] = False,
         nulls_last: bool = False,
+        maintain_order: bool = False,
     ) -> DataFrame:
         """
         Return the `k` largest elements.
 
         If 'descending=True` the smallest elements will be given.
 
         Parameters
@@ -4015,14 +4037,18 @@
             Column(s) included in sort order. Accepts expression input.
             Strings are parsed as column names.
         descending
             Return the 'k' smallest. Top-k by multiple columns can be specified
             per column by passing a sequence of booleans.
         nulls_last
             Place null values last.
+        maintain_order
+            Whether the order should be maintained if elements are equal.
+            Note that if `true` streaming is not possible and performance might be
+            worse since this requires a stable search.
 
         See Also
         --------
         bottom_k
 
         Examples
         --------
@@ -4062,15 +4088,21 @@
          a    2   
          c    1   
         
 
         """
         return (
             self.lazy()
-            .top_k(k, by=by, descending=descending, nulls_last=nulls_last)
+            .top_k(
+                k,
+                by=by,
+                descending=descending,
+                nulls_last=nulls_last,
+                maintain_order=maintain_order,
+            )
             .collect(
                 projection_pushdown=False,
                 predicate_pushdown=False,
                 common_subplan_elimination=False,
                 slice_pushdown=True,
             )
         )
@@ -4078,14 +4110,15 @@
     def bottom_k(
         self,
         k: int,
         *,
         by: IntoExpr | Iterable[IntoExpr],
         descending: bool | Sequence[bool] = False,
         nulls_last: bool = False,
+        maintain_order: bool = False,
     ) -> DataFrame:
         """
         Return the `k` smallest elements.
 
         If 'descending=True` the largest elements will be given.
 
         Parameters
@@ -4096,14 +4129,18 @@
             Column(s) included in sort order. Accepts expression input.
             Strings are parsed as column names.
         descending
             Return the 'k' smallest. Top-k by multiple columns can be specified
             per column by passing a sequence of booleans.
         nulls_last
             Place null values last.
+        maintain_order
+            Whether the order should be maintained if elements are equal.
+            Note that if `true` streaming is not possible and performance might be
+            worse since this requires a stable search.
 
         See Also
         --------
         top_k
 
         Examples
         --------
@@ -4143,15 +4180,21 @@
          b    1   
          b    2   
         
 
         """
         return (
             self.lazy()
-            .bottom_k(k, by=by, descending=descending, nulls_last=nulls_last)
+            .bottom_k(
+                k,
+                by=by,
+                descending=descending,
+                nulls_last=nulls_last,
+                maintain_order=maintain_order,
+            )
             .collect(
                 projection_pushdown=False,
                 predicate_pushdown=False,
                 common_subplan_elimination=False,
                 slice_pushdown=True,
             )
         )
@@ -4439,15 +4482,15 @@
          null  2     null 
          null  null  null 
          null  1     1    
         
 
         Drop a row only if all values are null:
 
-        >>> df.filter(~pl.all(pl.all().is_null()))
+        >>> df.filter(~pl.all_horizontal(pl.all().is_null()))
         shape: (3, 3)
         
          a     b    c    
          ---   ---  ---  
          f32   i64  i64  
         
          null  1    1    
@@ -5139,15 +5182,15 @@
          b       2021-12-16 02:00:00  2021-12-16 03:00:00  2021-12-16 02:00:00  1          
         
 
         Dynamic groupby on an index column
 
         >>> df = pl.DataFrame(
         ...     {
-        ...         "idx": pl.arange(0, 6, eager=True),
+        ...         "idx": pl.int_range(0, 6, eager=True),
         ...         "A": ["A", "A", "B", "B", "B", "C"],
         ...     }
         ... )
         >>> (
         ...     df.groupby_dynamic(
         ...         "idx",
         ...         every="2i",
@@ -6558,15 +6601,15 @@
 
         Examples
         --------
         >>> from string import ascii_uppercase
         >>> df = pl.DataFrame(
         ...     {
         ...         "col1": list(ascii_uppercase[0:9]),
-        ...         "col2": pl.arange(0, 9, eager=True),
+        ...         "col2": pl.int_range(0, 9, eager=True),
         ...     }
         ... )
         >>> df
         shape: (9, 2)
         
          col1  col2 
          ---   ---  
@@ -6630,15 +6673,15 @@
                     for s, next_fill in zip(df, fill_values)
                 ]
             )
 
         if how == "horizontal":
             df = (
                 df.with_columns(
-                    (F.arange(0, n_cols * n_rows, eager=True) % n_cols).alias(
+                    (F.int_range(0, n_cols * n_rows, eager=True) % n_cols).alias(
                         "__sort_order"
                     ),
                 )
                 .sort("__sort_order")
                 .drop("__sort_order")
             )
 
@@ -6655,47 +6698,52 @@
 
     @overload
     def partition_by(
         self,
         by: str | Iterable[str],
         *more_by: str,
         maintain_order: bool = ...,
+        include_key: bool = ...,
         as_dict: Literal[False] = ...,
     ) -> list[Self]:
         ...
 
     @overload
     def partition_by(
         self,
         by: str | Iterable[str],
         *more_by: str,
         maintain_order: bool = ...,
+        include_key: bool = ...,
         as_dict: Literal[True],
     ) -> dict[Any, Self]:
         ...
 
     def partition_by(
         self,
         by: str | Iterable[str],
         *more_by: str,
         maintain_order: bool = True,
+        include_key: bool = True,
         as_dict: bool = False,
     ) -> list[Self] | dict[Any, Self]:
         """
         Group by the given columns and return the groups as separate dataframes.
 
         Parameters
         ----------
         by
             Name of the column(s) to group by.
         *more_by
             Additional names of columns to group by, specified as positional arguments.
         maintain_order
             Ensure that the order of the groups is consistent with the input data.
             This is slower than a default partition by operation.
+        include_key
+            Include the columns used to partition the DataFrame in the output.
         as_dict
             Return a dictionary instead of a list. The dictionary keys are the distinct
             group values that identify that group.
 
         Examples
         --------
         Pass a single column name to partition by that column.
@@ -6808,15 +6856,16 @@
             by = [by]
         elif not isinstance(by, list):
             by = list(by)
         if more_by:
             by.extend(more_by)
 
         partitions = [
-            self._from_pydf(_df) for _df in self._df.partition_by(by, maintain_order)
+            self._from_pydf(_df)
+            for _df in self._df.partition_by(by, maintain_order, include_key)
         ]
 
         if as_dict:
             if len(by) == 1:
                 return {df[by][0, 0]: df for df in partitions}
             else:
                 return {df[by].row(0): df for df in partitions}
@@ -8285,17 +8334,18 @@
         named
             Return dictionaries instead of tuples. The dictionaries are a mapping of
             column name to row value. This is more expensive than returning a regular
             tuple, but allows for accessing values by column name.
 
         Notes
         -----
-        If you have ``ns``-precision temporal values you should be aware that python
-        natively only supports up to ``us``-precision; if this matters you should export
-        to a different format, as this method returns only python-native values.
+        If you have ``ns``-precision temporal values you should be aware that Python
+        natively only supports up to ``s``-precision; `ns`-precision values will be
+        truncated to microseconds on conversion to Python. If this matters to your
+        use-case you should export to a different format (such as Arrow or NumPy).
 
         Warnings
         --------
         Row-iteration is not optimal as the underlying data is stored in columnar form;
         where possible, prefer export via one of the dedicated export/output methods.
         Where possible you should also consider using ``iter_rows`` instead to avoid
         materialising all the data at once.
@@ -8365,17 +8415,18 @@
         unique
             Indicate that the key is unique; this will result in a 1:1 mapping from
             key to a single associated row. Note that if the key is *not* actually
             unique the last row with the given key will be returned.
 
         Notes
         -----
-        If you have ``ns``-precision temporal values you should be aware that python
-        natively only supports up to ``us``-precision; if this matters you should export
-        to a different format, as this method returns only python-native values.
+        If you have ``ns``-precision temporal values you should be aware that Python
+        natively only supports up to ``s``-precision; `ns`-precision values will be
+        truncated to microseconds on conversion to Python. If this matters to your
+        use-case you should export to a different format (such as Arrow or NumPy).
 
         Examples
         --------
         >>> df = pl.DataFrame(
         ...     {
         ...         "w": ["a", "b", "b", "a"],
         ...         "x": ["q", "q", "q", "k"],
@@ -8525,17 +8576,18 @@
             over the data; you should only modify this in very specific cases where the
             default value is determined not to be a good fit to your access pattern, as
             the speedup from using the buffer is significant (~2-4x). Setting this
             value to zero disables row buffering (not recommended).
 
         Notes
         -----
-        If you have ``ns``-precision temporal values you should be aware that python
-        natively only supports up to ``us``-precision; if this matters in your use-case
-        you should export to a different format.
+        If you have ``ns``-precision temporal values you should be aware that Python
+        natively only supports up to ``s``-precision; `ns`-precision values will be
+        truncated to microseconds on conversion to Python. If this matters to your
+        use-case you should export to a different format (such as Arrow or NumPy).
 
         Warnings
         --------
         Row iteration is not optimal as the underlying data is stored in columnar form;
         where possible, prefer export via one of the dedicated export/output methods
         that deals with columnar data.
```

### Comparing `polars_u64_idx-0.18.6/polars/dataframe/groupby.py` & `polars_u64_idx-0.18.7/polars/dataframe/groupby.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/datatypes/__init__.py` & `polars_u64_idx-0.18.7/polars/datatypes/__init__.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/datatypes/classes.py` & `polars_u64_idx-0.18.7/polars/datatypes/classes.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/datatypes/constants.py` & `polars_u64_idx-0.18.7/polars/datatypes/constants.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/datatypes/constructor.py` & `polars_u64_idx-0.18.7/polars/datatypes/constructor.py`

 * *Files 3% similar despite different names*

```diff
@@ -98,18 +98,22 @@
         else values.dtype.type
     )
 
     if dtype == np.float16:
         values = values.astype(np.float32)
         dtype = values.dtype.type
     elif dtype == np.datetime64:
-        if np.datetime_data(values.dtype)[0] in dt.DTYPE_TEMPORAL_UNITS:
+        time_unit = np.datetime_data(values.dtype)[0]
+        if time_unit in dt.DTYPE_TEMPORAL_UNITS or time_unit == "D":
             values = values.astype(np.int64)
         else:
-            dtype = object
+            raise ValueError(
+                "Only 'D', 'ms', 'us', and 'ns' resolutions are supported when converting from numpy.datetime64. "
+                "Please cast to the closest supported unit before converting."
+            )
     return values, dtype
 
 
 def numpy_type_to_constructor(dtype: type[np.dtype[Any]]) -> Callable[..., PySeries]:
     """Get the right PySeries constructor for the given Polars dtype."""
     if _NUMPY_TYPE_TO_CONSTRUCTOR is None:
         _set_numpy_to_constructor()
```

### Comparing `polars_u64_idx-0.18.6/polars/datatypes/convert.py` & `polars_u64_idx-0.18.7/polars/datatypes/convert.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/dependencies.py` & `polars_u64_idx-0.18.7/polars/dependencies.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/exceptions.py` & `polars_u64_idx-0.18.7/polars/exceptions.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/expr/array.py` & `polars_u64_idx-0.18.7/polars/expr/array.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/expr/binary.py` & `polars_u64_idx-0.18.7/polars/expr/binary.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/expr/categorical.py` & `polars_u64_idx-0.18.7/polars/expr/categorical.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/expr/datetime.py` & `polars_u64_idx-0.18.7/polars/expr/datetime.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/expr/expr.py` & `polars_u64_idx-0.18.7/polars/expr/expr.py`

 * *Files 0% similar despite different names*

```diff
@@ -3235,26 +3235,30 @@
         return self._from_pyexpr(self._pyexpr.quantile(quantile, interpolation))
 
     def cut(
         self,
         breaks: list[float],
         labels: list[str] | None = None,
         left_closed: bool = False,
+        include_breaks: bool = False,
     ) -> Self:
         """
         Bin continuous values into discrete categories.
 
         Parameters
         ----------
         breaks
             A list of unique cut points.
         labels
             Labels to assign to bins. If given, the length must be len(probs) + 1.
         left_closed
             Whether intervals should be [) instead of the default of (]
+        include_breaks
+            Include the the right endpoint of the bin each observation falls in.
+            If True, the resulting column will be a Struct.
 
         Examples
         --------
         >>> g = pl.repeat("a", 5, eager=True).append(pl.repeat("b", 5, eager=True))
         >>> df = pl.DataFrame(dict(g=g, x=range(10)))
         >>> df.with_columns(q=pl.col("x").cut([2, 5]))
         shape: (10, 3)
@@ -3287,22 +3291,25 @@
                           
          b    6    [5, inf)  
          b    7    [5, inf)  
          b    8    [5, inf)  
          b    9    [5, inf)  
         
         """
-        return self._from_pyexpr(self._pyexpr.cut(breaks, labels, left_closed))
+        return self._from_pyexpr(
+            self._pyexpr.cut(breaks, labels, left_closed, include_breaks)
+        )
 
     def qcut(
         self,
         probs: list[float],
         labels: list[str] | None = None,
         left_closed: bool = False,
         allow_duplicates: bool = False,
+        include_breaks: bool = False,
     ) -> Self:
         """
         Bin continuous values into discrete categories based on their quantiles.
 
         Parameters
         ----------
         probs
@@ -3313,14 +3320,17 @@
             If computing over groups this must be set for now.
         left_closed
             Whether intervals should be [) instead of the default of (]
         allow_duplicates
             If True, the resulting quantile breaks don't have to be unique. This can
             happen even with unique probs depending on the data. Duplicates will be
             dropped, resulting in fewer bins.
+        include_breaks
+            Include the the right endpoint of the bin each observation falls in.
+            If True, the resulting column will be a Struct.
 
 
         Examples
         --------
         >>> g = pl.repeat("a", 5, eager=True).append(pl.repeat("b", 5, eager=True))
         >>> df = pl.DataFrame(dict(g=g, x=range(10)))
         >>> df.with_columns(q=pl.col("x").qcut([0.5]))
@@ -3370,20 +3380,95 @@
          a    3    hi  
                     
          b    6    lo  
          b    7    hi  
          b    8    hi  
          b    9    hi  
         
-
+        >>> df.with_columns(q=pl.col("x").qcut([0.25, 0.5], include_breaks=True))
+        shape: (10, 3)
+        
+         g    x    q                     
+         ---  ---  ---                   
+         str  i64  struct[2]             
+        
+         a    0    {2.25,"(-inf, 2.25]"} 
+         a    1    {2.25,"(-inf, 2.25]"} 
+         a    2    {2.25,"(-inf, 2.25]"} 
+         a    3    {4.5,"(2.25, 4.5]"}   
+                                      
+         b    6    {inf,"(4.5, inf]"}    
+         b    7    {inf,"(4.5, inf]"}    
+         b    8    {inf,"(4.5, inf]"}    
+         b    9    {inf,"(4.5, inf]"}    
+        
         """
         return self._from_pyexpr(
-            self._pyexpr.qcut(probs, labels, left_closed, allow_duplicates)
+            self._pyexpr.qcut(
+                probs, labels, left_closed, allow_duplicates, include_breaks
+            )
         )
 
+    def rle(self) -> Self:
+        """
+        Get the lengths of runs of identical values.
+
+        Returns
+        -------
+            A Struct Series containing "lengths" and "values" Fields
+
+        Examples
+        --------
+        >>> df = pl.DataFrame(pl.Series("s", [1, 1, 2, 1, None, 1, 3, 3]))
+        >>> df.select(pl.col("s").rle()).unnest("s")
+        shape: (6, 2)
+        
+         lengths  values 
+         ---      ---    
+         i32      i64    
+        
+         2        1      
+         1        2      
+         1        1      
+         1        null   
+         1        1      
+         2        3      
+        
+        """
+        return self._from_pyexpr(self._pyexpr.rle())
+
+    def rle_id(self) -> Self:
+        """
+        Map values to run IDs.
+
+        Similar to RLE, but it maps each value to an ID corresponding to the run into
+        which it falls. This is especially useful when you want to define groups by
+        runs of identical values rather than the values themselves.
+
+
+        Examples
+        --------
+        >>> df = pl.DataFrame(dict(a=[1, 2, 1, 1, 1], b=["x", "x", None, "y", "y"]))
+        >>> # It works on structs of multiple values too!
+        >>> df.with_columns(a_r=pl.col("a").rle_id(), ab_r=pl.struct("a", "b").rle_id())
+        shape: (5, 4)
+        
+         a    b     a_r  ab_r 
+         ---  ---   ---  ---  
+         i64  str   u32  u32  
+        
+         1    x     0    0    
+         2    x     1    1    
+         1    null  2    2    
+         1    y     2    3    
+         1    y     2    3    
+        
+        """
+        return self._from_pyexpr(self._pyexpr.rle_id())
+
     def filter(self, predicate: Expr) -> Self:
         """
         Filter a single column.
 
         Mostly useful in an aggregation context. If you want to filter on a DataFrame
         level, use `LazyFrame.filter`.
```

### Comparing `polars_u64_idx-0.18.6/polars/expr/list.py` & `polars_u64_idx-0.18.7/polars/expr/list.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/expr/meta.py` & `polars_u64_idx-0.18.7/polars/expr/meta.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/expr/string.py` & `polars_u64_idx-0.18.7/polars/expr/string.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/expr/struct.py` & `polars_u64_idx-0.18.7/polars/expr/struct.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/functions/__init__.py` & `polars_u64_idx-0.18.7/polars/functions/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,96 +1,114 @@
+from polars.functions.aggregation import (
+    all,
+    all_horizontal,
+    any,
+    any_horizontal,
+    cumsum,
+    cumsum_horizontal,
+    max,
+    max_horizontal,
+    min,
+    min_horizontal,
+    sum,
+    sum_horizontal,
+)
 from polars.functions.as_datatype import (
     concat_list,
     concat_str,
     duration,
     format,
     struct,
 )
 from polars.functions.as_datatype import date_ as date
 from polars.functions.as_datatype import datetime_ as datetime
 from polars.functions.as_datatype import time_ as time
 from polars.functions.eager import align_frames, concat
 from polars.functions.lazy import (
-    all,
-    any,
     apply,
     approx_unique,
     arg_sort_by,
     arg_where,
     avg,
     coalesce,
     col,
     collect_all,
     corr,
     count,
     cov,
     cumfold,
     cumreduce,
-    cumsum,
     element,
     exclude,
     first,
     fold,
     from_epoch,
     groups,
     head,
     implode,
     last,
     lit,
     map,
-    max,
     mean,
     median,
-    min,
     n_unique,
     quantile,
     reduce,
     rolling_corr,
     rolling_cov,
     select,
     sql_expr,
     std,
-    sum,
     tail,
     var,
 )
 from polars.functions.range import arange, date_range, int_range, int_ranges, time_range
 from polars.functions.repeat import ones, repeat, zeros
 from polars.functions.whenthen import when
 
 __all__ = [
+    # polars.functions.aggregation
+    "all",
+    "any",
+    "cumsum",
+    "max",
+    "min",
+    "sum",
+    "all_horizontal",
+    "any_horizontal",
+    "cumsum_horizontal",
+    "max_horizontal",
+    "min_horizontal",
+    "sum_horizontal",
     # polars.functions.eager
     "align_frames",
     "approx_unique",
     "arg_where",
     "concat",
     "date_range",
     "element",
     "ones",
     "repeat",
     "time_range",
     "zeros",
     # polars.functions.lazy
-    "all",
-    "any",
     "apply",
     "arange",
     "arg_sort_by",
     "avg",
     "coalesce",
     "col",
     "collect_all",
     "concat_list",
     "concat_str",
     "corr",
     "count",
     "cov",
     "cumfold",
     "cumreduce",
-    "cumsum",
     "date",  # named date_, see import above
     "datetime",  # named datetime_, see import above
     "duration",
     "exclude",
     "first",
     "fold",
     "format",
@@ -99,27 +117,24 @@
     "head",
     "implode",
     "int_range",
     "int_ranges",
     "last",
     "lit",
     "map",
-    "max",
     "mean",
     "median",
-    "min",
     "n_unique",
     "quantile",
     "reduce",
     "rolling_corr",
     "rolling_cov",
     "select",
     "std",
     "struct",
-    "sum",
     "tail",
     "time",
     "var",
     # polars.functions.whenthen
     "when",
     "sql_expr",
 ]
```

### Comparing `polars_u64_idx-0.18.6/polars/functions/as_datatype.py` & `polars_u64_idx-0.18.7/polars/functions/as_datatype.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/functions/eager.py` & `polars_u64_idx-0.18.7/polars/functions/eager.py`

 * *Files 0% similar despite different names*

```diff
@@ -315,15 +315,15 @@
     #             
     #  1.0  1.5         1.0  12.0        2.0   2.5  
     #             
     ...
 
     Now data is aligned, and you can easily calculate the row-wise dot product:
 
-    >>> (af1 * af2 * af3).fill_null(0).select(pl.sum(pl.col("*")).alias("dot"))
+    >>> (af1 * af2 * af3).fill_null(0).select(pl.sum_horizontal("*").alias("dot"))
     shape: (3, 1)
     
      dot   
      ---   
      f64   
     
      0.0   
```

### Comparing `polars_u64_idx-0.18.6/polars/functions/lazy.py` & `polars_u64_idx-0.18.7/polars/functions/lazy.py`

 * *Files 9% similar despite different names*

```diff
@@ -8,45 +8,42 @@
 from polars.datatypes import (
     DTYPE_TEMPORAL_UNITS,
     Date,
     Datetime,
     Duration,
     Int64,
     Time,
-    UInt32,
     is_polars_dtype,
 )
 from polars.dependencies import _check_for_numpy
 from polars.dependencies import numpy as np
 from polars.utils._parse_expr_input import (
     parse_as_expression,
     parse_as_list_of_expressions,
 )
 from polars.utils._wrap import wrap_df, wrap_expr
 from polars.utils.convert import (
     _datetime_to_pl_timestamp,
     _time_to_pl_time,
     _timedelta_to_pl_timedelta,
 )
-from polars.utils.decorators import deprecated_alias
 
 with contextlib.suppress(ImportError):  # Module not available when building docs
     import polars.polars as plr
 
 
 if TYPE_CHECKING:
     from typing import Literal
 
     from polars import DataFrame, Expr, LazyFrame, Series
     from polars.type_aliases import (
         CorrelationMethod,
         EpochTimeUnit,
         IntoExpr,
         PolarsDataType,
-        PythonLiteral,
         RollingInterpolationMethod,
         TimeUnit,
     )
 
 
 def col(
     name: str | PolarsDataType | Iterable[str] | Iterable[PolarsDataType],
@@ -425,322 +422,14 @@
     """
     if isinstance(column, pl.Series):
         return column.var(ddof)
     return col(column).var(ddof)
 
 
 @overload
-def max(exprs: Series) -> PythonLiteral | None:  # type: ignore[misc]
-    ...
-
-
-@overload
-def max(exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr) -> Expr:
-    ...
-
-
-def max(exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr) -> Expr | Any:
-    """
-    Get the maximum value.
-
-    If a single string is passed, this is an alias for ``pl.col(name).max()``.
-    If a single Series is passed, this is an alias for ``Series.max()``.
-
-    Otherwise, this function computes the maximum value horizontally across multiple
-    columns.
-
-    Parameters
-    ----------
-    exprs
-        Column(s) to use in the aggregation. Accepts expression input. Strings are
-        parsed as column names, other non-expression inputs are parsed as literals.
-    *more_exprs
-        Additional columns to use in the aggregation, specified as positional arguments.
-
-    Examples
-    --------
-    Get the maximum value by row by passing multiple columns/expressions.
-
-    >>> df = pl.DataFrame(
-    ...     {
-    ...         "a": [1, 8, 3],
-    ...         "b": [4, 5, 2],
-    ...         "c": ["foo", "bar", "foo"],
-    ...     }
-    ... )
-    >>> df.select(pl.max("a", "b"))
-    shape: (3, 1)
-    
-     max 
-     --- 
-     i64 
-    
-     4   
-     8   
-     3   
-    
-
-    Get the maximum value of a column by passing a single column name.
-
-    >>> df.select(pl.max("a"))
-    shape: (1, 1)
-    
-     a   
-     --- 
-     i64 
-    
-     8   
-    
-
-    Get column-wise maximums for multiple columns by passing a regular expression,
-    or call ``.max()`` on a multi-column expression instead.
-
-    >>> df.select(pl.max("^a|b$"))
-    shape: (1, 2)
-    
-     a    b   
-     ---  --- 
-     i64  i64 
-    
-     8    5   
-    
-    >>> df.select(pl.col("a", "b").max())
-    shape: (1, 2)
-    
-     a    b   
-     ---  --- 
-     i64  i64 
-    
-     8    5   
-    
-
-    """
-    if not more_exprs:
-        if isinstance(exprs, pl.Series):
-            return exprs.max()
-        elif isinstance(exprs, str):
-            return col(exprs).max()
-
-    exprs = parse_as_list_of_expressions(exprs, *more_exprs)
-    return wrap_expr(plr.max_exprs(exprs))
-
-
-@overload
-def min(exprs: Series) -> PythonLiteral | None:  # type: ignore[misc]
-    ...
-
-
-@overload
-def min(exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr) -> Expr:
-    ...
-
-
-def min(
-    exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr
-) -> Expr | PythonLiteral | None:
-    """
-    Get the minimum value.
-
-    If a single string is passed, this is an alias for ``pl.col(name).min()``.
-    If a single Series is passed, this is an alias for ``Series.min()``.
-
-    Otherwise, this function computes the minimum value horizontally across multiple
-    columns.
-
-    Parameters
-    ----------
-    exprs
-        Column(s) to use in the aggregation. Accepts expression input. Strings are
-        parsed as column names, other non-expression inputs are parsed as literals.
-    *more_exprs
-        Additional columns to use in the aggregation, specified as positional arguments.
-
-    Examples
-    --------
-    Get the minimum value by row by passing multiple columns/expressions.
-
-    >>> df = pl.DataFrame(
-    ...     {
-    ...         "a": [1, 8, 3],
-    ...         "b": [4, 5, 2],
-    ...         "c": ["foo", "bar", "foo"],
-    ...     }
-    ... )
-    >>> df.select(pl.min("a", "b"))
-    shape: (3, 1)
-    
-     min 
-     --- 
-     i64 
-    
-     1   
-     5   
-     2   
-    
-
-    Get the minimum value of a column by passing a single column name.
-
-    >>> df.select(pl.min("a"))
-    shape: (1, 1)
-    
-     a   
-     --- 
-     i64 
-    
-     1   
-    
-
-    Get column-wise minimums for multiple columns by passing a regular expression,
-    or call ``.min()`` on a multi-column expression instead.
-
-    >>> df.select(pl.min("^a|b$"))
-    shape: (1, 2)
-    
-     a    b   
-     ---  --- 
-     i64  i64 
-    
-     1    2   
-    
-    >>> df.select(pl.col("a", "b").min())
-    shape: (1, 2)
-    
-     a    b   
-     ---  --- 
-     i64  i64 
-    
-     1    2   
-    
-
-    """
-    if not more_exprs:
-        if isinstance(exprs, pl.Series):
-            return exprs.min()
-        elif isinstance(exprs, str):
-            return col(exprs).min()
-
-    exprs = parse_as_list_of_expressions(exprs, *more_exprs)
-    return wrap_expr(plr.min_exprs(exprs))
-
-
-@overload
-def sum(exprs: Series) -> int | float:  # type: ignore[misc]
-    ...
-
-
-@overload
-def sum(exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr) -> Expr:
-    ...
-
-
-@deprecated_alias(column="exprs")
-def sum(
-    exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr
-) -> Expr | int | float:
-    """
-    Sum all values.
-
-    If a single string is passed, this is an alias for ``pl.col(name).sum()``.
-    If a single Series is passed, this is an alias for ``Series.sum()``.
-
-    Otherwise, this function computes the sum horizontally across multiple columns.
-
-    Parameters
-    ----------
-    exprs
-        Column(s) to use in the aggregation. Accepts expression input. Strings are
-        parsed as column names, other non-expression inputs are parsed as literals.
-    *more_exprs
-        Additional columns to use in the aggregation, specified as positional arguments.
-
-    Examples
-    --------
-    >>> df = pl.DataFrame(
-    ...     {
-    ...         "a": [1, 2],
-    ...         "b": [3, 4],
-    ...         "c": [5, 6],
-    ...     }
-    ... )
-    >>> df
-    shape: (2, 3)
-    
-     a    b    c   
-     ---  ---  --- 
-     i64  i64  i64 
-    
-     1    3    5   
-     2    4    6   
-    
-
-    Sum a column by name:
-
-    >>> df.select(pl.sum("a"))
-    shape: (1, 1)
-    
-     a   
-     --- 
-     i64 
-    
-     3   
-    
-
-    Sum a list of columns/expressions horizontally:
-
-    >>> df.with_columns(pl.sum("a", "c"))
-    shape: (2, 4)
-    
-     a    b    c    sum 
-     ---  ---  ---  --- 
-     i64  i64  i64  i64 
-    
-     1    3    5    6   
-     2    4    6    8   
-    
-
-    Sum a series:
-
-    >>> pl.sum(df.get_column("a"))
-    3
-
-    To aggregate the sums for more than one column/expression use ``pl.col(list).sum()``
-    or a regular expression selector like ``pl.sum(regex)``:
-
-    >>> df.select(pl.col("a", "c").sum())
-    shape: (1, 2)
-    
-     a    c   
-     ---  --- 
-     i64  i64 
-    
-     3    11  
-    
-
-    >>> df.select(pl.sum("^.*[bc]$"))
-    shape: (1, 2)
-    
-     b    c   
-     ---  --- 
-     i64  i64 
-    
-     7    11  
-    
-
-    """
-    if not more_exprs:
-        if isinstance(exprs, pl.Series):
-            return exprs.sum()
-        elif isinstance(exprs, str):
-            return col(exprs).sum()
-
-    exprs = parse_as_list_of_expressions(exprs, *more_exprs)
-    return wrap_expr(plr.sum_exprs(exprs))
-
-
-@overload
 def mean(column: str) -> Expr:
     ...
 
 
 @overload
 def mean(column: Series) -> float:
     ...
@@ -1268,107 +957,14 @@
                 )
 
     except AttributeError:
         item = value
     return wrap_expr(plr.lit(item, allow_object))
 
 
-@overload
-def cumsum(exprs: Series) -> Series:  # type: ignore[misc]
-    ...
-
-
-@overload
-def cumsum(exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr) -> Expr:
-    ...
-
-
-@deprecated_alias(column="exprs")
-def cumsum(
-    exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr
-) -> Expr | Series:
-    """
-    Cumulatively sum all values.
-
-    If a single string is passed, this is an alias for ``pl.col(name).cumsum()``.
-    If a single Series is passed, this is an alias for ``Series.cumsum()``.
-
-    Otherwise, this function computes the cumulative sum horizontally across multiple
-    columns.
-
-    Parameters
-    ----------
-    exprs
-        Column(s) to use in the aggregation. Accepts expression input. Strings are
-        parsed as column names, other non-expression inputs are parsed as literals.
-    *more_exprs
-        Additional columns to use in the aggregation, specified as positional arguments.
-
-    Examples
-    --------
-    >>> df = pl.DataFrame(
-    ...     {
-    ...         "a": [1, 2],
-    ...         "b": [3, 4],
-    ...         "c": [5, 6],
-    ...     }
-    ... )
-    >>> df
-    shape: (2, 3)
-    
-     a    b    c   
-     ---  ---  --- 
-     i64  i64  i64 
-    
-     1    3    5   
-     2    4    6   
-    
-
-    Cumulatively sum a column by name:
-
-    >>> df.select(pl.cumsum("a"))
-    shape: (2, 1)
-    
-     a   
-     --- 
-     i64 
-    
-     1   
-     3   
-    
-
-    Cumulatively sum a list of columns/expressions horizontally:
-
-    >>> df.with_columns(pl.cumsum("a", "c"))
-    shape: (2, 4)
-    
-     a    b    c    cumsum    
-     ---  ---  ---  ---       
-     i64  i64  i64  struct[2] 
-    
-     1    3    5    {1,6}     
-     2    4    6    {2,8}     
-    
-
-    """
-    if not more_exprs:
-        if isinstance(exprs, pl.Series):
-            return exprs.cumsum()
-        elif isinstance(exprs, str):
-            return col(exprs).cumsum()
-
-    pyexprs = parse_as_list_of_expressions(exprs, *more_exprs)
-    exprs_wrapped = [wrap_expr(e) for e in pyexprs]
-
-    # (Expr): use u32 as that will not cast to float as eagerly
-    return cumfold(lit(0).cast(UInt32), lambda a, b: a + b, exprs_wrapped).alias(
-        "cumsum"
-    )
-
-
 def corr(
     a: str | Expr,
     b: str | Expr,
     *,
     method: CorrelationMethod = "pearson",
     ddof: int = 1,
     propagate_nans: bool = False,
@@ -1920,195 +1516,14 @@
     if isinstance(exprs, pl.Expr):
         exprs = [exprs]
 
     exprs = parse_as_list_of_expressions(exprs)
     return wrap_expr(plr.cumreduce(function, exprs))
 
 
-@overload
-def any(exprs: Series) -> bool:  # type: ignore[misc]
-    ...
-
-
-@overload
-def any(exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr) -> Expr:
-    ...
-
-
-@deprecated_alias(columns="exprs")
-def any(exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr) -> Expr | bool:
-    """
-    Evaluate a bitwise OR operation.
-
-    If a single string is passed, this is an alias for ``pl.col(name).any()``.
-    If a single Series is passed, this is an alias for ``Series.any()``.
-
-    Otherwise, this function computes the bitwise OR horizontally across multiple
-    columns.
-
-    Parameters
-    ----------
-    exprs
-        Column(s) to use in the aggregation. Accepts expression input. Strings are
-        parsed as column names, other non-expression inputs are parsed as literals.
-    *more_exprs
-        Additional columns to use in the aggregation, specified as positional arguments.
-
-    Examples
-    --------
-    >>> df = pl.DataFrame(
-    ...     {
-    ...         "a": [True, False, True],
-    ...         "b": [False, False, False],
-    ...         "c": [False, True, False],
-    ...     }
-    ... )
-    >>> df
-    shape: (3, 3)
-    
-     a      b      c     
-     ---    ---    ---   
-     bool   bool   bool  
-    
-     true   false  false 
-     false  false  true  
-     true   false  false 
-    
-
-    Compares the values (in binary format) and return true if any value in the column
-    is true.
-
-    >>> df.select(pl.any("*"))
-    shape: (1, 3)
-    
-     a     b      c    
-     ---   ---    ---  
-     bool  bool   bool 
-    
-     true  false  true 
-    
-
-    Across multiple columns:
-
-    >>> df.select(pl.any("a", "b"))
-    shape: (3, 1)
-    
-     any   
-     ---   
-     bool  
-    
-     true  
-     false 
-     true  
-    
-
-    """
-    if not more_exprs:
-        if isinstance(exprs, pl.Series):
-            return exprs.any()
-        elif isinstance(exprs, str):
-            return col(exprs).any()
-
-    pyexprs = parse_as_list_of_expressions(exprs, *more_exprs)
-    exprs_wrapped = [wrap_expr(e) for e in pyexprs]
-
-    return fold(
-        lit(False), lambda a, b: a.cast(bool) | b.cast(bool), exprs_wrapped
-    ).alias("any")
-
-
-@overload
-def all(exprs: Series) -> bool:  # type: ignore[misc]
-    ...
-
-
-@overload
-def all(
-    exprs: IntoExpr | Iterable[IntoExpr] | None = ..., *more_exprs: IntoExpr
-) -> Expr:
-    ...
-
-
-@deprecated_alias(columns="exprs")
-def all(
-    exprs: IntoExpr | Iterable[IntoExpr] | None = None, *more_exprs: IntoExpr
-) -> Expr | bool:
-    """
-    Either return an expression representing all columns, or evaluate a bitwise AND operation.
-
-    If no arguments are passed, this is an alias for ``pl.col("*")``.
-    If a single string is passed, this is an alias for ``pl.col(name).any()``.
-    If a single Series is passed, this is an alias for ``Series.any()``.
-
-    Otherwise, this function computes the bitwise AND horizontally across multiple
-    columns.
-
-    Parameters
-    ----------
-    exprs
-        Column(s) to use in the aggregation. Accepts expression input. Strings are
-        parsed as column names, other non-expression inputs are parsed as literals.
-    *more_exprs
-        Additional columns to use in the aggregation, specified as positional arguments.
-
-    Examples
-    --------
-    Selecting all columns and calculating the sum:
-
-    >>> df = pl.DataFrame(
-    ...     {"a": [1, 2, 3], "b": ["hello", "foo", "bar"], "c": [1, 1, 1]}
-    ... )
-    >>> df.select(pl.all().sum())
-    shape: (1, 3)
-    
-     a    b     c   
-     ---  ---   --- 
-     i64  str   i64 
-    
-     6    null  3   
-    
-
-    Bitwise AND across multiple columns:
-
-    >>> df = pl.DataFrame(
-    ...     {
-    ...         "a": [True, False, True],
-    ...         "b": [True, False, False],
-    ...         "c": [False, True, False],
-    ...     }
-    ... )
-    >>> df.select(pl.all("a", "b"))
-    shape: (3, 1)
-    
-     all   
-     ---   
-     bool  
-    
-     true  
-     false 
-     false 
-    
-
-    """  # noqa: W505
-    if not more_exprs:
-        if exprs is None:
-            return col("*")
-        elif isinstance(exprs, pl.Series):
-            return exprs.all()
-        elif isinstance(exprs, str):
-            return col(exprs).all()
-
-    pyexprs = parse_as_list_of_expressions(exprs, *more_exprs)
-    exprs_wrapped = [wrap_expr(e) for e in pyexprs]
-
-    return fold(
-        lit(True), lambda a, b: a.cast(bool) & b.cast(bool), exprs_wrapped
-    ).alias("all")
-
-
 def exclude(
     columns: str | PolarsDataType | Iterable[str] | Iterable[PolarsDataType],
     *more_columns: str | PolarsDataType,
 ) -> Expr:
     """
     Represent all columns except for the given columns.
 
@@ -2365,15 +1780,15 @@
     -------
     DataFrame
 
     Examples
     --------
     >>> foo = pl.Series("foo", [1, 2, 3])
     >>> bar = pl.Series("bar", [3, 2, 1])
-    >>> pl.select(pl.min([foo, bar]))
+    >>> pl.select(pl.min_horizontal(foo, bar))
     shape: (3, 1)
     
      min 
      --- 
      i64 
     
      1   
```

### Comparing `polars_u64_idx-0.18.6/polars/functions/range.py` & `polars_u64_idx-0.18.7/polars/functions/range.py`

 * *Files 3% similar despite different names*

```diff
@@ -78,16 +78,19 @@
     *,
     dtype: PolarsDataType | None = None,
     eager: bool = False,
 ) -> Expr | Series:
     """
     Generate a range of integers.
 
-    This can be used in a ``select``, ``with_columns`` etc. Be sure that the resulting
-    range size is equal to the length of the DataFrame you are collecting.
+    .. deprecated:: 0.18.5
+        ``arange`` has been replaced by two new functions: ``int_range`` for generating
+        a single range, and ``int_ranges`` for generating a list column with multiple
+        ranges. ``arange`` will remain available as an alias for `int_range`, which
+        means it will lose the functionality to generate multiple ranges.
 
     Parameters
     ----------
     start
         Lower bound of the range (inclusive).
     end
         Upper bound of the range (exclusive).
@@ -95,14 +98,19 @@
         Step size of the range.
     dtype
         Data type of the resulting column. Defaults to ``Int64``.
     eager
         Evaluate immediately and return a ``Series``. If set to ``False`` (default),
         return an expression instead.
 
+    See Also
+    --------
+    int_range : Generate a range of integers.
+    int_ranges : Generate a range of integers for each row of the input columns.
+
     Examples
     --------
     >>> pl.arange(0, 3, eager=True)
     shape: (3,)
     Series: 'arange' [i64]
     [
             0
@@ -137,82 +145,92 @@
 
 @overload
 def int_range(
     start: int | IntoExpr,
     end: int | IntoExpr,
     step: int = ...,
     *,
+    dtype: PolarsIntegerType = ...,
     eager: Literal[False] = ...,
 ) -> Expr:
     ...
 
 
 @overload
 def int_range(
     start: int | IntoExpr,
     end: int | IntoExpr,
     step: int = ...,
     *,
+    dtype: PolarsIntegerType = ...,
     eager: Literal[True],
 ) -> Series:
     ...
 
 
 @overload
 def int_range(
     start: int | IntoExpr,
     end: int | IntoExpr,
     step: int = ...,
     *,
+    dtype: PolarsIntegerType = ...,
     eager: bool,
 ) -> Expr | Series:
     ...
 
 
 def int_range(
     start: int | IntoExpr,
     end: int | IntoExpr,
     step: int = 1,
     *,
+    dtype: PolarsIntegerType = Int64,
     eager: bool = False,
 ) -> Expr | Series:
     """
     Generate a range of integers.
 
     Parameters
     ----------
     start
         Lower bound of the range (inclusive).
     end
         Upper bound of the range (exclusive).
     step
         Step size of the range.
+    dtype
+        Data type of the range. Defaults to ``Int64``.
     eager
         Evaluate immediately and return a ``Series``. If set to ``False`` (default),
         return an expression instead.
 
     Returns
     -------
     Column of data type ``Int64``.
 
+    See Also
+    --------
+    int_ranges : Generate a range of integers for each row of the input columns.
+
     Examples
     --------
     >>> pl.int_range(0, 3, eager=True)
     shape: (3,)
     Series: 'int' [i64]
     [
             0
             1
             2
     ]
 
     """
     start = parse_as_expression(start)
     end = parse_as_expression(end)
-    result = wrap_expr(plr.int_range(start, end, step))
+    result = wrap_expr(plr.int_range(start, end, step, dtype))
 
     if eager:
         return F.select(result).to_series()
 
     return result
 
 
@@ -277,14 +295,18 @@
         Evaluate immediately and return a ``Series``. If set to ``False`` (default),
         return an expression instead.
 
     Returns
     -------
     Column of data type ``List(dtype)``.
 
+    See Also
+    --------
+    int_range : Generate a single range of integers.
+
     Examples
     --------
     >>> df = pl.DataFrame({"start": [1, -1], "end": [3, 2]})
     >>> df.with_columns(pl.int_ranges("start", "end"))
     shape: (2, 3)
     
      start  end  int_range  
```

### Comparing `polars_u64_idx-0.18.6/polars/functions/repeat.py` & `polars_u64_idx-0.18.7/polars/functions/repeat.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/functions/whenthen.py` & `polars_u64_idx-0.18.7/polars/functions/whenthen.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/io/__init__.py` & `polars_u64_idx-0.18.7/polars/io/__init__.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/io/_utils.py` & `polars_u64_idx-0.18.7/polars/io/_utils.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/io/avro.py` & `polars_u64_idx-0.18.7/polars/io/avro.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/io/csv/_utils.py` & `polars_u64_idx-0.18.7/polars/io/csv/_utils.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/io/csv/batched_reader.py` & `polars_u64_idx-0.18.7/polars/io/csv/batched_reader.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/io/csv/functions.py` & `polars_u64_idx-0.18.7/polars/io/csv/functions.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/io/database.py` & `polars_u64_idx-0.18.7/polars/io/database.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/io/delta.py` & `polars_u64_idx-0.18.7/polars/io/delta.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/io/excel/_write_utils.py` & `polars_u64_idx-0.18.7/polars/io/excel/_write_utils.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/io/excel/functions.py` & `polars_u64_idx-0.18.7/polars/io/excel/functions.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/io/ipc/anonymous_scan.py` & `polars_u64_idx-0.18.7/polars/io/ipc/anonymous_scan.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/io/ipc/functions.py` & `polars_u64_idx-0.18.7/polars/io/ipc/functions.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/io/ndjson.py` & `polars_u64_idx-0.18.7/polars/io/ndjson.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/io/parquet/anonymous_scan.py` & `polars_u64_idx-0.18.7/polars/io/parquet/anonymous_scan.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/io/parquet/functions.py` & `polars_u64_idx-0.18.7/polars/io/parquet/functions.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/io/pyarrow_dataset/anonymous_scan.py` & `polars_u64_idx-0.18.7/polars/io/pyarrow_dataset/anonymous_scan.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/io/pyarrow_dataset/functions.py` & `polars_u64_idx-0.18.7/polars/io/pyarrow_dataset/functions.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/lazyframe/frame.py` & `polars_u64_idx-0.18.7/polars/lazyframe/frame.py`

 * *Files 0% similar despite different names*

```diff
@@ -1026,14 +1026,15 @@
 
     def sort(
         self,
         by: IntoExpr | Iterable[IntoExpr],
         *more_by: IntoExpr,
         descending: bool | Sequence[bool] = False,
         nulls_last: bool = False,
+        maintain_order: bool = False,
     ) -> Self:
         """
         Sort the dataframe by the given columns.
 
         Parameters
         ----------
         by
@@ -1042,14 +1043,18 @@
         *more_by
             Additional columns to sort by, specified as positional arguments.
         descending
             Sort in descending order. When sorting by multiple columns, can be specified
             per column by passing a sequence of booleans.
         nulls_last
             Place null values last.
+        maintain_order
+            Whether the order should be maintained if elements are equal.
+            Note that if `true` streaming is not possible and performance might be
+            worse since this requires a stable search.
 
         Examples
         --------
         Pass a single column name to sort by that column.
 
         >>> lf = pl.LazyFrame(
         ...     {
@@ -1111,33 +1116,38 @@
          null  4.0  b   
          2     5.0  c   
         
 
         """
         # Fast path for sorting by a single existing column
         if isinstance(by, str) and not more_by:
-            return self._from_pyldf(self._ldf.sort(by, descending, nulls_last))
+            return self._from_pyldf(
+                self._ldf.sort(by, descending, nulls_last, maintain_order)
+            )
 
         by = parse_as_list_of_expressions(by, *more_by)
 
         if isinstance(descending, bool):
             descending = [descending]
         elif len(by) != len(descending):
             raise ValueError(
                 f"the length of `descending` ({len(descending)}) does not match the length of `by` ({len(by)})"
             )
-        return self._from_pyldf(self._ldf.sort_by_exprs(by, descending, nulls_last))
+        return self._from_pyldf(
+            self._ldf.sort_by_exprs(by, descending, nulls_last, maintain_order)
+        )
 
     def top_k(
         self,
         k: int,
         *,
         by: IntoExpr | Iterable[IntoExpr],
         descending: bool | Sequence[bool] = False,
         nulls_last: bool = False,
+        maintain_order: bool = False,
     ) -> Self:
         """
         Return the `k` largest elements.
 
         If 'descending=True` the smallest elements will be given.
 
         Parameters
@@ -1148,14 +1158,18 @@
             Column(s) included in sort order. Accepts expression input.
             Strings are parsed as column names.
         descending
             Return the 'k' smallest. Top-k by multiple columns can be specified
             per column by passing a sequence of booleans.
         nulls_last
             Place null values last.
+        maintain_order
+            Whether the order should be maintained if elements are equal.
+            Note that if `true` streaming is not possible and performance might
+            be worse since this requires a stable search.
 
         See Also
         --------
         bottom_k
 
         Examples
         --------
@@ -1200,23 +1214,26 @@
         by = parse_as_list_of_expressions(by)
         if isinstance(descending, bool):
             descending = [descending]
         elif len(by) != len(descending):
             raise ValueError(
                 f"the length of `descending` ({len(descending)}) does not match the length of `by` ({len(by)})"
             )
-        return self._from_pyldf(self._ldf.top_k(k, by, descending, nulls_last))
+        return self._from_pyldf(
+            self._ldf.top_k(k, by, descending, nulls_last, maintain_order)
+        )
 
     def bottom_k(
         self,
         k: int,
         *,
         by: IntoExpr | Iterable[IntoExpr],
         descending: bool | Sequence[bool] = False,
         nulls_last: bool = False,
+        maintain_order: bool = False,
     ) -> Self:
         """
         Return the `k` smallest elements.
 
         If 'descending=True` the largest elements will be given.
 
         Parameters
@@ -1227,14 +1244,18 @@
             Column(s) included in sort order. Accepts expression input.
             Strings are parsed as column names.
         descending
             Return the 'k' smallest. Top-k by multiple columns can be specified
             per column by passing a sequence of booleans.
         nulls_last
             Place null values last.
+        maintain_order
+            Whether the order should be maintained if elements are equal.
+            Note that if `true` streaming is not possible and performance might be
+            worse since this requires a stable search.
 
         See Also
         --------
         top_k
 
         Examples
         --------
@@ -1275,15 +1296,17 @@
          b    2   
         
 
         """
         by = parse_as_list_of_expressions(by)
         if isinstance(descending, bool):
             descending = [descending]
-        return self._from_pyldf(self._ldf.bottom_k(k, by, descending, nulls_last))
+        return self._from_pyldf(
+            self._ldf.bottom_k(k, by, descending, nulls_last, maintain_order)
+        )
 
     def profile(
         self,
         *,
         type_coercion: bool = True,
         predicate_pushdown: bool = True,
         projection_pushdown: bool = True,
@@ -2603,15 +2626,15 @@
          b       2021-12-16 02:00:00  2021-12-16 03:00:00  2021-12-16 02:00:00  1          
         
 
         Dynamic groupby on an index column
 
         >>> lf = pl.LazyFrame(
         ...     {
-        ...         "idx": pl.arange(0, 6, eager=True),
+        ...         "idx": pl.int_range(0, 6, eager=True),
         ...         "A": ["A", "A", "B", "B", "B", "C"],
         ...     }
         ... )
         >>> lf.groupby_dynamic(
         ...     "idx",
         ...     every="2i",
         ...     period="3i",
@@ -4417,15 +4440,15 @@
          null  2     null 
          null  null  null 
          null  1     1    
         
 
         Drop a row only if all values are null:
 
-        >>> lf.filter(~pl.all(pl.all().is_null())).collect()
+        >>> lf.filter(~pl.all_horizontal(pl.all().is_null())).collect()
         shape: (3, 3)
         
          a     b    c    
          ---   ---  ---  
          f32   i64  i64  
         
          null  1    1    
```

### Comparing `polars_u64_idx-0.18.6/polars/lazyframe/groupby.py` & `polars_u64_idx-0.18.7/polars/lazyframe/groupby.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/selectors.py` & `polars_u64_idx-0.18.7/polars/selectors.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,14 +9,15 @@
 from polars.datatypes import (
     FLOAT_DTYPES,
     INTEGER_DTYPES,
     NUMERIC_DTYPES,
     TEMPORAL_DTYPES,
     Categorical,
     Datetime,
+    Duration,
     Utf8,
     is_polars_dtype,
 )
 
 if TYPE_CHECKING:
     import sys
 
@@ -26,30 +27,28 @@
 
     if sys.version_info >= (3, 11):
         from typing import Self
     else:
         from typing_extensions import Self
 
 
-SelectorType = TypeVar("SelectorType", bound="_selector_proxy_")
-
-
 def is_selector(obj: Any) -> bool:
     """
     Indicate whether the given object/expression is a selector.
 
     Examples
     --------
     >>> from polars.selectors import is_selector
     >>> import polars.selectors as cs
     >>> is_selector(pl.col("colx"))
     False
     >>> is_selector(cs.first() | cs.last())
     True
     """
+    # note: don't want to expose the "_selector_proxy_" object
     return isinstance(obj, _selector_proxy_)
 
 
 def selector_column_names(
     frame: DataFrame | LazyFrame, selector: SelectorType
 ) -> tuple[str, ...]:
     """
@@ -126,52 +125,52 @@
             else:
                 str_params = ",".join(
                     (repr(v)[1:-1] if k.startswith("*") else f"{k}={v!r}")
                     for k, v in (params or {}).items()
                 )
                 return f"cs.{selector_name}({str_params})"
 
-    def __sub__(self, other: Any) -> Expr:  # type: ignore[override]
+    def __sub__(self, other: Any) -> SelectorType | Expr:  # type: ignore[override]
         if isinstance(other, _selector_proxy_) and hasattr(other, "_attrs"):
             return _selector_proxy_(
                 self.meta._as_selector().meta._selector_sub(other),
                 parameters={"self": self, "other": other},
                 name="sub",
             )
         else:
             return self.as_expr().__sub__(other)
 
-    def __and__(self, other: Any) -> Expr:  # type: ignore[override]
+    def __and__(self, other: Any) -> SelectorType | Expr:  # type: ignore[override]
         if isinstance(other, _selector_proxy_) and hasattr(other, "_attrs"):
             return _selector_proxy_(
                 self.meta._as_selector().meta._selector_and(other),
                 parameters={"self": self, "other": other},
                 name="and",
             )
         else:
             return self.as_expr().__and__(other)
 
-    def __or__(self, other: Any) -> Expr:  # type: ignore[override]
+    def __or__(self, other: Any) -> SelectorType | Expr:  # type: ignore[override]
         if isinstance(other, _selector_proxy_) and hasattr(other, "_attrs"):
             return _selector_proxy_(
                 self.meta._as_selector().meta._selector_add(other),
                 parameters={"self": self, "other": other},
                 name="or",
             )
         else:
             return self.as_expr().__or__(other)
 
-    def __rand__(self, other: Any) -> Expr:  # type: ignore[override]
+    def __rand__(self, other: Any) -> SelectorType | Expr:  # type: ignore[override]
         # order of operation doesn't matter
         if isinstance(other, _selector_proxy_) and hasattr(other, "_attrs"):
             return self.__and__(other)
         else:
             return self.as_expr().__rand__(other)
 
-    def __ror__(self, other: Any) -> Expr:  # type: ignore[override]
+    def __ror__(self, other: Any) -> SelectorType | Expr:  # type: ignore[override]
         # order of operation doesn't matter
         if isinstance(other, _selector_proxy_) and hasattr(other, "_attrs"):
             return self.__or__(other)
         else:
             return self.as_expr().__ror__(other)
 
     def as_expr(self) -> Expr:
@@ -195,15 +194,18 @@
                 strings.extend(st)
             else:
                 strings.append(st)
         rx = "|".join(re.escape(x) for x in strings)
     return f"({rx})"
 
 
-def all() -> Expr:
+SelectorType = TypeVar("SelectorType", Expr, _selector_proxy_)
+
+
+def all() -> SelectorType:
     """
     Select all columns.
 
     Examples
     --------
     >>> from datetime import date
     >>> import polars.selectors as cs
@@ -248,15 +250,15 @@
 
     """
     return _selector_proxy_(F.all(), name="all")
 
 
 def by_dtype(
     *dtypes: PolarsDataType | Collection[PolarsDataType],
-) -> Expr:
+) -> SelectorType:
     """
     Select all columns matching the given dtypes.
 
     Examples
     --------
     >>> from datetime import date
     >>> import polars.selectors as cs
@@ -330,15 +332,15 @@
             raise TypeError(f"Invalid dtype: {tp!r}")
 
     return _selector_proxy_(
         F.col(*all_dtypes), name="by_dtype", parameters={"dtypes": all_dtypes}
     )
 
 
-def by_name(*names: str | Collection[str]) -> Expr:
+def by_name(*names: str | Collection[str]) -> SelectorType:
     """
     Select all columns matching the given names.
 
     Parameters
     ----------
     *names
         One or more names of columns to select.
@@ -399,15 +401,15 @@
             TypeError(f"Invalid name: {nm!r}")
 
     return _selector_proxy_(
         F.col(*all_names), name="by_name", parameters={"*names": all_names}
     )
 
 
-def contains(substring: str | Collection[str]) -> Expr:
+def contains(substring: str | Collection[str]) -> SelectorType:
     """
     Select columns that contain the given literal substring(s).
 
     Parameters
     ----------
     substring
         Substring(s) that matching column names should contain.
@@ -482,17 +484,17 @@
 
 def datetime(
     time_unit: TimeUnit | Collection[TimeUnit] | None = None,
     time_zone: (str | timezone | Collection[str | timezone | None] | None) = (
         "*",
         None,
     ),
-) -> Expr:
+) -> SelectorType:
     """
-    Select all datetime columns, optionally filtering by timeunit/timezone.
+    Select all datetime columns, optionally filtering by time unit/zone.
 
     Parameters
     ----------
     time_unit
         One (or more) of the allowed timeunit precision strings, "ms", "us", and "ns".
         Omit to select columns with any valid timeunit.
     time_zone
@@ -602,15 +604,15 @@
      date       
     
      1999-12-31 
      2010-07-05 
     
 
     """  # noqa: W505
-    if not time_unit or time_unit == "*":
+    if time_unit is None:
         time_unit = ["ms", "us", "ns"]
     else:
         time_unit = [time_unit] if isinstance(time_unit, str) else list(time_unit)
 
     if time_zone is None:
         time_zone = [None]
     elif time_zone:
@@ -626,15 +628,120 @@
     return _selector_proxy_(
         F.col(datetime_dtypes),
         name="datetime",
         parameters={"time_unit": time_unit, "time_zone": time_zone},
     )
 
 
-def ends_with(*suffix: str) -> Expr:
+def duration(
+    time_unit: TimeUnit | Collection[TimeUnit] | None = None,
+) -> SelectorType:
+    """
+    Select all duration columns, optionally filtering by time unit.
+
+    Parameters
+    ----------
+    time_unit
+        One (or more) of the allowed timeunit precision strings, "ms", "us", and "ns".
+        Omit to select columns with any valid timeunit.
+
+    Examples
+    --------
+    >>> from datetime import date, timedelta
+    >>> import polars.selectors as cs
+    >>> df = pl.DataFrame(
+    ...     {
+    ...         "dt": [date(2022, 1, 31), date(2025, 7, 5)],
+    ...         "td1": [
+    ...             timedelta(days=1, milliseconds=123456),
+    ...             timedelta(days=1, hours=23, microseconds=987000),
+    ...         ],
+    ...         "td2": [
+    ...             timedelta(days=7, microseconds=456789),
+    ...             timedelta(days=14, minutes=999, seconds=59),
+    ...         ],
+    ...         "td3": [
+    ...             timedelta(weeks=4, days=-10, microseconds=999999),
+    ...             timedelta(weeks=3, milliseconds=123456, microseconds=1),
+    ...         ],
+    ...     },
+    ...     schema_overrides={
+    ...         "td1": pl.Duration("ms"),
+    ...         "td2": pl.Duration("us"),
+    ...         "td3": pl.Duration("ns"),
+    ...     },
+    ... )
+
+    Select all duration columns:
+
+    >>> df.select(cs.duration())
+    shape: (2, 3)
+    
+     td1             td2              td3                
+     ---             ---              ---                
+     duration[ms]    duration[s]     duration[ns]       
+    
+     1d 2m 3s 456ms  7d 456789s      18d 999999s       
+     1d 23h 987ms    14d 16h 39m 59s  21d 2m 3s 456001s 
+    
+
+    Select all duration columns that have 'ms' precision:
+
+    >>> df.select(cs.duration("ms"))
+    shape: (2, 1)
+    
+     td1            
+     ---            
+     duration[ms]   
+    
+     1d 2m 3s 456ms 
+     1d 23h 987ms   
+    
+
+    Select all duration columns that have 'ms' OR 'ns' precision:
+
+    >>> df.select(cs.duration(["ms", "ns"]))
+    shape: (2, 2)
+    
+     td1             td3                
+     ---             ---                
+     duration[ms]    duration[ns]       
+    
+     1d 2m 3s 456ms  18d 999999s       
+     1d 23h 987ms    21d 2m 3s 456001s 
+    
+
+    Select all columns *except* for duration columns:
+
+    >>> df.select(~cs.duration())
+    shape: (2, 1)
+    
+     dt         
+     ---        
+     date       
+    
+     2022-01-31 
+     2025-07-05 
+    
+
+    """
+    if time_unit is None:
+        time_unit = ["ms", "us", "ns"]
+    else:
+        time_unit = [time_unit] if isinstance(time_unit, str) else list(time_unit)
+
+    duration_dtypes = [Duration(tu) for tu in time_unit]
+    return _selector_proxy_(
+        F.col(duration_dtypes),
+        name="duration",
+        parameters={"time_unit": time_unit},
+    )
+
+
+def ends_with(*suffix: str) -> SelectorType:
     """
     Select columns that end with the given substring(s).
 
     Parameters
     ----------
     suffix
         Substring(s) that matching column names should end with.
@@ -703,15 +810,15 @@
     return _selector_proxy_(
         F.col(raw_params),
         name="ends_with",
         parameters={"*suffix": escaped_suffix},
     )
 
 
-def first() -> Expr:
+def first() -> SelectorType:
     """
     Select the first column in the current scope.
 
     Examples
     --------
     >>> import polars.selectors as cs
     >>> df = pl.DataFrame(
@@ -741,15 +848,15 @@
     all : Select all columns.
     last : Select the last column in the current scope.
 
     """
     return _selector_proxy_(F.first(), name="first")
 
 
-def float() -> Expr:
+def float() -> SelectorType:
     """
     Select all float columns.
 
     Examples
     --------
     >>> import polars.selectors as cs
     >>> df = pl.DataFrame(
@@ -798,15 +905,15 @@
     """
     return _selector_proxy_(
         F.col(FLOAT_DTYPES),
         name="float",
     )
 
 
-def integer() -> Expr:
+def integer() -> SelectorType:
     """
     Select all integer columns.
 
     Examples
     --------
     >>> import polars.selectors as cs
     >>> df = pl.DataFrame(
@@ -855,15 +962,15 @@
     """
     return _selector_proxy_(
         F.col(INTEGER_DTYPES),
         name="integer",
     )
 
 
-def last() -> Expr:
+def last() -> SelectorType:
     """
     Select the last column in the current scope.
 
     Examples
     --------
     >>> import polars.selectors as cs
     >>> df = pl.DataFrame(
@@ -893,15 +1000,15 @@
     all : Select all columns.
     first : Select the first column in the current scope.
 
     """
     return _selector_proxy_(F.last(), name="last")
 
 
-def matches(pattern: str) -> Expr:
+def matches(pattern: str) -> SelectorType:
     """
     Select all columns that match the given regex pattern.
 
     Parameters
     ----------
     pattern
         A valid regular expression pattern, compatible with the `regex crate
@@ -967,15 +1074,15 @@
         return _selector_proxy_(
             F.col(raw_params),
             name="matches",
             parameters={"pattern": pattern},
         )
 
 
-def numeric() -> Expr:
+def numeric() -> SelectorType:
     """
     Select all numeric columns.
 
     Examples
     --------
     >>> import polars.selectors as cs
     >>> df = pl.DataFrame(
@@ -1025,15 +1132,15 @@
     """
     return _selector_proxy_(
         F.col(NUMERIC_DTYPES),
         name="numeric",
     )
 
 
-def starts_with(*prefix: str) -> Expr:
+def starts_with(*prefix: str) -> SelectorType:
     """
     Select columns that start with the given substring(s).
 
     Parameters
     ----------
     prefix
         Substring(s) that matching column names should start with.
@@ -1102,15 +1209,15 @@
     return _selector_proxy_(
         F.col(raw_params),
         name="starts_with",
         parameters={"*prefix": prefix},
     )
 
 
-def string(include_categorical: bool = False) -> Expr:
+def string(include_categorical: bool = False) -> SelectorType:
     """
     Select all Utf8 (and, optionally, Categorical) string columns.
 
     Examples
     --------
     >>> import polars.selectors as cs
     >>> df = pl.DataFrame(
@@ -1166,15 +1273,15 @@
 
     return _selector_proxy_(
         F.col(string_dtypes),
         name="string",
     )
 
 
-def temporal() -> Expr:
+def temporal() -> SelectorType:
     """
     Select all temporal columns.
 
     Examples
     --------
     >>> from datetime import date, time
     >>> import polars.selectors as cs
@@ -1242,14 +1349,15 @@
 
 __all__ = [
     "all",
     "by_dtype",
     "by_name",
     "contains",
     "datetime",
+    "duration",
     "ends_with",
     "first",
     "float",
     "integer",
     "last",
     "matches",
     "numeric",
```

### Comparing `polars_u64_idx-0.18.6/polars/series/_numpy.py` & `polars_u64_idx-0.18.7/polars/series/_numpy.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/series/array.py` & `polars_u64_idx-0.18.7/polars/series/array.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/series/binary.py` & `polars_u64_idx-0.18.7/polars/series/binary.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/series/categorical.py` & `polars_u64_idx-0.18.7/polars/series/categorical.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/series/datetime.py` & `polars_u64_idx-0.18.7/polars/series/datetime.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/series/list.py` & `polars_u64_idx-0.18.7/polars/series/list.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/series/series.py` & `polars_u64_idx-0.18.7/polars/series/series.py`

 * *Files 2% similar despite different names*

```diff
@@ -266,15 +266,15 @@
             self._s = sequence_to_pyseries(
                 name, [], dtype=dtype, dtype_if_empty=dtype_if_empty
             )
         elif isinstance(values, Series):
             self._s = series_to_pyseries(name, values)
 
         elif isinstance(values, range):
-            self._s = range_to_series(name, values, dtype=dtype)._s
+            self._s = range_to_series(name, values, dtype=dtype)._s  # type: ignore[arg-type]
 
         elif isinstance(values, Sequence):
             self._s = sequence_to_pyseries(
                 name,
                 values,
                 dtype=dtype,
                 strict=strict,
@@ -865,14 +865,21 @@
 
     def __copy__(self) -> Self:
         return self.clone()
 
     def __deepcopy__(self, memo: None = None) -> Self:
         return self.clone()
 
+    def __contains__(self, item: Any) -> bool:
+        # TODO! optimize via `is_in` and `SORTED` flags
+        try:
+            return (self == item).any()
+        except ValueError:
+            return False
+
     def __iter__(self) -> Generator[Any, None, None]:
         if self.dtype == List:
             # TODO: either make a change and return py-native list data here, or find
             #  a faster way to return nested/List series; sequential 'get_idx' calls
             #  make this path a lot slower (~10x) than it needs to be.
             get_idx = self._s.get_idx
             for idx in range(0, self.len()):
@@ -1600,63 +1607,68 @@
     def cut(
         self,
         bins: list[float],
         labels: list[str] | None = None,
         break_point_label: str = "break_point",
         category_label: str = "category",
         *,
-        maintain_order: bool = False,
-        series: bool = False,
+        series: bool = True,
         left_closed: bool = False,
+        include_breaks: bool = False,
     ) -> DataFrame | Series:
         """
         Bin continuous values into discrete categories.
 
         Parameters
         ----------
         bins
             Bins to create.
         labels
             Labels to assign to the bins. If given the length of labels must be
             len(bins) + 1.
         break_point_label
-            Name given to the breakpoint column. Only used if series == False
+            Name given to the breakpoint column/field. Only used if series == False or
+            include_breaks == True
         category_label
             Name given to the category column. Only used if series == False
         maintain_order
             Keep the order of the original `Series`. Only used if series == False
         series
-            If True, return the a categorical series in the data's original order
+            If True, return the a categorical series in the data's original order.
         left_closed
             Whether intervals should be [) instead of (]
+        include_breaks
+            Include the the right endpoint of the bin each observation falls in.
+            If returning a DataFrame, it will be a column, and if returning a Series
+            it will be a field in a Struct
 
         Returns
         -------
         DataFrame or Series
 
         Examples
         --------
         >>> a = pl.Series("a", [v / 10 for v in range(-30, 30, 5)])
-        >>> a.cut([-1, 1])
+        >>> a.cut([-1, 1], series=False)
         shape: (12, 3)
-        
-         a     break_point  category     
-         ---   ---          ---          
-         f64   f64          cat          
-        
-         -3.0  -1.0         (-inf, -1.0] 
-         -2.5  -1.0         (-inf, -1.0] 
-         -2.0  -1.0         (-inf, -1.0] 
-         -1.5  -1.0         (-inf, -1.0] 
-                                      
-         1.0   1.0          (-1.0, 1.0]  
-         1.5   inf          (1.0, inf]   
-         2.0   inf          (1.0, inf]   
-         2.5   inf          (1.0, inf]   
-        
+        
+         a     break_point  category   
+         ---   ---          ---        
+         f64   f64          cat        
+        
+         -3.0  -1.0         (-inf, -1] 
+         -2.5  -1.0         (-inf, -1] 
+         -2.0  -1.0         (-inf, -1] 
+         -1.5  -1.0         (-inf, -1] 
+                                    
+         1.0   1.0          (-1, 1]    
+         1.5   inf          (1, inf]   
+         2.0   inf          (1, inf]   
+         2.5   inf          (1, inf]   
+        
         >>> a.cut([-1, 1], series=True)
         shape: (12,)
         Series: 'a' [cat]
         [
             "(-inf, -1]"
             "(-inf, -1]"
             "(-inf, -1]"
@@ -1684,96 +1696,106 @@
             "[-1, 1)"
             "[1, inf)"
             "[1, inf)"
             "[1, inf)"
             "[1, inf)"
         ]
         """
-        if series:
+        n = self._s.name()
+
+        if not series:
+            # "Old style" always includes breaks
             return (
                 self.to_frame()
-                .select(F.col(self._s.name()).cut(bins, labels, left_closed))
-                .to_series()
-            )
-        return wrap_df(
-            self._s.cut(
-                Series(break_point_label, bins, dtype=Float64)._s,
-                labels,
-                break_point_label,
-                category_label,
-                maintain_order,
+                .with_columns(
+                    F.col(n).cut(bins, labels, left_closed, True).alias(n + "_bin")
+                )
+                .unnest(n + "_bin")
+                .rename({"brk": break_point_label, n + "_bin": category_label})
             )
+        res = (
+            self.to_frame()
+            .select(F.col(n).cut(bins, labels, left_closed, include_breaks))
+            .to_series()
         )
+        if include_breaks:
+            return res.struct.rename_fields([break_point_label, category_label])
+        return res
 
     def qcut(
         self,
         quantiles: list[float],
         *,
         labels: list[str] | None = None,
         break_point_label: str = "break_point",
         category_label: str = "category",
-        maintain_order: bool = False,
         series: bool = False,
         left_closed: bool = False,
         allow_duplicates: bool = False,
+        include_breaks: bool = False,
     ) -> DataFrame | Series:
         """
         Bin continuous values into discrete categories based on their quantiles.
 
         Parameters
         ----------
         quantiles
             List of quantiles to create.
             We expect quantiles ``0.0 <= quantile <= 1``
         labels
             Labels to assign to the quantiles. If given the length of labels must be
             len(bins) + 1.
         break_point_label
-            Name given to the breakpoint column. Only used if series == False.
+            Name given to the breakpoint column/field. Only used if series == False or
+            include_breaks == True
         category_label
             Name given to the category column. Only used if series == False.
         maintain_order
             Keep the order of the original `Series`. Only used if series == False.
         series
             If True, return a categorical series in the data's original order
         left_closed
             Whether intervals should be [) instead of (]
         allow_duplicates
             If True, the resulting quantile breaks don't have to be unique. This can
             happen even with unique probs depending on the data. Duplicates will be
             dropped, resulting in fewer bins.
+        include_breaks
+            Include the the right endpoint of the bin each observation falls in.
+            If returning a DataFrame, it will be a column, and if returning a Series
+            it will be a field in a Struct
 
         Returns
         -------
         DataFrame or Series
 
         Warnings
         --------
         This functionality is experimental and may change without it being considered a
         breaking change.
 
         Examples
         --------
         >>> a = pl.Series("a", range(-5, 3))
-        >>> a.qcut([0.0, 0.25, 0.75])
+        >>> a.qcut([0.0, 0.25, 0.75], series=False)
         shape: (8, 3)
-        
-         a     break_point  category      
-         ---   ---          ---           
-         f64   f64          cat           
-        
-         -5.0  -5.0         (-inf, -5.0]  
-         -4.0  -3.25        (-5.0, -3.25] 
-         -3.0  0.25         (-3.25, 0.25] 
-         -2.0  0.25         (-3.25, 0.25] 
-         -1.0  0.25         (-3.25, 0.25] 
-         0.0   0.25         (-3.25, 0.25] 
-         1.0   inf          (0.25, inf]   
-         2.0   inf          (0.25, inf]   
-        
+        
+         a    break_point  category      
+         ---  ---          ---           
+         i64  f64          cat           
+        
+         -5   -5.0         (-inf, -5]    
+         -4   -3.25        (-5, -3.25]   
+         -3   0.25         (-3.25, 0.25] 
+         -2   0.25         (-3.25, 0.25] 
+         -1   0.25         (-3.25, 0.25] 
+         0    0.25         (-3.25, 0.25] 
+         1    inf          (0.25, inf]   
+         2    inf          (0.25, inf]   
+        
         >>> a.qcut([0.0, 0.25, 0.75], series=True)
         shape: (8,)
         Series: 'a' [cat]
         [
             "(-inf, -5]"
             "(-5, -3.25]"
             "(-3.25, 0.25]"
@@ -1793,33 +1815,100 @@
             "[-3.25, 0.25)"
             "[-3.25, 0.25)"
             "[-3.25, 0.25)"
             "[0.25, inf)"
             "[0.25, inf)"
         ]
         """
-        if series:
+        n = self._s.name()
+
+        if not series:
+            # "Old style" always includes breaks
             return (
                 self.to_frame()
-                .select(
-                    F.col(self._s.name()).qcut(
-                        quantiles, labels, left_closed, allow_duplicates
-                    )
+                .with_columns(
+                    F.col(n)
+                    .qcut(quantiles, labels, left_closed, allow_duplicates, True)
+                    .alias(n + "_bin")
                 )
-                .to_series()
+                .unnest(n + "_bin")
+                .rename({"brk": break_point_label, n + "_bin": category_label})
             )
-        return wrap_df(
-            self._s.qcut(
-                Series(quantiles, dtype=Float64)._s,
-                labels,
-                break_point_label,
-                category_label,
-                maintain_order,
+        res = (
+            self.to_frame()
+            .select(
+                F.col(n).qcut(
+                    quantiles, labels, left_closed, allow_duplicates, include_breaks
+                )
             )
+            .to_series()
         )
+        if include_breaks:
+            return res.struct.rename_fields([break_point_label, category_label])
+        return res
+
+    def rle(self) -> Series:
+        """
+        Get the lengths of runs of identical values.
+
+        Returns
+        -------
+            A Struct Series containing "lengths" and "values" Fields
+
+        Examples
+        --------
+        >>> s = pl.Series("s", [1, 1, 2, 1, None, 1, 3, 3])
+        >>> s.rle().struct.unnest()
+        shape: (6, 2)
+        
+         lengths  values 
+         ---      ---    
+         i32      i64    
+        
+         2        1      
+         1        2      
+         1        1      
+         1        null   
+         1        1      
+         2        3      
+        
+        """
+        return self.to_frame().select(F.col(self.name).rle()).to_series()
+
+    def rle_id(self) -> Series:
+        """
+        Map values to run IDs.
+
+        Similar to RLE, but it maps each value to an ID corresponding to the run into
+        which it falls. This is especially useful when you want to define groups by
+        runs of identical values rather than the values themselves.
+
+        Returns
+        -------
+            Series
+
+
+        Examples
+        --------
+        >>> s = pl.Series("s", [1, 1, 2, 1, None, 1, 3, 3])
+        >>> s.rle_id()
+        shape: (8,)
+        Series: 's' [u32]
+        [
+            0
+            0
+            1
+            2
+            3
+            4
+            5
+            5
+        ]
+        """
+        return self.to_frame().select(F.col(self.name).rle_id()).to_series()
 
     def hist(
         self,
         bins: list[float] | None = None,
         *,
         bin_count: int | None = None,
     ) -> DataFrame:
@@ -6070,8 +6159,10 @@
         # (and avoids unsupported timeunits such as "s")
         if time_unit == "ns":
             dtype = Datetime("ns")
         elif time_unit == "us":
             dtype = Datetime("us")
         elif time_unit == "ms":
             dtype = Datetime("ms")
+        elif time_unit == "D":
+            dtype = Date
     return dtype
```

### Comparing `polars_u64_idx-0.18.6/polars/series/string.py` & `polars_u64_idx-0.18.7/polars/series/string.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/series/struct.py` & `polars_u64_idx-0.18.7/polars/series/struct.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/series/utils.py` & `polars_u64_idx-0.18.7/polars/series/utils.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/slice.py` & `polars_u64_idx-0.18.7/polars/slice.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/sql/context.py` & `polars_u64_idx-0.18.7/polars/sql/context.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/string_cache.py` & `polars_u64_idx-0.18.7/polars/string_cache.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/testing/_private.py` & `polars_u64_idx-0.18.7/polars/testing/_private.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/testing/asserts.py` & `polars_u64_idx-0.18.7/polars/testing/asserts.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/testing/parametric/__init__.py` & `polars_u64_idx-0.18.7/polars/testing/parametric/__init__.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/testing/parametric/primitives.py` & `polars_u64_idx-0.18.7/polars/testing/parametric/primitives.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/testing/parametric/profiles.py` & `polars_u64_idx-0.18.7/polars/testing/parametric/profiles.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/testing/parametric/strategies.py` & `polars_u64_idx-0.18.7/polars/testing/parametric/strategies.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/type_aliases.py` & `polars_u64_idx-0.18.7/polars/type_aliases.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/utils/__init__.py` & `polars_u64_idx-0.18.7/polars/utils/__init__.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/utils/_construction.py` & `polars_u64_idx-0.18.7/polars/utils/_construction.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/utils/_parse_expr_input.py` & `polars_u64_idx-0.18.7/polars/utils/_parse_expr_input.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/utils/_scan.py` & `polars_u64_idx-0.18.7/polars/utils/_scan.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/utils/_wrap.py` & `polars_u64_idx-0.18.7/polars/utils/_wrap.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/utils/build_info.py` & `polars_u64_idx-0.18.7/polars/utils/build_info.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/utils/convert.py` & `polars_u64_idx-0.18.7/polars/utils/convert.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/utils/decorators.py` & `polars_u64_idx-0.18.7/polars/utils/decorators.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/utils/meta.py` & `polars_u64_idx-0.18.7/polars/utils/meta.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/utils/polars_version.py` & `polars_u64_idx-0.18.7/polars/utils/polars_version.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/utils/show_versions.py` & `polars_u64_idx-0.18.7/polars/utils/show_versions.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/polars/utils/various.py` & `polars_u64_idx-0.18.7/polars/utils/various.py`

 * *Files 0% similar despite different names*

```diff
@@ -24,15 +24,15 @@
 from polars.dependencies import _PYARROW_AVAILABLE
 
 if TYPE_CHECKING:
     from collections.abc import Reversible
     from pathlib import Path
 
     from polars import DataFrame, Series
-    from polars.type_aliases import PolarsDataType, SizeUnit
+    from polars.type_aliases import PolarsDataType, PolarsIntegerType, SizeUnit
 
     if sys.version_info >= (3, 10):
         from typing import ParamSpec, TypeGuard
     else:
         from typing_extensions import ParamSpec, TypeGuard
 
     P = ParamSpec("P")
@@ -92,18 +92,19 @@
     """
     if allow_str is False and isinstance(val, str):
         return False
     return isinstance(val, Sequence) and _is_iterable_of(val, str)
 
 
 def range_to_series(
-    name: str, rng: range, dtype: PolarsDataType | None = None
+    name: str, rng: range, dtype: PolarsIntegerType | None = None
 ) -> Series:
     """Fast conversion of the given range to a Series."""
-    return F.arange(
+    dtype = dtype or Int64
+    return F.int_range(
         start=rng.start,
         end=rng.stop,
         step=rng.step,
         dtype=dtype,
         eager=True,
     ).alias(name)
```

### Comparing `polars_u64_idx-0.18.6/pyproject.toml` & `polars_u64_idx-0.18.7/pyproject.toml`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/requirements-dev.txt` & `polars_u64_idx-0.18.7/requirements-dev.txt`

 * *Files 12% similar despite different names*

```diff
@@ -8,14 +8,15 @@
 deltalake >= 0.10.0
 numpy
 pandas
 pyarrow
 pydantic
 backports.zoneinfo; python_version < '3.9'
 tzdata; platform_system == 'Windows'
+SQLAlchemy
 xlsx2csv
 XlsxWriter
 adbc_driver_sqlite; python_version >= '3.9' and platform_system != 'Windows'
 connectorx==0.3.2a5; python_version >= '3.8'  # Latest full release is broken - unpin when 0.3.2 released
 
 # Tooling
 hypothesis==6.79.4; python_version < '3.8'
```

### Comparing `polars_u64_idx-0.18.6/scripts/check_stacklevels.py` & `polars_u64_idx-0.18.7/scripts/check_stacklevels.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/apply/dataframe.rs` & `polars_u64_idx-0.18.7/src/apply/dataframe.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/apply/lazy.rs` & `polars_u64_idx-0.18.7/src/apply/lazy.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/apply/mod.rs` & `polars_u64_idx-0.18.7/src/apply/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/apply/series.rs` & `polars_u64_idx-0.18.7/src/apply/series.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/arrow_interop/to_py.rs` & `polars_u64_idx-0.18.7/src/arrow_interop/to_py.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/arrow_interop/to_rust.rs` & `polars_u64_idx-0.18.7/src/arrow_interop/to_rust.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/batched_csv.rs` & `polars_u64_idx-0.18.7/src/batched_csv.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/conversion.rs` & `polars_u64_idx-0.18.7/src/conversion.rs`

 * *Files 4% similar despite different names*

```diff
@@ -16,23 +16,25 @@
 use polars_core::prelude::{IndexOrder, QuantileInterpolOptions};
 use polars_core::utils::arrow::types::NativeType;
 use polars_lazy::prelude::*;
 use pyo3::basic::CompareOp;
 use pyo3::conversion::{FromPyObject, IntoPy};
 use pyo3::exceptions::{PyTypeError, PyValueError};
 use pyo3::prelude::*;
-use pyo3::types::{PyBool, PyBytes, PyDict, PyFloat, PyList, PySequence, PyString, PyTuple};
+use pyo3::types::{
+    PyBool, PyBytes, PyDict, PyFloat, PyList, PySequence, PyString, PyTuple, PyType,
+};
 use pyo3::{PyAny, PyResult};
 use smartstring::alias::String as SmartString;
 
 use crate::error::PyPolarsErr;
 #[cfg(feature = "object")]
 use crate::object::OBJECT_NAME;
 use crate::prelude::*;
-use crate::py_modules::{POLARS, UTILS};
+use crate::py_modules::{POLARS, SERIES, UTILS};
 use crate::series::PySeries;
 use crate::{PyDataFrame, PyLazyFrame};
 
 pub(crate) fn slice_to_wrapped<T>(slice: &[T]) -> &[Wrap<T>] {
     // Safety:
     // Wrap is transparent.
     unsafe { std::mem::transmute(slice) }
@@ -601,31 +603,14 @@
     } else {
         (-exp) as usize
     };
     // TODO: do we care for checking if it fits in MAX_ABS_DEC? (if we set precision to None anyway?)
     (v <= MAX_ABS_DEC).then_some((v, scale))
 }
 
-fn materialize_list(ob: &PyAny) -> PyResult<Wrap<AnyValue>> {
-    if ob.is_empty()? {
-        Ok(Wrap(AnyValue::List(Series::new_empty("", &DataType::Null))))
-    } else {
-        let avs = ob.extract::<Wrap<Row>>()?.0 .0;
-        // use first `n` values to infer datatype
-        // this value is not too large as this will be done with every
-        // anyvalue that has to be converted, which can be many
-        let n = 25;
-        let dtype =
-            any_values_to_dtype(&avs[..std::cmp::min(avs.len(), n)]).map_err(PyPolarsErr::from)?;
-        let s =
-            Series::from_any_values_and_dtype("", &avs, &dtype, true).map_err(PyPolarsErr::from)?;
-        Ok(Wrap(AnyValue::List(s)))
-    }
-}
-
 fn convert_date(ob: &PyAny) -> PyResult<Wrap<AnyValue>> {
     Python::with_gil(|py| {
         let date = UTILS
             .as_ref(py)
             .getattr("_date_to_pl_date")
             .unwrap()
             .call1((ob,))
@@ -658,121 +643,240 @@
         v += microseconds;
 
         // choose "us" as that is python's default unit
         Ok(AnyValue::Datetime(v, TimeUnit::Microseconds, &None).into())
     })
 }
 
+type TypeObjectPtr = usize;
+type InitFn = fn(&PyAny) -> PyResult<Wrap<AnyValue<'_>>>;
+pub(crate) static LUT: crate::gil_once_cell::GILOnceCell<PlHashMap<TypeObjectPtr, InitFn>> =
+    crate::gil_once_cell::GILOnceCell::new();
+
 impl<'s> FromPyObject<'s> for Wrap<AnyValue<'s>> {
     fn extract(ob: &'s PyAny) -> PyResult<Self> {
-        if ob.is_instance_of::<PyBool>() {
+        // conversion functions
+        fn get_bool(ob: &PyAny) -> PyResult<Wrap<AnyValue<'_>>> {
             Ok(AnyValue::Boolean(ob.extract::<bool>().unwrap()).into())
-        } else if let Ok(value) = ob.extract::<i64>() {
-            Ok(AnyValue::Int64(value).into())
-        } else if ob.is_instance_of::<PyFloat>() {
-            let value = ob.extract::<f64>().unwrap();
-            Ok(AnyValue::Float64(value).into())
-        } else if ob.is_instance_of::<PyString>() {
-            let value = ob.extract::<&'s str>().unwrap();
+        }
+
+        fn get_int(ob: &PyAny) -> PyResult<Wrap<AnyValue<'_>>> {
+            // can overflow
+            match ob.extract::<i64>() {
+                Ok(v) => Ok(AnyValue::Int64(v).into()),
+                Err(_) => Ok(AnyValue::UInt64(ob.extract::<u64>()?).into()),
+            }
+        }
+
+        fn get_float(ob: &PyAny) -> PyResult<Wrap<AnyValue<'_>>> {
+            Ok(AnyValue::Float64(ob.extract::<f64>().unwrap()).into())
+        }
+
+        fn get_str(ob: &PyAny) -> PyResult<Wrap<AnyValue<'_>>> {
+            let value = ob.extract::<&str>().unwrap();
             Ok(AnyValue::Utf8(value).into())
-        } else if ob.is_none() {
-            Ok(AnyValue::Null.into())
-        } else if ob.is_instance_of::<PyDict>() {
+        }
+
+        fn get_struct(ob: &PyAny) -> PyResult<Wrap<AnyValue<'_>>> {
             let dict = ob.downcast::<PyDict>().unwrap();
             let len = dict.len();
             let mut keys = Vec::with_capacity(len);
             let mut vals = Vec::with_capacity(len);
             for (k, v) in dict.into_iter() {
                 let key = k.extract::<&str>()?;
                 let val = v.extract::<Wrap<AnyValue>>()?.0;
                 let dtype = DataType::from(&val);
                 keys.push(Field::new(key, dtype));
                 vals.push(val)
             }
             Ok(Wrap(AnyValue::StructOwned(Box::new((vals, keys)))))
-        } else if ob.is_instance_of::<PyList>() || ob.is_instance_of::<PyTuple>() {
-            materialize_list(ob)
-        } else if let Ok(value) = ob.extract::<u64>() {
-            Ok(AnyValue::UInt64(value).into())
-        } else if ob.hasattr("_s")? {
-            let py_pyseries = ob.getattr("_s").unwrap();
-            let series = py_pyseries.extract::<PySeries>().unwrap().series;
-            Ok(Wrap(AnyValue::List(series)))
-        } else if let Ok(v) = ob.extract::<&'s [u8]>() {
-            Ok(AnyValue::Binary(v).into())
-        } else {
-            let type_name = ob.get_type().name()?;
-            match type_name {
-                "datetime" => convert_datetime(ob),
-                "date" => convert_date(ob),
-                "timedelta" => Python::with_gil(|py| {
-                    let td = UTILS
-                        .as_ref(py)
-                        .getattr("_timedelta_to_pl_timedelta")
-                        .unwrap()
-                        .call1((ob, "us"))
-                        .unwrap();
-                    let v = td.extract::<i64>().unwrap();
-                    Ok(Wrap(AnyValue::Duration(v, TimeUnit::Microseconds)))
-                }),
-                "time" => Python::with_gil(|py| {
-                    let time = UTILS
-                        .as_ref(py)
-                        .getattr("_time_to_pl_time")
-                        .unwrap()
-                        .call1((ob,))
-                        .unwrap();
-                    let v = time.extract::<i64>().unwrap();
-                    Ok(Wrap(AnyValue::Time(v)))
-                }),
-                "Decimal" => {
-                    let (sign, digits, exp): (i8, Vec<u8>, i32) =
-                        ob.call_method0("as_tuple").unwrap().extract().unwrap();
-                    // note: using Vec<u8> is not the most efficient thing here (input is a tuple)
-                    let (mut v, scale) = abs_decimal_from_digits(digits, exp).ok_or_else(|| {
-                        PyErr::from(PyPolarsErr::Other(
-                            "Decimal is too large to fit in Decimal128".into(),
-                        ))
-                    })?;
-                    if sign > 0 {
-                        v = -v; // won't overflow since -i128::MAX > i128::MIN
-                    }
-                    Ok(Wrap(AnyValue::Decimal(v, scale)))
+        }
+
+        fn get_list(ob: &PyAny) -> PyResult<Wrap<AnyValue>> {
+            fn get_list_with_constructor(ob: &PyAny) -> PyResult<Wrap<AnyValue>> {
+                // Use the dedicated constructor
+                // this constructor is able to go via dedicated type constructors
+                // so it can be much faster
+                Python::with_gil(|py| {
+                    let s = SERIES.call1(py, (ob,))?;
+                    get_series_el(s.as_ref(py))
+                })
+            }
+
+            if ob.is_empty()? {
+                Ok(Wrap(AnyValue::List(Series::new_empty("", &DataType::Null))))
+            } else if ob.is_instance_of::<PyList>() | ob.is_instance_of::<PyTuple>() {
+                let list = ob.downcast::<PySequence>().unwrap();
+
+                let mut avs = Vec::with_capacity(25);
+                let mut iter = list.iter()?;
+
+                for item in (&mut iter).take(25) {
+                    avs.push(item?.extract::<Wrap<AnyValue>>()?.0)
                 }
-                "range" => materialize_list(ob),
-                _ => {
-                    // special branch for np.float as this fails isinstance float
-                    if let Ok(value) = ob.extract::<f64>() {
-                        return Ok(AnyValue::Float64(value).into());
-                    }
 
-                    // Can't use pyo3::types::PyDateTime with abi3-py37 feature,
-                    // so need this workaround instead of `isinstance(ob, datetime)`.
-                    let bases = ob.get_type().getattr("__bases__")?.iter()?;
-                    for base in bases {
-                        let parent_type = base.unwrap().str().unwrap().to_str().unwrap();
-                        match parent_type {
-                            "<class 'datetime.datetime'>" => {
-                                // `datetime.datetime` is a subclass of `datetime.date`,
-                                // so need to check `datetime.datetime` first
-                                return convert_datetime(ob);
-                            }
-                            "<class 'datetime.date'>" => {
-                                return convert_date(ob);
-                            }
-                            _ => (),
-                        }
+                let (dtype, n_types) = any_values_to_dtype(&avs).map_err(PyPolarsErr::from)?;
+
+                // we only take this path if there is no question of the data-type
+                if dtype.is_primitive() && n_types == 1 {
+                    get_list_with_constructor(ob)
+                } else {
+                    // push the rest
+                    avs.reserve(list.len()?);
+                    for item in iter {
+                        avs.push(item?.extract::<Wrap<AnyValue>>()?.0)
                     }
 
-                    // this is slow, but hey don't use objects
-                    let v = &ObjectValue { inner: ob.into() };
-                    Ok(Wrap(AnyValue::ObjectOwned(OwnedObject(v.to_boxed()))))
+                    let s = Series::from_any_values_and_dtype("", &avs, &dtype, true)
+                        .map_err(PyPolarsErr::from)?;
+                    Ok(Wrap(AnyValue::List(s)))
                 }
+            } else {
+                // range will take this branch
+                get_list_with_constructor(ob)
             }
         }
+
+        fn get_series_el(ob: &PyAny) -> PyResult<Wrap<AnyValue<'static>>> {
+            let py_pyseries = ob.getattr("_s").unwrap();
+            let series = py_pyseries.extract::<PySeries>().unwrap().series;
+            Ok(Wrap(AnyValue::List(series)))
+        }
+
+        fn get_bin(ob: &PyAny) -> PyResult<Wrap<AnyValue>> {
+            let value = ob.extract::<&[u8]>().unwrap();
+            Ok(AnyValue::Binary(value).into())
+        }
+
+        fn get_null(_ob: &PyAny) -> PyResult<Wrap<AnyValue>> {
+            Ok(AnyValue::Null.into())
+        }
+
+        fn get_timedelta(ob: &PyAny) -> PyResult<Wrap<AnyValue>> {
+            Python::with_gil(|py| {
+                let td = UTILS
+                    .as_ref(py)
+                    .getattr("_timedelta_to_pl_timedelta")
+                    .unwrap()
+                    .call1((ob, "us"))
+                    .unwrap();
+                let v = td.extract::<i64>().unwrap();
+                Ok(Wrap(AnyValue::Duration(v, TimeUnit::Microseconds)))
+            })
+        }
+
+        fn get_time(ob: &PyAny) -> PyResult<Wrap<AnyValue>> {
+            Python::with_gil(|py| {
+                let time = UTILS
+                    .as_ref(py)
+                    .getattr("_time_to_pl_time")
+                    .unwrap()
+                    .call1((ob,))
+                    .unwrap();
+                let v = time.extract::<i64>().unwrap();
+                Ok(Wrap(AnyValue::Time(v)))
+            })
+        }
+
+        fn get_decimal(ob: &PyAny) -> PyResult<Wrap<AnyValue>> {
+            let (sign, digits, exp): (i8, Vec<u8>, i32) =
+                ob.call_method0("as_tuple").unwrap().extract().unwrap();
+            // note: using Vec<u8> is not the most efficient thing here (input is a tuple)
+            let (mut v, scale) = abs_decimal_from_digits(digits, exp).ok_or_else(|| {
+                PyErr::from(PyPolarsErr::Other(
+                    "Decimal is too large to fit in Decimal128".into(),
+                ))
+            })?;
+            if sign > 0 {
+                v = -v; // won't overflow since -i128::MAX > i128::MIN
+            }
+            Ok(Wrap(AnyValue::Decimal(v, scale)))
+        }
+
+        fn get_object(ob: &PyAny) -> PyResult<Wrap<AnyValue>> {
+            // this is slow, but hey don't use objects
+            let v = &ObjectValue { inner: ob.into() };
+            Ok(Wrap(AnyValue::ObjectOwned(OwnedObject(v.to_boxed()))))
+        }
+
+        // TYPE key
+        let type_object_ptr = PyType::as_type_ptr(ob.get_type()) as usize;
+
+        Python::with_gil(|py| {
+            LUT.with_gil(py, |lut| {
+                // get the conversion function
+                let convert_fn = lut.entry(type_object_ptr).or_insert_with(
+                    // This only runs if type is not in LUT
+                    || {
+                        if ob.is_instance_of::<PyBool>() {
+                            get_bool
+                            // TODO: this heap allocs on failure
+                        } else if ob.extract::<i64>().is_ok() {
+                            get_int
+                        } else if ob.is_instance_of::<PyFloat>() {
+                            get_float
+                        } else if ob.is_instance_of::<PyString>() {
+                            get_str
+                        } else if ob.is_instance_of::<PyDict>() {
+                            get_struct
+                        } else if ob.is_instance_of::<PyList>() || ob.is_instance_of::<PyTuple>() {
+                            get_list
+                        } else if ob.hasattr("_s").unwrap() {
+                            get_series_el
+                        }
+                        // TODO: this heap allocs on failure
+                        else if ob.extract::<&'s [u8]>().is_ok() {
+                            get_bin
+                        } else if ob.is_none() {
+                            get_null
+                        } else {
+                            let type_name = ob.get_type().name().unwrap();
+                            match type_name {
+                                "datetime" => convert_datetime,
+                                "date" => convert_date,
+                                "timedelta" => get_timedelta,
+                                "time" => get_time,
+                                "Decimal" => get_decimal,
+                                "range" => get_list,
+                                _ => {
+                                    // special branch for np.float as this fails isinstance float
+                                    if ob.extract::<f64>().is_ok() {
+                                        return get_float;
+                                    }
+
+                                    // Can't use pyo3::types::PyDateTime with abi3-py37 feature,
+                                    // so need this workaround instead of `isinstance(ob, datetime)`.
+                                    let bases =
+                                        ob.get_type().getattr("__bases__").unwrap().iter().unwrap();
+                                    for base in bases {
+                                        let parent_type =
+                                            base.unwrap().str().unwrap().to_str().unwrap();
+                                        match parent_type {
+                                            "<class 'datetime.datetime'>" => {
+                                                // `datetime.datetime` is a subclass of `datetime.date`,
+                                                // so need to check `datetime.datetime` first
+                                                return convert_datetime;
+                                            }
+                                            "<class 'datetime.date'>" => {
+                                                return convert_date;
+                                            }
+                                            _ => (),
+                                        }
+                                    }
+
+                                    get_object
+                                }
+                            }
+                        }
+                    },
+                );
+
+                convert_fn(ob)
+            })
+        })
     }
 }
 
 impl<'s> FromPyObject<'s> for Wrap<Row<'s>> {
     fn extract(ob: &'s PyAny) -> PyResult<Self> {
         let vals = ob.extract::<Vec<Wrap<AnyValue<'s>>>>()?;
         let vals: Vec<AnyValue> = unsafe { std::mem::transmute(vals) };
```

### Comparing `polars_u64_idx-0.18.6/src/dataframe.rs` & `polars_u64_idx-0.18.7/src/dataframe.rs`

 * *Files 1% similar despite different names*

```diff
@@ -1151,19 +1151,24 @@
             agg_expr,
             separator,
         )
         .map_err(PyPolarsErr::from)?;
         Ok(PyDataFrame::new(df))
     }
 
-    pub fn partition_by(&self, by: Vec<String>, maintain_order: bool) -> PyResult<Vec<Self>> {
+    pub fn partition_by(
+        &self,
+        by: Vec<String>,
+        maintain_order: bool,
+        include_key: bool,
+    ) -> PyResult<Vec<Self>> {
         let out = if maintain_order {
-            self.df.partition_by_stable(by)
+            self.df.partition_by_stable(by, include_key)
         } else {
-            self.df.partition_by(by)
+            self.df.partition_by(by, include_key)
         }
         .map_err(PyPolarsErr::from)?;
         // Safety:
         // Repr mem layout
         Ok(unsafe { std::mem::transmute::<Vec<DataFrame>, Vec<PyDataFrame>>(out) })
     }
```

### Comparing `polars_u64_idx-0.18.6/src/datatypes.rs` & `polars_u64_idx-0.18.7/src/datatypes.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/error.rs` & `polars_u64_idx-0.18.7/src/error.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/expr/array.rs` & `polars_u64_idx-0.18.7/src/expr/array.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/expr/binary.rs` & `polars_u64_idx-0.18.7/src/expr/binary.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/expr/datetime.rs` & `polars_u64_idx-0.18.7/src/expr/datetime.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/expr/general.rs` & `polars_u64_idx-0.18.7/src/expr/general.rs`

 * *Files 1% similar despite different names*

```diff
@@ -174,34 +174,53 @@
     fn quantile(&self, quantile: Self, interpolation: Wrap<QuantileInterpolOptions>) -> Self {
         self.clone()
             .inner
             .quantile(quantile.inner, interpolation.0)
             .into()
     }
 
-    #[pyo3(signature = (breaks, labels, left_closed))]
+    #[pyo3(signature = (breaks, labels, left_closed, include_breaks))]
     #[cfg(feature = "cutqcut")]
-    fn cut(&self, breaks: Vec<f64>, labels: Option<Vec<String>>, left_closed: bool) -> Self {
-        self.inner.clone().cut(breaks, labels, left_closed).into()
+    fn cut(
+        &self,
+        breaks: Vec<f64>,
+        labels: Option<Vec<String>>,
+        left_closed: bool,
+        include_breaks: bool,
+    ) -> Self {
+        self.inner
+            .clone()
+            .cut(breaks, labels, left_closed, include_breaks)
+            .into()
     }
-    #[pyo3(signature = (probs, labels, left_closed, allow_duplicates))]
+    #[pyo3(signature = (probs, labels, left_closed, allow_duplicates, include_breaks))]
     #[cfg(feature = "cutqcut")]
     fn qcut(
         &self,
         probs: Vec<f64>,
         labels: Option<Vec<String>>,
         left_closed: bool,
         allow_duplicates: bool,
+        include_breaks: bool,
     ) -> Self {
         self.inner
             .clone()
-            .qcut(probs, labels, left_closed, allow_duplicates)
+            .qcut(probs, labels, left_closed, allow_duplicates, include_breaks)
             .into()
     }
 
+    #[cfg(feature = "rle")]
+    fn rle(&self) -> Self {
+        self.clone().inner.rle().into()
+    }
+    #[cfg(feature = "rle")]
+    fn rle_id(&self) -> Self {
+        self.clone().inner.rle_id().into()
+    }
+
     fn agg_groups(&self) -> Self {
         self.clone().inner.agg_groups().into()
     }
     fn count(&self) -> Self {
         self.clone().inner.count().into()
     }
     fn value_counts(&self, multithreaded: bool, sorted: bool) -> Self {
@@ -228,25 +247,27 @@
     fn sort_with(&self, descending: bool, nulls_last: bool) -> Self {
         self.clone()
             .inner
             .sort_with(SortOptions {
                 descending,
                 nulls_last,
                 multithreaded: true,
+                maintain_order: false,
             })
             .into()
     }
 
     fn arg_sort(&self, descending: bool, nulls_last: bool) -> Self {
         self.clone()
             .inner
             .arg_sort(SortOptions {
                 descending,
                 nulls_last,
                 multithreaded: true,
+                maintain_order: false,
             })
             .into()
     }
 
     #[cfg(feature = "top_k")]
     fn top_k(&self, k: usize) -> Self {
         self.inner.clone().top_k(k).into()
```

### Comparing `polars_u64_idx-0.18.6/src/expr/list.rs` & `polars_u64_idx-0.18.7/src/expr/list.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/expr/meta.rs` & `polars_u64_idx-0.18.7/src/expr/meta.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/expr/mod.rs` & `polars_u64_idx-0.18.7/src/expr/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/expr/string.rs` & `polars_u64_idx-0.18.7/src/expr/string.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/file.rs` & `polars_u64_idx-0.18.7/src/file.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/functions/eager.rs` & `polars_u64_idx-0.18.7/src/functions/eager.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/functions/io.rs` & `polars_u64_idx-0.18.7/src/functions/io.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/functions/lazy.rs` & `polars_u64_idx-0.18.7/src/functions/lazy.rs`

 * *Files 3% similar despite different names*

```diff
@@ -376,26 +376,14 @@
         output_type,
         apply_groups,
         returns_scalar,
     )
 }
 
 #[pyfunction]
-pub fn max_exprs(exprs: Vec<PyExpr>) -> PyExpr {
-    let exprs = exprs.to_exprs();
-    dsl::max_exprs(exprs).into()
-}
-
-#[pyfunction]
-pub fn min_exprs(exprs: Vec<PyExpr>) -> PyExpr {
-    let exprs = exprs.to_exprs();
-    dsl::min_exprs(exprs).into()
-}
-
-#[pyfunction]
 pub fn pearson_corr(a: PyExpr, b: PyExpr, ddof: u8) -> PyExpr {
     dsl::pearson_corr(a.inner, b.inner, ddof).into()
 }
 
 #[pyfunction]
 pub fn reduce(lambda: PyObject, exprs: Vec<PyExpr>) -> PyExpr {
     let exprs = exprs.to_exprs();
@@ -435,20 +423,14 @@
     #[cfg(not(feature = "propagate_nans"))]
     {
         panic!("activate 'propagate_nans'")
     }
 }
 
 #[pyfunction]
-pub fn sum_exprs(exprs: Vec<PyExpr>) -> PyExpr {
-    let exprs = exprs.to_exprs();
-    dsl::sum_exprs(exprs).into()
-}
-
-#[pyfunction]
 pub fn time_range_lazy(
     start: PyExpr,
     end: PyExpr,
     every: &str,
     closed: Wrap<ClosedWindow>,
 ) -> PyExpr {
     let start = start.inner;
```

### Comparing `polars_u64_idx-0.18.6/src/functions/meta.rs` & `polars_u64_idx-0.18.7/src/functions/meta.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/functions/whenthen.rs` & `polars_u64_idx-0.18.7/src/functions/whenthen.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/lazyframe.rs` & `polars_u64_idx-0.18.7/src/lazyframe.rs`

 * *Files 2% similar despite different names*

```diff
@@ -350,49 +350,73 @@
         {
             ldf = ldf.with_common_subplan_elimination(cse);
         }
 
         ldf.into()
     }
 
-    fn sort(&self, by_column: &str, descending: bool, nulls_last: bool) -> Self {
+    fn sort(
+        &self,
+        by_column: &str,
+        descending: bool,
+        nulls_last: bool,
+        maintain_order: bool,
+    ) -> Self {
         let ldf = self.ldf.clone();
         ldf.sort(
             by_column,
             SortOptions {
                 descending,
                 nulls_last,
                 multithreaded: true,
+                maintain_order,
             },
         )
         .into()
     }
 
-    fn sort_by_exprs(&self, by: Vec<PyExpr>, descending: Vec<bool>, nulls_last: bool) -> Self {
+    fn sort_by_exprs(
+        &self,
+        by: Vec<PyExpr>,
+        descending: Vec<bool>,
+        nulls_last: bool,
+        maintain_order: bool,
+    ) -> Self {
         let ldf = self.ldf.clone();
         let exprs = by.to_exprs();
-        ldf.sort_by_exprs(exprs, descending, nulls_last).into()
+        ldf.sort_by_exprs(exprs, descending, nulls_last, maintain_order)
+            .into()
     }
 
-    fn top_k(&self, k: IdxSize, by: Vec<PyExpr>, descending: Vec<bool>, nulls_last: bool) -> Self {
+    fn top_k(
+        &self,
+        k: IdxSize,
+        by: Vec<PyExpr>,
+        descending: Vec<bool>,
+        nulls_last: bool,
+        maintain_order: bool,
+    ) -> Self {
         let ldf = self.ldf.clone();
         let exprs = by.to_exprs();
-        ldf.top_k(k, exprs, descending, nulls_last).into()
+        ldf.top_k(k, exprs, descending, nulls_last, maintain_order)
+            .into()
     }
 
     fn bottom_k(
         &self,
         k: IdxSize,
         by: Vec<PyExpr>,
         descending: Vec<bool>,
         nulls_last: bool,
+        maintain_order: bool,
     ) -> Self {
         let ldf = self.ldf.clone();
         let exprs = by.to_exprs();
-        ldf.bottom_k(k, exprs, descending, nulls_last).into()
+        ldf.bottom_k(k, exprs, descending, nulls_last, maintain_order)
+            .into()
     }
 
     fn cache(&self) -> Self {
         let ldf = self.ldf.clone();
         ldf.cache().into()
     }
```

### Comparing `polars_u64_idx-0.18.6/src/lazygroupby.rs` & `polars_u64_idx-0.18.7/src/lazygroupby.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/lib.rs` & `polars_u64_idx-0.18.7/src/lib.rs`

 * *Files 2% similar despite different names*

```diff
@@ -19,14 +19,15 @@
 pub mod conversion;
 pub mod dataframe;
 pub mod datatypes;
 pub mod error;
 pub mod expr;
 pub mod file;
 pub mod functions;
+pub(crate) mod gil_once_cell;
 pub mod lazyframe;
 pub mod lazygroupby;
 #[cfg(feature = "object")]
 mod object;
 #[cfg(feature = "object")]
 mod on_startup;
 pub mod prelude;
@@ -94,14 +95,26 @@
     m.add_wrapped(wrap_pyfunction!(functions::range::arange))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::range::int_range))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::range::int_ranges))
         .unwrap();
 
+    // Functions - aggregation
+    m.add_wrapped(wrap_pyfunction!(functions::aggregation::all_horizontal))
+        .unwrap();
+    m.add_wrapped(wrap_pyfunction!(functions::aggregation::any_horizontal))
+        .unwrap();
+    m.add_wrapped(wrap_pyfunction!(functions::aggregation::max_horizontal))
+        .unwrap();
+    m.add_wrapped(wrap_pyfunction!(functions::aggregation::min_horizontal))
+        .unwrap();
+    m.add_wrapped(wrap_pyfunction!(functions::aggregation::sum_horizontal))
+        .unwrap();
+
     // Functions - lazy
     m.add_wrapped(wrap_pyfunction!(functions::lazy::arg_sort_by))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::lazy::arg_where))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::lazy::as_struct))
         .unwrap();
@@ -145,32 +158,26 @@
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::lazy::last))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::lazy::lit))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::lazy::map_mul))
         .unwrap();
-    m.add_wrapped(wrap_pyfunction!(functions::lazy::max_exprs))
-        .unwrap();
-    m.add_wrapped(wrap_pyfunction!(functions::lazy::min_exprs))
-        .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::lazy::pearson_corr))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::lazy::rolling_corr))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::lazy::rolling_cov))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::lazy::reduce))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::lazy::repeat))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::lazy::spearman_rank_corr))
         .unwrap();
-    m.add_wrapped(wrap_pyfunction!(functions::lazy::sum_exprs))
-        .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::lazy::time_range_lazy))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::whenthen::when))
         .unwrap();
 
     #[cfg(feature = "sql")]
     m.add_wrapped(wrap_pyfunction!(functions::lazy::sql_expr))
```

### Comparing `polars_u64_idx-0.18.6/src/on_startup.rs` & `polars_u64_idx-0.18.7/src/on_startup.rs`

 * *Files 4% similar despite different names*

```diff
@@ -55,24 +55,31 @@
         Ok(df)
     })
 }
 
 #[pyfunction]
 pub fn __register_startup_deps() {
     if !registry::is_object_builder_registered() {
+        // register object type builder
         let object_builder = Box::new(|name: &str, capacity: usize| {
             Box::new(ObjectChunkedBuilder::<ObjectValue>::new(name, capacity))
                 as Box<dyn AnonymousObjectBuilder>
         });
 
         let object_converter = Arc::new(|av: AnyValue| {
             let object = Python::with_gil(|py| ObjectValue {
                 inner: Wrap(av).to_object(py),
             });
             Box::new(object) as Box<dyn Any>
         });
 
         registry::register_object_builder(object_builder, object_converter);
+        // register SERIES UDF
         unsafe { python_udf::CALL_SERIES_UDF_PYTHON = Some(python_function_caller_series) }
+        // register DATAFRAME UDF
         unsafe { python_udf::CALL_DF_UDF_PYTHON = Some(python_function_caller_df) }
+        Python::with_gil(|py| {
+            // init AnyValue LUT
+            crate::conversion::LUT.set(py, Default::default()).unwrap();
+        })
     }
 }
```

### Comparing `polars_u64_idx-0.18.6/src/series/aggregation.rs` & `polars_u64_idx-0.18.7/src/series/aggregation.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/series/arithmetic.rs` & `polars_u64_idx-0.18.7/src/series/arithmetic.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/series/comparison.rs` & `polars_u64_idx-0.18.7/src/series/comparison.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/series/construction.rs` & `polars_u64_idx-0.18.7/src/series/construction.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/series/export.rs` & `polars_u64_idx-0.18.7/src/series/export.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/series/mod.rs` & `polars_u64_idx-0.18.7/src/series/mod.rs`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 mod arithmetic;
 mod comparison;
 mod construction;
 mod export;
 mod numpy_ufunc;
 mod set_at_idx;
 
-use polars_algo::{cut, hist, qcut};
+use polars_algo::hist;
 use polars_core::series::IsSorted;
 use polars_core::utils::flatten::flatten_series;
 use polars_core::with_match_physical_numeric_polars_type;
 use pyo3::exceptions::{PyRuntimeError, PyValueError};
 use pyo3::prelude::*;
 use pyo3::types::PyBytes;
 use pyo3::Python;
@@ -647,77 +647,28 @@
             flatten_series(&self.series)
                 .into_iter()
                 .map(|s| wrap_s.call1(py, (Self::new(s),)))
                 .collect()
         })
     }
 
-    fn is_sorted(&self, descending: bool) -> bool {
+    fn is_sorted(&self, descending: bool) -> PyResult<bool> {
         let options = SortOptions {
             descending,
             nulls_last: descending,
             multithreaded: true,
+            maintain_order: false,
         };
-        self.series.is_sorted(options)
+        Ok(self.series.is_sorted(options).map_err(PyPolarsErr::from)?)
     }
 
     fn clear(&self) -> Self {
         self.series.clear().into()
     }
 
-    #[pyo3(signature = (bins, labels, break_point_label, category_label, maintain_order))]
-    fn cut(
-        &self,
-        bins: Self,
-        labels: Option<Vec<&str>>,
-        break_point_label: Option<&str>,
-        category_label: Option<&str>,
-        maintain_order: bool,
-    ) -> PyResult<PyDataFrame> {
-        let out = cut(
-            &self.series,
-            bins.series,
-            labels,
-            break_point_label,
-            category_label,
-            maintain_order,
-        )
-        .map_err(PyPolarsErr::from)?;
-        Ok(out.into())
-    }
-
-    #[pyo3(signature = (quantiles, labels, break_point_label, category_label, maintain_order))]
-    fn qcut(
-        &self,
-        quantiles: Self,
-        labels: Option<Vec<&str>>,
-        break_point_label: Option<&str>,
-        category_label: Option<&str>,
-        maintain_order: bool,
-    ) -> PyResult<PyDataFrame> {
-        if quantiles.series.null_count() > 0 {
-            return Err(PyValueError::new_err(
-                "did not expect null values in list of quantiles",
-            ));
-        }
-        let quantiles = quantiles.series.cast(&DataType::Float64).unwrap();
-        let quantiles = quantiles.f64().unwrap().rechunk();
-
-        let out = qcut(
-            &self.series,
-            quantiles.cont_slice().unwrap(),
-            labels,
-            break_point_label,
-            category_label,
-            maintain_order,
-        )
-        .map_err(PyPolarsErr::from)?;
-        Ok(out.into())
-    }
-
     fn hist(&self, bins: Option<Self>, bin_count: Option<usize>) -> PyResult<PyDataFrame> {
         let bins = bins.map(|s| s.series);
         let out = hist(&self.series, bins.as_ref(), bin_count).map_err(PyPolarsErr::from)?;
         Ok(out.into())
     }
 
     fn get_ptr(&self) -> PyResult<usize> {
```

### Comparing `polars_u64_idx-0.18.6/src/series/numpy_ufunc.rs` & `polars_u64_idx-0.18.7/src/series/numpy_ufunc.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/series/set_at_idx.rs` & `polars_u64_idx-0.18.7/src/series/set_at_idx.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/sql.rs` & `polars_u64_idx-0.18.7/src/sql.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/src/utils.rs` & `polars_u64_idx-0.18.7/src/utils.rs`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/README.md` & `polars_u64_idx-0.18.7/tests/README.md`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/benchmark/groupby-datagen.R` & `polars_u64_idx-0.18.7/tests/benchmark/groupby-datagen.R`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/benchmark/run_h2oai_benchmark.py` & `polars_u64_idx-0.18.7/tests/benchmark/run_h2oai_benchmark.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/benchmark/test_release.py` & `polars_u64_idx-0.18.7/tests/benchmark/test_release.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/docs/run_doctest.py` & `polars_u64_idx-0.18.7/tests/docs/run_doctest.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/parametric/test_dataframe.py` & `polars_u64_idx-0.18.7/tests/parametric/test_dataframe.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/parametric/test_groupby_rolling.py` & `polars_u64_idx-0.18.7/tests/parametric/test_groupby_rolling.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/parametric/test_lazyframe.py` & `polars_u64_idx-0.18.7/tests/parametric/test_lazyframe.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/parametric/test_lit.py` & `polars_u64_idx-0.18.7/tests/parametric/test_lit.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/parametric/test_series.py` & `polars_u64_idx-0.18.7/tests/parametric/test_series.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/parametric/test_testing.py` & `polars_u64_idx-0.18.7/tests/parametric/test_testing.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/parametric/time_series/test_to_datetime.py` & `polars_u64_idx-0.18.7/tests/parametric/time_series/test_to_datetime.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/conftest.py` & `polars_u64_idx-0.18.7/tests/unit/conftest.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/datatypes/test_binary.py` & `polars_u64_idx-0.18.7/tests/unit/datatypes/test_binary.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/datatypes/test_bool.py` & `polars_u64_idx-0.18.7/tests/unit/datatypes/test_bool.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/datatypes/test_categorical.py` & `polars_u64_idx-0.18.7/tests/unit/datatypes/test_categorical.py`

 * *Files 0% similar despite different names*

```diff
@@ -236,15 +236,15 @@
 def test_cast_inner_categorical() -> None:
     dtype = pl.List(pl.Categorical)
     out = pl.Series("foo", [["a"], ["a", "b"]]).cast(dtype)
     assert out.dtype == dtype
     assert out.to_list() == [["a"], ["a", "b"]]
 
     with pytest.raises(
-        pl.ComputeError, match=r"casting to categorical not allowed in `arr.eval`"
+        pl.ComputeError, match=r"casting to categorical not allowed in `list.eval`"
     ):
         pl.Series("foo", [["a", "b"], ["a", "b"]]).list.eval(
             pl.element().cast(pl.Categorical)
         )
 
 
 @pytest.mark.slow()
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/datatypes/test_decimal.py` & `polars_u64_idx-0.18.7/tests/unit/datatypes/test_decimal.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/datatypes/test_duration.py` & `polars_u64_idx-0.18.7/tests/unit/datatypes/test_duration.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/datatypes/test_list.py` & `polars_u64_idx-0.18.7/tests/unit/datatypes/test_list.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/datatypes/test_object.py` & `polars_u64_idx-0.18.7/tests/unit/datatypes/test_object.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/datatypes/test_struct.py` & `polars_u64_idx-0.18.7/tests/unit/datatypes/test_struct.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/datatypes/test_temporal.py` & `polars_u64_idx-0.18.7/tests/unit/datatypes/test_temporal.py`

 * *Files 0% similar despite different names*

```diff
@@ -269,19 +269,43 @@
     assert df.select(
         [pl.col(col).dt.timestamp() for col in ("c", "d", "e")]
     ).rows() == [(100001, 100001, 100001), (200002, 200002, 200002)]
 
 
 def test_from_numpy() -> None:
     # note: numpy timeunit support is limited to those supported by polars.
-    # as a result, datetime64[s] will be stored as object.
+    # as a result, datetime64[s] raises
     x = np.asarray(range(100_000, 200_000, 10_000), dtype="datetime64[s]")
-    s = pl.Series(x)
-    assert s[0] == x[0]
-    assert len(s) == 10
+    with pytest.raises(ValueError, match="Please cast to the closest supported unit"):
+        pl.Series(x)
+
+
+@pytest.mark.parametrize(
+    ("numpy_time_unit", "expected_values", "expected_dtype"),
+    [
+        ("ns", ["1970-01-02T01:12:34.123456789"], pl.Datetime("ns")),
+        ("us", ["1970-01-02T01:12:34.123456"], pl.Datetime("us")),
+        ("ms", ["1970-01-02T01:12:34.123"], pl.Datetime("ms")),
+        ("D", ["1970-01-02"], pl.Date),
+    ],
+)
+def test_from_numpy_supported_units(
+    numpy_time_unit: str,
+    expected_values: list[str],
+    expected_dtype: PolarsTemporalType,
+) -> None:
+    values = np.array(
+        ["1970-01-02T01:12:34.123456789123456789"],
+        dtype=f"datetime64[{numpy_time_unit}]",
+    )
+    result = pl.from_numpy(values)
+    expected = (
+        pl.Series("column_0", expected_values).str.strptime(expected_dtype).to_frame()
+    )
+    assert_frame_equal(result, expected)
 
 
 def test_datetime_consistency() -> None:
     dt = datetime(2022, 7, 5, 10, 30, 45, 123455)
     df = pl.DataFrame({"date": [dt]})
 
     assert df["date"].dt[0] == dt
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/functions/test_as_datatype.py` & `polars_u64_idx-0.18.7/tests/unit/functions/test_as_datatype.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/functions/test_functions.py` & `polars_u64_idx-0.18.7/tests/unit/functions/test_functions.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from __future__ import annotations
 
 from datetime import timedelta
-from typing import Any, cast
+from typing import cast
 
 import numpy as np
 import pytest
 
 import polars as pl
 from polars.testing import assert_frame_equal
 
@@ -99,40 +99,14 @@
             """
         ),
     )
     assert_frame_equal(out, expected)
     assert out.rows() == [("a", 1), ("b", 2), ("c", 3), ("d", 4), ("e", 5)]
 
 
-def test_all_any_horizontally() -> None:
-    df = pl.DataFrame(
-        [
-            [False, False, True],
-            [False, False, True],
-            [True, False, False],
-            [False, None, True],
-            [None, None, False],
-        ],
-        schema=["var1", "var2", "var3"],
-    )
-    expected = pl.DataFrame(
-        {
-            "any": [True, True, False, True, None],
-            "all": [False, False, False, None, False],
-        }
-    )
-    result = df.select(
-        [
-            pl.any([pl.col("var2"), pl.col("var3")]),
-            pl.all([pl.col("var2"), pl.col("var3")]),
-        ]
-    )
-    assert_frame_equal(result, expected)
-
-
 def test_null_handling_correlation() -> None:
     df = pl.DataFrame({"a": [1, 2, 3, None, 4], "b": [1, 2, 3, 10, 4]})
 
     out = df.select(
         [
             pl.corr("a", "b").alias("pearson"),
             pl.corr("a", "b", method="spearman").alias("spearman"),
@@ -185,15 +159,15 @@
         pl.from_pandas(df1.reset_index()),
         pl.from_pandas(df2.reset_index()),
         on="date",
     )
     pl_dot = (
         (pf1[["a", "b"]] * pf2[["a", "b"]])
         .fill_null(0)
-        .select(pl.sum(pl.col("*")).alias("dot"))
+        .select(pl.sum_horizontal("*").alias("dot"))
         .insert_at_idx(0, pf1["date"])
     )
     # confirm we match the same operation in pandas
     assert_frame_equal(pl_dot, pl.from_pandas(pd_dot))
     pd.testing.assert_frame_equal(pd_dot, pl_dot.to_pandas())
 
     # (also: confirm alignment function works with lazyframes)
@@ -369,108 +343,14 @@
             20.085536923187668,
             54.598150033144236,
             148.4131591025766,
         ]
     }
 
 
-def test_min_alias_for_series_min() -> None:
-    s = pl.Series([1, 2, 3])
-    assert pl.min(s) == s.min()
-
-
-@pytest.mark.parametrize("input", ["a", "^a|b$"])
-def test_min_alias_for_col_min(input: str) -> None:
-    df = pl.DataFrame({"a": [1, 4], "b": [3, 2]})
-    expr = pl.col(input).min()
-    expr_alias = pl.min(input)
-    assert_frame_equal(df.select(expr), df.select(expr_alias))
-
-
-@pytest.mark.parametrize(
-    ("input", "expected_data"),
-    [
-        (pl.col("^a|b$"), [1, 2]),
-        (pl.col("a", "b"), [1, 2]),
-        (pl.col("a"), [1, 4]),
-        (pl.lit(5, dtype=pl.Int64), [5]),
-        (5.0, [5.0]),
-    ],
-)
-def test_min_column_wise_single_input(input: Any, expected_data: list[Any]) -> None:
-    df = pl.DataFrame({"a": [1, 4], "b": [3, 2]})
-    result = df.select(pl.min(input))
-    expected = pl.DataFrame({"min": expected_data})
-    assert_frame_equal(result, expected)
-
-
-@pytest.mark.parametrize(
-    ("inputs", "expected_data"),
-    [
-        ((["a", "b"]), [1, 2]),
-        (("a", "b"), [1, 2]),
-        (("a", 3), [1, 3]),
-    ],
-)
-def test_min_column_wise_multi_input(
-    inputs: tuple[Any, ...], expected_data: list[Any]
-) -> None:
-    df = pl.DataFrame({"a": [1, 4], "b": [3, 2]})
-    result = df.select(pl.min(*inputs))
-    expected = pl.DataFrame({"min": expected_data})
-    assert_frame_equal(result, expected)
-
-
-def test_max_alias_for_series_max() -> None:
-    s = pl.Series([1, 2, 3])
-    assert pl.max(s) == s.max()
-
-
-@pytest.mark.parametrize("input", ["a", "^a|b$"])
-def test_max_alias_for_col_max(input: str) -> None:
-    df = pl.DataFrame({"a": [1, 4], "b": [3, 2]})
-    expr = pl.col(input).max()
-    expr_alias = pl.max(input)
-    assert_frame_equal(df.select(expr), df.select(expr_alias))
-
-
-@pytest.mark.parametrize(
-    ("input", "expected_data"),
-    [
-        (pl.col("^a|b$"), [3, 4]),
-        (pl.col("a", "b"), [3, 4]),
-        (pl.col("a"), [1, 4]),
-        (pl.lit(5, dtype=pl.Int64), [5]),
-        (5.0, [5.0]),
-    ],
-)
-def test_max_column_wise_single_input(input: Any, expected_data: list[Any]) -> None:
-    df = pl.DataFrame({"a": [1, 4], "b": [3, 2]})
-    result = df.select(pl.max(input))
-    expected = pl.DataFrame({"max": expected_data})
-    assert_frame_equal(result, expected)
-
-
-@pytest.mark.parametrize(
-    ("inputs", "expected_data"),
-    [
-        ((["a", "b"]), [3, 4]),
-        (("a", "b"), [3, 4]),
-        (("a", 3), [3, 4]),
-    ],
-)
-def test_max_column_wise_multi_input(
-    inputs: tuple[Any, ...], expected_data: list[Any]
-) -> None:
-    df = pl.DataFrame({"a": [1, 4], "b": [3, 2]})
-    result = df.select(pl.max(*inputs))
-    expected = pl.DataFrame({"max": expected_data})
-    assert_frame_equal(result, expected)
-
-
 def test_abs_logical_type() -> None:
     s = pl.Series([timedelta(hours=1), timedelta(hours=-1)])
     assert s.abs().to_list() == [timedelta(hours=1), timedelta(hours=1)]
 
 
 def test_approx_unique() -> None:
     df1 = pl.DataFrame({"a": [None, 1, 2], "b": [None, 2, 1]})
@@ -485,7 +365,73 @@
         pl.DataFrame({"b": pl.Series(values=[3], dtype=pl.UInt32)}),
     )
 
     assert_frame_equal(
         df1.select(pl.col("b").approx_unique()),
         pl.DataFrame({"b": pl.Series(values=[3], dtype=pl.UInt32)}),
     )
+
+
+def test_lazy_functions() -> None:
+    df = pl.DataFrame({"a": ["foo", "bar", "2"], "b": [1, 2, 3], "c": [1.0, 2.0, 3.0]})
+    out = df.select(pl.count("a"))
+    assert list(out["a"]) == [3]
+    assert pl.count(df["a"]) == 3
+    out = df.select(
+        [
+            pl.var("b").alias("1"),
+            pl.std("b").alias("2"),
+            pl.max("b").alias("3"),
+            pl.min("b").alias("4"),
+            pl.sum("b").alias("5"),
+            pl.mean("b").alias("6"),
+            pl.median("b").alias("7"),
+            pl.n_unique("b").alias("8"),
+            pl.first("b").alias("9"),
+            pl.last("b").alias("10"),
+        ]
+    )
+    expected = 1.0
+    assert np.isclose(out.to_series(0), expected)
+    assert np.isclose(pl.var(df["b"]), expected)  # type: ignore[arg-type]
+    expected = 1.0
+    assert np.isclose(out.to_series(1), expected)
+    assert np.isclose(pl.std(df["b"]), expected)  # type: ignore[arg-type]
+    expected = 3
+    assert np.isclose(out.to_series(2), expected)
+    with pytest.deprecated_call():
+        assert np.isclose(pl.max(df["b"]), expected)  # type: ignore[arg-type]
+    expected = 1
+    assert np.isclose(out.to_series(3), expected)
+    with pytest.deprecated_call():
+        assert np.isclose(pl.min(df["b"]), expected)  # type: ignore[arg-type]
+    expected = 6
+    assert np.isclose(out.to_series(4), expected)
+    with pytest.deprecated_call():
+        assert np.isclose(pl.sum(df["b"]), expected)
+    expected = 2
+    assert np.isclose(out.to_series(5), expected)
+    assert np.isclose(pl.mean(df["b"]), expected)
+    expected = 2
+    assert np.isclose(out.to_series(6), expected)
+    assert np.isclose(pl.median(df["b"]), expected)
+    expected = 3
+    assert np.isclose(out.to_series(7), expected)
+    assert np.isclose(pl.n_unique(df["b"]), expected)
+    expected = 1
+    assert np.isclose(out.to_series(8), expected)
+    assert np.isclose(pl.first(df["b"]), expected)
+    expected = 3
+    assert np.isclose(out.to_series(9), expected)
+    assert np.isclose(pl.last(df["b"]), expected)
+
+    # regex selection
+    out = df.select(
+        [
+            pl.struct(pl.max("^a|b$")).alias("x"),
+            pl.struct(pl.min("^.*[bc]$")).alias("y"),
+            pl.struct(pl.sum("^[^b]$")).alias("z"),
+        ]
+    )
+    assert out.rows() == [
+        ({"a": "foo", "b": 3}, {"b": 1, "c": 1.0}, {"a": None, "c": 6.0})
+    ]
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/functions/test_range.py` & `polars_u64_idx-0.18.7/tests/unit/functions/test_range.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/functions/test_repeat.py` & `polars_u64_idx-0.18.7/tests/unit/functions/test_repeat.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/files/delta-table/_delta_log/00000000000000000000.json` & `polars_u64_idx-0.18.7/tests/unit/io/files/delta-table/_delta_log/00000000000000000000.json`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/files/delta-table/_delta_log/00000000000000000001.json` & `polars_u64_idx-0.18.7/tests/unit/io/files/delta-table/_delta_log/00000000000000000001.json`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/files/delta-table/part-00000-e42312d7-60e5-454d-acbc-db192d220e73-c000.snappy.parquet` & `polars_u64_idx-0.18.7/tests/unit/io/files/delta-table/part-00000-e42312d7-60e5-454d-acbc-db192d220e73-c000.snappy.parquet`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/files/delta-table/part-00000-e4a999da-df45-4fb0-bdc4-d999fc0f58aa-c000.snappy.parquet` & `polars_u64_idx-0.18.7/tests/unit/io/files/delta-table/part-00000-e4a999da-df45-4fb0-bdc4-d999fc0f58aa-c000.snappy.parquet`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/files/example.xlsx` & `polars_u64_idx-0.18.7/tests/unit/io/files/example.xlsx`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/files/foods1.ipc` & `polars_u64_idx-0.18.7/tests/unit/io/files/foods1.ipc`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/files/foods1.ndjson` & `polars_u64_idx-0.18.7/tests/unit/io/files/foods1.ndjson`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/files/foods1.parquet` & `polars_u64_idx-0.18.7/tests/unit/io/files/foods1.parquet`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/files/foods2.ipc` & `polars_u64_idx-0.18.7/tests/unit/io/files/foods2.ipc`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/files/foods2.ndjson` & `polars_u64_idx-0.18.7/tests/unit/io/files/foods2.ndjson`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/files/foods2.parquet` & `polars_u64_idx-0.18.7/tests/unit/io/files/foods2.parquet`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/files/small.parquet` & `polars_u64_idx-0.18.7/tests/unit/io/files/small.parquet`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/test_avro.py` & `polars_u64_idx-0.18.7/tests/unit/io/test_avro.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/test_csv.py` & `polars_u64_idx-0.18.7/tests/unit/io/test_csv.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/test_database.py` & `polars_u64_idx-0.18.7/tests/unit/io/test_database.py`

 * *Files 4% similar despite different names*

```diff
@@ -166,51 +166,78 @@
 @pytest.mark.write_disk()
 @pytest.mark.parametrize(
     ("engine", "mode"),
     [
         pytest.param(
             "adbc",
             "create",
-            id="create",
+            id="adbc_create",
             marks=pytest.mark.skipif(
                 sys.version_info < (3, 9) or sys.platform == "win32",
                 reason="adbc_driver_sqlite not available below Python 3.9 / on Windows",
             ),
         ),
         pytest.param(
             "adbc",
             "append",
-            id="append",
+            id="adbc_append",
             marks=pytest.mark.skipif(
                 sys.version_info < (3, 9) or sys.platform == "win32",
                 reason="adbc_driver_sqlite not available below Python 3.9 / on Windows",
             ),
         ),
+        pytest.param(
+            "sqlalchemy",
+            "create",
+            id="sa_create",
+        ),
+        pytest.param(
+            "sqlalchemy",
+            "append",
+            id="sa_append",
+        ),
     ],
 )
 def test_write_database(
     engine: DbWriteEngine, mode: DbWriteMode, sample_df: pl.DataFrame, tmp_path: Path
 ) -> None:
     tmp_path.mkdir(exist_ok=True)
 
-    test_db = str(tmp_path / "test.db")
+    tmp_db = f"test_{engine}.db"
+    test_db = str(tmp_path / tmp_db)
+
+    # note: test a table name that requires quotes to ensure that we handle
+    # it correctly (also supply an explicit db schema with/without quotes)
+    tbl_name = '"test-data"'
 
     sample_df.write_database(
-        table_name="test_data",
+        table_name=f"main.{tbl_name}",
         connection_uri=f"sqlite:///{test_db}",
         if_exists="replace",
         engine=engine,
     )
 
     if mode == "append":
         sample_df.write_database(
-            table_name="test_data",
+            table_name=f'"main".{tbl_name}',
             connection_uri=f"sqlite:///{test_db}",
             if_exists="append",
             engine=engine,
         )
         sample_df = pl.concat([sample_df, sample_df])
 
-    result = pl.read_database("SELECT * FROM test_data", f"sqlite:///{test_db}")
+    result = pl.read_database(f"SELECT * FROM {tbl_name}", f"sqlite:///{test_db}")
 
     sample_df = sample_df.with_columns(pl.col("date").cast(pl.Utf8))
     assert_frame_equal(sample_df, result)
+
+    # check that some invalid parameters raise errors
+    for invalid_params in (
+        {"table_name": "w.x.y.z"},
+        {"if_exists": "crunk", "table_name": f"main.{tbl_name}"},
+    ):
+        with pytest.raises(ValueError):
+            sample_df.write_database(
+                connection_uri=f"sqlite:///{test_db}",
+                engine=engine,
+                **invalid_params,  # type: ignore[arg-type]
+            )
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/test_delta.py` & `polars_u64_idx-0.18.7/tests/unit/io/test_delta.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/test_excel.py` & `polars_u64_idx-0.18.7/tests/unit/io/test_excel.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/test_ipc.py` & `polars_u64_idx-0.18.7/tests/unit/io/test_ipc.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/test_json.py` & `polars_u64_idx-0.18.7/tests/unit/io/test_json.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/test_lazy_csv.py` & `polars_u64_idx-0.18.7/tests/unit/io/test_lazy_csv.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/test_lazy_ipc.py` & `polars_u64_idx-0.18.7/tests/unit/io/test_lazy_ipc.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/test_lazy_json.py` & `polars_u64_idx-0.18.7/tests/unit/io/test_lazy_json.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/test_lazy_parquet.py` & `polars_u64_idx-0.18.7/tests/unit/io/test_lazy_parquet.py`

 * *Files 1% similar despite different names*

```diff
@@ -193,15 +193,15 @@
         pl.scan_parquet(file_path).filter(pl.col("a") > 4).select(pl.col("a").sum())
     ).collect()[0, "a"] == 10.0
     assert pl.scan_parquet(file_path).filter(
         (pl.col("a") * 10) > 5.0
     ).collect().shape == (8, 1)
 
 
-def test_row_count_schema(parquet_file_path: Path) -> None:
+def test_row_count_schema_parquet(parquet_file_path: Path) -> None:
     assert (
         pl.scan_parquet(str(parquet_file_path), row_count_name="id")
         .select(["id", "b"])
         .collect()
     ).dtypes == [pl.UInt32, pl.Utf8]
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/test_other.py` & `polars_u64_idx-0.18.7/tests/unit/io/test_other.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/test_parquet.py` & `polars_u64_idx-0.18.7/tests/unit/io/test_parquet.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,18 @@
 from __future__ import annotations
 
 import io
+import os
+from datetime import datetime, timezone
 from typing import TYPE_CHECKING
 
 import numpy as np
 import pandas as pd
 import pyarrow as pa
 import pyarrow.dataset as ds
-import pyarrow.parquet as pq
 import pytest
 
 import polars as pl
 from polars.testing import (
     assert_frame_equal,
     assert_frame_equal_local_categoricals,
     assert_series_equal,
@@ -30,14 +31,25 @@
     "gzip",
     # "lzo",  # LZO compression currently not supported by Arrow backend
     "brotli",
     "zstd",
 ]
 
 
+def test_write_parquet_using_pyarrow_9753(tmpdir: Path) -> None:
+    df = pl.DataFrame({"a": [1, 2, 3]})
+    df.write_parquet(
+        tmpdir / "test.parquet",
+        compression="zstd",
+        statistics=True,
+        use_pyarrow=True,
+        pyarrow_options={"coerce_timestamps": "us"},
+    )
+
+
 @pytest.fixture()
 def small_parquet_path(io_files_path: Path) -> Path:
     return io_files_path / "small.parquet"
 
 
 @pytest.mark.parametrize("compression", COMPRESSIONS)
 @pytest.mark.parametrize("use_pyarrow", [True, False])
@@ -350,14 +362,16 @@
 
     table = pa.table({"Col1": col1})
 
     with pl.StringCache():
         df = pl.from_arrow(table)
 
         f = io.BytesIO()
+        import pyarrow.parquet as pq
+
         pq.write_table(table, f, compression="snappy")
         f.seek(0)
         read = pl.read_parquet(f)
         assert_frame_equal(read, df)  # type: ignore[arg-type]
 
 
 @pytest.mark.write_disk()
@@ -491,7 +505,17 @@
 
     df.write_parquet(f, row_group_size=2)
 
     # this file has 2 row groups and a categorical column
     # so polars should automatically set string cache
     f.seek(0)
     assert_series_equal(pl.read_parquet(f)["a"].cast(str), df["a"].cast(str))
+
+
+def test_tz_aware_parquet_9586() -> None:
+    result = pl.read_parquet(
+        os.path.join("tests", "unit", "io", "files", "tz_aware.parquet")
+    )
+    expected = pl.DataFrame(
+        {"UTC_DATETIME_ID": [datetime(2023, 6, 26, 14, 15, 0, tzinfo=timezone.utc)]}
+    ).select(pl.col("*").cast(pl.Datetime("ns", "UTC")))
+    assert_frame_equal(result, expected)
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/test_pickle.py` & `polars_u64_idx-0.18.7/tests/unit/io/test_pickle.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/io/test_pyarrow_dataset.py` & `polars_u64_idx-0.18.7/tests/unit/io/test_pyarrow_dataset.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/namespaces/test_array.py` & `polars_u64_idx-0.18.7/tests/unit/namespaces/test_array.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/namespaces/test_binary.py` & `polars_u64_idx-0.18.7/tests/unit/namespaces/test_binary.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/namespaces/test_categorical.py` & `polars_u64_idx-0.18.7/tests/unit/namespaces/test_categorical.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/namespaces/test_datetime.py` & `polars_u64_idx-0.18.7/tests/unit/namespaces/test_datetime.py`

 * *Files 2% similar despite different names*

```diff
@@ -135,14 +135,40 @@
 def test_local_time_sortedness(time_zone: str | None) -> None:
     ser = (pl.Series([datetime(2022, 1, 1, 23)]).dt.replace_time_zone(time_zone)).sort()
     result = ser.dt.time()
     assert result.flags["SORTED_ASC"] is False
     assert result.flags["SORTED_DESC"] is False
 
 
+@pytest.mark.parametrize(
+    ("time_zone", "offset", "expected"),
+    [
+        (None, "1d", True),
+        ("Asia/Kathmandu", "1d", False),
+        ("UTC", "1d", True),
+        (None, "1mo", True),
+        ("Asia/Kathmandu", "1mo", False),
+        ("UTC", "1mo", True),
+        (None, "1w", True),
+        ("Asia/Kathmandu", "1w", False),
+        ("UTC", "1w", True),
+        (None, "1h", True),
+        ("Asia/Kathmandu", "1h", True),
+        ("UTC", "1h", True),
+    ],
+)
+def test_offset_by_sortedness(
+    time_zone: str | None, offset: str, expected: bool
+) -> None:
+    ser = (pl.Series([datetime(2022, 1, 1, 23)]).dt.replace_time_zone(time_zone)).sort()
+    result = ser.dt.offset_by(offset)
+    assert result.flags["SORTED_ASC"] == expected
+    assert result.flags["SORTED_DESC"] is False
+
+
 def test_dt_datetime_date_time_invalid() -> None:
     with pytest.raises(ComputeError, match="expected Datetime"):
         pl.Series([date(2021, 1, 2)]).dt.datetime()
     with pytest.raises(ComputeError, match="expected Datetime or Date"):
         pl.Series([time(23)]).dt.date()
     with pytest.raises(ComputeError, match="expected Datetime"):
         pl.Series([time(23)]).dt.datetime()
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/namespaces/test_list.py` & `polars_u64_idx-0.18.7/tests/unit/namespaces/test_list.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/namespaces/test_meta.py` & `polars_u64_idx-0.18.7/tests/unit/namespaces/test_meta.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/namespaces/test_string.py` & `polars_u64_idx-0.18.7/tests/unit/namespaces/test_string.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/namespaces/test_strptime.py` & `polars_u64_idx-0.18.7/tests/unit/namespaces/test_strptime.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/namespaces/test_struct.py` & `polars_u64_idx-0.18.7/tests/unit/namespaces/test_struct.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_aggregations.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_aggregations.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_apply.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_apply.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_arithmetic.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_arithmetic.py`

 * *Files 5% similar despite different names*

```diff
@@ -50,15 +50,15 @@
 def test_struct_arithmetic() -> None:
     df = pl.DataFrame(
         {
             "a": [1, 2],
             "b": [3, 4],
             "c": [5, 6],
         }
-    ).select(pl.cumsum(["a", "c"]))
+    ).select(pl.cumsum_horizontal("a", "c"))
     assert df.select(pl.col("cumsum") * 2).to_dict(False) == {
         "cumsum": [{"a": 2, "c": 12}, {"a": 4, "c": 16}]
     }
     assert df.select(pl.col("cumsum") - 2).to_dict(False) == {
         "cumsum": [{"a": -1, "c": 4}, {"a": 0, "c": 6}]
     }
     assert df.select(pl.col("cumsum") + 2).to_dict(False) == {
@@ -69,15 +69,15 @@
     }
     assert df.select(pl.col("cumsum") // 2).to_dict(False) == {
         "cumsum": [{"a": 0, "c": 3}, {"a": 1, "c": 4}]
     }
 
     # inline, this check cumsum reports the right output type
     assert pl.DataFrame({"a": [1, 2], "b": [3, 4], "c": [5, 6]}).select(
-        pl.cumsum(["a", "c"]) * 3
+        pl.cumsum_horizontal("a", "c") * 3
     ).to_dict(False) == {"cumsum": [{"a": 3, "c": 18}, {"a": 6, "c": 24}]}
 
 
 def test_simd_float_sum_determinism() -> None:
     out = []
     for _ in range(10):
         a = pl.Series(
@@ -188,15 +188,15 @@
 def test_boolean_addition() -> None:
     s = pl.DataFrame({"a": [True, False, False], "b": [True, False, True]}).sum(axis=1)
 
     assert s.dtype == pl.utils.get_index_type()
     assert s.to_list() == [2, 0, 1]
     df = pl.DataFrame(
         {"a": [True], "b": [False]},
-    ).select(pl.sum(pl.col(["a", "b"])))
+    ).select(pl.sum_horizontal("a", "b"))
     assert df.dtypes == [pl.utils.get_index_type()]
 
 
 def test_bitwise_6311() -> None:
     df = pl.DataFrame({"col1": [0, 1, 2, 3], "flag": [0, 0, 0, 0]})
 
     assert (
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_comparison.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_comparison.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_drop.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_drop.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_explode.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_explode.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_filter.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_filter.py`

 * *Files 5% similar despite different names*

```diff
@@ -47,31 +47,35 @@
         .groupby("id")
         .agg(pl.col("k").filter(pl.col("k").is_in(["a"])).implode())
     )
     assert_frame_equal(result, expected)
 
 
 def test_filter_aggregation_any() -> None:
-    assert pl.DataFrame(
+    df = pl.DataFrame(
         {
             "id": [1, 2, 3, 4],
             "group": [1, 2, 1, 1],
             "pred_a": [False, True, False, False],
             "pred_b": [False, False, True, True],
         }
-    ).groupby("group").agg(
-        [
-            pl.any(["pred_a", "pred_b"]),
-            pl.col("id").filter(pl.any(["pred_a", "pred_b"])).alias("filtered"),
-        ]
-    ).sort(
-        "group"
-    ).to_dict(
-        False
-    ) == {
+    )
+
+    result = (
+        df.groupby("group")
+        .agg(
+            pl.any_horizontal("pred_a", "pred_b"),
+            pl.col("id")
+            .filter(pl.any_horizontal("pred_a", "pred_b"))
+            .alias("filtered"),
+        )
+        .sort("group")
+    )
+
+    assert result.to_dict(False) == {
         "group": [1, 2],
         "any": [[False, True, True], [True]],
         "filtered": [[3, 4], [2]],
     }
 
 
 def test_predicate_order_explode_5950() -> None:
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_groupby.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_groupby.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_groupby_rolling.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_groupby_rolling.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_is_in.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_is_in.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_join.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_join.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_join_asof.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_join_asof.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_melt.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_melt.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_pivot.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_pivot.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_random.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_random.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_rolling.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_rolling.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_select.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_select.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_sort.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_sort.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_statistics.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_statistics.py`

 * *Files 6% similar despite different names*

```diff
@@ -23,68 +23,66 @@
         }
     )
     assert_frame_equal(result, expected)
 
 
 def test_cut() -> None:
     a = pl.Series("a", [v / 10 for v in range(-30, 30, 5)])
-    out = cast(pl.DataFrame, a.cut(bins=[-1, 1]))
+    out = cast(pl.DataFrame, a.cut(bins=[-1, 1], series=False))
 
     assert out.shape == (12, 3)
     assert out.filter(pl.col("break_point") < 1e9).to_dict(False) == {
         "a": [-3.0, -2.5, -2.0, -1.5, -1.0, -0.5, 0.0, 0.5, 1.0],
         "break_point": [-1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0],
         "category": [
-            "(-inf, -1.0]",
-            "(-inf, -1.0]",
-            "(-inf, -1.0]",
-            "(-inf, -1.0]",
-            "(-inf, -1.0]",
-            "(-1.0, 1.0]",
-            "(-1.0, 1.0]",
-            "(-1.0, 1.0]",
-            "(-1.0, 1.0]",
+            "(-inf, -1]",
+            "(-inf, -1]",
+            "(-inf, -1]",
+            "(-inf, -1]",
+            "(-inf, -1]",
+            "(-1, 1]",
+            "(-1, 1]",
+            "(-1, 1]",
+            "(-1, 1]",
         ],
     }
 
     # test cut on integers #4939
     inf = float("inf")
     df = pl.DataFrame({"a": list(range(5))})
     ser = df.select("a").to_series()
-    assert cast(pl.DataFrame, ser.cut(bins=[-1, 1])).rows() == [
-        (0.0, 1.0, "(-1.0, 1.0]"),
-        (1.0, 1.0, "(-1.0, 1.0]"),
-        (2.0, inf, "(1.0, inf]"),
-        (3.0, inf, "(1.0, inf]"),
-        (4.0, inf, "(1.0, inf]"),
+    assert cast(pl.DataFrame, ser.cut(bins=[-1, 1], series=False)).rows() == [
+        (0.0, 1.0, "(-1, 1]"),
+        (1.0, 1.0, "(-1, 1]"),
+        (2.0, inf, "(1, inf]"),
+        (3.0, inf, "(1, inf]"),
+        (4.0, inf, "(1, inf]"),
     ]
 
-
-def test_cut_maintain_order() -> None:
     expected_df = pl.DataFrame(
         {
             "a": [5.0, 8.0, 9.0, 5.0, 0.0, 0.0, 1.0, 7.0, 6.0, 9.0],
             "break_point": [inf, inf, inf, inf, 1.0, 1.0, 1.0, inf, inf, inf],
             "category": [
-                "(1.0, inf]",
-                "(1.0, inf]",
-                "(1.0, inf]",
-                "(1.0, inf]",
-                "(-1.0, 1.0]",
-                "(-1.0, 1.0]",
-                "(-1.0, 1.0]",
-                "(1.0, inf]",
-                "(1.0, inf]",
-                "(1.0, inf]",
+                "(1, inf]",
+                "(1, inf]",
+                "(1, inf]",
+                "(1, inf]",
+                "(-1, 1]",
+                "(-1, 1]",
+                "(-1, 1]",
+                "(1, inf]",
+                "(1, inf]",
+                "(1, inf]",
             ],
         }
     )
     np.random.seed(1)
     a = pl.Series("a", np.random.randint(0, 10, 10))
-    out = cast(pl.DataFrame, a.cut(bins=[-1, 1], maintain_order=True))
+    out = cast(pl.DataFrame, a.cut(bins=[-1, 1], series=False))
     out_s = cast(pl.Series, a.cut(bins=[-1, 1], series=True))
     assert out["a"].cast(int).series_equal(a)
     # Compare strings and categoricals without a hassle
     assert_frame_equal(expected_df, out, check_dtype=False)
     # It formats differently
     assert_series_equal(
         pl.Series(["(1, inf]"] * 4 + ["(-1, 1]"] * 3 + ["(1, inf]"] * 3),
@@ -96,33 +94,24 @@
 
 def test_qcut() -> None:
     input = pl.Series("a", range(-5, 3))
     exp = pl.DataFrame(
         {
             "a": [-5.0, -4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0],
             "break_point": [-5.0, -3.25, 0.25, 0.25, 0.25, 0.25, inf, inf],
-            "category": [
-                "(-inf, -5.0]",
-                "(-5.0, -3.25]",
-                "(-3.25, 0.25]",
-                "(-3.25, 0.25]",
-                "(-3.25, 0.25]",
-                "(-3.25, 0.25]",
-                "(0.25, inf]",
-                "(0.25, inf]",
-            ],
+            "category": ["(-inf, -5]", "(-5, -3.25]"]
+            + ["(-3.25, 0.25]"] * 4
+            + ["(0.25, inf]"] * 2,
         }
     )
     out = cast(pl.DataFrame, input.qcut([0.0, 0.25, 0.75]))
     out_s = cast(pl.Series, input.qcut([0.0, 0.25, 0.75], series=True))
     assert_frame_equal(out, exp, check_dtype=False)
     assert_series_equal(
-        pl.Series(
-            ["(-inf, -5]", "(-5, -3.25]"] + ["(-3.25, 0.25]"] * 4 + ["(0.25, inf]"] * 2
-        ),
+        exp["category"],
         out_s,
         check_dtype=False,
         check_names=False,
     )
 
 
 def test_hist() -> None:
@@ -155,30 +144,25 @@
                 None,
                 "(1.2000000000000002, inf]",
                 "(1.2000000000000002, inf]",
             ],
         }
     )
     assert_frame_equal(
-        cast(pl.DataFrame, s.qcut([0.2, 0.3], maintain_order=True)),
+        cast(pl.DataFrame, s.qcut([0.2, 0.3], series=False)),
         exp,
         check_dtype=False,
     )
     assert_series_equal(
         cast(pl.Series, s.qcut([0.2, 0.3], series=True)),
         exp.get_column("category"),
         check_dtype=False,
         check_names=False,
     )
 
-    assert (
-        str(cast(pl.DataFrame, s.qcut([0.2, 0.3], maintain_order=False)).to_dict(False))
-        == "{'': [-1.0, 1.0, 2.0, 4.0, 8.0, None, None], 'break_point': [0.5999999999999996, 1.2000000000000002, inf, inf, inf, None, None], 'category': ['(-inf, 0.5999999999999996]', '(0.5999999999999996, 1.2000000000000002]', '(1.2000000000000002, inf]', '(1.2000000000000002, inf]', '(1.2000000000000002, inf]', None, None]}"
-    )
-
 
 def test_median_quantile_duration() -> None:
     df = pl.DataFrame({"A": [timedelta(days=0), timedelta(days=1)]})
     assert df.select(pl.col("A").median()).to_dict(False) == {
         "A": [timedelta(seconds=43200)]
     }
     assert df.select(pl.col("A").quantile(0.5, interpolation="linear")).to_dict(
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_transpose.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_transpose.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_unique.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_unique.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_window.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_window.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/operations/test_with_columns.py` & `polars_u64_idx-0.18.7/tests/unit/operations/test_with_columns.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/streaming/test_ooc.py` & `polars_u64_idx-0.18.7/tests/unit/streaming/test_ooc.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/streaming/test_streaming.py` & `polars_u64_idx-0.18.7/tests/unit/streaming/test_streaming.py`

 * *Files 4% similar despite different names*

```diff
@@ -377,69 +377,92 @@
         .collect(streaming=True)["s"]
         .is_sorted()
     )
     (_, err) = capfd.readouterr()
     assert "df -> sort" in err
 
 
-@pytest.mark.write_disk()
-def test_streaming_groupby_ooc(monkeypatch: Any) -> None:
+@pytest.fixture(scope="module")
+def random_integers() -> pl.Series:
     np.random.seed(1)
-    s = pl.Series("a", np.random.randint(0, 10, 100))
+    return pl.Series("a", np.random.randint(0, 10, 100), dtype=pl.Int64)
 
-    for env in ["POLARS_FORCE_OOC", "_NO_OP"]:
-        monkeypatch.setenv(env, "1")
-        q = (
-            s.to_frame()
-            .lazy()
-            .groupby("a")
-            .agg(pl.first("a").alias("a_first"), pl.last("a").alias("a_last"))
-            .sort("a")
-        )
 
-        assert q.collect(streaming=True).to_dict(False) == {
+@pytest.mark.write_disk()
+def test_streaming_groupby_ooc_q1(monkeypatch: Any, random_integers: pl.Series) -> None:
+    s = random_integers
+    monkeypatch.setenv("POLARS_FORCE_OOC", "1")
+
+    result = (
+        s.to_frame()
+        .lazy()
+        .groupby("a")
+        .agg(pl.first("a").alias("a_first"), pl.last("a").alias("a_last"))
+        .sort("a")
+        .collect(streaming=True)
+    )
+
+    expected = pl.DataFrame(
+        {
             "a": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
             "a_first": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
             "a_last": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
         }
+    )
+    assert_frame_equal(result, expected)
 
-        q = (
-            s.cast(str)
-            .to_frame()
-            .lazy()
-            .groupby("a")
-            .agg(pl.first("a").alias("a_first"), pl.last("a").alias("a_last"))
-            .sort("a")
-        )
 
-        assert q.collect(streaming=True).to_dict(False) == {
+@pytest.mark.write_disk()
+def test_streaming_groupby_ooc_q2(monkeypatch: Any, random_integers: pl.Series) -> None:
+    s = random_integers
+    monkeypatch.setenv("POLARS_FORCE_OOC", "1")
+
+    result = (
+        s.cast(str)
+        .to_frame()
+        .lazy()
+        .groupby("a")
+        .agg(pl.first("a").alias("a_first"), pl.last("a").alias("a_last"))
+        .sort("a")
+        .collect(streaming=True)
+    )
+
+    expected = pl.DataFrame(
+        {
             "a": ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
             "a_first": ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
             "a_last": ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
         }
+    )
+    assert_frame_equal(result, expected)
 
-        q = (
-            pl.DataFrame(
-                {
-                    "a": s,
-                    "b": s.rename("b"),
-                }
-            )
-            .lazy()
-            .groupby(["a", "b"])
-            .agg(pl.first("a").alias("a_first"), pl.last("a").alias("a_last"))
-            .sort("a")
-        )
 
-        assert q.collect(streaming=True).to_dict(False) == {
+@pytest.mark.write_disk()
+def test_streaming_groupby_ooc_q3(monkeypatch: Any, random_integers: pl.Series) -> None:
+    s = random_integers
+    monkeypatch.setenv("POLARS_FORCE_OOC", "1")
+
+    result = (
+        pl.DataFrame({"a": s, "b": s})
+        .lazy()
+        .groupby(["a", "b"])
+        .agg(pl.first("a").alias("a_first"), pl.last("a").alias("a_last"))
+        .sort("a")
+        .collect(streaming=True)
+    )
+
+    expected = pl.DataFrame(
+        {
             "a": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
             "b": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
             "a_first": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
             "a_last": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
         }
+    )
+    assert_frame_equal(result, expected)
 
 
 def test_streaming_groupby_struct_key() -> None:
     df = pl.DataFrame(
         {"A": [1, 2, 3, 2], "B": ["google", "ms", "apple", "ms"], "C": [2, 3, 4, 3]}
     )
     df1 = df.lazy().with_columns(pl.struct(["A", "C"]).alias("tuples"))
@@ -632,7 +655,36 @@
     lf0 = pl.scan_parquet(p0)
     lf1 = pl.scan_parquet(p1).select(pl.all().suffix("_r"))
 
     join_strategies: list[JoinStrategy] = ["left", "inner"]
     for how in join_strategies:
         q = lf0.join(lf1, left_on="id", right_on="id_r", how=how)
         assert_frame_equal(q.collect(streaming=True), q.collect(streaming=False))
+
+
+def test_streaming_9776() -> None:
+    df = pl.DataFrame({"col_1": ["a"] * 1000, "ID": [None] + ["a"] * 999})
+    ordered = (
+        df.groupby("col_1", "ID", maintain_order=True)
+        .count()
+        .filter(pl.col("col_1") == "a")
+    )
+    unordered = (
+        df.groupby("col_1", "ID", maintain_order=False)
+        .count()
+        .filter(pl.col("col_1") == "a")
+    )
+    expected = [("a", None, 1), ("a", "a", 999)]
+    assert ordered.rows() == expected
+    assert unordered.sort(["col_1", "ID"]).rows() == expected
+
+
+def test_streaming_groupby_list_9758() -> None:
+    payload = {"a": [[1, 2]]}
+    assert (
+        pl.LazyFrame(payload)
+        .groupby("a")
+        .first()
+        .collect(streaming=True)
+        .to_dict(False)
+        == payload
+    )
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_api.py` & `polars_u64_idx-0.18.7/tests/unit/test_api.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_arity.py` & `polars_u64_idx-0.18.7/tests/unit/test_arity.py`

 * *Files 7% similar despite different names*

```diff
@@ -9,24 +9,26 @@
         {
             "1": ["a", "b"],
             "2": ["c", "d"],
         }
     )
 
     out0 = df.with_columns(
-        pl.when(pl.any(pl.all() == "a"))
+        pl.when(pl.any_horizontal(pl.all() == "a"))
         .then("a")
-        .otherwise(pl.when(pl.any(pl.all() == "d")).then("d").otherwise(None))
+        .otherwise(
+            pl.when(pl.any_horizontal(pl.all() == "d")).then("d").otherwise(None)
+        )
         .alias("result")
     )
 
     out1 = df.with_columns(
-        pl.when(pl.any(pl.all() == "a"))
+        pl.when(pl.any_horizontal(pl.all() == "a"))
         .then("a")
-        .when(pl.any(pl.all() == "d"))
+        .when(pl.any_horizontal(pl.all() == "d"))
         .then("d")
         .otherwise(None)
         .alias("result")
     )
 
     assert_frame_equal(out0, out1)
     assert out0.to_dict(False) == {
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_cfg.py` & `polars_u64_idx-0.18.7/tests/unit/test_cfg.py`

 * *Files 1% similar despite different names*

```diff
@@ -63,21 +63,21 @@
 
 def test_hide_header_elements() -> None:
     df = pl.DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [7, 8, 9]})
 
     pl.Config.set_tbl_hide_column_data_types(True)
     assert (
         str(df) == "shape: (3, 3)\n"
-        "\n"
-        " a    b    c   \n"
-        "\n"
-        " 1    4    7   \n"
-        " 2    5    8   \n"
-        " 3    6    9   \n"
-        ""
+        "\n"
+        " a  b  c \n"
+        "\n"
+        " 1  4  7 \n"
+        " 2  5  8 \n"
+        " 3  6  9 \n"
+        ""
     )
 
     pl.Config.set_tbl_hide_column_data_types(False).set_tbl_hide_column_names(True)
     assert (
         str(df) == "shape: (3, 3)\n"
         "\n"
         " i64  i64  i64 \n"
@@ -338,20 +338,32 @@
         }
     )
     assert max(len(line) for line in str(df).split("\n")) == 70
 
     pl.Config.set_tbl_width_chars(60)
     assert max(len(line) for line in str(df).split("\n")) == 60
 
-    # formula for determining min width is
-    # sum(max(min(header.len, 12), 5)) + header.len + 1
-    # so we end up with 12+5+10+4 = 31
-
+    # force minimal table size (will hard-wrap everything; "don't try this at home" :p)
     pl.Config.set_tbl_width_chars(0)
-    assert max(len(line) for line in str(df).split("\n")) == 31
+    assert max(len(line) for line in str(df).split("\n")) == 19
+
+    # this check helps to check that column width bucketing
+    # is exact; no extraneous character allocation
+    df = pl.DataFrame(
+        {
+            "A": [1, 2, 3, 4, 5],
+            "fruits": ["banana", "banana", "apple", "apple", "banana"],
+            "B": [5, 4, 3, 2, 1],
+            "cars": ["beetle", "audi", "beetle", "beetle", "beetle"],
+        },
+        schema_overrides={"A": pl.Int64, "B": pl.Int64},
+    ).select(pl.all(), pl.all().suffix("_suffix!"))
+
+    with pl.Config(tbl_width_chars=87):
+        assert max(len(line) for line in str(df).split("\n")) == 87
 
 
 def test_shape_below_table_and_inlined_dtype() -> None:
     df = pl.DataFrame({"a": [1, 2], "b": [3, 4], "c": [5, 6]})
 
     pl.Config.set_tbl_column_data_type_inline(True).set_tbl_dataframe_shape_below(True)
     pl.Config.set_tbl_formatting("UTF8_FULL", rounded_corners=True)
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_constructors.py` & `polars_u64_idx-0.18.7/tests/unit/test_constructors.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_cse.py` & `polars_u64_idx-0.18.7/tests/unit/test_cse.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,9 +1,12 @@
 import re
 from datetime import date
+from tempfile import NamedTemporaryFile
+
+import pytest
 
 import polars as pl
 
 
 def test_cse_rename_cross_join_5405() -> None:
     right = pl.DataFrame({"A": [1, 2], "B": [3, 4], "D": [5, 6]}).lazy()
 
@@ -100,7 +103,32 @@
     ).to_dict(False) == {
         "key": [1],
         "value": [[1, 2]],
         "x": [1],
         "value_right": [[1, 2]],
         "y": [2],
     }
+
+
+@pytest.mark.write_disk()
+def test_schema_row_count_cse() -> None:
+    csv_a = NamedTemporaryFile()
+    csv_a.write(
+        b"""
+    A,B
+    Gr1,A
+    Gr1,B
+    """.strip()
+    )
+    csv_a.seek(0)
+
+    df_a = pl.scan_csv(csv_a.name).with_row_count("Idx")
+    assert df_a.join(df_a, on="B").groupby(
+        "A", maintain_order=True
+    ).all().collect().to_dict(False) == {
+        "A": ["Gr1"],
+        "Idx": [[0, 1]],
+        "B": [["A", "B"]],
+        "Idx_right": [[0, 1]],
+        "A_right": [["Gr1", "Gr1"]],
+    }
+    csv_a.close()
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_datatypes.py` & `polars_u64_idx-0.18.7/tests/unit/test_datatypes.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_df.py` & `polars_u64_idx-0.18.7/tests/unit/test_df.py`

 * *Files 3% similar despite different names*

```diff
@@ -479,14 +479,32 @@
     df = pl.DataFrame({"a": [2, 1, 3], "b": [1, 2, 3]})
     assert_frame_equal(df.sort("a"), pl.DataFrame({"a": [1, 2, 3], "b": [2, 1, 3]}))
     assert_frame_equal(
         df.sort(["a", "b"]), pl.DataFrame({"a": [1, 2, 3], "b": [2, 1, 3]})
     )
 
 
+def test_sort_maintain_order() -> None:
+    l1 = (
+        pl.LazyFrame({"A": [1] * 4, "B": ["A", "B", "C", "D"]})
+        .sort("A", maintain_order=True)
+        .slice(0, 3)
+        .collect()["B"]
+        .to_list()
+    )
+    l2 = (
+        pl.LazyFrame({"A": [1] * 4, "B": ["A", "B", "C", "D"]})
+        .sort("A")
+        .collect()
+        .slice(0, 3)["B"]
+        .to_list()
+    )
+    assert l1 == l2 == ["A", "B", "C"]
+
+
 def test_replace() -> None:
     df = pl.DataFrame({"a": [2, 1, 3], "b": [1, 2, 3]})
     s = pl.Series("c", [True, False, True])
     df.replace("a", s)
     assert_frame_equal(df, pl.DataFrame({"a": [True, False, True], "b": [1, 2, 3]}))
 
 
@@ -1130,77 +1148,14 @@
     out = df.groupby("letters").head(2).sort("letters")
     assert_frame_equal(
         out,
         pl.DataFrame({"letters": ["a", "a", "b", "c", "c"], "nrs": [3, 5, 6, 1, 2]}),
     )
 
 
-def test_lazy_functions() -> None:
-    df = pl.DataFrame({"a": ["foo", "bar", "2"], "b": [1, 2, 3], "c": [1.0, 2.0, 3.0]})
-    out = df.select([pl.count("a")])
-    assert list(out["a"]) == [3]
-    assert pl.count(df["a"]) == 3
-    out = df.select(
-        [
-            pl.var("b").alias("1"),
-            pl.std("b").alias("2"),
-            pl.max("b").alias("3"),
-            pl.min("b").alias("4"),
-            pl.sum("b").alias("5"),
-            pl.mean("b").alias("6"),
-            pl.median("b").alias("7"),
-            pl.n_unique("b").alias("8"),
-            pl.first("b").alias("9"),
-            pl.last("b").alias("10"),
-        ]
-    )
-    expected = 1.0
-    assert np.isclose(out.to_series(0), expected)
-    assert np.isclose(pl.var(df["b"]), expected)  # type: ignore[arg-type]
-    expected = 1.0
-    assert np.isclose(out.to_series(1), expected)
-    assert np.isclose(pl.std(df["b"]), expected)  # type: ignore[arg-type]
-    expected = 3
-    assert np.isclose(out.to_series(2), expected)
-    assert np.isclose(pl.max(df["b"]), expected)  # type: ignore[arg-type]
-    expected = 1
-    assert np.isclose(out.to_series(3), expected)
-    assert np.isclose(pl.min(df["b"]), expected)  # type: ignore[arg-type]
-    expected = 6
-    assert np.isclose(out.to_series(4), expected)
-    assert np.isclose(pl.sum(df["b"]), expected)
-    expected = 2
-    assert np.isclose(out.to_series(5), expected)
-    assert np.isclose(pl.mean(df["b"]), expected)
-    expected = 2
-    assert np.isclose(out.to_series(6), expected)
-    assert np.isclose(pl.median(df["b"]), expected)
-    expected = 3
-    assert np.isclose(out.to_series(7), expected)
-    assert np.isclose(pl.n_unique(df["b"]), expected)
-    expected = 1
-    assert np.isclose(out.to_series(8), expected)
-    assert np.isclose(pl.first(df["b"]), expected)
-    expected = 3
-    assert np.isclose(out.to_series(9), expected)
-    assert np.isclose(pl.last(df["b"]), expected)
-
-    # regex selection
-    out = df.select(
-        [
-            pl.struct(pl.max("^a|b$")).alias("x"),
-            pl.struct(pl.min("^.*[bc]$")).alias("y"),
-            pl.struct(pl.sum("^[^b]$")).alias("z"),
-        ]
-    )
-    assert out.rows() == [
-        ({"a": "foo", "b": 3}, {"b": 1, "c": 1.0}, {"a": None, "c": 6.0})
-    ]
-
-
 def test_is_null_is_not_null() -> None:
     df = pl.DataFrame({"nrs": [1, 2, None]})
     assert df.select(pl.col("nrs").is_null())["nrs"].to_list() == [False, False, True]
     assert df.select(pl.col("nrs").is_not_null())["nrs"].to_list() == [
         True,
         True,
         False,
@@ -2915,14 +2870,37 @@
     assert [
         a.to_dict(False) for a in df.partition_by(["foo", "bar"], maintain_order=True)
     ] == expected
     assert [
         a.to_dict(False) for a in df.partition_by("foo", "bar", maintain_order=True)
     ] == expected
 
+    expected = [
+        {
+            "N": [1],
+        },
+        {
+            "N": [2],
+        },
+        {
+            "N": [2, 4],
+        },
+        {
+            "N": [2],
+        },
+    ]
+    assert [
+        a.to_dict(False)
+        for a in df.partition_by(["foo", "bar"], maintain_order=True, include_key=False)
+    ] == expected
+    assert [
+        a.to_dict(False)
+        for a in df.partition_by("foo", "bar", maintain_order=True, include_key=False)
+    ] == expected
+
     assert [a.to_dict(False) for a in df.partition_by("foo", maintain_order=True)] == [
         {"foo": ["A", "A"], "N": [1, 2], "bar": ["k", "l"]},
         {"foo": ["B", "B"], "N": [2, 4], "bar": ["m", "m"]},
         {"foo": ["C"], "N": [2], "bar": ["l"]},
     ]
 
     df = pl.DataFrame({"a": ["one", "two", "one", "two"], "b": [1, 2, 3, 4]})
@@ -2985,39 +2963,14 @@
             False,
             False,
             False,
         ],
     }
 
 
-def test_max_min_multiple_columns(fruits_cars: pl.DataFrame) -> None:
-    res = fruits_cars.select(pl.max(["A", "B"]).alias("max"))
-    assert_series_equal(res.to_series(0), pl.Series("max", [5, 4, 3, 4, 5]))
-
-    res = fruits_cars.select(pl.min(["A", "B"]).alias("min"))
-    assert_series_equal(res.to_series(0), pl.Series("min", [1, 2, 3, 2, 1]))
-
-
-def test_max_min_wildcard_columns(fruits_cars: pl.DataFrame) -> None:
-    res = fruits_cars.select([pl.col(pl.datatypes.Int64)]).select(pl.min(["*"]))
-    assert_series_equal(res.to_series(0), pl.Series("min", [1, 2, 3, 2, 1]))
-    res = fruits_cars.select([pl.col(pl.datatypes.Int64)]).select(pl.min([pl.all()]))
-    assert_series_equal(res.to_series(0), pl.Series("min", [1, 2, 3, 2, 1]))
-
-    res = fruits_cars.select([pl.col(pl.datatypes.Int64)]).select(pl.max(["*"]))
-    assert_series_equal(res.to_series(0), pl.Series("max", [5, 4, 3, 4, 5]))
-    res = fruits_cars.select([pl.col(pl.datatypes.Int64)]).select(pl.max([pl.all()]))
-    assert_series_equal(res.to_series(0), pl.Series("max", [5, 4, 3, 4, 5]))
-
-    res = fruits_cars.select([pl.col(pl.datatypes.Int64)]).select(
-        pl.max([pl.all(), "A", "*"])
-    )
-    assert_series_equal(res.to_series(0), pl.Series("max", [5, 4, 3, 4, 5]))
-
-
 def test_head_tail(fruits_cars: pl.DataFrame) -> None:
     res_expr = fruits_cars.select([pl.head("A", 2)])
     res_series = pl.head(fruits_cars["A"], 2)
     expected = pl.Series("A", [1, 2])
     assert_series_equal(res_expr.to_series(0), expected)
     assert_series_equal(res_series, expected)
 
@@ -3035,22 +2988,14 @@
     res_expr = fruits_cars.select(pl.col("B").upper_bound())
     assert res_expr.item() == 9223372036854775807
 
     with pytest.raises(pl.ComputeError):
         fruits_cars.select(pl.col("fruits").upper_bound())
 
 
-def test_nested_min_max() -> None:
-    df = pl.DataFrame({"a": [1], "b": [2], "c": [3], "d": [4]})
-    out = df.with_columns(pl.max([pl.min(["a", "b"]), pl.min(["c", "d"])]).alias("t"))
-    assert out.shape == (1, 5)
-    assert out.row(0) == (1, 2, 3, 4, 3)
-    assert out.columns == ["a", "b", "c", "d", "t"]
-
-
 def test_selection_misc() -> None:
     df = pl.DataFrame({"x": "abc"}, schema={"x": pl.Utf8})
 
     # literal values (as scalar/list)
     for zero in (0, [0]):
         assert df.select(zero)["literal"].to_list() == [0]  # type: ignore[arg-type]
     assert df.select(literal=0)["literal"].to_list() == [0]
@@ -3608,25 +3553,15 @@
     df = pl.DataFrame({"a": [1.8, 1.2, 3.0]})
     col_a_rounded = df.select(pl.col("a").round(decimals=0))["a"]
     assert_series_equal(col_a_rounded, pl.Series("a", [2, 1, 3]).cast(pl.Float64))
 
 
 def test_dot() -> None:
     df = pl.DataFrame({"a": [1.8, 1.2, 3.0], "b": [3.2, 1, 2]})
-    assert cast(float, df.select(pl.col("a").dot(pl.col("b"))).item()) == 12.96
-
-
-def test_all_expr() -> None:
-    df = pl.DataFrame({"nrs": [1, 2, 3, 4, 5, None]})
-    assert_frame_equal(df.select([pl.all()]), df)
-
-
-def test_any_expr(fruits_cars: pl.DataFrame) -> None:
-    assert fruits_cars.with_columns(pl.col("A").cast(bool)).select(pl.any("A"))[0, 0]
-    assert fruits_cars.select(pl.any([pl.col("A"), pl.col("B")]))[0, 0]
+    assert df.select(pl.col("a").dot(pl.col("b"))).item() == 12.96
 
 
 def test_rolling_apply() -> None:
     s = pl.Series("A", [1.0, 2.0, 9.0, 2.0, 13.0], dtype=pl.Float64)
     out = s.rolling_apply(function=lambda s: s.std(), window_size=3)
     assert out[0] is None
     assert out[1] is None
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_empty.py` & `polars_u64_idx-0.18.7/tests/unit/test_empty.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_errors.py` & `polars_u64_idx-0.18.7/tests/unit/test_errors.py`

 * *Files 0% similar despite different names*

```diff
@@ -39,17 +39,15 @@
         pl.InvalidOperationError,
         match=(
             r"output length of `map` \(4\) must be equal to "
             r"the input length \(1\); consider using `apply` instead"
         ),
     ):
         df.select(
-            pl.col("x")
-            .map(lambda x: x.cut(bins=[1, 2, 3], maintain_order=True))
-            .over("group")
+            pl.col("x").map(lambda x: x.cut(bins=[1, 2, 3], series=False)).over("group")
         )
 
 
 def test_error_on_invalid_by_in_asof_join() -> None:
     df1 = pl.DataFrame(
         {
             "a": ["a", "b", "a"],
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_expr_multi_cols.py` & `polars_u64_idx-0.18.7/tests/unit/test_expr_multi_cols.py`

 * *Files 9% similar despite different names*

```diff
@@ -27,27 +27,14 @@
         "x": [0, 1, 2],
         "y_1": [1.1, 2.2, 3.3],
         "y_2": [1.0, 2.5, 3.5],
         "y_sum": [2.1, 4.7, 6.8],
     }
 
 
-def test_expanding_sum() -> None:
-    df = pl.DataFrame(
-        {
-            "x": [0, 1, 2],
-            "y_1": [1.1, 2.2, 3.3],
-            "y_2": [1.0, 2.5, 3.5],
-        }
-    )
-    assert df.with_columns(pl.sum(pl.col(r"^y_.*$")).alias("y_sum"))[
-        "y_sum"
-    ].to_list() == [2.1, 4.7, 6.8]
-
-
 def test_arg_sort_argument_expansion() -> None:
     df = pl.DataFrame(
         {
             "col1": [1, 2, 3],
             "col2": [4, 5, 6],
             "sort_order": [9, 8, 7],
         }
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_exprs.py` & `polars_u64_idx-0.18.7/tests/unit/test_exprs.py`

 * *Files 1% similar despite different names*

```diff
@@ -59,23 +59,14 @@
     assert df.select(pl.col(pl.Int64, pl.Float64)).columns == [
         "ham",
         "hamburger",
         "foo",
     ]
 
 
-def test_horizontal_agg(fruits_cars: pl.DataFrame) -> None:
-    df = fruits_cars
-    out = df.select(pl.max([pl.col("A"), pl.col("B")]))
-    assert out[:, 0].to_list() == [5, 4, 3, 4, 5]
-
-    out = df.select(pl.min([pl.col("A"), pl.col("B")]))
-    assert out[:, 0].to_list() == [1, 2, 3, 2, 1]
-
-
 def test_suffix(fruits_cars: pl.DataFrame) -> None:
     df = fruits_cars
     out = df.select([pl.all().suffix("_reverse")])
     assert out.columns == ["A_reverse", "fruits_reverse", "B_reverse", "cars_reverse"]
 
 
 def test_pipe() -> None:
@@ -119,25 +110,14 @@
         pl.col("b").filter(pl.col("b") > 4).alias("c")
     )
     expected = pl.DataFrame({"a": [1, 2, 3], "c": [[7], [5, 8], [6, 9]]})
     assert_frame_equal(result_where, expected)
     assert_frame_equal(result_filter, expected)
 
 
-def test_min_nulls_consistency() -> None:
-    df = pl.DataFrame({"a": [None, 2, 3], "b": [4, None, 6], "c": [7, 5, 0]})
-    out = df.select([pl.min(["a", "b", "c"])]).to_series()
-    expected = pl.Series("min", [4, 2, 0])
-    assert_series_equal(out, expected)
-
-    out = df.select([pl.max(["a", "b", "c"])]).to_series()
-    expected = pl.Series("max", [7, 5, 6])
-    assert_series_equal(out, expected)
-
-
 def test_list_join_strings() -> None:
     s = pl.Series("a", [["ab", "c", "d"], ["e", "f"], ["g"], []])
     expected = pl.Series("a", ["ab-c-d", "e-f", "g", ""])
     assert_series_equal(s.list.join("-"), expected)
 
 
 def test_count_expr() -> None:
@@ -354,32 +334,14 @@
 
     out = df.select(pl.concat([pl.repeat(None, 3), pl.col("a")]))
 
     assert out.n_chunks() == 1
     assert out.to_series().to_list() == [None, None, None, 1, 1, 2]
 
 
-def test_regex_in_filter() -> None:
-    df = pl.DataFrame(
-        {
-            "nrs": [1, 2, 3, None, 5],
-            "names": ["foo", "ham", "spam", "egg", None],
-            "flt": [1.0, None, 3.0, 1.0, None],
-        }
-    )
-
-    res = df.filter(
-        pl.fold(
-            acc=False, function=lambda acc, s: acc | s, exprs=(pl.col("^nrs|flt*$") < 3)
-        )
-    ).row(0)
-    expected = (1, "foo", 1.0)
-    assert res == expected
-
-
 def test_arr_contains() -> None:
     df_groups = pl.DataFrame(
         {
             "str_list": [
                 ["cat", "mouse", "dog"],
                 ["dog", "mouse", "cat"],
                 ["dog", "mouse", "aardvark"],
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_fmt.py` & `polars_u64_idx-0.18.7/tests/unit/test_fmt.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_interchange.py` & `polars_u64_idx-0.18.7/tests/unit/test_interchange.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_interop.py` & `polars_u64_idx-0.18.7/tests/unit/test_interop.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_lazy.py` & `polars_u64_idx-0.18.7/tests/unit/test_lazy.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 from typing import TYPE_CHECKING, Any, cast
 
 import numpy as np
 import pytest
 
 import polars as pl
 from polars import lit, when
-from polars.datatypes import FLOAT_DTYPES, NUMERIC_DTYPES
+from polars.datatypes import FLOAT_DTYPES
 from polars.testing import assert_frame_equal
 from polars.testing.asserts import assert_series_equal
 
 if TYPE_CHECKING:
     from _pytest.capture import CaptureFixture
 
 
@@ -563,31 +563,14 @@
 
 
 def test_sort() -> None:
     ldf = pl.LazyFrame({"a": [1, 2, 3, 2]}).select(pl.col("a").sort())
     assert_series_equal(ldf.collect()["a"], pl.Series("a", [1, 2, 2, 3]))
 
 
-def test_all_expr() -> None:
-    ldf = pl.LazyFrame({"nrs": [1, 2, 3, 4, 5, None]})
-    assert_frame_equal(ldf.select([pl.all()]), ldf)
-
-
-def test_any_expr(fruits_cars: pl.DataFrame) -> None:
-    assert (
-        fruits_cars.lazy()
-        .with_columns(pl.col("A").cast(bool))
-        .select(pl.any("A"))
-        .collect()[0, 0]
-    ) is True
-    assert (
-        fruits_cars.lazy().select(pl.any([pl.col("A"), pl.col("B")])).collect()[0, 0]
-    ) is True
-
-
 def test_custom_groupby() -> None:
     ldf = pl.LazyFrame({"a": [1, 2, 1, 1], "b": ["a", "b", "c", "c"]})
     out = (
         ldf.groupby("b", maintain_order=True)
         .agg([pl.col("a").apply(lambda x: x.sum(), return_dtype=pl.Int64)])
         .collect()
     )
@@ -601,35 +584,14 @@
             "b": [1],
             "c": [1],
         }
     )
     assert ldf.select(["a", "c"]).columns == ["a", "c"]
 
 
-def test_regex_selection() -> None:
-    ldf = pl.LazyFrame(
-        {
-            "foo": [1],
-            "fooey": [1],
-            "foobar": [1],
-            "bar": [1],
-        }
-    )
-    assert ldf.select([pl.col("^foo.*$")]).columns == ["foo", "fooey", "foobar"]
-
-
-def test_exclude_selection() -> None:
-    ldf = pl.LazyFrame({"a": [1], "b": [1], "c": [True]})
-
-    assert ldf.select([pl.exclude("a")]).columns == ["b", "c"]
-    assert ldf.select(pl.all().exclude(pl.Boolean)).columns == ["a", "b"]
-    assert ldf.select(pl.all().exclude([pl.Boolean])).columns == ["a", "b"]
-    assert ldf.select(pl.all().exclude(NUMERIC_DTYPES)).columns == ["c"]
-
-
 def test_col_series_selection() -> None:
     ldf = pl.LazyFrame({"a": [1], "b": [1], "c": [1]})
     srs = pl.Series(["b", "c"])
 
     assert ldf.select(pl.col(srs)).columns == ["b", "c"]
 
 
@@ -1289,32 +1251,14 @@
             [pl.col("a") & pl.col("a").fill_null(True)]
         )
     ).collect()
     assert df.shape == (3, 2)
     assert df.rows() == [(1, 1), (2, 2), (3, 3)]
 
 
-def test_all_any_accept_expr() -> None:
-    ldf = pl.LazyFrame(
-        {
-            "a": [1, None, 2],
-            "b": [1, 2, None],
-        }
-    )
-    assert ldf.select(
-        [
-            pl.any(pl.all().is_null()).alias("null_in_row"),
-            pl.all(pl.all().is_null()).alias("all_null_in_row"),
-        ]
-    ).collect().to_dict(False) == {
-        "null_in_row": [False, True, True],
-        "all_null_in_row": [False, False, False],
-    }
-
-
 def test_lazy_cache_same_key() -> None:
     ldf = pl.LazyFrame({"a": [1, 2, 3], "b": [3, 4, 5], "c": ["x", "y", "z"]})
 
     # these have the same schema, but should not be used by cache as they are different
     add_node = ldf.select([(pl.col("a") + pl.col("b")).alias("a"), pl.col("c")]).cache()
     mult_node = ldf.select(
         [(pl.col("a") * pl.col("b")).alias("a"), pl.col("c")]
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_polars_import.py` & `polars_u64_idx-0.18.7/tests/unit/test_polars_import.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_predicates.py` & `polars_u64_idx-0.18.7/tests/unit/test_predicates.py`

 * *Files 1% similar despite different names*

```diff
@@ -15,15 +15,16 @@
                 date(2022, 9, 10),
                 date(2022, 9, 20),
             ]
         }
     ).lazy()
 
     assert ldf.filter(
-        pl.min([(pl.col("dt") + one_day), date(2022, 9, 30)]) > date(2022, 9, 10)
+        pl.min_horizontal((pl.col("dt") + one_day), date(2022, 9, 30))
+        > date(2022, 9, 10)
     ).collect().to_dict(False) == {"dt": [date(2022, 9, 10), date(2022, 9, 20)]}
 
 
 def test_when_then_implicit_none() -> None:
     df = pl.DataFrame(
         {
             "team": ["A", "A", "A", "B", "B", "C"],
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_projections.py` & `polars_u64_idx-0.18.7/tests/unit/test_projections.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_queries.py` & `polars_u64_idx-0.18.7/tests/unit/test_queries.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_rows.py` & `polars_u64_idx-0.18.7/tests/unit/test_rows.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_schema.py` & `polars_u64_idx-0.18.7/tests/unit/test_schema.py`

 * *Files 9% similar despite different names*

```diff
@@ -183,15 +183,16 @@
             "fruits": ["banana", "banana", "apple", "apple", "banana"],
             "B": [5, 4, 3, 2, 1],
             "cars": ["beetle", "audi", "beetle", "beetle", "beetle"],
             "optional": [28, 300, None, 2, -30],
         }
     )
     # divide because of overflow
-    assert df.select(pl.sum(pl.all().hash(seed=1) // int(1e8))).dtypes == [pl.UInt64]
+    result = df.select(pl.sum_horizontal(pl.all().hash(seed=1) // int(1e8)))
+    assert result.dtypes == [pl.UInt64]
 
 
 def test_fill_null_static_schema_4843() -> None:
     df1 = pl.DataFrame(
         {
             "a": [1, 2, None],
             "b": [1, None, 4],
@@ -210,36 +211,45 @@
             "b": [1, 2, 2 << 32],
             "c": [-1, 2, 1 << 30],
             "d": [-112, 2, 112],
             "e": [-112, 2, 129],
             "f": ["a", "b", "c"],
             "g": [0.1, 1.32, 0.12],
             "h": [True, None, False],
+            "i": pl.Series([None, None, None], dtype=pl.UInt64),
+            "j": pl.Series([None, None, None], dtype=pl.Int64),
+            "k": pl.Series([None, None, None], dtype=pl.Float64),
         }
     ).select(pl.all().shrink_dtype())
     assert out.dtypes == [
         pl.Int8,
         pl.Int64,
         pl.Int32,
         pl.Int8,
         pl.Int16,
         pl.Utf8,
         pl.Float32,
         pl.Boolean,
+        pl.UInt8,
+        pl.Int8,
+        pl.Float32,
     ]
 
     assert out.to_dict(False) == {
         "a": [1, 2, 3],
         "b": [1, 2, 8589934592],
         "c": [-1, 2, 1073741824],
         "d": [-112, 2, 112],
         "e": [-112, 2, 129],
         "f": ["a", "b", "c"],
         "g": [0.10000000149011612, 1.3200000524520874, 0.11999999731779099],
         "h": [True, None, False],
+        "i": [None, None, None],
+        "j": [None, None, None],
+        "k": [None, None, None],
     }
 
 
 def test_diff_duration_dtype() -> None:
     dates = ["2022-01-01", "2022-01-02", "2022-01-03", "2022-01-03"]
     df = pl.DataFrame({"date": pl.Series(dates).str.strptime(pl.Date, "%Y-%m-%d")})
 
@@ -464,28 +474,42 @@
     df = pl.DataFrame({"a": [0, 1, None], "b": [True, False, True]})
 
     assert df.select(pl.col("a").ne_missing(0).or_(pl.col("b")))["a"].all()
 
 
 def test_concat_vertically_relaxed() -> None:
     a = pl.DataFrame(
-        {
-            "a": [1, 2, 3],
-            "b": [True, False, None],
-        },
+        data={"a": [1, 2, 3], "b": [True, False, None]},
         schema={"a": pl.Int8, "b": pl.Boolean},
     )
-
     b = pl.DataFrame(
-        {
-            "a": [43, 2, 3],
-            "b": [32, 1, None],
-        },
+        data={"a": [43, 2, 3], "b": [32, 1, None]},
         schema={"a": pl.Int16, "b": pl.Int64},
     )
-
     out = pl.concat([a, b], how="vertical_relaxed")
     assert out.schema == {"a": pl.Int16, "b": pl.Int64}
     assert out.to_dict(False) == {
         "a": [1, 2, 3, 43, 2, 3],
         "b": [1, 0, None, 32, 1, None],
     }
+    out = pl.concat([b, a], how="vertical_relaxed")
+    assert out.schema == {"a": pl.Int16, "b": pl.Int64}
+    assert out.to_dict(False) == {
+        "a": [43, 2, 3, 1, 2, 3],
+        "b": [32, 1, None, 1, 0, None],
+    }
+
+    c = pl.DataFrame({"a": [1, 2], "b": [2, 1]})
+    d = pl.DataFrame({"a": [1.0, 0.2], "b": [None, 0.1]})
+
+    out = pl.concat([c, d], how="vertical_relaxed")
+    assert out.schema == {"a": pl.Float64, "b": pl.Float64}
+    assert out.to_dict(False) == {
+        "a": [1.0, 2.0, 1.0, 0.2],
+        "b": [2.0, 1.0, None, 0.1],
+    }
+    out = pl.concat([d, c], how="vertical_relaxed")
+    assert out.schema == {"a": pl.Float64, "b": pl.Float64}
+    assert out.to_dict(False) == {
+        "a": [1.0, 0.2, 1.0, 2.0],
+        "b": [None, 0.1, 2.0, 1.0],
+    }
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_selectors.py` & `polars_u64_idx-0.18.7/tests/unit/test_selectors.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 import pytest
 
 import polars as pl
 import polars.selectors as cs
+from polars.selectors import selector_column_names
 from polars.testing import assert_frame_equal
 
 
 @pytest.fixture()
 def df() -> pl.DataFrame:
     # set up an empty dataframe with plenty of columns of various dtypes
     df = pl.DataFrame(
@@ -161,14 +162,31 @@
                 pl.Datetime("ms", time_zone="*"), pl.Datetime("ns", time_zone="*")
             )
         ).columns
         == df.select(~cs.datetime(["ms", "ns"], time_zone="*")).columns
     )
 
 
+def test_selector_duration(df: pl.DataFrame) -> None:
+    assert df.select(cs.duration("ms")).columns == []
+    assert df.select(cs.duration(["ms", "ns"])).columns == []
+    assert selector_column_names(df, cs.duration()) == ("Lmn",)
+
+    df = pl.DataFrame(
+        schema={
+            "d1": pl.Duration("ns"),
+            "d2": pl.Duration("us"),
+            "d3": pl.Duration("ms"),
+        },
+    )
+    assert selector_column_names(df, cs.duration()) == ("d1", "d2", "d3")
+    assert selector_column_names(df, cs.duration("us")) == ("d2",)
+    assert selector_column_names(df, cs.duration(["ms", "ns"])) == ("d1", "d3")
+
+
 def test_selector_ends_with(df: pl.DataFrame) -> None:
     assert df.select(cs.ends_with("e")).columns == ["cde", "eee"]
     assert df.select(cs.ends_with("ee")).columns == ["eee"]
     assert df.select(cs.ends_with("e", "g", "i", "n", "p")).columns == [
         "cde",
         "eee",
         "fgg",
@@ -395,16 +413,16 @@
         df.with_columns(
             pl.when(~cs.float().is_finite()).then(0.0).otherwise(cs.float()).keep_name()
         ),
     )
 
     # check that "as_expr" behaves, both explicitly and implicitly
     for nan_or_inf in (
-        cs.float().is_nan().as_expr() | cs.float().is_infinite().as_expr(),  # type: ignore[attr-defined]
-        cs.float().is_nan().as_expr() | cs.float().is_infinite(),  # type: ignore[attr-defined]
+        cs.float().is_nan().as_expr() | cs.float().is_infinite().as_expr(),
+        cs.float().is_nan().as_expr() | cs.float().is_infinite(),
         cs.float().is_nan() | cs.float().is_infinite(),
     ):
         assert_frame_equal(
             expected,
             df.with_columns(
                 pl.when(nan_or_inf).then(0.0).otherwise(cs.float()).keep_name()
             ).fill_null(0),
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_serde.py` & `polars_u64_idx-0.18.7/tests/unit/test_serde.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_series.py` & `polars_u64_idx-0.18.7/tests/unit/test_series.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_single.py` & `polars_u64_idx-0.18.7/tests/unit/test_single.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_sql.py` & `polars_u64_idx-0.18.7/tests/unit/test_sql.py`

 * *Files 18% similar despite different names*

```diff
@@ -13,14 +13,68 @@
 
 # TODO: Do not rely on I/O for these tests
 @pytest.fixture()
 def foods_ipc_path() -> str:
     return str(Path(os.path.dirname(__file__)) / "io" / "files" / "foods1.ipc")
 
 
+def test_sql_cast() -> None:
+    df = pl.DataFrame(
+        {
+            "a": [1, 2, 3, 4, 5],
+            "b": [1.1, 2.2, 3.3, 4.4, 5.5],
+            "c": ["a", "b", "c", "d", "e"],
+            "d": [True, False, True, False, True],
+        }
+    )
+    # test various dtype casts, using standard ("CAST <col> AS <dtype>")
+    # and postgres-specific ("<col>::<dtype>") cast syntax
+    with pl.SQLContext(df=df, eager_execution=True) as ctx:
+        res = ctx.execute(
+            """
+            SELECT
+              -- float
+              CAST(a AS DOUBLE PRECISION) AS a_f64,
+              a::real AS a_f32,
+              -- integer
+              CAST(b AS TINYINT) AS b_i8,
+              CAST(b AS SMALLINT) AS b_i16,
+              b::bigint AS b_i64,
+              d::tinyint AS d_i8,
+              -- string/binary
+              CAST(a AS CHAR) AS a_char,
+              CAST(b AS VARCHAR) AS b_varchar,
+              c::blob AS c_blob,
+              c::VARBINARY AS c_varbinary,
+              CAST(d AS CHARACTER VARYING) AS d_charvar,
+            FROM df
+            """
+        )
+    assert res.schema == {
+        "a_f64": pl.Float64,
+        "a_f32": pl.Float32,
+        "b_i8": pl.Int8,
+        "b_i16": pl.Int16,
+        "b_i64": pl.Int64,
+        "d_i8": pl.Int8,
+        "a_char": pl.Utf8,
+        "b_varchar": pl.Utf8,
+        "c_blob": pl.Binary,
+        "c_varbinary": pl.Binary,
+        "d_charvar": pl.Utf8,
+    }
+    assert res.rows() == [
+        (1.0, 1.0, 1, 1, 1, 1, "1", "1.1", b"a", b"a", "true"),
+        (2.0, 2.0, 2, 2, 2, 0, "2", "2.2", b"b", b"b", "false"),
+        (3.0, 3.0, 3, 3, 3, 1, "3", "3.3", b"c", b"c", "true"),
+        (4.0, 4.0, 4, 4, 4, 0, "4", "4.4", b"d", b"d", "false"),
+        (5.0, 5.0, 5, 5, 5, 1, "5", "5.5", b"e", b"e", "true"),
+    ]
+
+
 def test_sql_distinct() -> None:
     df = pl.DataFrame(
         {
             "a": [1, 1, 1, 2, 2, 3],
             "b": [1, 2, 3, 4, 5, 6],
         }
     )
@@ -378,14 +432,34 @@
         GROUP BY grp
         HAVING n_dist_attr > 1
         """
     )
     assert out.to_dict(False) == {"grp": ["c"], "n_dist_attr": [2]}
 
 
+def test_sql_left() -> None:
+    df = pl.DataFrame({"scol": ["abcde", "abc", "a", None]})
+    ctx = pl.SQLContext(df=df)
+    res = ctx.execute(
+        'SELECT scol, LEFT(scol,2) AS "scol:left2" FROM df',
+    ).collect()
+
+    assert res.to_dict(False) == {
+        "scol": ["abcde", "abc", "a", None],
+        "scol:left2": ["ab", "ab", "a", None],
+    }
+    with pytest.raises(
+        pl.InvalidOperationError,
+        match="Invalid 'length' for Left: 'xyz'",
+    ):
+        ctx.execute(
+            """SELECT scol, LEFT(scol,'xyz') AS "scol:left2" FROM df"""
+        ).collect()
+
+
 def test_sql_limit_offset() -> None:
     n_values = 11
     lf = pl.LazyFrame({"a": range(n_values), "b": reversed(range(n_values))})
     c = pl.SQLContext(tbl=lf)
 
     assert c.execute("SELECT * FROM tbl LIMIT 3 OFFSET 4", eager=True).rows() == [
         (4, 6),
@@ -492,44 +566,96 @@
         ("~*", "^VEG", "vegetables"),
         ("!~", "(t|s)$", "seafood"),
         ("!~*", "(T|S)$", "seafood"),
         ("!~*", "^.E", "fruit"),
         ("!~*", "[aeiOU]", None),
     ],
 )
-def test_sql_regex(
+def test_sql_regex_operators(
     foods_ipc_path: Path, op: str, pattern: str, expected: str | None
 ) -> None:
     lf = pl.scan_ipc(foods_ipc_path)
 
     with pl.SQLContext(foods=lf, eager_execution=True) as ctx:
         out = ctx.execute(
             f"""
             SELECT DISTINCT category FROM foods
             WHERE category {op} '{pattern}'
             """
         )
         assert out.rows() == ([(expected,)] if expected else [])
 
 
-def test_sql_regex_error() -> None:
+def test_sql_regex_operators_error() -> None:
     df = pl.LazyFrame({"sval": ["ABC", "abc", "000", "A0C", "a0c"]})
     with pl.SQLContext(df=df, eager_execution=True) as ctx:
         with pytest.raises(
             pl.ComputeError, match="Invalid pattern for '~' operator: 12345"
         ):
             ctx.execute("SELECT * FROM df WHERE sval ~ 12345")
         with pytest.raises(
             pl.ComputeError,
             match=r"""Invalid pattern for '!~\*' operator: col\("abcde"\)""",
         ):
             ctx.execute("SELECT * FROM df WHERE sval !~* abcde")
 
 
 @pytest.mark.parametrize(
+    ("not_", "pattern", "flags", "expected"),
+    [
+        ("", "^veg", None, "vegetables"),
+        ("", "^VEG", None, None),
+        ("", "(?i)^VEG", None, "vegetables"),
+        ("NOT", "(t|s)$", None, "seafood"),
+        ("NOT", "T|S$", "i", "seafood"),
+        ("NOT", "^.E", "i", "fruit"),
+        ("NOT", "[aeiOU]", "i", None),
+    ],
+)
+def test_sql_regexp_like(
+    foods_ipc_path: Path,
+    not_: str,
+    pattern: str,
+    flags: str | None,
+    expected: str | None,
+) -> None:
+    lf = pl.scan_ipc(foods_ipc_path)
+    flags = "" if flags is None else f",'{flags}'"
+    with pl.SQLContext(foods=lf, eager_execution=True) as ctx:
+        out = ctx.execute(
+            f"""
+            SELECT DISTINCT category FROM foods
+            WHERE {not_} REGEXP_LIKE(category,'{pattern}'{flags})
+            """
+        )
+        assert out.rows() == ([(expected,)] if expected else [])
+
+
+def test_sql_regexp_like_errors() -> None:
+    with pl.SQLContext(df=pl.DataFrame({"scol": ["xyz"]})) as ctx:
+        with pytest.raises(
+            pl.InvalidOperationError,
+            match="Invalid/empty 'flags' for RegexpLike",
+        ):
+            ctx.execute("SELECT * FROM df WHERE REGEXP_LIKE(scol,'[x-z]+','')")
+
+        with pytest.raises(
+            pl.InvalidOperationError,
+            match="Invalid arguments for RegexpLike",
+        ):
+            ctx.execute("SELECT * FROM df WHERE REGEXP_LIKE(scol,999,999)")
+
+        with pytest.raises(
+            pl.InvalidOperationError,
+            match="Invalid number of arguments for RegexpLike",
+        ):
+            ctx.execute("SELECT * FROM df WHERE REGEXP_LIKE(scol)")
+
+
+@pytest.mark.parametrize(
     ("decimals", "expected"),
     [
         (0, [-8192.0, -4.0, -2.0, 2.0, 4.0, 8193.0]),
         (1, [-8192.5, -4.0, -1.5, 2.5, 3.6, 8192.5]),
         (2, [-8192.5, -3.96, -1.54, 2.46, 3.6, 8192.5]),
         (3, [-8192.499, -3.955, -1.543, 2.457, 3.599, 8192.5]),
         (4, [-8192.499, -3.955, -1.5432, 2.4568, 3.599, 8192.5001]),
@@ -540,26 +666,56 @@
         {"n": [-8192.499, -3.9550, -1.54321, 2.45678, 3.59901, 8192.5001]},
     )
     with pl.SQLContext(df=df, eager_execution=True) as ctx:
         if decimals == 0:
             out = ctx.execute("SELECT ROUND(n) AS n FROM df")
             assert_series_equal(out["n"], pl.Series("n", values=expected))
 
-        out = ctx.execute(f"""SELECT ROUND("n",{decimals}) AS n FROM df""")
+        out = ctx.execute(f'SELECT ROUND("n",{decimals}) AS n FROM df')
         assert_series_equal(out["n"], pl.Series("n", values=expected))
 
 
 def test_sql_round_ndigits_errors() -> None:
     df = pl.DataFrame({"n": [99.999]})
     with pl.SQLContext(df=df, eager_execution=True) as ctx, pytest.raises(
         pl.InvalidOperationError, match="Invalid 'decimals' for Round: -1"
     ):
         ctx.execute("SELECT ROUND(n,-1) AS n FROM df")
 
 
+def test_sql_substr() -> None:
+    df = pl.DataFrame(
+        {
+            "scol": ["abcdefg", "abcde", "abc", None],
+        }
+    )
+    with pl.SQLContext(df=df) as ctx:
+        res = ctx.execute(
+            """
+            SELECT
+              SUBSTR(scol,1) AS s1,
+              SUBSTR(scol,2) AS s2,
+              SUBSTR(scol,3) AS s3,
+              SUBSTR(scol,1,5) AS s1_5,
+              SUBSTR(scol,2,2) AS s2_2,
+              SUBSTR(scol,3,1) AS s3_1,
+            FROM df
+            """
+        ).collect()
+
+    assert res.to_dict(False) == {
+        "s1": ["bcdefg", "bcde", "bc", None],
+        "s2": ["cdefg", "cde", "c", None],
+        "s3": ["defg", "de", "", None],
+        "s1_5": ["bcdef", "bcde", "bc", None],
+        "s2_2": ["cd", "cd", "c", None],
+        "s3_1": ["d", "d", "", None],
+    }
+
+
 def test_sql_trim(foods_ipc_path: Path) -> None:
     with warnings.catch_warnings():
         warnings.simplefilter("ignore", DeprecationWarning)
 
         out = pl.SQLContext(foods1=pl.scan_ipc(foods_ipc_path)).query(  # type: ignore[attr-defined]
             """
             SELECT DISTINCT TRIM(LEADING 'vmf' FROM category)
@@ -589,11 +745,14 @@
 
         assert ctx.tables() == ["_lf1", "_lf2"]
 
     assert ctx.tables() == []
 
 
 def test_sql_expr() -> None:
-    df = pl.DataFrame({"a": [1, 2, 3], "b": [4, None, 6]})
-    sql_expr = pl.sql_expr("MIN(a)")
-    expected = pl.DataFrame({"a": [1]})
-    assert df.select(sql_expr).frame_equal(expected)
+    df = pl.DataFrame({"a": [1, 2, 3], "b": ["xyz", "abcde", None]})
+    sql_exprs = (
+        pl.sql_expr("MIN(a)"),
+        pl.sql_expr("SUBSTR(b,1,2)"),
+    )
+    expected = pl.DataFrame({"a": [1, 1, 1], "b": ["yz", "bc", None]})
+    assert df.select(sql_exprs).frame_equal(expected)
```

### Comparing `polars_u64_idx-0.18.6/tests/unit/test_testing.py` & `polars_u64_idx-0.18.7/tests/unit/test_testing.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/utils/test_parse_expr_input.py` & `polars_u64_idx-0.18.7/tests/unit/utils/test_parse_expr_input.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/tests/unit/utils/test_utils.py` & `polars_u64_idx-0.18.7/tests/unit/utils/test_utils.py`

 * *Files identical despite different names*

### Comparing `polars_u64_idx-0.18.6/Cargo.lock` & `polars_u64_idx-0.18.7/Cargo.lock`

 * *Files 0% similar despite different names*

```diff
@@ -358,17 +358,17 @@
 dependencies = [
  "ciborium-io",
  "half",
 ]
 
 [[package]]
 name = "comfy-table"
-version = "6.2.0"
+version = "7.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7e959d788268e3bf9d35ace83e81b124190378e4c91c9067524675e33394b8ba"
+checksum = "9ab77dbd8adecaf3f0db40581631b995f312a8a5ae3aa9993188bb8f23d83a5b"
 dependencies = [
  "crossterm",
  "strum",
  "strum_macros 0.24.3",
  "unicode-width",
 ]
 
@@ -1714,15 +1714,15 @@
 checksum = "6aeca18b86b413c660b781aa319e4e2648a3e6f9eadc9b47e9038e6fe9f3451b"
 dependencies = [
  "unicode-ident",
 ]
 
 [[package]]
 name = "py-polars"
-version = "0.18.6"
+version = "0.18.7"
 dependencies = [
  "ahash",
  "built",
  "ciborium",
  "jemallocator",
  "lexical-core",
  "libc",
```

### Comparing `polars_u64_idx-0.18.6/PKG-INFO` & `polars_u64_idx-0.18.7/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: polars-u64-idx
-Version: 0.18.6
+Version: 0.18.7
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Environment :: Console
 Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3
```

#### html2text {}

```diff
@@ -1,8 +1,8 @@
-Metadata-Version: 2.1 Name: polars-u64-idx Version: 0.18.6 Classifier:
+Metadata-Version: 2.1 Name: polars-u64-idx Version: 0.18.7 Classifier:
 Development Status :: 5 - Production/Stable Classifier: Environment :: Console
 Classifier: Intended Audience :: Science/Research Classifier: License :: OSI
 Approved :: MIT License Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python Classifier: Programming Language ::
 Python :: 3 Classifier: Programming Language :: Python :: 3 :: Only Classifier:
 Programming Language :: Python :: 3.8 Classifier: Programming Language ::
 Python :: 3.9 Classifier: Programming Language :: Python :: 3.10 Classifier:
```

