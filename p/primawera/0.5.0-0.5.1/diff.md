# Comparing `tmp/primawera-0.5.0-py3-none-any.whl.zip` & `tmp/primawera-0.5.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,28 +1,28 @@
-Zip file size: 45166 bytes, number of entries: 26
--rw-r--r--  2.0 unx      332 b- defN 23-Jun-19 20:02 primawera/__init__.py
--rw-r--r--  2.0 unx    16496 b- defN 23-Jun-19 20:02 primawera/app.py
--rw-r--r--  2.0 unx     1427 b- defN 23-Jun-19 20:02 primawera/filters.py
--rw-r--r--  2.0 unx     1514 b- defN 23-Jun-19 20:02 primawera/html_codes.py
--rw-r--r--  2.0 unx     4363 b- defN 23-Jun-19 20:02 primawera/loading.py
--rw-r--r--  2.0 unx     2183 b- defN 23-Jun-19 20:02 primawera/lut.py
--rw-r--r--  2.0 unx     1387 b- defN 23-Jun-19 20:02 primawera/modeutils.py
--rw-rw-rw-  2.0 unx     3656 b- defN 23-Jun-19 20:02 primawera/luts/grayscale.lut
--rw-rw-rw-  2.0 unx     3366 b- defN 23-Jun-19 20:02 primawera/luts/jet.lut
--rw-rw-rw-  2.0 unx     3767 b- defN 23-Jun-19 20:02 primawera/luts/sepia.lut
--rw-r--r--  2.0 unx      981 b- defN 23-Jun-19 20:02 primawera/widgets/HighlightScrollArea.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-19 20:02 primawera/widgets/__init__.py
--rw-r--r--  2.0 unx     6476 b- defN 23-Jun-19 20:02 primawera/widgets/canvas2d.py
--rw-r--r--  2.0 unx     9303 b- defN 23-Jun-19 20:02 primawera/widgets/canvas3d.py
--rw-r--r--  2.0 unx    16407 b- defN 23-Jun-19 20:02 primawera/widgets/canvasbase.py
--rw-r--r--  2.0 unx     7073 b- defN 23-Jun-19 20:02 primawera/widgets/canvascomplex.py
--rw-r--r--  2.0 unx     2981 b- defN 23-Jun-19 20:02 primawera/widgets/informationwindow.py
--rw-r--r--  2.0 unx     2948 b- defN 23-Jun-19 20:02 primawera/widgets/pixmaplabel.py
--rw-r--r--  2.0 unx     4782 b- defN 23-Jun-19 20:02 primawera/widgets/previewwindow.py
--rw-r--r--  2.0 unx    10156 b- defN 23-Jun-19 20:02 primawera/widgets/visualiser.py
--rw-rw-rw-  2.0 unx    35149 b- defN 23-Jun-19 20:06 primawera-0.5.0.dist-info/COPYING.txt
--rw-r--r--  2.0 unx     2967 b- defN 23-Jun-19 20:06 primawera-0.5.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jun-19 20:06 primawera-0.5.0.dist-info/WHEEL
--rw-r--r--  2.0 unx       46 b- defN 23-Jun-19 20:06 primawera-0.5.0.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       10 b- defN 23-Jun-19 20:06 primawera-0.5.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2175 b- defN 23-Jun-19 20:06 primawera-0.5.0.dist-info/RECORD
-26 files, 140037 bytes uncompressed, 41660 bytes compressed:  70.3%
+Zip file size: 49826 bytes, number of entries: 26
+-rw-r--r--  2.0 unx      365 b- defN 23-Jul-12 20:50 primawera/__init__.py
+-rw-r--r--  2.0 unx    17866 b- defN 23-Jul-12 20:50 primawera/app.py
+-rw-r--r--  2.0 unx     2530 b- defN 23-Jul-12 20:50 primawera/filters.py
+-rw-r--r--  2.0 unx     1514 b- defN 23-Jul-12 20:50 primawera/html_codes.py
+-rw-r--r--  2.0 unx     4363 b- defN 23-Jul-12 20:50 primawera/loading.py
+-rw-r--r--  2.0 unx     3864 b- defN 23-Jul-12 20:50 primawera/lut.py
+-rw-r--r--  2.0 unx     2246 b- defN 23-Jul-12 20:50 primawera/modeutils.py
+-rw-rw-rw-  2.0 unx     3656 b- defN 23-Jul-12 20:50 primawera/luts/grayscale.lut
+-rw-rw-rw-  2.0 unx     3366 b- defN 23-Jul-12 20:50 primawera/luts/jet.lut
+-rw-rw-rw-  2.0 unx     3767 b- defN 23-Jul-12 20:50 primawera/luts/sepia.lut
+-rw-r--r--  2.0 unx     1250 b- defN 23-Jul-12 20:50 primawera/widgets/HighlightScrollArea.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-12 20:51 primawera/widgets/__init__.py
+-rw-r--r--  2.0 unx     7088 b- defN 23-Jul-12 20:50 primawera/widgets/canvas2d.py
+-rw-r--r--  2.0 unx    10137 b- defN 23-Jul-12 20:50 primawera/widgets/canvas3d.py
+-rw-r--r--  2.0 unx    18823 b- defN 23-Jul-12 20:50 primawera/widgets/canvasbase.py
+-rw-r--r--  2.0 unx     7511 b- defN 23-Jul-12 20:50 primawera/widgets/canvascomplex.py
+-rw-r--r--  2.0 unx     3823 b- defN 23-Jul-12 20:50 primawera/widgets/informationwindow.py
+-rw-r--r--  2.0 unx     3647 b- defN 23-Jul-12 20:50 primawera/widgets/pixmaplabel.py
+-rw-r--r--  2.0 unx     5721 b- defN 23-Jul-12 20:50 primawera/widgets/previewwindow.py
+-rw-r--r--  2.0 unx    13320 b- defN 23-Jul-12 20:50 primawera/widgets/visualiser.py
+-rw-rw-rw-  2.0 unx    35149 b- defN 23-Jul-12 20:52 primawera-0.5.1.dist-info/COPYING.txt
+-rw-r--r--  2.0 unx     3109 b- defN 23-Jul-12 20:52 primawera-0.5.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-12 20:52 primawera-0.5.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx       46 b- defN 23-Jul-12 20:52 primawera-0.5.1.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       10 b- defN 23-Jul-12 20:52 primawera-0.5.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2177 b- defN 23-Jul-12 20:52 primawera-0.5.1.dist-info/RECORD
+26 files, 155440 bytes uncompressed, 46320 bytes compressed:  70.2%
```

## zipnote {}

```diff
@@ -54,26 +54,26 @@
 
 Filename: primawera/widgets/previewwindow.py
 Comment: 
 
 Filename: primawera/widgets/visualiser.py
 Comment: 
 
-Filename: primawera-0.5.0.dist-info/COPYING.txt
+Filename: primawera-0.5.1.dist-info/COPYING.txt
 Comment: 
 
-Filename: primawera-0.5.0.dist-info/METADATA
+Filename: primawera-0.5.1.dist-info/METADATA
 Comment: 
 
-Filename: primawera-0.5.0.dist-info/WHEEL
+Filename: primawera-0.5.1.dist-info/WHEEL
 Comment: 
 
-Filename: primawera-0.5.0.dist-info/entry_points.txt
+Filename: primawera-0.5.1.dist-info/entry_points.txt
 Comment: 
 
-Filename: primawera-0.5.0.dist-info/top_level.txt
+Filename: primawera-0.5.1.dist-info/top_level.txt
 Comment: 
 
-Filename: primawera-0.5.0.dist-info/RECORD
+Filename: primawera-0.5.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## primawera/__init__.py

```diff
@@ -3,13 +3,14 @@
 from primawera.app import create_window
 
 
 def start():
     create_window()
 
 
+# Sets the __version__ variable.
 # Taken from:
 # https://www.moritzkoerber.com/posts/versioning-with-setuptools_scm/
 try:
     __version__ = version("primawera")
 except PackageNotFoundError:
     __version__ = "unknown version"
```

## primawera/app.py

```diff
@@ -17,25 +17,46 @@
 from primawera.modeutils import translate_mode
 from primawera.widgets.canvas2d import Canvas2D
 from primawera.widgets.canvas3d import Canvas3D
 from primawera.widgets.canvascomplex import CanvasComplex
 
 
 class MainWindow(QtWidgets.QMainWindow):
+    """
+    The main widget of the Primawera application.
+    """
     def __init__(self, filepath: Optional[str] = None,
                  data: Optional[ArrayLike] = None, mode: Optional[str] = None,
                  title: Optional[str] = "Primawera",
                  overlay_data: Optional[NDArray[int]] = None,
                  overlay_is_grayscale: bool = True):
-        super(MainWindow, self).__init__()
-        # TODO: rework
+        """
+        Constructs the object.
 
+        Parameters
+        ----------
+        filepath: string, optional
+            Path to the image file.
+        data: ArrayLike, optional
+            Data to visualise. The application will try to readjust it to the
+            format (frames, width, height, channels).
+        mode: string, optional
+            Mode of the image data. Needed if NumPy data is passed in.
+        title: string, optional
+            Title of the window.
+        overlay_data: integer ndarray, optional
+            Data to use as overlays. Has to be the same shape as input data.
+        overlay_is_grayscale: bool
+            Is overlay data grayscale?
+        """
+        super(MainWindow, self).__init__()
         self.last_accessed_file_path = "."
         self.last_accessed_folder_path = "."
 
+        # First tries to readjust the data to suitable format.
         if data is not None:
             data = np.asanyarray(data)
 
         if mode is not None:
             mode = mode.strip()
             if filepath is not None:
                 QMessageBox \
@@ -124,14 +145,16 @@
     def keyPressEvent(self, event):
         if event.key() == QtCore.Qt.Key_PageDown:
             self.canvas.previous_frame()
         elif event.key() == QtCore.Qt.Key_PageUp:
             self.canvas.next_frame()
 
     def _recognize_mode(self, array: ArrayLike) -> Optional[str]:
+        """If not information about mode is passed, try to recognize it
+        automatically."""
         if not isinstance(array, np.ndarray):
             return None
         scalar_type = array.dtype
 
         if np.issubdtype(scalar_type, np.integer):
             if np.issubdtype(scalar_type, np.bool_):
                 return "1"
@@ -144,14 +167,15 @@
         elif np.issubdtype(scalar_type, np.floating):
             return "F"
         return None
 
     def _start_visualiser(self, data: ArrayLike, mode: str,
                           overlay_data: Optional[NDArray[int]] = None,
                           overlay_is_grayscale: bool = False) -> None:
+        """Starts the visualiser."""
         if self.canvas is not None:
             self.canvas.close()
             self.canvas = None
         if self.central_widget is not None:
             self.central_widget.deleteLater()
 
         data = np.asanyarray(data)
@@ -189,14 +213,15 @@
         self.central_widget = QtWidgets.QWidget()
         self.central_widget.setLayout(layout)
         self.setCentralWidget(self.central_widget)
         self._refresh_menu_bar()
 
     @pyqtSlot()
     def _refresh_menu_bar(self) -> None:
+        """Redraws the menu bars."""
         # Clear menubar
         self._create_menu_bar()
 
         # Update menu with available filters
         menubar = self.menuBar()
         canvas_menus = self.canvas.get_menus()
         for menu_title, actions in canvas_menus:
@@ -207,39 +232,44 @@
             action_group = QActionGroup(self)
             for idx, action in enumerate(actions):
                 action_group.addAction(action)
                 new_menu.addAction(action)
         self._create_menu_bar_post()
 
     def _create_menu_bar(self) -> None:
+        """Creates menu bar."""
         menubar = self.menuBar()
         menubar.clear()
 
         # File menu
         file_menu = menubar.addMenu("&File")
         file_menu.addAction(self.open_file_action)
         file_menu.addAction(self.open_folder_action)
         file_menu.addAction(self.exit_action)
 
     def _create_menu_bar_post(self) -> None:
+        """Run after the creation of the menu bar. Useful for adding extra
+        menus at the right."""
         menubar = self.menuBar()
 
         # Help menu
         help_menu = menubar.addMenu("&Help")
         help_menu.addAction(self.about_action)
         help_menu.addAction(self.help_commands_action)
 
     def _create_actions(self) -> None:
+        """Create all QActions."""
         self.open_file_action = QAction("Open file...")
         self.open_folder_action = QAction("Open folder...")
         self.exit_action = QAction("Exit")
         self.about_action = QAction("About")
         self.help_commands_action = QAction("Commands")
 
     def _connect_actions(self) -> None:
+        """Connects all actions."""
         self.exit_action.triggered.connect(self.close)
         self.open_file_action.triggered.connect(self.open_file)
         self.open_folder_action.triggered.connect(self.open_folder)
         self.help_commands_action.triggered.connect(self.help_commands)
         self.about_action.triggered.connect(self.about_command)
 
     def resizeEvent(self, event):
@@ -254,14 +284,15 @@
     def closeEvent(self, event) -> None:
         self.canvas.closeEvent(event)
         if self._help_window is not None:
             self._help_window.close()
         event.accept()
 
     def open_file(self) -> None:
+        """Opens the file selection dialog."""
         file_name, _ = QFileDialog. \
             getOpenFileName(self, "Open file",
                             self.last_accessed_file_path,
                             "Image file (*.jpg *.png"
                             " *.h5 *.tif *.tiff)")
         if file_name == "":
             # User did not select a file
@@ -270,46 +301,50 @@
         parent_path = dirname(file_name)  # path to the parent directory
         if file_name != "":
             self.last_accessed_file_path = parent_path
 
         self._open(file_name)
 
     def open_folder(self) -> None:
+        """Opens the folder selection dialog."""
         folder_name = QFileDialog. \
             getExistingDirectory(self, "Open folder",
                                  self.last_accessed_folder_path,
                                  QFileDialog.ShowDirsOnly
                                  )
         if folder_name == "":
             # No folder was selected
             return
         self.last_accessed_folder_path = folder_name
         self._open(folder_name)
 
     def _open(self, path: str) -> None:
+        """Open a file at given path."""
         try:
             data, mode = load_data(path)
             self._start_visualiser(data, mode)
         except UnsupportedFormatError as err:
             self.setCentralWidget(QLabel(
                 "Error inside Primawera encountered with the following "
                 f"message:\n{err}"))
         except UnidentifiedImageError as err:
             self.setCentralWidget(QLabel(
                 f"Error inside PIL library with the following message:\n{err}"
             ))
 
     def help_commands(self) -> None:
+        """Shows the help window."""
         self._help_window = QLabel(command_page_content)
         self._help_window.setWindowTitle("Primawera - Help window.")
         self._help_window.setFont(self.main_font)
         self._help_window.setMargin(10)
         self._help_window.show()
 
     def about_command(self) -> None:
+        """Shows the 'about' window."""
         self._help_window = QLabel(about_page_content)
         self._help_window.setWindowTitle("Primawera - About window.")
         self._help_window.setFont(self.main_font)
         self._help_window.setMargin(10)
         self._help_window.show()
 
     def paintEvent(self, event) -> None:
@@ -323,43 +358,42 @@
 
 def print_help(name: str) -> None:
     print(f"Usage: {name} FILEPATH\n"
           f"-----\n"
           f"Filepath specifies path to an image file. It is optional.\n\n")
 
 
-# TODO: update docs
 def run_app(data: Union[str, ArrayLike], mode: Optional[str] = None,
             overlay_data: Optional[NDArray[int]] = None,
             is_overlay_grayscale: bool = True,
             title: str = "Primawera") \
         -> Union[QMainWindow, bool]:
     """
     Creates a Primawera window.
 
-        Parameters
-        ----------
-        data : string or arraylike object
-            Either a path to a file or a numpy array.
-        mode : string, optional
-            "gray", "color, "rgb", "float" or "complex". Additional aliases
-            can be found inside the `modeutils.py` file or inside README.md
-        overlay_data : arraylike with integer type, optional
-            Data to overlay on top of the image. Can include colours or
-            grayscale data, but must have the same dimensions as data.
-        is_overlay_grayscale : bool, optional
-            Should the overlay data be interpreted as coloured?
-        title : string, optional
-            The window's title.
-
-        Returns
-        -------
-        out: bool or MainWindow
-            MainWindow object representing the PyQT application or False if
-            an error happened.
+    Parameters
+    ----------
+    data : string or arraylike object
+        Either a path to a file or a numpy array.
+    mode : string, optional
+        "gray", "color, "rgb", "float" or "complex". Additional aliases
+        can be found inside the `modeutils.py` file or inside README.md
+    overlay_data : arraylike with integer type, optional
+        Data to overlay on top of the image. Can include colours or
+        grayscale data, but must have the same dimensions as data.
+    is_overlay_grayscale : bool, optional
+        Should the overlay data be interpreted as coloured?
+    title : string, optional
+        The window's title.
+
+    Returns
+    -------
+    out: bool or MainWindow
+        MainWindow object representing the PyQT application or False if
+        an error happened.
 
     """
     app = QtCore.QCoreApplication.instance()
     app_created = False
     if app is None:
         print("Creating app")
         app = QtWidgets.QApplication(sys.argv)
@@ -398,14 +432,15 @@
         app.exec_()
     return _window
 
 
 # Inspired by:
 # https://cyrille.rossant.net/making-pyqt4-pyside-and-ipython-work-together/
 def create_window(filepath: Optional[str] = None):
+    """Creates the Primawera window with the passed in file path."""
     app_created = False
     app = QtCore.QCoreApplication.instance()
     if app is None:
         print("Creating app")
         app = QtWidgets.QApplication(sys.argv)
         app_created = True
     app.references = set()
```

## primawera/filters.py

```diff
@@ -1,13 +1,30 @@
+"""
+Implementation of various filters that Primawera uses.
+"""
 import numpy as np
 from numpy.typing import ArrayLike
 
 
 # Expects an array with dtype=float
 def linear_stretch(array: ArrayLike) -> ArrayLike:
+    """
+    Linearly stretches the data inside the array to range [0.0, 1.0].
+
+    Parameters
+    ----------
+    array: ndarray of type float.
+        Data to strech.
+
+    Returns
+    -------
+    out: ndarray of type float
+        New array filled with stretched data.
+
+    """
     array = np.array(array, dtype=float, copy=True)
     frames, height, width = array.shape
     max_val, min_val = np.max(array), np.min(array)
     if max_val - min_val == 0:
         print("Error: Cannot apply linear stretch filter on constant images, "
               "which would cause a division by 0 error! Ignoring filter.")
         return array
@@ -15,33 +32,69 @@
     for n in range(frames):
         array[n] = array[n] - min_val
         array[n] = array[n] * factor
     return array
 
 
 def gamma_correction(array: ArrayLike, factor: float) -> ArrayLike:
+    """
+    Applies gamma correction with the given factor.
+
+    Parameters
+    ----------
+    array: ndarray
+        Input data.
+    factor: float
+        Gamma correction factor.
+
+    Returns
+    -------
+    array: ndarray float
+        New array with gamma correction applied.
+    """
     array = np.array(array, dtype=float, copy=True)
     max_value = array.max()
     array = array / max_value
     array **= factor
     array *= max_value
     return array
 
 
 def linear_contrast(array: ArrayLike, factor: float) -> ArrayLike:
     modified = array * factor
     return modified
 
 
 def logarithm_stretch(array: ArrayLike, factor=1.0) -> ArrayLike:
+    """
+    Apply logarithm stretch to the data.
+
+    Result is calculated as taking the natural logarithm of the data and then
+    multiplied by the passed in factor.
+
+    If the data contains negatives values, the transformation is applied on
+    the absolute value of the data, and then the signs are reapplied.
+
+    Parameters
+    ----------
+    array: ArrayLike
+        Input data.
+    factor: float
+        Multiplication factor.
+
+    Returns
+    -------
+    result: ArrayLike
+        Stretched data.
+
+    """
     array = np.asanyarray(array)
     shift = False
     original_signs = None
     if array.min() < 0:
         shift = True
         original_signs = np.sign(array)
         array = np.abs(array)
     result = factor * np.log(array + 1)
     if shift:
-        assert original_signs is not None
         result = result * original_signs
     return result
```

## primawera/lut.py

```diff
@@ -1,33 +1,68 @@
+"""
+This module handles loading of lookup tables (LUT).
+
+Every LUT is stored inside the LUTS dictionary object with its name as the
+key. The value inside the dictionary is equal to an array, which specifies how
+should pixel values be translated.
+
+The .lut file specifying the transformations looks like:
+0;0;0;0         # 0 ~> RGB(0, 0, 0)
+1;43;28;4       # 1 ~> RGB(43, 28, 4)
+2;57;35;5       # 2 ~> RGB(57, 35, 5)
+...
+
+"""
 import sys
 from importlib.resources import files
 from os import listdir
 from os.path import isdir
 from pathlib import Path
 from typing import TextIO
 
 import numpy as np
-from numpy.typing import ArrayLike
+from numpy.typing import ArrayLike, NDArray
 
 LUT = ArrayLike
 LUTS = dict()
 
 
 def add_file(file_descriptor: TextIO, name: str) -> None:
+    """
+    Takes a text stream containing a LUT definition and adds to the global
+    LUT repository.
+
+    Parameters
+    ----------
+    file_descriptor: TextIO
+        Text stream from which the data is loaded.
+    name: str
+        Name of the LUT table.
+
+    """
     # Load the LUT
     file_lut = [0 for _ in range(256)]
     for line in file_descriptor:
         parts = [int(x) for x in line.rstrip().split(";")]
         val, map_val = parts[0], parts[1:]
         file_lut[val] = map_val
     file_lut = np.array(file_lut)
     LUTS[name] = file_lut
 
 
 def add_luts_at_path(path_to_luts: str) -> None:
+    """
+    Loads all .lut files at the given directory.
+
+    Parameters
+    ----------
+    path_to_luts: str
+        Path to the directory containing the .lut files.
+
+    """
     if not isdir(path_to_luts):
         raise RuntimeWarning(f"{path_to_luts} is not a directory!")
 
     for file in listdir(path_to_luts):
         if path_to_luts is None:
             file = str(file)
 
@@ -35,42 +70,82 @@
             print(
                 f"Warning: Skipped f{file} as it does not end with \'.lut\'.",
                 file=sys.stderr)
             continue
 
         # Create name
         name = Path(file).stem.capitalize()
-        with open(path_to_luts + file) as file_input:
-            add_file(file_input, name)
+        try:
+            with open(path_to_luts + file) as file_input:
+                add_file(file_input, name)
+        except OSError:
+            print(f"Warning: Failed to load {name}! Skipping...")
 
 
 def fill_luts() -> None:
+    """
+    Loads all LUTs included in the package.
+    """
     resource = files("primawera.luts")
     if not resource.is_dir():
         raise RuntimeWarning("Cannot find LUTs resource inside the package!")
 
     for resource_file in resource.iterdir():
         if not resource_file.name.endswith(".lut"):
             print(
                 f"Warning: Skipped f{resource_file} as it does not end with \'"
                 f".lut\'.",
                 file=sys.stderr)
             continue
 
         # Create name
         name = resource_file.name.capitalize()
-        with open(resource_file) as file_input:
-            add_file(file_input, name)
+
+        try:
+            with open(resource_file) as file_input:
+                add_file(file_input, name)
+        except OSError:
+            print(f"Warning: Failed to load LUT with {name}. Skipping...")
 
 
 def get_lut(name: str) -> LUT:
+    """
+    Get LUT with the given name.
+
+    Parameters
+    ----------
+    name: str
+        Name of the LUT.
+
+    Returns
+    -------
+    lut: LUT
+        LUT with the given name if one exists otherwise returns an empty array.
+
+    """
     return LUTS.get(name, [])
 
 
-def apply_lut(data: ArrayLike, lut: LUT) -> ArrayLike:
+def apply_lut(data: NDArray[np.uint8], lut: LUT) -> ArrayLike:
+    """
+    Apply LUT to grayscale data.
+
+    Parameters
+    ----------
+    data: uint8 2D ndarray.
+        Data to apply LUT onto.
+    lut: LUT
+        LUT to apply.
+
+    Returns
+    -------
+    out: uint8 2D ndarray
+        New array with changed values.
+
+    """
     result = lut[data]
     return result.astype(np.uint8)
 
 
 if __name__ == "__main__":
     add_luts_at_path("luts/")
     lut = get_lut("Sepia")
```

## primawera/modeutils.py

```diff
@@ -1,31 +1,78 @@
+"""
+This module handles the translation between various names of color modes e.g.
+gray = grey = I;16B etc.
+"""
 from typing import Optional
 
+# Various name aliases for common color modes.
 BOOL_ALIASES = {"1", "BOOL"}
 GRAYSCALE_ALIASES = {"GRAY", "GRAYSCALE", "GREY", "GREYSCALE", "I;16", "I;16B"}
 COLOR_ALIASES = {"RGB", "COLOR", "COLOUR"}
 FLOATING_ALIASES = {"F", "FLOATING", "FLOAT"}
 COMPLEX_ALIASES = {"C", "COMPLEX"}
 RECOGNIZED_MODES = {None}.union(BOOL_ALIASES, GRAYSCALE_ALIASES, COLOR_ALIASES,
                                 FLOATING_ALIASES, COMPLEX_ALIASES)
 
 HUMAN_NAMES = [(BOOL_ALIASES, "Bool"), (GRAYSCALE_ALIASES, "Grayscale"),
                (COLOR_ALIASES, "Color"), (FLOATING_ALIASES, "Floating"),
                (COMPLEX_ALIASES, "Complex")]
 
 
 def is_mode_grayscale(mode: str) -> bool:
+    """
+    Is the passed in name a genuine name for a grayscale color mode?
+
+    Parameters
+    ----------
+    mode: str
+        Name of the mode.
+
+    Returns
+    -------
+    out: bool
+        True if it is.
+
+    """
     return mode.upper() in GRAYSCALE_ALIASES
 
 
 def is_mode_color(mode: str) -> bool:
+    """
+    Is the passed in name a genuine name for a colored image mode (RGB, Color,
+    etc)?
+
+    Parameters
+    ----------
+    mode: str
+        Name of the mode.
+
+    Returns
+    -------
+    out: bool
+        True if it is.
+
+    """
     return mode.upper() in COLOR_ALIASES
 
 
 def translate_mode(mode: str) -> Optional[str]:
+    """
+    Translates from PIL's towards Primawera's names for image modes.
+    Parameters
+    ----------
+    mode: str
+        Name of the mode.
+
+    Returns
+    -------
+    out: str
+        Equivalent name in the Primawera system.
+
+    """
     if mode.upper() not in RECOGNIZED_MODES:
         return None
     if mode.upper() in BOOL_ALIASES:
         return "1"
     elif mode.upper() in GRAYSCALE_ALIASES:
         return "grayscale"
     elif mode.upper() in COLOR_ALIASES:
```

## primawera/widgets/HighlightScrollArea.py

```diff
@@ -1,16 +1,29 @@
+"""
+This module contains the custom QScrollArea class used for visualisng pixmap
+data.
+"""
 from PyQt5.QtWidgets import QScrollArea
 
 
 class HighlightScrollArea(QScrollArea):
     """
-    QScrollArea with focus indicating borders.
+    Custom QScrollArea widget. If the widget has focus, then it has a yellow
+    border.
     """
 
     def __init__(self, width: int = 1):
+        """
+        Constructor.
+
+        Parameters
+        ----------
+        width: int
+            Width of the border.
+        """
         super(HighlightScrollArea, self).__init__()
         if self.hasFocus():
             self.setStyleSheet(
                 f"border: {width}px solid yellow; padding: 0px; margin: 0px;")
         else:
             self.setStyleSheet(
                 f"border: {width}px solid gray; padding: 0px; margin: 0px;")
```

## primawera/widgets/canvas2d.py

```diff
@@ -9,23 +9,48 @@
     linear_contrast, logarithm_stretch
 from primawera.lut import apply_lut
 from primawera.widgets.canvasbase import CanvasBase
 from primawera.widgets.visualiser import Visualiser
 
 
 class Canvas2D(CanvasBase):
+    """
+    Basic view of 2D image data.
+    """
     menus_changed_signal = pyqtSignal()
 
     def __init__(self, data: ArrayLike, mode: str,
                  desktop_height: int, desktop_width: int,
                  filters: Optional[Dict[str, bool]] = None,
                  filters_options: Optional[Dict[str, int]] = None,
                  overlay_data: Optional[NDArray[int]] = None,
                  overlay_is_grayscale: bool = True,
                  *args, **kwargs) -> None:
+        """
+        Constructs the object.
+        Parameters
+        ----------
+        data: ArrayLike
+            Data to visualise. Has to be in the format (frames, width, height,
+            channels). The last dimension is voluntary.
+        mode: string
+            Name of the image mode.
+        desktop_height: int
+            Height of the desktop.
+        desktop_width: int
+            Width of the desktop.
+        filters: dictionary of (str, int) pairs, optional
+            Describes the name of the filter to use.
+        filters_options: dictionary of (str, int), optional
+            Parameters for the filters.
+        overlay_data: integer ndarray, optional
+            Data to overlay on top.
+        overlay_is_grayscale: bool
+            Is the overlay data grayscale?
+        """
         super(Canvas2D, self).__init__(data, mode, desktop_height,
                                        desktop_width, filters, filters_options,
                                        overlay_data, overlay_is_grayscale,
                                        *args, **kwargs)
         self._init_interface()
         self._create_actions()
         self._set_actions_checkable()
@@ -145,21 +170,17 @@
         if overlay_reshaped is None:
             return  # Failed to use the overlay data
         self.raw_overlay_data = overlay_data
         self.overlay_is_grayscale = is_grayscale
 
         # Upload to visualiser
         self.visualiser.update_overlay(overlay_reshaped)
-        # TODO: It does not make sense to reset the overlay_data when
-        #       new filter or LUT is applied.
-        #       => Separate this behaviour in other functions.
         self.visualiser.redraw()
 
     def _remove_overlay(self) -> None:
-        # TODO: consider if redrawing is necessary in all cases
         self.visualiser.remove_overlay()
         self.visualiser.redraw()
 
     def _hide_overlay(self) -> None:
         self.visualiser.hide_overlay()
 
     def _show_overlay(self) -> None:
```

## primawera/widgets/canvas3d.py

```diff
@@ -10,34 +10,59 @@
     linear_contrast, logarithm_stretch
 from primawera.lut import apply_lut
 from primawera.widgets.canvasbase import CanvasBase
 from primawera.widgets.visualiser import Visualiser
 
 
 class Canvas3D(CanvasBase):
+    """
+    Canvas used for visualising 3D data. Has 3 different views - the main view
+    (frame by frame) and two orthogonal projections.
+    """
     def __init__(self, data: ArrayLike, mode: str,
                  desktop_height: int, desktop_width: int,
                  filters: Optional[Dict[str, bool]] = None,
                  filters_options: Optional[Dict[str, int]] = None,
                  overlay_data: Optional[NDArray[int]] = None,
                  overlay_is_grayscale: bool = True, *args,
                  **kwargs) -> None:
+
+        """
+        Constructs the object.
+        Parameters
+        ----------
+        data: ArrayLike
+            Data to visualise. Has to be in the format (frames, width, height,
+            channels). The last dimension is voluntary.
+        mode: string
+            Name of the image mode.
+        desktop_height: int
+            Height of the desktop.
+        desktop_width: int
+            Width of the desktop.
+        filters: dictionary of (str, int) pairs, optional
+            Describes the name of the filter to use.
+        filters_options: dictionary of (str, int), optional
+            Parameters for the filters.
+        overlay_data: integer ndarray, optional
+            Data to overlay on top.
+        overlay_is_grayscale: bool
+            Is the overlay data grayscale?
+        """
         super().__init__(data, mode, desktop_height, desktop_width,
                          filters, filters_options, overlay_data,
                          overlay_is_grayscale, *args, **kwargs)
         self._init_interface()
         self._create_actions()
         self._set_actions_checkable()
         self._connect_actions()
 
         if self.raw_overlay_data is not None:
             self._add_overlay(overlay_data, overlay_is_grayscale)
 
-        # TODO: move this higher, so that we do not have to process image
-        #       twice during this constructor.
         if self.mode != 'F':
             self._no_filter()
         else:
             self._linear_stretch()
         self.get_actions()[0].setChecked(True)
 
     def _init_interface(self):
```

## primawera/widgets/canvasbase.py

```diff
@@ -14,26 +14,52 @@
 from primawera.loading import load_data
 from primawera.modeutils import is_mode_color, is_mode_grayscale
 from primawera.widgets.informationwindow import InformationWindow
 from primawera.widgets.previewwindow import PreviewDialog
 
 
 class CanvasBase(QWidget):
-    menus_changed_signal = pyqtSignal()
-    signal_changed_filter = pyqtSignal(str)
+    """
+    Base class for all the various widget. It itself does not represent any
+    single view, but it contains a lot of the shared code.
+    """
+    menus_changed_signal = pyqtSignal()  # when menu changes
+    signal_changed_filter = pyqtSignal(str)  # when filter changes
     signal_changed_coordinates = pyqtSignal(int, int, int, object, object,
-                                            object)
+                                            object)  # current coordinates
 
     def __init__(self, data: ArrayLike, mode: str,
                  desktop_height: int, desktop_width: int,
                  filters: Optional[Dict[str, bool]] = None,
                  filters_options: Optional[Dict[str, int]] = None,
                  overlay_data: Optional[NDArray[int]] = None,
                  overlay_is_grayscale: bool = True,
                  *args, **kwargs) -> None:
+        """
+        Constructs the object
+        Parameters
+        ----------
+        data: ArrayLike
+            Data to visualise. Has to be in the format (frames, width, height,
+            channels). The last dimension is voluntary.
+        mode: string
+            Name of the image mode.
+        desktop_height: int
+            Height of the desktop.
+        desktop_width: int
+            Width of the desktop.
+        filters: dictionary of (str, int) pairs, optional
+            Describes the name of the filter to use. Deprecated
+        filters_options: dictionary of (str, int), optional
+            Parameters for the filters. Deprecated.
+        overlay_data: integer ndarray, optional
+            Data to overlay on top.
+        overlay_is_grayscale: bool
+            Is the overlay data grayscale?
+        """
         super(CanvasBase, self).__init__(*args, **kwargs)
         self.data = np.asanyarray(data)
         if overlay_data is not None \
                 and self._check_overlay_dtype(overlay_data,
                                               overlay_is_grayscale):
             self.raw_overlay_data = overlay_data
         elif overlay_data is not None:
@@ -64,41 +90,45 @@
         self.axes_orientation = (0, 1, 2)
         self.desktop_height = desktop_height
         self.desktop_width = desktop_width
         if self.mode == "":
             raise RuntimeError("Empty mode encountered")
 
     def _init_interface(self):
+        """Initialises interface."""
         self.main_layout = QVBoxLayout()
         self.view_layout = QGridLayout()
         self._information_window = InformationWindow()
         self._information_window.update_data_format(self.data.shape,
                                                     self.data.dtype, self.mode)
         self._information_window.hide()
         self.signal_changed_filter.connect(
             self._information_window.update_filter_name_slot)
 
     def _create_actions(self):
+        """Creates all QAction objects."""
         self.no_filter_action = QAction("None")
         self.logarithm_stretch_action = QAction("Logarithm stretch")
         self.linear_stretch_action = QAction("Linear stretch")
         self.linear_contrast_action = QAction("Linear contrast...")
         self.gamma_correction_action = QAction("Gamma correction...")
         self.lut_actions = []
         self.lut_actions.append(("None", QAction("None")))
         for lut_name in lut.LUTS.keys():
             self.lut_actions.append((lut_name, QAction(lut_name)))
         self.show_info_action = QAction("Show info panel")
         self.add_overlay_action = QAction("Add file as overlay...")
         self.remove_overlay_action = QAction("Remove overlay")
 
     def _connect_info_window_and_canvas(self):
+        """Connect behaviour between information panel and canvas."""
         raise NotImplementedError("CanvasBase should not be directly created!")
 
     def _connect_actions(self):
+        """Connects QActions to methods."""
         self.no_filter_action.triggered.connect(self._no_filter)
         self.logarithm_stretch_action.triggered.connect(
             self._logarithm_stretch)
         self.linear_stretch_action.triggered.connect(self._linear_stretch)
         self.linear_contrast_action.triggered.connect(self._linear_contrast)
         self.gamma_correction_action.triggered.connect(self._gamma_correction)
         for lut_name, lut_action in self.lut_actions:
@@ -107,78 +137,87 @@
         self.signal_changed_coordinates.connect(
             self._information_window.update_coordinates_slot)
         self.show_info_action.triggered.connect(self._toggle_information_panel)
         self.add_overlay_action.triggered.connect(self._add_overlay_ui)
         self.remove_overlay_action.triggered.connect(self._remove_overlay)
 
     def _set_actions_checkable(self) -> None:
+        """Set all QActions as checkable."""
         for action in self.get_actions():
             action.setCheckable(True)
 
     def _no_filter(self):
+        """Disable filters."""
         self.current_filter_name = "No filter"
         self.filters.clear()
         self._redraw(self._process_data())
 
     def _linear_stretch(self):
+        """Apply linear stretch."""
         self.current_filter_name = "Linearly stretched"
         self.filters = {"linear_stretch": True}
         self._redraw(self._process_data())
 
     def _logarithm_stretch(self):
+        """Logarithmically stretch."""
         self.current_filter_name = "Logarithmically stretched"
         self.filters = {"logarithm_stretch": True}
         self._redraw(self._process_data())
 
     def _linear_contrast(self):
+        """Linearly stretch the contrast."""
         self.current_filter_name = "Linearly adjusted contrast"
         dialog = PreviewDialog(self.data, [("Factor", int, 100, 0, 1)],
                                self.mode, linear_contrast)
         dialog.return_signal.connect(self.preview_dialog_slot)
         ret = dialog.exec()
         if ret == 0:
             self.no_filter_action.trigger()
             return
         factor = self.preview_dialog_value
         self.filters = {"linear_contrast": True}
         self.filters_options = {"factor": float(factor)}
         self._redraw(self._process_data())
 
     def _gamma_correction(self):
+        """Gamma correct image."""
         self.current_filter_name = "Gamma corrected"
         dialog = PreviewDialog(self.data, [("Factor", float, 2.0, 0.0, 0.1)],
                                self.mode, gamma_correction)
         dialog.return_signal.connect(self.preview_dialog_slot)
         ret = dialog.exec()
         if ret == 0:
             self.no_filter_action.trigger()
             return
         factor = self.preview_dialog_value
         self.filters = {"gamma_correction": True}
         self.filters_options = {"factor": factor}
         self._redraw(self._process_data())
 
     def _apply_lut(self, name):
+        """Apply a LUT with the given name."""
         if name == "None":
             self.mode_visualisation = self.mode
             self.lut = None
         else:
             self.lut = lut.get_lut(name)
         self._redraw(self._process_data())
 
     def _check_overlay_dtype(self, overlay: NDArray,
                              is_overlay_grayscale: bool) -> bool:
+        """Check of overlay is castable to integer type."""
         if is_overlay_grayscale:
             # We can linearly stretch it later
             return np.can_cast(overlay.dtype, int)
 
         # Overlay contains RGB data
         return np.can_cast(overlay.dtype, np.uint8)
 
     def _add_overlay_io(self) -> Optional[Tuple[ArrayLike, bool]]:
+        """Opens the file dialog for choosing overlay file."""
         file_name, _ = QFileDialog.getOpenFileName(self, "Open file", ".",
                                                    "Image file (*.jpg *.png"
                                                    " *.h5 *.tif *.tiff)")
         if file_name == "":
             # User did not select a file
             return
         try:
@@ -201,18 +240,18 @@
                                  buttons=QMessageBox.Ok,
                                  defaultButton=QMessageBox.Ok)
             return None
         return data, is_grayscale
 
     def _reshape_overlay_data(self, overlay_data: NDArray[int],
                               is_grayscale: bool) -> NDArray[int]:
+        """Reshapes overlay data to the correct format."""
         overlay_dims = len(overlay_data.shape)
 
         if is_grayscale and overlay_dims == 2:
-            # TODO: this is probably never called. Need to investigate further.
             w, h = overlay_data.shape
             overlay_data = np.reshape(overlay_data, (1, w, h))
             overlay_dims = len(overlay_data.shape)
             assert overlay_dims == 3
         elif not is_grayscale and overlay_dims == 3:
             w, h, ch = overlay_data.shape
             overlay_data = np.reshape(overlay_data, (1, w, h, ch))
@@ -236,14 +275,15 @@
 
         assert overlay_dims == 4, "Reshaping failed due to incorrect " \
                                   "internal logic. Please contact the " \
                                   "developer."
         return overlay_data
 
     def _add_overlay_ui(self) -> None:
+        """UI for the add overlay action."""
         result = self._add_overlay_io()
         if result is None:
             return
 
         overlay_data, is_grayscale = result
         self._add_overlay(overlay_data, is_grayscale)
 
@@ -277,21 +317,23 @@
 
         # Add opacity (alpha channel) to the overlay data
         overlay_reshaped = np.append(overlay_reshaped, opacity_mask, axis=3)
         return overlay_reshaped
 
     def _add_overlay(self, overlay_data: NDArray[int],
                      is_grayscale: bool = True) -> None:
+        """Add overlay."""
         raise NotImplementedError("CanvasBase should not be directly created!")
 
     def _remove_overlay(self) -> None:
+        """Removes overlay."""
         raise NotImplementedError("CanvasBase should not be directly created!")
 
-    # TODO: this is not a redraw function, but an update function.
     def _redraw(self, new_data) -> None:
+        """Updates and redraws the canvas."""
         raise NotImplementedError("CanvasBase should not be directly created!")
 
     def keyPressEvent(self, event: QKeyEvent) -> None:
         actions = [
             (QtCore.Qt.Key_Plus, self._increase_zoom_level),
             (QtCore.Qt.Key_Minus, self._decrease_zoom_level),
             (QtCore.Qt.Key_I, self._toggle_information_panel),
@@ -312,55 +354,67 @@
         elif event.key() == QtCore.Qt.Key_Space:
             self._show_overlay()
             event.accept()
         else:
             event.ignore()
 
     def _increase_zoom_level(self):
+        """Increases zoom level."""
         raise NotImplementedError("CanvasBase should not be directly created!")
 
     def _decrease_zoom_level(self):
+        """Decreases zoom level."""
         raise NotImplementedError("CanvasBase should not be directly created!")
 
     def _toggle_information_panel(self):
         self._showing_info_panel = not self._showing_info_panel
         if not self._showing_info_panel:
             self._information_window.hide()
         else:
             self._information_window.show()
 
     def get_filters(self):
+        """Returns all possible filters as a list of QActions."""
         raise NotImplementedError("CanvasBase should not be directly created!")
 
     def get_luts(self):
+        """Returns all possible LUT QActions as a list."""
         raise NotImplementedError("CanvasBase should not be directly created!")
 
     def get_actions(self):
+        """Returns all possible QActions."""
         raise NotImplementedError("CanvasBase should not be directly created!")
 
     def get_menus(self):
+        """Returns all menus."""
         return [
             ("Other", [self.show_info_action]),
         ]
 
     def _process_data(self):
+        """Apply filters on data and emit the currently used filter name."""
         if self.current_filter_name is not None:
             self.signal_changed_filter.emit(self.current_filter_name)
 
     def update_desktop_size(self, width: int, height: int) -> None:
+        """Update the desktop size."""
         self.desktop_width = width
         self.desktop_height = height
 
     @pyqtSlot(list)
     def preview_dialog_slot(self, data: List[Union[int, float]]) -> None:
+        """Slot for taking the parameters chosen by user in the
+        PreviewWindow."""
         self.preview_dialog_value = data[0]
 
     @pyqtSlot(int, int, int, list)
     def changed_coordinates_slot_emitter(self, frame: int, row: int, col: int,
                                          mapped_val: ArrayLike) -> None:
+        """Emits the current coordinates under the cursor, its original value
+        at those coordinates, the mapped value, and value of the overlay."""
         if self.raw_overlay_data is not None:
             chosen_coords = (frame, row, col)
             # Note: unlike the data, overlay data can have all sorts of shapes-
             # mainly (f, w, h, ch), (w, h, ch) or (f, w, h).
             # Since the signal always returns coordinates in the form (f, w, h)
             # we need to handle the (w, h, ch) case specially
             if not self.overlay_is_grayscale \
@@ -377,11 +431,13 @@
                                              [overlay_label])
 
     def closeEvent(self, event) -> None:
         self._information_window.close()
         super().closeEvent(event)
 
     def _hide_overlay(self) -> None:
+        """Hides the overlay temporarily."""
         raise NotImplementedError("CanvasBase should not be directly created!")
 
     def _show_overlay(self) -> None:
+        """Shows the overlay."""
         raise NotImplementedError("CanvasBase should not be directly created!")
```

## primawera/widgets/canvascomplex.py

```diff
@@ -16,15 +16,18 @@
     MAGNITUDE = auto()
     PHASE = auto()
     REAL_PART = auto()
     IMAG_PART = auto()
 
 
 class CanvasComplex(CanvasBase):
-
+    """
+    Canvas used for visualising complex data. Automatically stretches the data
+    and offers view of the magnitude and the phase of the data.
+    """
     def __init__(self, data: ArrayLike, mode: str,
                  desktop_height: int, desktop_width: int,
                  filters: Optional[Dict[str, bool]] = None,
                  filters_options: Optional[Dict[str, int]] = None, *args,
                  **kwargs) -> None:
         super().__init__(data, mode, desktop_height, desktop_width,
                          filters, filters_options, *args, **kwargs)
@@ -32,15 +35,15 @@
             raise RuntimeError("CanvasComplex expects complex data!")
 
         if filters:
             self.filters = filters
         else:
             self.filters = {"linear_stretch": True}
 
-        self.show = ShowEnum.MAGNITUDE
+        self.show = ShowEnum.MAGNITUDE  # Show magnitude by default.
 
         self._init_interface()
         self._create_actions()
         self._set_actions_checkable()
         self._reset_checked_states()
         self._connect_actions()
         self._show_magnitude()
@@ -88,52 +91,58 @@
             self.mode_visualisation = "rgb"
             data = apply_lut(data, self.lut)
 
         self.menus_changed_signal.emit()
         return data
 
     def _reset_view(self):
+        """Resets to the default view."""
         self._reset_checked_states()
         self.get_luts()[0].setChecked(True)
         self.lut = None
         self.mode_visualisation = self.mode
 
     def _show_magnitude(self):
+        """Show magnitude."""
         self._reset_view()
         self.show_magnitude_action.setChecked(True)
         self.linear_stretch_action.setChecked(True)
         self.show = ShowEnum.MAGNITUDE
         self.menus_changed_signal.emit()
         self._linear_stretch()
 
     def _show_phase(self):
+        """Show phase."""
         self._reset_view()
         self.show_phase_action.setChecked(True)
         self.linear_stretch_action.setChecked(True)
         self.show = ShowEnum.PHASE
         self.menus_changed_signal.emit()
         self._linear_stretch()
 
     def _show_real_part(self):
+        """Show the real part of the data."""
         self._reset_view()
         self.show_real_part_action.setChecked(True)
         self.linear_stretch_action.setChecked(True)
         self.show = ShowEnum.REAL_PART
         self.menus_changed_signal.emit()
         self._linear_stretch()
 
     def _show_imag_part(self):
+        """Show the imaginary part of the data."""
         self._reset_view()
         self.show_imag_part_action.setChecked(True)
         self.linear_stretch_action.setChecked(True)
         self.show = ShowEnum.IMAG_PART
         self.menus_changed_signal.emit()
         self._linear_stretch()
 
     def _reset_checked_states(self):
+        """Reset the checked states of all actions."""
         for action in self.get_actions():
             action.setChecked(False)
 
     def _redraw(self, new_data):
         # Showing phase/magnitude
         if self.show == ShowEnum.MAGNITUDE:
             showing = "Magnitude"
```

## primawera/widgets/informationwindow.py

```diff
@@ -1,7 +1,11 @@
+"""
+This module contains the definition of InformationWindow, an auxiliary window
+showing information about the data.
+"""
 from typing import Tuple
 
 import numpy as np
 from PyQt5.QtCore import pyqtSlot, Qt
 from PyQt5.QtWidgets import QWidget, QVBoxLayout, QLabel, QHBoxLayout
 from numpy.typing import DTypeLike, ArrayLike
 
@@ -19,14 +23,15 @@
                 Parent of this widget.
         """
         super().__init__(parent)
         self.setWindowTitle("Primawera - Info panel")
         self.label_format_info = QLabel()
         self.main_layout = QVBoxLayout()
 
+        # Set up layout
         self.label_format_info.setAlignment(Qt.AlignTop)
         self.label_used_filter = QLabel("")
         self.label_used_filter.setContentsMargins(20, 0, 0, 0)
         info_layout = QHBoxLayout()
         info_layout.addWidget(self.label_format_info)
         info_layout.addWidget(self.label_used_filter)
         self.main_layout.addLayout(info_layout)
@@ -53,22 +58,44 @@
         self.label_format_info.setText(
             f"Data shape: {self._transform_shape(shape)}\n"
             f"Data type: {datatype}\n"
             f"Data mode: {print_mode(mode)}")
 
     @pyqtSlot(str)
     def update_filter_name_slot(self, filter_name: str) -> None:
+        """Updates the name of the filter."""
         self.label_used_filter.setText(filter_name)
 
     @pyqtSlot(int, int, int, object, object, object)
     def update_coordinates_slot(self, frame: int, row: int, col: int,
                                 mapped_value: ArrayLike,
                                 original_value: ArrayLike,
                                 overlay_label: ArrayLike) -> None:
+        """
+        Shows information about the data.
+
+        Parameters
+        ----------
+        frame: int
+            Currently showed frame.
+        row: int
+            Current row.
+        col: int
+            Current column.
+        mapped_value: ArrayLike
+            Mapped value at the given position.
+        original_value: ArrayLike
+            Original value at the given position.
+        overlay_label: ArrayLike
+            Overlay label at the given position.
+
+        """
         # Note: numpy is row-centric, that's why y and x are switched
+        # Note: The printing format of the values is quite unfortunate, but I
+        # have not found a good method of formatting numpy values in general.
         text = f"frame={frame}, row={row}, col={col}\n" \
                f"original value={original_value}\n" \
                f"mapped value={mapped_value}\n"
         if overlay_label[0] is not None:
             text += f"overlay label={np.array(overlay_label)[0]}"
 
         self.label_coordinates.setText(text)
```

## primawera/widgets/pixmaplabel.py

```diff
@@ -1,50 +1,63 @@
+"""
+This module contains the definition of PixmapLabel, used for showing pixmaps.
+"""
 from PyQt5 import QtGui
 from PyQt5.QtCore import pyqtSignal
 from PyQt5.QtGui import QImage, QPixmap, QPainter
 from PyQt5.QtWidgets import QLabel
 
 
 class CompositionError(Exception):
     pass
 
 
 class PixmapLabel(QLabel):
+    """
+    The PixmapLabel object is used to show pixmaps on screen. Unlike the QLabel
+    object it allows the user to also overlay another semi-transparent pixmap
+    on top.
+    """
     mouse_position_signal = pyqtSignal(float, float)
 
     def __init__(self):
+        """Construct the object."""
         super().__init__()
         self.handle_mouse_movement = False
         self._overlay_pixmap = None
         self._background_pixmap = None
         self._hide_overlay = False
 
     def setPixmap(self, pixmap: QPixmap) -> None:
+        """Sets the main pixmap."""
         self.handle_mouse_movement = True
         self.setMouseTracking(True)
         self._background_pixmap = pixmap
 
     def setOverlay(self, image: QImage) -> None:
+        """Sets the overlay pixmap."""
         if self._background_pixmap is None:
             raise CompositionError("Cannot overlay data when background is "
                                    "equal to None!")
         if self._background_pixmap.height() != image.size().height():
             raise CompositionError(
                 f"Height mismatch! bg: {self._background_pixmap.height()} "
                 f" overlay: {image.size().height()}")
         if self._background_pixmap.width() != image.size().width():
             raise CompositionError(
                 f"Width mismatch! bg: {self._background_pixmap.width()} "
                 f"overlay: {image.size().width()}")
         self._overlay_pixmap = image
 
     def remove_overlay(self) -> None:
+        """Removes the overlay."""
         self._overlay_pixmap = None
 
     def paintEvent(self, event: QtGui.QPaintEvent) -> None:
+        """Overrides the paintEvent, allowing it to draw overlays."""
         painter = QPainter(self)
         if self._background_pixmap is None:
             event.accept()
             return
 
         width, height = self._background_pixmap.width(), \
             self._background_pixmap.height()
@@ -53,14 +66,18 @@
         if self._overlay_pixmap is None or self._hide_overlay:
             event.accept()
             return
         painter.drawPixmap(0, 0, width, height, self._overlay_pixmap)
         event.accept()
 
     def mouseMoveEvent(self, event):
+        """
+        Overrides the mouseMoveEvent, and emits the relative position of the
+        cursor using mouse_position_signal.
+        """
         if not self.handle_mouse_movement or self._background_pixmap is None:
             event.ignore()
             return
 
         event_x = event.pos().x()
         event_y = event.pos().y()
         if event_x < 0 or event_y < 0:
@@ -74,13 +91,15 @@
 
         position_x = (event_x / pixmap_width)
         position_y = (event_y / pixmap_height)
         event.accept()
         self.mouse_position_signal.emit(position_x, position_y)
 
     def hide_overlay(self) -> None:
+        """Hides the overlay."""
         self._hide_overlay = True
         self.update()  # To generate a paint event
 
     def show_overlay(self) -> None:
+        """Shows the overlay."""
         self._hide_overlay = False
         self.update()
```

## primawera/widgets/previewwindow.py

```diff
@@ -1,50 +1,75 @@
+"""
+This module contains the definition of the preview window, when the user
+selects a filter, which requires an argument.
+"""
 from typing import Union, Callable, Tuple, List, Optional
 
 import numpy as np
 from PyQt5.QtCore import pyqtSignal, pyqtSlot
 from PyQt5.QtWidgets import QDialog, QVBoxLayout, QLabel, QSpinBox, \
     QDoubleSpinBox, QMessageBox, QHBoxLayout, QPushButton, QCheckBox
-from numpy.typing import ArrayLike
+from numpy.typing import ArrayLike, NDArray
 
 from primawera.widgets.visualiser import Visualiser
 
 ConstraintType = Union[int, float]
 Bound = Union[int, float]
+# Name of the parameter, and the bounds for the parameter.
 Constraint = Tuple[str, ConstraintType, Bound, Bound, float]
 
 
 class PreviewDialog(QDialog):
+    """
+    An auxiliary window letting the user view the effect of some filter for
+    various values of the argument.
+    """
     return_signal = pyqtSignal(list)
     maximum_width = 400
     maximum_height = 400
 
-    def __init__(self, data: ArrayLike, constraints: List[Constraint],
+    def __init__(self, data: NDArray[int], constraints: List[Constraint],
                  mode: str, function: Callable[
                 [ArrayLike, Union[int, float]], ArrayLike]):
+        """
+        Construct the widget.
+
+        Parameters
+        ----------
+        data:
+            Data to show.
+        constraints:
+            Describes the number of free variables and their bounds.
+        mode:
+            Name of the image mode.
+        function:
+            Function which is called on the data with the arguments specified
+            by the user.
+        """
         super().__init__()
         self.function = function
         self.data = data
         self.mode = mode
         self._init_interface(constraints)
 
     def _init_interface(self, constraints: List[Constraint]) -> None:
+        """Initialises the interface."""
         self.main_layout = QVBoxLayout()
         self.main_layout.addWidget(QLabel("Preview:"))
         processed_data = np.clip(self.data, 0, 255.0).astype(np.uint8)
         self.visualiser = Visualiser(processed_data, (0, 1, 2), self.mode,
                                      self.maximum_height, self.maximum_width,
                                      True)
         self.main_layout.addWidget(self.visualiser)
 
+        # For each constraint create a new slider.
         self.sliders = []
         for name, constraint, max_val, min_val, step in constraints:
             name_label = QLabel(name)
             slider: Optional[Union[QSpinBox, QDoubleSpinBox]] = None
-            # TODO: Maybe it is better to always use float
             if constraint == int:
                 slider = QSpinBox()
             elif constraint == float:
                 slider = QDoubleSpinBox()
             else:
                 QMessageBox \
                     .warning(self, "Warning",
@@ -71,14 +96,15 @@
             slider.valueChanged.connect(self._constrained_changed_slot)
 
             line_layout = QHBoxLayout()
             line_layout.addWidget(name_label)
             line_layout.addWidget(slider)
         self.main_layout.addLayout(line_layout)
 
+        # Set up control buttons
         self.preview_button = QPushButton("Refresh preview")
         self.preview_button.clicked.connect(self._refresh_preview)
         self.preview_button.setDisabled(True)
         self.auto_refresh_checkbox = QCheckBox("Automatically refresh preview")
         self.auto_refresh_checkbox.clicked.connect(self._toggle_auto_refresh)
         self.auto_refresh_checkbox.setChecked(True)
         accept_button = QPushButton("Apply")
@@ -91,14 +117,15 @@
         button_layout.addWidget(accept_button)
         button_layout.addWidget(reject_button)
 
         self.main_layout.addLayout(button_layout)
         self.setLayout(self.main_layout)
 
     def _refresh_preview(self) -> None:
+        """Refreshes the preview."""
         inputs = list(map(lambda x: x.value(), self.sliders))
         if np.issubdtype(self.data.dtype, np.integer):
             # Bump up the bitdepth
             data = self.data.astype(int)
         else:
             data = self.data.astype(float)
         new_data = self.function(data, inputs[0])
@@ -112,9 +139,11 @@
             self._refresh_preview()
 
     @pyqtSlot(bool)
     def _toggle_auto_refresh(self, val: bool):
         self.preview_button.setEnabled(not val)
 
     def accept(self) -> None:
+        """After the user accepts the preview, a signal with the chosen values
+        for arguments is emitted."""
         self.return_signal.emit(list(map(lambda x: x.value(), self.sliders)))
         super().accept()
```

## primawera/widgets/visualiser.py

```diff
@@ -1,107 +1,168 @@
+"""
+This module contains the Visualiser class, which is responsible for visualising
+data.
+"""
 import numpy as np
 from PIL import ImageQt
 from PyQt5.QtCore import pyqtSignal, Qt, QSize, pyqtSlot
 from PyQt5.QtGui import QPixmap, QImage, QPalette
 from PyQt5.QtWidgets import QVBoxLayout, QWidget
-from numpy.typing import NDArray
 
 from primawera.loading import UnsupportedFormatError
 from primawera.widgets.HighlightScrollArea import HighlightScrollArea
 from primawera.widgets.pixmaplabel import PixmapLabel
 
 
 class Visualiser(QWidget):
+    """
+    This class handles the visualisation of grayscale/coloured 2D/3D numerical
+    data. It supports zooming in and dynamically changes to a scroll bar
+    layout.
+    """
     signal_position = pyqtSignal(int, int, int, list)
+    # Following signals are used to indicate a change in the scroll bar value.
     value_change_emitter_vertical = pyqtSignal(int)
     value_change_emitter_horizontal = pyqtSignal(int)
 
     def __init__(self, data, axes_orientation, mode, maximum_height,
                  maximum_width, main_window, *args, overlay_data=None,
                  **kwargs):
+        """
+        Constructs the object.
+
+        Parameters
+        ----------
+        data: ndarray of type int
+            Has the format (frame, width, height, channels). Last dimension is
+            not mandatory.
+        axes_orientation: list of ints
+            Indicates the orders of dimensions in the data.
+        mode: str
+            Name of the image mode.
+        maximum_height: int
+            Maximum height of the visualiser.
+        maximum_width: int
+            Maximum width of the visualiser.
+        main_window: bool
+            Is this widget the main widget (only that one has visible scroll
+            bars).
+        overlay_data: integer ndarray
+            Must have the same number of frames, width, and height. Does not
+            support colours; hence, it does not have the channels dimension.
+        """
         super(Visualiser, self).__init__(*args, **kwargs)
         self.axes_orientation = None
         self.data = None
         self.overlay_data = overlay_data
         self.mode = None
         self.height = 0
         self.width = 0
         self.frames = 0
         self.frame = 0
+        # In the following lists the already generated pixmaps are cached.
         self.background_pixmaps = []
         self.overlay_pixmaps = []
         self.main_window = main_window
 
         self.MAXIMUM_HEIGHT = maximum_height
         self.MAXIMUM_WIDTH = maximum_width
         self.ZOOMED_MAX_SIZE = 32000
 
-        # Set up label
+        # Set up label containing the image and overlay.
         self.label = PixmapLabel()
         self.label.setAlignment(Qt.AlignLeft)
         self.setContentsMargins(0, 0, 0, 0)
         self.setStyleSheet(
             "padding: 0px; border: 0px; margin: 0px")
 
         self.zoom_level = 1
         self.update_data(data, axes_orientation, mode)
 
-        # Set up scroll area
+        # Set up the scroll area, which contains the image label.
         self.scroll_area = HighlightScrollArea(width=1)
         self.scroll_area.setBackgroundRole(QPalette.Dark)
         self.scroll_area.setWidget(self.label)
         self.scroll_area.setAlignment(Qt.AlignLeft)
         self.scroll_area.setContentsMargins(0, 0, 0, 0)
 
-        # Set up layout
+        # Set up layout of the widget
         self.layout = QVBoxLayout()
         self.layout.addWidget(self.scroll_area)
         self.layout.setAlignment(Qt.AlignLeft)
         self.layout.setContentsMargins(0, 0, 0, 0)
         self.setLayout(self.layout)
 
         # Set up event handling
-        self.connect_horizontal_bar()
-        self.connect_vertical_bar()
+        self._connect_horizontal_bar()
+        self._connect_vertical_bar()
 
         self.setStyleSheet("padding: 0px; margin:0px; border: 0px")
 
-        # Set up focus in/out border change
-        # self.focusChanged.connect(self.focus_changed)
-
-    def connect_vertical_bar(self):
+    def _connect_vertical_bar(self):
         self.get_vertical_bar().valueChanged.connect(
             self._value_change_wrapper_vertical)
 
-    def connect_horizontal_bar(self):
+    def _connect_horizontal_bar(self):
         self.get_horizontal_bar().valueChanged.connect(
             self._value_change_wrapper_horizontal)
 
     def update_data(self, data, axes_orientation, mode):
+        """
+        Updates the data.
+
+        Parameters
+        ----------
+        data: ndarray of integers
+            See constructor of this class.
+        axes_orientation:
+            See constructor of this class.
+        mode:
+            See constructor of this class.
+
+        """
         # Prepare the data
-        # NOTE: Without copy() the program may receive SIGSEV.
         self.axes_orientation = axes_orientation
         self.mode = mode
         if self.mode == "rgb":
+            # RGB data has one more dimension.
             axes_orientation = axes_orientation[0], axes_orientation[1], \
                 axes_orientation[2], 3
+        # NOTE: Without copy() the program may receive SIGSEV due to how
+        # numpy views are constructed.
         self.data = np.transpose(data, axes_orientation).copy()
         self.frames, self.height, self.width = self.data.shape[0], \
             self.data.shape[1], \
             self.data.shape[2]
         self.frame = 0
         self.background_pixmaps = [None] * self.frames
         self.overlay_pixmaps = [None] * self.frames
         self.label.mouse_position_signal.connect(self.print_info_emitter)
 
     def redraw(self):
+        """
+        Redraws the widget.
+        """
         self._generate(self.frame)
         self.choose_frame(self.frame)
 
     def print_info_emitter(self, relative_x: float, relative_y: float) -> None:
+        """
+        Calculates the real coordinates of the cursor on the image, and uses
+        the signal_position signal to emit it along with the current frame.
+
+        Parameters
+        ----------
+        relative_x: float
+            Relative x position of the cursor in the widget (from 0 to 1.0).
+        relative_y: float
+            Relative y position of the cursor in the widget (from 0 to 1.0).
+
+        """
+
         if self.mode in {"grayscale", "1", "F", "C"}:
             _, data_rows, data_cols = self.data.shape
         else:
             _, data_rows, data_cols, _ = self.data.shape
         position_x = int(relative_x * data_cols)
         position_y = int(relative_y * data_rows)
 
@@ -121,47 +182,54 @@
             self.background_pixmaps[frame] = self._generate_background(frame)
 
         if self.overlay_data is not None \
                 and self.overlay_pixmaps[frame] is None:
             self.overlay_pixmaps[frame] = self._generate_overlay(frame)
 
     def _generate_background(self, frame: int) -> QPixmap:
-
+        # Generate pixmaps from the numpy arrays.
         if self.mode in {"grayscale", "1", "F", "C"}:
             qimage = ImageQt.QImage(self.data[frame, :, :], self.width,
                                     self.height,
                                     self.width, QImage.Format_Grayscale8)
         elif self.mode == "rgb":
             qimage = ImageQt.QImage(self.data[frame, :, :], self.width,
                                     self.height,
                                     3 * self.width, QImage.Format_RGB888)
         else:
-            # TODO: This isn't handled in Canvas objects.
             raise UnsupportedFormatError(
                 f"Combination of mode='{self.mode}' with Canvas is not"
                 f" supported.")
         return QPixmap.fromImage(qimage)
 
     def _generate_overlay(self, frame: int) -> QPixmap:
         assert self.overlay_data is not None
         assert np.issubdtype(self.overlay_data.dtype, np.uint8)
         overlay_image = ImageQt.QImage(self.overlay_data[frame, :, :],
                                        self.width, self.height, 4 * self.width,
                                        QImage.Format_RGBA8888)
         return QPixmap.fromImage(overlay_image)
 
-    def choose_frame(self, frame: int) -> None:
+    def choose_frame(self, frame):
+        """
+        Sets the current frame.
+
+        Parameters
+        ----------
+        frame: int
+            Frame to view.
+        """
         if frame < 0 or frame >= self.frames:
             return
         self.frame = frame
 
         # Calculate the right size of the image label
         zoomed_width = self.width * self.zoom_level
         zoomed_height = self.height * self.zoom_level
-        self._generate(frame)  # TODO: this causes unnecessary operations
+        self._generate(frame)
         resized_background = self.background_pixmaps[self.frame].scaled(
             QSize(zoomed_width, zoomed_height),
             Qt.KeepAspectRatio)
         # Update the pixmap
         self.label.setPixmap(resized_background)
 
         if self.overlay_pixmaps[self.frame] is not None:
@@ -203,60 +271,102 @@
 
         # I am really not sure why it is needed to add the 2 pixels; otherwise,
         # it breaks on *some* machines running Windows.
         self.scroll_area.setMaximumSize(width + 2, height + 2)
         self.scroll_area.setMinimumSize(width + 2, height + 2)
 
     def next_frame(self) -> None:
+        """
+        Shows next frame.
+        """
         self.choose_frame(self.frame + 1)
 
     def previous_frame(self) -> None:
+        """
+        See previous frame.
+        """
         self.choose_frame(self.frame - 1)
 
     def decrease_zoom_level(self) -> None:
+        """
+        Decreases zoom level.
+        """
         self.zoom_level = max(self.zoom_level // 2, 1)
         self.choose_frame(self.frame)
 
     def increase_zoom_level(self) -> None:
+        """
+        Increases zoom level.
+        """
         size = max(self.width, self.height) * self.zoom_level
         if size * 2 <= self.ZOOMED_MAX_SIZE:
             self.zoom_level = self.zoom_level * 2
             self.choose_frame(self.frame)
 
     def get_horizontal_bar(self):
+        """
+        Returns the horizontal scroll bar of the scroll area.
+
+        Returns
+        -------
+        out: Scroll bar
+        """
         return self.scroll_area.horizontalScrollBar()
 
     def get_vertical_bar(self):
+        """
+        Returns the vertical scroll bar of the scroll area.
+
+        Returns
+        -------
+        out: Scroll bar
+        """
         return self.scroll_area.verticalScrollBar()
 
     def get_scroll_area(self):
+        """Return the scroll area."""
         return self.scroll_area
 
     @pyqtSlot(int)
     def _value_change_wrapper_horizontal(self, value: int):
+        """Used to emit the current value of the horizontal scrollbar"""
         if self.scroll_area.in_focus():
             self.value_change_emitter_horizontal.emit(value)
 
     @pyqtSlot(int)
     def _value_change_wrapper_vertical(self, value: int):
+        """Used to emit the current value of the vertical scrollbar"""
         if self.scroll_area.in_focus():
             self.value_change_emitter_vertical.emit(value)
 
     def has_focus(self) -> bool:
+        """Does the scroll area have focus?"""
         return self.scroll_area.in_focus()
 
-    def update_overlay(self, overlay_data: NDArray[int]):
+    def update_overlay(self, overlay_data):
+        """
+        Sets new overlay data.
+
+        Parameters
+        ----------
+        overlay_data: ndarray of integers
+
+        """
         self.overlay_data = overlay_data
 
     def remove_overlay(self) -> None:
+        """Removes the overlay."""
         self.overlay_pixmaps = [None] * self.frames
         self.overlay_data = None
         self.label.remove_overlay()
 
     def has_overlay(self) -> bool:
+        """Is any data overlaying the image?"""
         return self.overlay_data is not None
 
     def hide_overlay(self) -> None:
+        """Hides the overlay."""
         self.label.hide_overlay()
 
     def show_overlay(self) -> None:
+        """Show the overlay."""
         self.label.show_overlay()
```

## Comparing `primawera-0.5.0.dist-info/COPYING.txt` & `primawera-0.5.1.dist-info/COPYING.txt`

 * *Files identical despite different names*

## Comparing `primawera-0.5.0.dist-info/METADATA` & `primawera-0.5.1.dist-info/METADATA`

 * *Files 5% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: primawera
-Version: 0.5.0
+Version: 0.5.1
 Summary: Simple image viewer with 3D, complex and floating images support.
 Author-email: Bruno Petrus <xpetrus@fi.muni.cz>
 Project-URL: Source, https://gitlab.fi.muni.cz/xpetrus/primawera
 Project-URL: Bug tracker, https://gitlab.fi.muni.cz/xpetrus/primawera/-/issues
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
 Classifier: Development Status :: 3 - Alpha
@@ -16,15 +16,15 @@
 Requires-Dist: Pillow (>=9.2)
 Requires-Dist: PyQt5 (>=5.15.7)
 Requires-Dist: h5py (>=3.7)
 
 # Intro
 
 Primawera is a simple imager viewer with support for non-standard image data such as complex, floating point
-or 3D image data.
+or 3D image data. For more detailed description about the basics of the viewer, please view the [official website](https://cbia.fi.muni.cz/software/primawera).
 
 # Installation
 
 This package is available at [PyPI](https://pypi.org/project/primawera/). To install the package using `pip`
 run:
 ```bash
 python -m pip install primawera
```

## Comparing `primawera-0.5.0.dist-info/RECORD` & `primawera-0.5.1.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-primawera/__init__.py,sha256=ePNs-xclORfBJ8nLZgrfvKuIIf1sLWozhTxGNaSNnzI,332
-primawera/app.py,sha256=Gg_BuvUoKXtdFlDrcl7jTCAoKX65xJLkWIEqpXq5Hs0,16496
-primawera/filters.py,sha256=0wFr0q9vcRfOj-2SdIu0YTfxH6oZF4YJY3DCunpdW6g,1427
+primawera/__init__.py,sha256=6r0SbSrW9DnHE0Q_2zoMYDim9VZ5mxg-aqCJuGTdANQ,365
+primawera/app.py,sha256=gdAoacyvCai11kDWmdTsS4pDmASXohbbmkZt-Szeb_I,17866
+primawera/filters.py,sha256=Tn0GhHeXAfWftmkDOHA0HjUu9MgbfAh51HFIhqD7YUA,2530
 primawera/html_codes.py,sha256=p-Ra6YLqApfh0OSXzU4SsE-LbsDGIs5dfaQEFMM76Nw,1514
 primawera/loading.py,sha256=Tsbf553JP5hmOD7hdP9iOtQiUENewqaD1IJ7En7YMQk,4363
-primawera/lut.py,sha256=rbCygkEOB1d3CpBRi_Xga9JgorZmy7rOcWPzps8ejyI,2183
-primawera/modeutils.py,sha256=btbc18qjTfw-DfBxe-pFzeX0iNMUrFHyyJZ48lVceaI,1387
+primawera/lut.py,sha256=dfdpDT2QAWjjD41CTIawjv22Hopn9CSkyILJ7Uj60RM,3864
+primawera/modeutils.py,sha256=CbqJMDrOQjYR5bJa0YiJTYqzsWn6Hb26HQP6UnIGYaY,2246
 primawera/luts/grayscale.lut,sha256=9TVO_IhYWXtn1vI99RX8Gp8zrnYMnCW_KzOi4DFGOxs,3656
 primawera/luts/jet.lut,sha256=o1TAkAO-Xz47WpeSn2KZW_-4_vRXugmVQ5esJtbscSo,3366
 primawera/luts/sepia.lut,sha256=uDHATW9-t3ArAtYN6s0Wh8yFl7Tu1MllKPaGC8i4YtU,3767
-primawera/widgets/HighlightScrollArea.py,sha256=FjoXNUa36PtJPWIgw8vHibsqGDmAPoD60lO1TeObkp8,981
+primawera/widgets/HighlightScrollArea.py,sha256=ZRtF_8vbsUhTLIDmZZRhvvZ7k0rBoxLTWR1Dj0aP9sM,1250
 primawera/widgets/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-primawera/widgets/canvas2d.py,sha256=mSVJYe--bjsD9gK1PHAWyItVKFT6FlKdzbr82KtaDhI,6476
-primawera/widgets/canvas3d.py,sha256=2vdTH3znxswoQRGBOVW0kLWSUCQFBBbdEtcVFlMS5BI,9303
-primawera/widgets/canvasbase.py,sha256=3UZ8A1cOXJMp2CZFNN49VjU_xClSbWNpCiOP2pw-u9M,16407
-primawera/widgets/canvascomplex.py,sha256=DjWjPE-4QJms3oZFFq2lPtmt1CUDc1xxr8nxY5t0u5Q,7073
-primawera/widgets/informationwindow.py,sha256=PJlz-kZqdqF_fXZzfJIFcYg0GFAd-SNgOH2JtqpkpT8,2981
-primawera/widgets/pixmaplabel.py,sha256=Hj264rwqzgF82DCGznztp6qecOqbiGb4AOZ3gk-Va1g,2948
-primawera/widgets/previewwindow.py,sha256=iq9GUhx75kbhi2HZTqbRsGC82nXR4SPvLzWAdld04tg,4782
-primawera/widgets/visualiser.py,sha256=LdkvinqJ3DftKN6Yajj0yjyZquFTJdprP-5vDddxOTM,10156
-primawera-0.5.0.dist-info/COPYING.txt,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
-primawera-0.5.0.dist-info/METADATA,sha256=lxICoFCkYbHemYuv9YyD9ldwZSMavQIESMVPb7k_Vj4,2967
-primawera-0.5.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-primawera-0.5.0.dist-info/entry_points.txt,sha256=45CSMKGMvbRZAWyosbH0DNWMqhkX32T4egoJrlKzOdM,46
-primawera-0.5.0.dist-info/top_level.txt,sha256=JYh4fep6QQlzXuAbJxUllSjnupXyTh-7MshyywqRPZg,10
-primawera-0.5.0.dist-info/RECORD,,
+primawera/widgets/canvas2d.py,sha256=upCtrYQp7FNsY9hhm1NWqtXWd_3rCKA4WWcks8bz3lg,7088
+primawera/widgets/canvas3d.py,sha256=jgK-aw4kles6qgzr-THUNRPX29FxGE9ELqutLCHo_FA,10137
+primawera/widgets/canvasbase.py,sha256=vh1zqVzGlipAFacTvseiOrUMJUOqLSO5qbGTiN0gsD8,18823
+primawera/widgets/canvascomplex.py,sha256=jBjrbZTtagtrDcK9xGVvNY1yFSK4D4SlEtJx9aQMEH8,7511
+primawera/widgets/informationwindow.py,sha256=RmwFMKbsvb8opXNnDK4esNDbyo6L44YwB0sHYxf9kY8,3823
+primawera/widgets/pixmaplabel.py,sha256=lpB0R2AA5a_0zKa3dQG5capXnNJ3Qu5KIcU1fhbR68c,3647
+primawera/widgets/previewwindow.py,sha256=tLYBxhiKgsdaMEPzyaa03fTy2fffr58ch99Q4dipG-c,5721
+primawera/widgets/visualiser.py,sha256=Nc2DUEdh7JuQOsCzenh23tTTer2Gen8XD5KThGzET-o,13320
+primawera-0.5.1.dist-info/COPYING.txt,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
+primawera-0.5.1.dist-info/METADATA,sha256=AUpnVRzl8fNFVzWsm-tOCVC29a4JbBxA9Z_0rjfpAQM,3109
+primawera-0.5.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+primawera-0.5.1.dist-info/entry_points.txt,sha256=45CSMKGMvbRZAWyosbH0DNWMqhkX32T4egoJrlKzOdM,46
+primawera-0.5.1.dist-info/top_level.txt,sha256=JYh4fep6QQlzXuAbJxUllSjnupXyTh-7MshyywqRPZg,10
+primawera-0.5.1.dist-info/RECORD,,
```

