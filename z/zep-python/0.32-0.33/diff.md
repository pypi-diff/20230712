# Comparing `tmp/zep_python-0.32.tar.gz` & `tmp/zep_python-0.33.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "zep_python-0.32.tar", max compression
+gzip compressed data, was "zep_python-0.33.tar", max compression
```

## Comparing `zep_python-0.32.tar` & `zep_python-0.33.tar`

### file list

```diff
@@ -1,9 +1,9 @@
--rw-r--r--   0        0        0    11357 2023-06-26 21:22:44.926598 zep_python-0.32/LICENSE
--rw-r--r--   0        0        0     2402 2023-06-26 21:22:44.926598 zep_python-0.32/README.md
--rw-r--r--   0        0        0      872 2023-06-26 21:22:44.930598 zep_python-0.32/pyproject.toml
--rw-r--r--   0        0        0      389 2023-06-26 21:22:44.930598 zep_python-0.32/zep_python/__init__.py
--rw-r--r--   0        0        0     2234 2023-06-26 21:22:44.930598 zep_python-0.32/zep_python/exceptions.py
--rw-r--r--   0        0        0     4882 2023-06-26 21:22:44.930598 zep_python-0.32/zep_python/models.py
--rw-r--r--   0        0        0        0 2023-06-26 21:22:44.930598 zep_python-0.32/zep_python/py.typed
--rw-r--r--   0        0        0    13149 2023-06-26 21:22:44.930598 zep_python-0.32/zep_python/zep_client.py
--rw-r--r--   0        0        0     3081 1970-01-01 00:00:00.000000 zep_python-0.32/PKG-INFO
+-rw-r--r--   0        0        0    11357 2023-07-12 15:27:19.852473 zep_python-0.33/LICENSE
+-rw-r--r--   0        0        0     2402 2023-07-12 15:27:19.852473 zep_python-0.33/README.md
+-rw-r--r--   0        0        0      872 2023-07-12 15:27:19.856473 zep_python-0.33/pyproject.toml
+-rw-r--r--   0        0        0      389 2023-07-12 15:27:19.856473 zep_python-0.33/zep_python/__init__.py
+-rw-r--r--   0        0        0     2234 2023-07-12 15:27:19.856473 zep_python-0.33/zep_python/exceptions.py
+-rw-r--r--   0        0        0     5855 2023-07-12 15:27:19.856473 zep_python-0.33/zep_python/models.py
+-rw-r--r--   0        0        0        0 2023-07-12 15:27:19.856473 zep_python-0.33/zep_python/py.typed
+-rw-r--r--   0        0        0    18158 2023-07-12 15:27:19.856473 zep_python-0.33/zep_python/zep_client.py
+-rw-r--r--   0        0        0     3081 1970-01-01 00:00:00.000000 zep_python-0.33/PKG-INFO
```

### Comparing `zep_python-0.32/LICENSE` & `zep_python-0.33/LICENSE`

 * *Files identical despite different names*

### Comparing `zep_python-0.32/README.md` & `zep_python-0.33/README.md`

 * *Files identical despite different names*

### Comparing `zep_python-0.32/pyproject.toml` & `zep_python-0.33/pyproject.toml`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 [tool.poetry]
 name = "zep-python"
-version = "0.32"
+version = "0.33"
 description = "Zep stores, manages, enriches, indexes, and searches long-term memory for conversational AI applications. This is the Python client for the Zep service."
 authors = ["Daniel Chalef <daniel.chalef@private.org>"]
 readme = "README.md"
 
 [tool.poetry.dependencies]
 python = "^3.8"
 httpx = "^0.24.0"
```

### Comparing `zep_python-0.32/zep_python/exceptions.py` & `zep_python-0.33/zep_python/exceptions.py`

 * *Files identical despite different names*

### Comparing `zep_python-0.32/zep_python/models.py` & `zep_python-0.33/zep_python/models.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,14 +1,47 @@
 from __future__ import annotations
 
 from typing import Any, Dict, List, Optional
 
 from pydantic import BaseModel, Field
 
 
+class Session(BaseModel):
+    """
+    Represents a session object with a unique identifier, metadata,
+    and other attributes.
+
+    Attributes
+    ----------
+    uuid : Optional[str]
+        A unique identifier for the session.
+        This is generated server-side and is not expected to be present on creation.
+    created_at : str
+        The timestamp when the session was created.
+        Generated by the server.
+    updated_at : str
+        The timestamp when the session was last updated.
+        Generated by the server.
+    deleted_at : Optional[datetime]
+        The timestamp when the session was deleted.
+        Generated by the server.
+    session_id : str
+        The unique identifier of the session.
+    metadata : Dict[str, Any]
+        The metadata associated with the session.
+    """
+
+    uuid: Optional[str]
+    created_at: Optional[str]
+    updated_at: Optional[str]
+    deleted_at: Optional[str]
+    session_id: str
+    metadata: Dict[str, Any]
+
+
 class Summary(BaseModel):
     """
     Represents a summary of a conversation.
 
     Attributes
     ----------
     uuid : str
```

### Comparing `zep_python-0.32/zep_python/zep_client.py` & `zep_python-0.33/zep_python/zep_client.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,24 +1,27 @@
 from __future__ import annotations
 
 from types import TracebackType
 from typing import Any, Dict, List, Optional, Type
+from urllib.parse import urljoin
 
 import httpx
 
 from zep_python.exceptions import APIError, AuthError, NotFoundError
 from zep_python.models import (
     Memory,
     MemorySearchPayload,
     MemorySearchResult,
     Message,
+    Session,
     Summary,
 )
 
 API_BASE_PATH = "/api/v1"
+API_TIMEOUT = 10
 
 
 class ZepClient:
     """
     ZepClient class implementation.
 
     Attributes
@@ -56,17 +59,21 @@
             The API key to use for authentication. (optional)
         """
 
         headers: Dict[str, str] = {}
         if api_key is not None:
             headers["Authorization"] = f"Bearer {api_key}"
 
-        self.base_url = f"{base_url}{API_BASE_PATH}"
-        self.aclient = httpx.AsyncClient(base_url=self.base_url, headers=headers)
-        self.client = httpx.Client(base_url=self.base_url, headers=headers)
+        self.base_url = urljoin(base_url, API_BASE_PATH)
+        self.aclient = httpx.AsyncClient(
+            base_url=self.base_url, headers=headers, timeout=API_TIMEOUT
+        )
+        self.client = httpx.Client(
+            base_url=self.base_url, headers=headers, timeout=API_TIMEOUT
+        )
 
     async def __aenter__(self) -> "ZepClient":
         """Asynchronous context manager entry point"""
         return self
 
     async def __aexit__(
         self,
@@ -130,14 +137,164 @@
 
     def _gen_get_params(self, lastn: Optional[int] = None) -> Dict[str, Any]:
         params = {}
         if lastn is not None:
             params["lastn"] = lastn
         return params
 
+    def get_session(self, session_id: str) -> Session:
+        """
+        Retrieve the session with the specified ID.
+
+        Parameters
+        ----------
+        session_id : str
+            The ID of the session to retrieve.
+
+        Returns
+        -------
+        Session
+            The session with the specified ID.
+
+        Raises
+        ------
+        ValueError
+            If the session ID is None or empty.
+        APIError
+            If the API response format is unexpected.
+        """
+        if session_id is None or session_id.strip() == "":
+            raise ValueError("session_id must be provided")
+
+        url = f"/sessions/{session_id}"
+
+        try:
+            response = self.client.get(url)
+        except httpx.NetworkError as e:
+            raise ConnectionError("Failed to connect to server") from e
+
+        self._handle_response(response, f"No session found for session {session_id}")
+
+        response_data = response.json()
+
+        return Session.parse_obj(response_data)
+
+    async def aget_session(self, session_id: str) -> Session:
+        """
+        Asynchronously retrieve the session with the specified ID.
+
+        Parameters
+        ----------
+        session_id : str
+            The ID of the session to retrieve.
+
+        Returns
+        -------
+        Session
+            The session with the specified ID.
+
+        Raises
+        ------
+        ValueError
+            If the session ID is None or empty.
+        APIError
+            If the API response format is unexpected.
+        """
+        if session_id is None or session_id.strip() == "":
+            raise ValueError("session_id must be provided")
+
+        url = f"/sessions/{session_id}"
+
+        try:
+            response = await self.aclient.get(url)
+        except httpx.NetworkError as e:
+            raise ConnectionError("Failed to connect to server") from e
+
+        self._handle_response(response, f"No session found for session {session_id}")
+
+        response_data = response.json()
+
+        return Session.parse_obj(response_data)
+
+    def add_session(self, session: Session) -> str:
+        """
+        Add or update the specified session.
+
+        Parameters
+        ----------
+        session : Session
+            The session to add.
+
+        Returns
+        -------
+        Session
+            The added session.
+
+        Raises
+        ------
+        ValueError
+            If the session is None or empty.
+        APIError
+            If the API response format is unexpected.
+        """
+        if session is None:
+            raise ValueError("session must be provided")
+        if session.session_id is None or session.session_id.strip() == "":
+            raise ValueError("session.session_id must be provided")
+
+        url = f"/sessions/{session.session_id}"
+
+        try:
+            response = self.client.post(url, json=session.dict(exclude_none=True))
+        except httpx.NetworkError as e:
+            raise ConnectionError("Failed to connect to server") from e
+
+        self._handle_response(response, f"Failed to add session {session.session_id}")
+
+        return response.text
+
+    async def aadd_session(self, session: Session) -> str:
+        """
+        Asynchronously add or update the specified session.
+
+        Parameters
+        ----------
+        session : Session
+            The session to add.
+
+        Returns
+        -------
+        Session
+            The added session.
+
+        Raises
+        ------
+        ValueError
+            If the session is None or empty.
+        APIError
+            If the API response format is unexpected.
+        """
+        if session is None:
+            raise ValueError("session must be provided")
+        if session.session_id is None or session.session_id.strip() == "":
+            raise ValueError("session.session_id must be provided")
+
+        url = f"/sessions/{session.session_id}"
+
+        try:
+            response = await self.aclient.post(
+                url, json=session.dict(exclude_none=True)
+            )
+        except httpx.NetworkError as e:
+            raise ConnectionError("Failed to connect to server") from e
+
+        self._handle_response(response, f"Failed to add session {session.session_id}")
+
+        return response.text
+
     def get_memory(self, session_id: str, lastn: Optional[int] = None) -> Memory:
         """
         Retrieve memory for the specified session.
 
         Parameters
         ----------
         session_id : str
@@ -149,19 +306,21 @@
         Returns
         -------
         Memory
             A memory object containing a Summary, metadata, and list of Messages.
 
         Raises
         ------
+        ValueError
+            If the session ID is None or empty.
         APIError
             If the API response format is unexpected.
         """
 
-        if session_id is None or session_id == "":
+        if session_id is None or session_id.strip() == "":
             raise ValueError("session_id must be provided")
 
         url = f"/sessions/{session_id}/memory"
         params = self._gen_get_params(lastn)
         response = self.client.get(url, params=params)
 
         self._handle_response(response, f"No memory found for session {session_id}")
@@ -185,18 +344,20 @@
         Returns
         -------
         Memory
             A memory object containing a Summary, metadata, and list of Messages.
 
         Raises
         ------
+        ValueError
+            If the session ID is None or empty.
         APIError
             If the API response format is unexpected.
         """
-        if session_id is None or session_id == "":
+        if session_id is None or session_id.strip() == "":
             raise ValueError("session_id must be provided")
 
         url = f"/sessions/{session_id}/memory"
         params = self._gen_get_params(lastn)
         response = await self.aclient.get(url, params=params)
 
         self._handle_response(response, f"No memory found for session {session_id}")
@@ -219,18 +380,20 @@
         Returns
         -------
         str
             The response text from the API.
 
         Raises
         ------
+        ValueError
+            If the session ID is None or empty.
         APIError
             If the API response format is unexpected.
         """
-        if session_id is None or session_id == "":
+        if session_id is None or session_id.strip() == "":
             raise ValueError("session_id must be provided")
 
         response = self.client.post(
             f"/sessions/{session_id}/memory",
             json=memory_messages.dict(exclude_none=True),
         )
 
@@ -252,18 +415,20 @@
         Returns
         -------
         str
             The response text from the API.
 
         Raises
         ------
+        ValueError
+            If the session ID is None or empty.
         APIError
             If the API response format is unexpected.
         """
-        if session_id is None or session_id == "":
+        if session_id is None or session_id.strip() == "":
             raise ValueError("session_id must be provided")
 
         response = await self.aclient.post(
             f"/sessions/{session_id}/memory",
             json=memory_messages.dict(exclude_none=True),
         )
 
@@ -283,18 +448,20 @@
         Returns
         -------
         str
             The response text from the API.
 
         Raises
         ------
+        ValueError
+            If the session ID is None or empty.
         APIError
             If the API response format is unexpected.
         """
-        if session_id is None or session_id == "":
+        if session_id is None or session_id.strip() == "":
             raise ValueError("session_id must be provided")
 
         response = self.client.delete(f"/sessions/{session_id}/memory")
         self._handle_response(response)
         return response.text
 
     async def adelete_memory(self, session_id: str) -> str:
@@ -309,18 +476,20 @@
         Returns
         -------
         str
             The response text from the API.
 
         Raises
         ------
+        ValueError
+            If the session ID is None or empty.
         APIError
             If the API response format is unexpected.
         """
-        if session_id is None or session_id == "":
+        if session_id is None or session_id.strip() == "":
             raise ValueError("session_id must be provided")
 
         response = await self.aclient.delete(f"/sessions/{session_id}/memory")
         self._handle_response(response)
         return response.text
 
     def search_memory(
@@ -344,18 +513,20 @@
         Returns
         -------
         List[MemorySearchResult]
             A list of SearchResult objects representing the search results.
 
         Raises
         ------
+        ValueError
+            If the session ID is None or empty.
         APIError
             If the API response format is unexpected.
         """
-        if session_id is None or session_id == "":
+        if session_id is None or session_id.strip() == "":
             raise ValueError("session_id must be provided")
 
         if search_payload is None:
             raise ValueError("search_payload must be provided")
 
         params = {"limit": limit} if limit is not None else {}
         response = self.client.post(
@@ -389,18 +560,20 @@
         Returns
         -------
         List[MemorySearchResult]
             A list of SearchResult objects representing the search results.
 
         Raises
         ------
+        ValueError
+            If the session ID is None or empty.
         APIError
             If the API response format is unexpected.
         """
-        if session_id is None or session_id == "":
+        if session_id is None or session_id.strip() == "":
             raise ValueError("session_id must be provided")
 
         if search_payload is None:
             raise ValueError("search_payload must be provided")
 
         params = {"limit": limit} if limit is not None else {}
         response = await self.aclient.post(
```

### Comparing `zep_python-0.32/PKG-INFO` & `zep_python-0.33/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: zep-python
-Version: 0.32
+Version: 0.33
 Summary: Zep stores, manages, enriches, indexes, and searches long-term memory for conversational AI applications. This is the Python client for the Zep service.
 Author: Daniel Chalef
 Author-email: daniel.chalef@private.org
 Requires-Python: >=3.8,<4.0
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
```

